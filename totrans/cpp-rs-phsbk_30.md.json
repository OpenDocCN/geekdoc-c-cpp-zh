["```rs\nint main() {\n  // Local variables are lvalues,\n  int x(0);\n  // and therefore may be assigned to.\n  x = 42;\n\n  // x is converted to an rvalue when needed.\n  int y = x + 1;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cstring>\n\nint main() {\n  char example[6] = \"hello\";\n  char other[6];\n\n  // strncpy takes arguments of type char*\n  strncpy(other, example, 6);\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\nint twice(int n) {\n  return n * n;\n}\n\nstruct MyPair {\n  int x;\n  int y;\n\n  MyPair(int x, int y) : x(x), y(y) {}\n\n  static MyPair make() {\n    return MyPair{0, 0};\n  }\n};\n\nint main() {\n  // convert a function to a function pointer\n  int (*twicePtr)(int) = twice;\n  int result = twicePtr(5);\n\n  // Per C++23 11.4.5.1.6, can't take the address\n  // of a constructor.\n  // MyPair (*ctor)(int, int) = MyPair::MyPair;\n  // MyPair pair = ctor(10, 20);\n\n  // convert a static method to a function\n  // pointer\n  MyPair (*methodPtr)() = MyPair::make;\n  MyPair pair2 = methodPtr();\n\n  // convert a non-capturing closure to a\n  // function pointer\n  int (*closure)(int) = [](int x) -> int {\n    return x * 5;\n  };\n  int closureRes = closure(2);\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\nint main() {\n  int x(42);\n  long y = x;\n\n  float a(1.0);\n  double b = a;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\nint main() {\n  int x(42);\n  unsigned int y(x);\n\n  float a(1.0);\n  double b(a);\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cstdint>\n\nint main() {\n  int32_t x(42);\n  float a = x;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nvoid display(const std::string &msg) {\n  std::cout << \"Displaying: \" << msg << std::endl;\n}\n\nint main() {\n  // no const qualifier\n  std::string message(\"hello world\");\n\n  // used where const expected\n  display(message);\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cstdint>\n#include <iostream>\n\nint main() {\n  // Compiles without error (but with a warning).\n  uint32_t x = 4294967296;\n\n  // assumes int\n  auto y = 1;\n\n  // literal is given a larger type, so it prints\n  // correctly\n  std::cout << 4294967296 << std::endl;\n\n  // these work as expected\n  std::cout << INT64_C(4294967296) << std::endl;\n\n  uint64_t z = INT64_C(4294967296);\n  std::cout << z << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\nstruct Wire {\n  bool ready;\n  unsigned int value;\n\n  explicit operator bool() const { return ready; }\n};\n\nint main() {\n  Wire w{false, 0};\n  // ...\n\n  if (w) {\n    // use w.value\n  } else {\n    // do something else\n  }\n} \n```", "```rs\n\n```", "```rs\n\n```"]