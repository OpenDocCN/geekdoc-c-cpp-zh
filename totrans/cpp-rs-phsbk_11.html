<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Enums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Enums</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/data_modeling/enums.html">https://cel.cs.brown.edu/crp/idioms/data_modeling/enums.html</a></blockquote>
                        
<p>In C++, enums are often used to model a fixed set of alternatives, especially when
each of those enumerators corresponds to a specific integer value, such as is needed
when working with hardware, system calls, or protocol implementations.</p>
<p>For example, the various modes for a GPIO pin could be modeled as an enum, which
would restrict methods using the mode to valid values.</p>
<p>While Rust enums are <a href="./tagged_unions.html">more general</a>,
they can still be used for this sort of modeling.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;

enum Pin : uint8_t {
  Pin1 = 0x01,
  Pin2 = 0x02,
  Pin3 = 0x04
};

enum Mode : uint8_t {
  Output = 0x03,
  Pullup = 0x04,
  Analog = 0x27
  // ...
};

void low_level_set_pin(uint8_t pin, uint8_t mode);

void set_pin_mode(Pin pin, Mode mode) {
  low_level_set_pin(pin, mode);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
#[derive(Clone, Copy)]
enum Pin {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04,
}

#[repr(u8)]
#[derive(Clone, Copy)]
enum Mode {
    Output = 0x03,
    Pullup = 0x04,
    Analog = 0x27,
    // ...
}

extern "C" {
    fn low_level_set_pin(pin: u8, mode: u8);
}

fn set_pin_mode(pin: Pin, mode: Mode) {
    unsafe {
        low_level_set_pin(pin as u8, mode as u8)
    };
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The <code>#[repr(u8)]</code> attribute ensures that the representation of the enum is the
same as a byte (like declaring the underlying type of an enum in C++). The enum
values can then be freely converted to the underlying type with the <code>as</code>.</p>
<p>In C++ the standard way to convert from an integer to an enum is a static cast.
However, this <a href="https://eel.is/c++draft/expr.static.cast#9">requires that the user check the validity of the cast
themselves</a>. Often the conversion is
done by a function that checks that the value to convert is a valid enum value.</p>
<p>In Rust the standard way to perform the conversion is to implement the <code>TryFrom</code>
trait for the type and then use the <code>try_from</code> method or <code>try_into</code> method.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;cstdint&gt;
</span><span class="boring">
</span><span class="boring">enum Pin : uint8_t {
</span><span class="boring">  Pin1 = 0x01,
</span><span class="boring">  Pin2 = 0x02,
</span><span class="boring">  Pin3 = 0x04
</span><span class="boring">};
</span><span class="boring">
</span>struct InvalidPin {
    uint8_t pin;
};

Pin to_pin(uint8_t pin) {
  // The values are not contiguous, so we can't
  // just check the bounds and then cast.
  switch (pin) {
  case 0x1: { return Pin1; }
  case 0x2: { return Pin2; }
  case 0x4: { return Pin3; }
  }
  throw InvalidPin{pin};
}

int main() {
  try {
    Pin p(to_pin(2));
  } catch (InvalidPin &amp;e) {
    return 0;
  }

  // use pin p
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[repr(u8)]
</span><span class="boring">#[derive(Clone, Copy)]
</span><span class="boring">enum Pin {
</span><span class="boring">    Pin1 = 0x01,
</span><span class="boring">    Pin2 = 0x02,
</span><span class="boring">    Pin3 = 0x04,
</span><span class="boring">}
</span><span class="boring">
</span>use std::convert::TryFrom;

struct InvalidPin(u8);

impl TryFrom&lt;u8&gt; for Pin {
    type Error = InvalidPin;

    fn try_from(
        value: u8,
    ) -&gt; Result&lt;Self, Self::Error&gt; {
        match value {
            0x01 =&gt; Ok(Pin::Pin1),
            0x02 =&gt; Ok(Pin::Pin2),
            0x04 =&gt; Ok(Pin::Pin3),
            pin =&gt; Err(InvalidPin(pin)),
        }
    }
}

fn main() {
  let Ok(p) = Pin::try_from(2) else {
    return;
  };

  // use pin p
}</code></pre></pre>
</div>
<p>See <a href="../exceptions.html">Exceptions and error handling</a> for examples of how
to ergonomically handle the result of <code>try_from</code>.</p>
<p>If low-level performance is more of a concern than memory safety,
<code>std::mem::transmute</code> is analogous to a C++ reinterpret cast, but requires
unsafe Rust because its use can result in undefined behavior. Uses of
<code>std::mem::transmute</code> for this purpose should not be hidden behind an interface
that can be called from safe Rust unless the interface can actually guarantee
that the call will never happen with an invalid value.</p>
<h2 id="enums-and-methods"><a class="header" href="#enums-and-methods">Enums and methods</a></h2>
<p>In C++ enums cannot have methods. Instead, to model an enum with methods one
must define a wrapper class for the enum and define the methods on that wrapper
class. In Rust, methods can be defined on an enum with an <code>impl</code> block, just
like any other type.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstdint&gt;

// Actual enum
enum PinImpl : uint8_t {
  Pin1 = 0x01,
  Pin2 = 0x02,
  Pin3 = 0x04
};

class LastPin{};

// Wrapper type
struct Pin {
  PinImpl pin;

  // Conversion constructor so that PinImpl can be
  // used as a Pin.
  Pin(PinImpl p) : pin(p) {}

  // Conversion method so wrapper type can be
  // used with switch statement.
  operator PinImpl() {
    return this-&gt;pin;
  }

  Pin next() const {
    switch (pin) {
    case Pin1:
      return Pin(Pin2);
    case Pin2:
      return Pin(Pin3);
    default:
      throw LastPin{};
    }
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
#[derive(Clone, Copy)]
enum Pin {
    Pin1 = 0x01,
    Pin2 = 0x02,
    Pin3 = 0x04,
}

struct LastPin;

impl Pin {
    fn next(&amp;self) -&gt; Result&lt;Self, LastPin&gt; {
        match self {
            Pin::Pin1 =&gt; Ok(Pin::Pin2),
            Pin::Pin2 =&gt; Ok(Pin::Pin3),
            Pin::Pin3 =&gt; Err(LastPin),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<div class="quiz-placeholder" data-quiz-name="&quot;enums&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;b1f69693-be11-4105-b408-7f8925c4303d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nimpl TryFrom&lt;u8&gt; for Color {\n    type Error = InvalidColor;\n\n    fn try_from(c: u8) -&gt; Result&lt;Self, InvalidColor&gt; {\n        match c {\n            0 =&gt; Ok(Color::Red),\n            1 =&gt; Ok(Color::Blue),\n            2 =&gt; Ok(Color::Green),\n            3 =&gt; Ok(Color::Yellow),\n            _ =&gt; Err(InvalidColor(c)),\n        }\n    }\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nimpl TryFrom&lt;u8&gt; for Color {\n    type Error = InvalidColor;\n\n    fn try_from(c: u8) -&gt; Result&lt;Self, InvalidColor&gt; {\n        match c {\n            0 | 2 | 3 =&gt; Ok(c as Color),\n            _ =&gt; Err(InvalidColor(c)),\n        }\n    }\n}\n```\n&quot;,&quot;```rust\n#[derive(Clone, Copy)]\nstruct ColorWrapper {\n    color: Color,\n}\n\nimpl TryFrom&lt;u8&gt; for ColorWrapper {\n    type Error = InvalidColor;\n\n    fn try_from(c: u8) -&gt; Result&lt;Self, InvalidColor&gt; {\n        let color = match c {\n            0 =&gt; Ok(Color::Red),\n            1 =&gt; Ok(Color::Blue),\n            2 =&gt; Ok(Color::Green),\n            3 =&gt; Ok(Color::Yellow),\n            _ =&gt; Err(InvalidColor(c)),\n        }?;\n        Ok(ColorWrapper { color })\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of these Rust programs is the most idiomatic translation of the following\nC++ program?\n\n```cpp\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nenum ColorImpl : uint8_t {\n  Red,\n  Blue,\n  Green,\n  Yellow,\n};\n\nstruct InvalidColor {\n  uint8_t color;\n};\n\nstruct Color {\n  ColorImpl color;\n\n  Color(ColorImpl c) : color(c) {}\n\n  operator ColorImpl() {\n    return color;\n  }\n\n  explicit Color(uint8_t c) {\n    if (c &lt; Red || c &gt; Yellow) {\n      throw InvalidColor{c};\n    }\n    color = static_cast&lt;ColorImpl&gt;(c);\n  }\n};\n```\n\nAll of the Rust options start with the following import and definitions.\n\n```rust\nuse std::convert::TryFrom;\n\n#[repr(u8)]\n#[derive(Clone, Copy)]\nenum Color {\n    Red,\n    Blue,\n    Green,\n    Yellow,\n}\n\nstruct InvalidColor(u8);\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Enums">Click here to leave us feedback about this page.</a>
                        
</body>
</html>