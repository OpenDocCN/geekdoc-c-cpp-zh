<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Multiple return values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Multiple return values</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/out_params/multiple_return.html">https://cel.cs.brown.edu/crp/idioms/out_params/multiple_return.html</a></blockquote>
                        
<p>One idiom for returning multiple values from a function or method in C++ is to
pass in references to which the values can be assigned.</p>
<p>There are several reasons why this idiom might be used:</p>
<ul>
<li>compatibility with versions of C++ earlier than C++11,</li>
<li>working in a codebase that uses C-style of C++, or</li>
<li>performance concerns.</li>
</ul>
<p>The idiomatic translation of this program into Rust makes use of either
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">tuples</a> or a named
structure for the return type.</p>
<div class="comparison">
<pre><code class="language-cpp">void get_point(int &amp;x, int &amp;y) {
  x = 5;
  y = 6;
}

int main() {
  int x, y;
  get_point(x, y);
  // ...
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn get_point() -&gt; (i32, i32) {
    (5, 6)
}

fn main() {
    let (x, y) = get_point();
    // ...
}</code></pre></pre>
</div>
<p>Rust has a dedicated tuple syntax and supports pattern matching with <code>let</code>
bindings in part to support use cases like this one.</p>
<h2 id="problems-with-the-direct-transliteration"><a class="header" href="#problems-with-the-direct-transliteration">Problems with the direct transliteration</a></h2>
<p>It is possible to transliterate the original example that uses out parameters to
Rust, but Rust requires the initialization of the variables before they can be
passed to a function. The resulting program is not idiomatic Rust.</p>
<pre><pre class="playground"><code class="language-rust">// NOT IDIOMATIC RUST
fn get_point(x: &amp;mut i32, y: &amp;mut i32) {
    *x = 5;
    *y = 6;
}

fn main() {
    let mut x = 0; // initialized to arbitrary values
    let mut y = 0;
    get_point(&amp;mut x, &amp;mut y);
    // ...
}</code></pre></pre>
<p>This approach requires assigning arbitrary initial values to the variables and
making the variables mutable, both of which make it harder for the compiler to
help with avoiding programming errors.</p>
<p>Additionally, the Rust compiler is tuned for optimizing the idiomatic version of
the program, and produces a significantly faster binary for that version.</p>
<p>In situations where the performance of memory allocation is a concern (such as
when it is necessary to reuse entire buffers in memory), the trade-offs may be
different. That situation is discussed in the chapter on <a href="./pre-allocated_buffers.html">pre-allocated
buffers</a>.</p>
<h2 id="similarities-with-idiomatic-c-since-c11"><a class="header" href="#similarities-with-idiomatic-c-since-c11">Similarities with idiomatic C++ since C++11</a></h2>
<p>In C++11 and later, <code>std::pair</code> and <code>std::tuple</code> are available for returning
multiple values instead of assigning to reference parameters.</p>
<pre><code class="language-cpp">#include &lt;tuple&gt;
#include &lt;utility&gt;

std::pair&lt;int, int&gt; get_point() {
  return std::make_pair(5, 6);
}

int main() {
  int x, y;
  std::tie(x, y) = get_point();
  // ...
}
</code></pre>
<p>This more closely aligns with the normal Rust idiom for returning multiple
values.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;multiple_return&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;17e30276-7ebe-499e-b8b0-4acfb815feaa&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\npub fn split_at(\n    data: &amp;[u8],\n    mid: usize,\n) -&gt; (&amp;[u8], &amp;[u8]);\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\npub fn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    left: &amp;mut &amp;[u8],\n    right: &amp;mut &amp;[u8],\n);\n```\n&quot;,&quot;```rust\nfn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    left: &amp;mut &amp;[u8],\n    right: &amp;mut &amp;[u8],\n) -&gt; (usize, usize);\n```\n&quot;,&quot;```rust\nfn split_at(\n    data: &amp;[u8],\n    mid: usize,\n    remaining: &amp;mut &amp;[u8],\n) -&gt; &amp;[u8];\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following is the most idiomatic translation of this C++ function\nsignature into a Rust function signature?\n\n```cpp\nvoid main() {}\n```\n\n```cpp\n#include &lt;cstdint&gt;\n\nvoid splitAt(std::uint8_t *data,\n             std::size_t dataSize,\n             std::size_t mid,\n             uint8_t **left,\n             std::size_t *leftSize,\n             uint8_t **right,\n             std::size_t *rightSize);\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Multiple return values">Click here to leave us feedback about this page.</a>
                        
</body>
</html>