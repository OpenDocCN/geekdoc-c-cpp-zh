["```cpp\n 1 |#include <stdio.h> \n |\n |#define LOWER_MASK 0x0F \n |#define UPPER_MASK 0xF0 \n 5 |\n |int main(int argc, char* argv[]) \n |{ \n | /* Two 4-bit values stored in one \n | * 8-bit variable */ \n10 | char value = 0xA5; \n | char lower = value & LOWER_MASK; \n | char upper = (value & UPPER_MASK) >> 4; \n |\n | printf(\"Lower: %x\\n\", lower); \n15 | printf(\"Upper: %x\\n\", upper); \n |} \n\n```", "```cpp\n 1 |#include <stdio.h> \n |\n |/* \n | *  define all 8 possible flags for an 8 bit variable \n 5 | *      name  hex     binary \n | */ \n |#define FLAG1 0x01 /* 00000001 */ \n |#define FLAG2 0x02 /* 00000010 */ \n |#define FLAG3 0x04 /* 00000100 */ \n10 |#define FLAG4 0x08 /* 00001000 */ \n |/* ... and so on */ \n |#define FLAG8 0x80 /* 10000000 */ \n |\n |int main(int argc, char *argv[]) \n15 |{ \n | char flags = 0; /* an 8 bit variable */ \n |\n | /* set flags with a logical or */ \n | flags = flags | FLAG1; /* set flag 1 */ \n20 | flags = flags | FLAG3; /* set flag 3 \n |\n | /* check flags with a logical and.  If the flag is set (1) \n | * then the logical and will return 1, causing the if \n | * condition to be true. */ \n25 | if (flags & FLAG1) \n | printf(\"FLAG1 set!\\n\"); \n |\n | /* this of course will be untrue. */ \n | if (flags & FLAG8) \n30 | printf(\"FLAG8 set!\\n\"); \n |\n | /* check multiple flags by using a logical or \n | * this will pass as FLAG1 is set */ \n | if (flags & (FLAG1|FLAG4)) \n35 | printf(\"FLAG1 or FLAG4 set!\\n\"); \n |\n | return 0; \n |} \n\n```", "```cpp\n 1 |/* \n | * types.c \n | */ \n |\n 5 |#include <stdio.h> \n |#include <stdint.h> \n |\n |int main(void) \n |{ \n10 | char a; \n | char *p = \"hello\"; \n |\n | int i; \n |\n15 | // moving a larger variable into a smaller one \n | i = 0x12341234; \n | a = i; \n | i = a; \n | printf(\"i is %d\\n\", i); \n20 |\n | // moving a pointer into an integer \n | printf(\"p is %p\\n\", p); \n | i = p; \n | // \"fooling\" with casts \n25 | i = (int)p; \n | p = (char*)i; \n | printf(\"p is %p\\n\", p); \n |\n | return 0; \n30 |} \n\n```", "```cpp\n 1 |$ uname -m \n |i686 \n |\n |$ gcc -Wall -o types types.c \n 5 |types.c: In function 'main': \n |types.c:19: warning: assignment makes integer from pointer without a cast \n |\n |$ ./types \n |i is 52 \n10 |p is 0x80484e8 \n |p is 0x80484e8 \n |\n |$ uname -m \n |ia64 \n15 |\n |$ gcc -Wall  -o types types.c \n |types.c: In function 'main': \n |types.c:19: warning: assignment makes integer from pointer without a cast \n |types.c:21: warning: cast from pointer to integer of different size \n20 |types.c:22: warning: cast to pointer from integer of different size \n |\n |$ ./types \n |i is 52 \n |p is 0x40000000000009e0 \n25 |p is 0x9e0 \n\n```", "```cpp\n 1 |$ cat float.c \n |#include <stdio.h> \n |\n |int main(void) \n 5 |{ \n | float a = 0.45; \n | float b = 8.0; \n |\n | double ad = 0.45; \n10 | double bd = 8.0; \n |\n | printf(\"float+float, 6dp    : %f\\n\", a+b); \n | printf(\"double+double, 6dp  : %f\\n\", ad+bd); \n | printf(\"float+float, 20dp   : %10.20f\\n\", a+b); \n15 | printf(\"dobule+double, 20dp : %10.20f\\n\", ad+bd); \n |\n | return 0; \n |} \n |\n20 |$ gcc -o float float.c \n |\n |$ ./float \n |float+float, 6dp    : 8.450000 \n |double+double, 6dp  : 8.450000 \n25 |float+float, 20dp   : 8.44999998807907104492 \n |dobule+double, 20dp : 8.44999999999999928946 \n |\n |$ python \n |Python 2.4.4 (#2, Oct 20 2006, 00:23:25) \n30 |[GCC 4.1.2 20061015 (prerelease) (Debian 4.1.1-16.1)] on linux2 \n |Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \n |>>> 8.0 + 0.45 \n |8.4499999999999993 \n\n```", "```cpp\n 1 |#include <stdio.h> \n |\n |int main(void) \n |{ \n 5 | //  in binary = 1000 0000 0000 0000 \n | //  bit num     5432 1098 7654 3210 \n | int i = 0x8000; \n | int count = 0; \n | while ( !(i & 0x1) ) { \n10 | count ++; \n | i = i >> 1; \n | } \n | printf(\"First non-zero (slow) is %d\\n\", count); \n |\n15 | // this value is normalised when it is loaded \n | long double d = 0x8000UL; \n | long exp; \n |\n | // Itanium \"get floating point exponent\" instruction \n20 | asm (\"getf.exp %0=%1\" : \"=r\"(exp) : \"f\"(d)); \n |\n | // note exponent include bias \n | printf(\"The first non-zero (fast) is %d\\n\", exp - 65535); \n |\n25 |} \n\n```", "```cpp\n 1 |#include <stdio.h> \n |#include <string.h> \n |#include <stdlib.h> \n |\n 5 |/* return 2^n */ \n |int two_to_pos(int n) \n |{ \n | if (n == 0) \n | return 1; \n 10 | return 2 * two_to_pos(n - 1); \n |} \n |\n |double two_to_neg(int n) \n |{ \n 15 | if (n == 0) \n | return 1; \n | return 1.0 / (two_to_pos(abs(n))); \n |} \n |\n 20 |double two_to(int n) \n |{ \n | if (n >= 0) \n | return two_to_pos(n); \n | if (n < 0) \n 25 | return two_to_neg(n); \n | return 0; \n |} \n |\n |/* Go through some memory \"m\" which is the 24 bit significand of a \n 30 | floating point number.  We work \"backwards\" from the bits \n | furthest on the right, for no particular reason. */ \n |double calc_float(int m, int bit) \n |{ \n | /* 23 bits; this terminates recursion */ \n 35 | if (bit > 23) \n | return 0; \n |\n | /* if the bit is set, it represents the value 1/2^bit */ \n | if ((m >> bit) & 1) \n 40 | return 1.0L/two_to(23 - bit) + calc_float(m, bit + 1); \n |\n | /* otherwise go to the next bit */ \n | return calc_float(m, bit + 1); \n |} \n 45 |\n |int main(int argc, char *argv[]) \n |{ \n | float f; \n | int m,i,sign,exponent,significand; \n 50 |\n | if (argc != 2) \n | { \n | printf(\"usage: float 123.456\\n\"); \n | exit(1); \n 55 | } \n |\n | if (sscanf(argv[1], \"%f\", &f) != 1) \n | { \n | printf(\"invalid input\\n\"); \n 60 | exit(1); \n | } \n |\n | /* We need to \"fool\" the compiler, as if we start to use casts \n | (e.g. (int)f) it will actually do a conversion for us.  We \n 65 | want access to the raw bits, so we just copy it into a same \n | sized variable. */ \n | memcpy(&m, &f, 4); \n |\n | /* The sign bit is the first bit */ \n 70 | sign = (m >> 31) & 0x1; \n |\n | /* Exponent is 8 bits following the sign bit */ \n | exponent = ((m >> 23) & 0xFF) - 127; \n |\n 75 | /* Significand fills out the float, the first bit is implied \n | to be 1, hence the 24 bit OR value below. */ \n | significand = (m & 0x7FFFFF) | 0x800000; \n |\n | /* print out a power representation */ \n 80 | printf(\"%f = %d * (\", f, sign ? -1 : 1); \n | for(i = 23 ; i >= 0 ; i--) \n | { \n | if ((significand >> i) & 1) \n | printf(\"%s1/2^%d\", (i == 23) ? \"\" : \" + \", \n 85 | 23-i); \n | } \n | printf(\") * 2^%d\\n\", exponent); \n |\n | /* print out a fractional representation */ \n 90 | printf(\"%f = %d * (\", f, sign ? -1 : 1); \n | for(i = 23 ; i >= 0 ; i--) \n | { \n | if ((significand >> i) & 1) \n | printf(\"%s1/%d\", (i == 23) ? \"\" : \" + \", \n 95 | (int)two_to(23-i)); \n | } \n | printf(\") * 2^%d\\n\", exponent); \n |\n | /* convert this into decimal and print it out */ \n100 | printf(\"%f = %d * %.12g * %f\\n\", \n | f, \n | (sign ? -1 : 1), \n | calc_float(significand, 0), \n | two_to(exponent)); \n105 |\n | /* do the math this time */ \n | printf(\"%f = %.12g\\n\", \n | f, \n | (sign ? -1 : 1) * \n110 | calc_float(significand, 0) * \n | two_to(exponent) \n | ); \n |\n | return 0; \n115 |} \n\n```", "```cpp\n1 |$ ./float 8.45 \n |8.450000 = 1 * (1/2^0 + 1/2^5 + 1/2^6 + 1/2^7 + 1/2^10 + 1/2^11 + 1/2^14 + 1/2^15 + 1/2^18 + 1/2^19 + 1/2^22 + 1/2^23) * 2^3 \n |8.450000 = 1 * (1/1 + 1/32 + 1/64 + 1/128 + 1/1024 + 1/2048 + 1/16384 + 1/32768 + 1/262144 + 1/524288 + 1/4194304 + 1/8388608) * 2^3 \n |8.450000 = 1 * 1.05624997616 * 8.000000 \n5 |8.450000 = 8.44999980927 \n\n```"]