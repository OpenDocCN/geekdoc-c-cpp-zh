- en: Expected errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/exceptions/expected_errors.html](https://cel.cs.brown.edu/crp/idioms/exceptions/expected_errors.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In C++, `throw` both produces an error (the thrown exception) and initiates
    non-local control flow (unwinding to the nearest `catch` block). In Rust, error
    values (`Option::None` or `Result::Err`) are returned as normal values from a
    function. Rust's `return` statement can be used to return early from a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { fn divide('
  prefs: []
  type: TYPE_NORMAL
- en: 'dividend: f64,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'divisor: f64,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Option<f64> {
  prefs: []
  type: TYPE_NORMAL
- en: if divisor == 0.0 {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return None;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(dividend / divisor)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The requirement to have the return type indicate that an error is possible means
    that callbacks that are permitted to have errors need to be given an `Option`
    or `Result` return type. Omitting that is like requiring callbacks to be `noexcept`
    in C++. Functions that do not need to indicate errors but that will be used as
    callbacks where errors are permitted will need to wrap their results in `Option::Some`
    or `Result::Ok`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: fn produce_42() -> i32 {
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn fail() -> Option<i32> {
  prefs: []
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn use_callback(
  prefs: []
  type: TYPE_NORMAL
- en: 'f: impl Fn() -> Option<i32>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Option<i32> {
  prefs: []
  type: TYPE_NORMAL
- en: f()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: // need to wrap produce_42 to match the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // expected type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let Some(x) =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use_callback(|| Some(produce_42()))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let Some(y) = use_callback(fail) else {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // use x and y
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Handling errors](#handling-errors)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, the only way to handle exceptions is `catch`. In Rust, all of the features
    for dealing with [tagged unions](../data_modeling/tagged_unions.html) can be used
    with `Result` and `Option`. The most approach depends on the intention of the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: The basic way of handling an error indicated by a `Result` in Rust is by using
    `match`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `match` is the most general approach, because it enables handling additional
    cases explicitly and can be used as an expression. `match` connotes equal importance
    of all branches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut v = Vec::<i32>::new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ... populate v ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match v.get(0) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(x) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // use x
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: None => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because handling only a single variant of a Rust enum is so common, the `if
    let` syntax support that use case. The syntax both makes it clear that only the
    one case is important and reduces the levels of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: '`if let` is less general than `match`. It can also be used as an expression,
    but can only distinguish one case from the rest. `if let` connotes that the `else`
    case is not the normal case, but that some default handling will occur or some
    default value will be produced.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that with `Result`, `if let` does not enable accessing the error value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut v = Vec::<i32>::new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ... populate v ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if let Some(x) = v.get(0) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // use x
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When the error handling involves some kind of control flow operation, like `break`
    or `return`, the `let else` syntax is even more concise.
  prefs: []
  type: TYPE_NORMAL
- en: Much like normal `let` statements, `let else` statements can only be used where
    statements are expected. `let else` statements also connote that the else case
    is not the normal case, and that no further (normal) processing will occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut v = Vec::<i32>::new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ... populate v ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let Some(x) = v.get(0) else {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // use x
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Result` and `Option` also have some helper methods for handling errors. These
    methods resemble the methods on `std::expected` in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let res: Result<i32, String> = Ok(42);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let x = res.map(|n| n * 2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These helper methods and others are described in detail in the documentation
    for [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html#implementations)
    and [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html#implementations).
  prefs: []
  type: TYPE_NORMAL
- en: '[Borrowed results](#borrowed-results)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the above examples, the successful results are borrowed from the vector.
    It common to need to clone or copy the result into an owned copy, and to want
    to do so without having to match on and reconstruct the value. `Result` and `Option`
    have helper methods for these purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut v = Vec::<i32>::new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: v.push(42);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let x: Option<&i32> = v.get(0);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let y: Option<i32> = v.get(0).copied();'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut w = Vec::<String>::new();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: w.push("hello".to_string());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let s: Option<&String> = w.get(0);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let r: Option<String> = w.get(0).cloned();'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Propagating errors](#propagating-errors)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, exceptions propagate automatically. In Rust, errors indicated by `Result`
    or `Option` must be explicitly propagated. The `?` operator is a convenience for
    this. There are also several methods for manipulating `Result` and `Option` that
    have a similar effect to propagating the error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { fn access_value('
  prefs: []
  type: TYPE_NORMAL
- en: 'indices: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'values: Vec<i32>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'i: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Option<i32> {
  prefs: []
  type: TYPE_NORMAL
- en: // * dereferences the &i32 to copy it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ? propagates the None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let idx = *indices.get(i)?;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // returns the Option directly
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values.get(idx).copied()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The above Rust example is equivalent to the following, which does not use the
    `?` operator. The version using `?` is more idiomatic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { fn access_value('
  prefs: []
  type: TYPE_NORMAL
- en: 'indices: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'values: Vec<i32>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'i: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Option<i32> {
  prefs: []
  type: TYPE_NORMAL
- en: // matching through the & makes a copy of the i32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let Some(&idx) = indices.get(i) else {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return None;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // still returns the Option directly
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values.get(idx).copied()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The following example is also equivalent. It is not idiomatic (using `?` here
    is more readable), but does demonstrate one of the helper methods. `Option::and_then`
    is similar to [`std::optional::and_then` in C++23](https://en.cppreference.com/w/cpp/utility/optional/and_then).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { fn access_value('
  prefs: []
  type: TYPE_NORMAL
- en: 'indices: Vec<usize>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'values: Vec<i32>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'i: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Option<i32> {
  prefs: []
  type: TYPE_NORMAL
- en: // matching through the & makes a copy of the i32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: indices
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .get(i)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .and_then(|idx| values.get(*idx))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .copied()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These helper methods and others are described in detail in the documentation
    for [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html#implementations)
    and [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html#implementations).
  prefs: []
  type: TYPE_NORMAL
- en: '[Uncaught exceptions in `main`](#uncaught-exceptions-in-main)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++ when an exception is uncaught, it terminates the program with a non-zero
    exit code and an error message. To achieve a similar result using `Result` in
    Rust, `main` can be given a return type of `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rust, the `main` function can return any type that implements the [`Termination`
    trait](https://doc.rust-lang.org/std/process/trait.Termination.html), such as
    `()`, `Result`, and [`ExitCode`](https://doc.rust-lang.org/std/process/struct.ExitCode.html).
    For example, `main` can return a result whose error type implements the [`Debug`
    trait](https://doc.rust-lang.org/std/fmt/trait.Debug.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#[derive(Debug)]'
  prefs: []
  type: TYPE_NORMAL
- en: struct InterestingError {
  prefs: []
  type: TYPE_NORMAL
- en: 'message: &''static str,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'other_interesting_value: i32,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() -> Result<(), InterestingError> {
  prefs: []
  type: TYPE_NORMAL
- en: Err(InterestingError {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'message: "oops",'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'other_interesting_value: 9001,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program produces the output `Error: InterestingError { message:
    "oops", other_interesting_value: 9001 }` with an exit code of `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Limitations to forcing error handling with `Result`](#limitations-to-forcing-error-handling-with-result)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Returning `Result` or `Option` does not give the usual benefits when used with
    APIs that pass pre-allocated buffers by mutable reference. This is because the
    buffer is accessible outside of the `Result` or `Option`, and so the compiler
    cannot force handling of the error case.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the following example the result of `read_line` can be ignored,
    resulting in logic errors in the program. However, since the buffer is required
    to be initialized, it will not result in memory safety violations or undefined
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut buffer = String::with_capacity(1024);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: std::io::stdin().read_line(&mut buffer);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // use buffer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Rust will produce a warning in this case, because of the [`#[must_use]` attribute](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute)
    on `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`Option` does not have a `#[must_use]` attribute, so functions that return
    an `Option` that must be handled (due to the `None` case indicating an error)
    should be annotated with the `#[must_use]` attribute. For example, the `get` method
    on slices returns `Option` and is [annotated as `#[must_use]`](https://doc.rust-lang.org/src/core/slice/mod.rs.html#592-595).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Designing and implementing error types](#designing-and-implementing-error-types)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One challenge to handling errors in Rust compared to C++ is that because error
    propagation in Rust is explicit, error values from different subsystems need to
    be combined into a single type in order to be propagated further up the stack.
    With C++ exceptions, this requires no special effort.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how such an error type is implemented manually.
    Later examples show how the [thiserror](https://docs.rs/thiserror/latest/thiserror/)
    and [anyhow](https://docs.rs/anyhow/latest/anyhow/) crates can be used to reduce
    the verbosity of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { use std::error::Error;'
  prefs: []
  type: TYPE_NORMAL
- en: use std::fmt::Display;
  prefs: []
  type: TYPE_NORMAL
- en: use std::fmt::Formatter;
  prefs: []
  type: TYPE_NORMAL
- en: '#[derive(Debug)]'
  prefs: []
  type: TYPE_NORMAL
- en: struct ErrorA;
  prefs: []
  type: TYPE_NORMAL
- en: impl Display for ErrorA {
  prefs: []
  type: TYPE_NORMAL
- en: fn fmt(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&self,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt: &mut Formatter<''_>,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Result<(), std::fmt::Error> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: write!(fmt, "ErrorA produced")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Error for ErrorA {}
  prefs: []
  type: TYPE_NORMAL
- en: fn might_throw_A() -> Result<(), ErrorA> {
  prefs: []
  type: TYPE_NORMAL
- en: Ok(())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '#[derive(Debug)]'
  prefs: []
  type: TYPE_NORMAL
- en: struct ErrorB;
  prefs: []
  type: TYPE_NORMAL
- en: impl Display for ErrorB {
  prefs: []
  type: TYPE_NORMAL
- en: fn fmt(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&self,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt: &mut Formatter<''_>,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Result<(), std::fmt::Error> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: write!(fmt, "ErrorB produced")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Error for ErrorB {}
  prefs: []
  type: TYPE_NORMAL
- en: fn might_throw_B() -> Result<(), ErrorB> {
  prefs: []
  type: TYPE_NORMAL
- en: Ok(())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // This extra structure is needed to combine the errors
  prefs: []
  type: TYPE_NORMAL
- en: '#[derive(Debug)]'
  prefs: []
  type: TYPE_NORMAL
- en: enum ErrorAOrB {
  prefs: []
  type: TYPE_NORMAL
- en: ErrorA(ErrorA),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ErrorB(ErrorB),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Display for ErrorAOrB {
  prefs: []
  type: TYPE_NORMAL
- en: fn fmt(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&self,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fmt: &mut Formatter<''_>,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Result<(), std::fmt::Error> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match self {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Self::ErrorA(err) => err.fmt(fmt),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Self::ErrorB(err) => err.fmt(fmt),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Error for ErrorAOrB {}
  prefs: []
  type: TYPE_NORMAL
- en: impl From<ErrorA> for ErrorAOrB {
  prefs: []
  type: TYPE_NORMAL
- en: 'fn from(err: ErrorA) -> Self {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Self::ErrorA(err)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl From<ErrorB> for ErrorAOrB {
  prefs: []
  type: TYPE_NORMAL
- en: 'fn from(err: ErrorB) -> Self {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Self::ErrorB(err)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn process() -> Result<(), ErrorAOrB> {
  prefs: []
  type: TYPE_NORMAL
- en: // the ? operator uses the From instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: might_throw_A()?;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: might_throw_B()?;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The following example uses the [thiserror](https://docs.rs/thiserror/latest/thiserror/)
    crate to implement the same thing as in the above example. The C++ version shown
    for comparison is the same as in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[Error types for applications](#error-types-for-applications)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When implementing an application (as opposed to a library), it is often the
    case that the specific type of error isn't as significant as the ability to easily
    propagate them without the verbosity of the above example. For those cases, the
    [anyhow](https://crates.io/crates/anyhow) crate provides mechanisms for combining
    errors into a single error type, as well as the ability to produce one-off errors.
    Since the errors types used in conjunction with anyhow still need to implement
    the `std::error::Error` trait, anyhow is often used in conjunction with thiserror.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminating based on the type of the error, as one would do with `catch`
    in C++, can be done with one of the [`downcast` methods](https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[Backtraces](#backtraces)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backtraces can be manually included with errors by defining a field with the
    type [`Backtrace`](https://doc.rust-lang.org/std/backtrace/index.html). The backtrace
    can be captured using the [`Backtrace::capture` method](https://doc.rust-lang.org/std/backtrace/struct.Backtrace.html#method.capture).
    The [module documentation](https://doc.rust-lang.org/std/backtrace/index.html)
    describes the configuration required to enable backtraces.
  prefs: []
  type: TYPE_NORMAL
- en: Both [thiserror](https://docs.rs/thiserror/latest/thiserror/) and [anyhow](https://docs.rs/anyhow/latest/anyhow/)
    have support for conveniently adding backtrace information to errors. Instructions
    for including backtraces are given on the main documentation page for each crate.
  prefs: []
  type: TYPE_NORMAL
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Expected
    errors)
  prefs: []
  type: TYPE_NORMAL
