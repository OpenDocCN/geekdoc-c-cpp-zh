- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2026-01-06 18:01:40'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: C++ Core Guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#s-profile](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#s-profile)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jul 8, 2025
  prefs: []
  type: TYPE_NORMAL
- en: 'Editors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bjarne Stroustrup](https://www.stroustrup.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Herb Sutter](https://herbsutter.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a living document under continuous improvement. Had it been an open-source
    (code) project, this would have been release 0.8. Copying, use, modification,
    and creation of derivative works from this project is licensed under an MIT-style
    license. Contributing to this project requires agreeing to a Contributor License.
    See the accompanying [LICENSE](https://github.com/isocpp/CppCoreGuidelines/blob/master/LICENSE)
    file for details. We make this project available to “friendly users” to use, copy,
    modify, and derive from, hoping for constructive input.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and suggestions for improvements are most welcome. We plan to modify
    and extend this document as our understanding improves and the language and the
    set of available libraries improve. When commenting, please note [the introduction](#s-introduction)
    that outlines our aims and general approach. The list of contributors is [here](#ss-ack).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The sets of rules have not been completely checked for completeness, consistency,
    or enforceability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triple question marks (???) mark known missing information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update reference sections; many pre-C++11 sources are too old.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a more-or-less up-to-date to-do list see: [To-do: Unclassified proto-rules](#s-unclassified).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can [read an explanation of the scope and structure of this Guide](#s-abstract)
    or just jump straight in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[In: Introduction](#s-introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P: Philosophy](#s-philosophy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I: Interfaces](#s-interfaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F: Functions](#s-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C: Classes and class hierarchies](#s-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum: Enumerations](#s-enum)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R: Resource management](#s-resource)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES: Expressions and statements](#s-expr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per: Performance](#s-performance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP: Concurrency and parallelism](#s-concurrency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E: Error handling](#s-errors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Con: Constants and immutability](#s-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T: Templates and generic programming](#s-templates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CPL: C-style programming](#s-cpl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF: Source files](#s-source)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL: The Standard Library](#sl-the-standard-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supporting sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A: Architectural ideas](#s-a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR: Non-Rules and myths](#s-not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RF: References](#s-references)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pro: Profiles](#s-profile)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GSL: Guidelines support library](#gsl-guidelines-support-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL: Naming and layout suggestions](#s-naming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FAQ: Answers to frequently asked questions](#s-faq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix A: Libraries](#s-libraries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix B: Modernizing code](#s-modernizing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix C: Discussion](#s-discussion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix D: Supporting tools](#s-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Glossary](#s-glossary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[To-do: Unclassified proto-rules](#s-unclassified)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can sample rules for specific language features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'assignment: [regular types](#rc-regular) – [prefer initialization](#rc-initialize)
    – [copy](#rc-copy-semantic) – [move](#rc-move-semantic) – [other operations](#rc-matched)
    – [default](#rc-eqdefault)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class`: [data](#rc-org) – [invariant](#rc-struct) – [members](#rc-member)
    – [helpers](#rc-helper) – [concrete types](#ss-concrete) – [ctors, =, and dtors](#s-ctor)
    – [hierarchy](#ss-hier) – [operators](#ss-overload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concept`: [rules](#ss-concepts) – [in generic programming](#rt-raise) – [template
    arguments](#rt-concepts) – [semantics](#rt-low)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'constructor: [invariant](#rc-struct) – [establish invariant](#rc-ctor) – [`throw`](#rc-throw)
    – [default](#rc-default0) – [not needed](#rc-default) – [`explicit`](#rc-explicit)
    – [delegating](#rc-delegating) – [`virtual`](#rc-ctor-virtual)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'derived `class`: [when to use](#rh-domain) – [as interface](#rh-abstract) –
    [destructors](#rh-dtor) – [copy](#rh-copy) – [getters and setters](#rh-get) –
    [multiple inheritance](#rh-mi-interface) – [overloading](#rh-using) – [slicing](#rc-copy-virtual)
    – [`dynamic_cast`](#rh-dynamic_cast)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'destructor: [and constructors](#rc-matched) – [when needed?](#rc-dtor) – [must
    not fail](#rc-dtor-fail)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'exception: [errors](#s-errors) – [`throw`](#re-throw) – [for errors only](#re-errors)
    – [`noexcept`](#re-noexcept) – [minimize `try`](#re-catch) – [what if no exceptions?](#re-no-throw-codes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for`: [range-for and for](#res-for-range) – [for and while](#res-for-while)
    – [for-initializer](#res-for-init) – [empty body](#res-empty) – [loop variable](#res-loop-counter)
    – [loop variable type ???](#res-???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'function: [naming](#rf-package) – [single operation](#rf-logical) – [no throw](#rf-noexcept)
    – [arguments](#rf-smart) – [argument passing](#rf-conventional) – [multiple return
    values](#rf-out-multi) – [pointers](#rf-return-ptr) – [lambdas](#rf-capture-vs-overload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inline`: [small functions](#rf-inline) – [in headers](#rs-inline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'initialization: [always](#res-always) – [prefer `{}`](#res-list) – [lambdas](#res-lambda-init)
    – [default member initializers](#rc-in-class-initializer) – [class members](#rc-initialize)
    – [factory functions](#rc-factory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'lambda expression: [when to use](#ss-lambdas)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'operator: [conventional](#ro-conventional) – [avoid conversion operators](#ro-conversion)
    – [and lambdas](#ro-lambda)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`, `private`, and `protected`: [information hiding](#rc-private) – [consistency](#rh-public)
    – [`protected`](#rh-protected)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_assert`: [compile-time checking](#rp-compile-time) – [and concepts](#rt-check-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct`: [for organizing data](#rc-org) – [use if no invariant](#rc-struct)
    – [no private members](#rc-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`: [abstraction](#rt-raise) – [containers](#rt-cont) – [concepts](#rt-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned`: [and signed](#res-mix) – [bit manipulation](#res-unsigned)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtual`: [interfaces](#ri-abstract) – [not `virtual`](#rc-concrete) – [destructor](#rc-dtor-virtual)
    – [never fail](#rc-dtor-fail)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can look at design concepts used to express the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'assertion: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'error: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'exception: exception guarantee (???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'failure: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'invariant: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'leak: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'library: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'precondition: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'postcondition: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'resource: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This document is a set of guidelines for using C++ well. The aim of this document
    is to help people to use modern C++ effectively. By “modern C++” we mean effective
    use of the ISO C++ standard (currently C++20, but almost all of our recommendations
    also apply to C++17, C++14 and C++11). In other words, what would you like your
    code to look like in 5 years’ time, given that you can start now? In 10 years’
    time?
  prefs: []
  type: TYPE_NORMAL
- en: The guidelines are focused on relatively high-level issues, such as interfaces,
    resource management, memory management, and concurrency. Such rules affect application
    architecture and library design. Following the rules will lead to code that is
    statically type safe, has no resource leaks, and catches many more programming
    logic errors than is common in code today. And it will run fast – you can afford
    to do things right.
  prefs: []
  type: TYPE_NORMAL
- en: We are less concerned with low-level issues, such as naming conventions and
    indentation style. However, no topic that can help a programmer is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Our initial set of rules emphasizes safety (of various forms) and simplicity.
    They might very well be too strict. We expect to have to introduce more exceptions
    to better accommodate real-world needs. We also need more rules.
  prefs: []
  type: TYPE_NORMAL
- en: You will find some of the rules contrary to your expectations or even contrary
    to your experience. If we haven’t suggested you change your coding style in any
    way, we have failed! Please try to verify or disprove rules! In particular, we’d
    really like to have some of our rules backed up with measurements or better examples.
  prefs: []
  type: TYPE_NORMAL
- en: You will find some of the rules obvious or even trivial. Please remember that
    one purpose of a guideline is to help someone who is less experienced or coming
    from a different background or language to get up to speed.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the rules are designed to be supported by an analysis tool. Violations
    of rules will be flagged with references (or links) to the relevant rule. We do
    not expect you to memorize all the rules before trying to write code. One way
    of thinking about these guidelines is as a specification for tools that happens
    to be readable by humans.
  prefs: []
  type: TYPE_NORMAL
- en: The rules are meant for gradual introduction into a code base. We plan to build
    tools for that and hope others will too.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and suggestions for improvements are most welcome. We plan to modify
    and extend this document as our understanding improves and the language and the
    set of available libraries improve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a set of core guidelines for modern C++ (currently C++20 and C++17)
    taking likely future enhancements and ISO Technical Specifications (TSs) into
    account. The aim is to help C++ programmers to write simpler, more efficient,
    more maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduction summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[In.target: Target readership](#ss-readers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[In.aims: Aims](#ss-aims)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[In.not: Non-aims](#ss-non)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[In.force: Enforcement](#ss-force)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[In.struct: The structure of this document](#ss-struct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[In.sec: Major sections](#ss-sec)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In.target: Target readership'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All C++ programmers. This includes [programmers who might consider C](#s-cpl).
  prefs: []
  type: TYPE_NORMAL
- en: 'In.aims: Aims'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this document is to help developers to adopt modern C++ (currently
    C++20 and C++17) and to achieve a more uniform style across code bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not suffer the delusion that every one of these rules can be effectively
    applied to every code base. Upgrading old systems is hard. However, we do believe
    that a program that uses a rule is less error-prone and more maintainable than
    one that does not. Often, rules also lead to faster/easier initial development.
    As far as we can tell, these rules lead to code that performs as well or better
    than older, more conventional techniques; they are meant to follow the zero-overhead
    principle (“what you don’t use, you don’t pay for” or “when you use an abstraction
    mechanism appropriately, you get at least as good performance as if you had handcoded
    using lower-level language constructs”). Consider these rules ideals for new code,
    opportunities to exploit when working on older code, and try to approximate these
    ideals as closely as feasible. Remember:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In.0: Don’t panic!'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take the time to understand the implications of a guideline rule on your program.
  prefs: []
  type: TYPE_NORMAL
- en: These guidelines are designed according to the “subset of superset” principle
    ([Stroustrup05](#Stroustrup05)). They do not simply define a subset of C++ to
    be used (for reliability, safety, performance, or whatever). Instead, they strongly
    recommend the use of a few simple “extensions” ([library components](#gsl-guidelines-support-library))
    that make the use of the most error-prone features of C++ redundant, so that they
    can be banned (in our set of rules).
  prefs: []
  type: TYPE_NORMAL
- en: The rules emphasize static type safety and resource safety. For that reason,
    they emphasize possibilities for range checking, for avoiding dereferencing `nullptr`,
    for avoiding dangling pointers, and the systematic use of exceptions (via RAII).
    Partly to achieve that and partly to minimize obscure code as a source of errors,
    the rules also emphasize simplicity and the hiding of necessary complexity behind
    well-specified interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the rules are prescriptive. We are uncomfortable with rules that simply
    state “don’t do that!” without offering an alternative. One consequence of that
    is that some rules can be supported only by heuristics, rather than precise and
    mechanically verifiable checks. Other rules articulate general principles. For
    these more general rules, more detailed and specific rules provide partial checking.
  prefs: []
  type: TYPE_NORMAL
- en: These guidelines address the core of C++ and its use. We expect that most large
    organizations, specific application areas, and even large projects will need further
    rules, possibly further restrictions, and further library support. For example,
    hard-real-time programmers typically can’t use free store (dynamic memory) freely
    and will be restricted in their choice of libraries. We encourage the development
    of such more specific rules as addenda to these core guidelines. Build your ideal
    small foundation library and use that, rather than lowering your level of programming
    to glorified assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: The rules are designed to allow [gradual adoption](#s-modernizing).
  prefs: []
  type: TYPE_NORMAL
- en: Some rules aim to increase various forms of safety while others aim to reduce
    the likelihood of accidents, many do both. The guidelines aimed at preventing
    accidents often ban perfectly legal C++. However, when there are two ways of expressing
    an idea and one has shown itself a common source of errors and the other has not,
    we try to guide programmers towards the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In.not: Non-aims'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rules are not intended to be minimal or orthogonal. In particular, general
    rules can be simple, but unenforceable. Also, it is often hard to understand the
    implications of a general rule. More specialized rules are often easier to understand
    and to enforce, but without general rules, they would just be a long list of special
    cases. We provide rules aimed at helping novices as well as rules supporting expert
    use. Some rules can be completely enforced, but others are based on heuristics.
  prefs: []
  type: TYPE_NORMAL
- en: These rules are not meant to be read serially, like a book. You can browse through
    them using the links. However, their main intended use is to be targets for tools.
    That is, a tool looks for violations and the tool returns links to violated rules.
    The rules then provide reasons, examples of potential consequences of the violation,
    and suggested remedies.
  prefs: []
  type: TYPE_NORMAL
- en: These guidelines are not intended to be a substitute for a tutorial treatment
    of C++. If you need a tutorial for some given level of experience, see [the references](#s-references).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a guide on how to convert old C++ code to more modern code. It
    is meant to articulate ideas for new code in a concrete fashion. However, see
    [the modernization section](#s-modernizing) for some possible approaches to modernizing/rejuvenating/upgrading.
    Importantly, the rules support gradual adoption: It is typically infeasible to
    completely convert a large code base all at once.'
  prefs: []
  type: TYPE_NORMAL
- en: These guidelines are not meant to be complete or exact in every language-technical
    detail. For the final word on language definition issues, including every exception
    to general rules and every feature, see the ISO C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: The rules are not intended to force you to write in an impoverished subset of
    C++. They are *emphatically* not meant to define a, say, Java-like subset of C++.
    They are not meant to define a single “one true C++” language. We value expressiveness
    and uncompromised performance.
  prefs: []
  type: TYPE_NORMAL
- en: The rules are not value-neutral. They are meant to make code simpler and more
    correct/safer than most existing C++ code, without loss of performance. They are
    meant to inhibit perfectly valid C++ code that correlates with errors, spurious
    complexity, and poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: The rules are not precise to the point where a person (or machine) can follow
    them without thinking. The enforcement parts try to be that, but we would rather
    leave a rule or a definition a bit vague and open to interpretation than specify
    something precisely and wrong. Sometimes, precision comes only with time and experience.
    Design is not (yet) a form of Math.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules are not perfect. A rule can do harm by prohibiting something that
    is useful in a given situation. A rule can do harm by failing to prohibit something
    that enables a serious error in a given situation. A rule can do a lot of harm
    by being vague, ambiguous, unenforceable, or by enabling every solution to a problem.
    It is impossible to completely meet the “do no harm” criteria. Instead, our aim
    is the less ambitious: “Do the most good for most programmers”; if you cannot
    live with a rule, object to it, ignore it, but don’t water it down until it becomes
    meaningless. Also, suggest an improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In.force: Enforcement'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rules with no enforcement are unmanageable for large code bases. Enforcement
    of all rules is possible only for a small weak set of rules or for a specific
    user community.
  prefs: []
  type: TYPE_NORMAL
- en: But we want lots of rules, and we want rules that everybody can use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But different people have different needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But people don’t like to read lots of rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But people can’t remember many rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we need subsetting to meet a variety of needs.
  prefs: []
  type: TYPE_NORMAL
- en: But arbitrary subsetting leads to chaos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want guidelines that help a lot of people, make code more uniform, and strongly
    encourage people to modernize their code. We want to encourage best practices,
    rather than leave all to individual choices and management pressures. The ideal
    is to use all rules; that gives the greatest benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'This adds up to quite a few dilemmas. We try to resolve those using tools.
    Each rule has an **Enforcement** section listing ideas for enforcement. Enforcement
    might be done by code review, by static analysis, by compiler, or by run-time
    checks. Wherever possible, we prefer “mechanical” checking (humans are slow, inaccurate,
    and bore easily) and static checking. Run-time checks are suggested only rarely
    where no alternative exists; we do not want to introduce “distributed bloat”.
    Where appropriate, we label a rule (in the **Enforcement** sections) with the
    name of groups of related rules (called “profiles”). A rule can be part of several
    profiles, or none. For a start, we have a few profiles corresponding to common
    needs (desires, ideals):'
  prefs: []
  type: TYPE_NORMAL
- en: '**type**: No type violations (reinterpreting a `T` as a `U` through casts,
    unions, or varargs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bounds**: No bounds violations (accessing beyond the range of an array)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lifetime**: No leaks (failing to `delete` or multiple `delete`) and no access
    to invalid objects (dereferencing `nullptr`, using a dangling reference).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The profiles are intended to be used by tools, but also serve as an aid to the
    human reader. We do not limit our comment in the **Enforcement** sections to things
    we know how to enforce; some comments are mere wishes that might inspire some
    tool builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools that implement these rules shall respect the following syntax to explicitly
    suppress a rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and optionally with a message (following usual C++11 standard attribute syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '`"tag"` is a string literal with the anchor name of the item where the Enforcement
    rule appears (e.g., for [C.134](#rh-public) it is “rh-public”), the name of a
    profile group-of-rules (“type”, “bounds”, or “lifetime”), or a specific rule in
    a profile ([type.4](#pro-type-cstylecast), or [bounds.2](#pro-bounds-arrayindex)).
    Any text that is not one of those should be rejected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"message"` is a string literal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In.struct: The structure of this document'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each rule (guideline, suggestion) can have several parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The rule itself – e.g., **no naked `new`**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rule reference number – e.g., **C.7** (the 7th rule related to classes). Since
    the major sections are not inherently ordered, we use letters as the first part
    of a rule reference “number”. We leave gaps in the numbering to minimize “disruption”
    when we add or remove rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason**s (rationales) – because programmers find it hard to follow rules
    they don’t understand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example**s – because rules are hard to understand in the abstract; can be
    positive or negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alternative**s – for “don’t do this” rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception**s – we prefer simple general rules. However, many rules apply
    widely, but not universally, so exceptions must be listed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enforcement** – ideas about how the rule might be checked “mechanically”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**s – references to related rules and/or further discussion (in this
    document or elsewhere)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**s (comments) – something that needs saying that doesn’t fit the other
    classifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discussion** – references to more extensive rationale and/or examples placed
    outside the main lists of rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some rules are hard to check mechanically, but they all meet the minimal criteria
    that an expert programmer can spot many violations without too much trouble. We
    hope that “mechanical” tools will improve with time to approximate what such an
    expert programmer notices. Also, we assume that the rules will be refined over
    time to make them more precise and checkable.
  prefs: []
  type: TYPE_NORMAL
- en: A rule is aimed at being simple, rather than carefully phrased to mention every
    alternative and special case. Such information is found in the **Alternative**
    paragraphs and the [Discussion](#s-discussion) sections. If you don’t understand
    a rule or disagree with it, please visit its **Discussion**. If you feel that
    a discussion is missing or incomplete, enter an [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)
    explaining your concerns and possibly a corresponding PR.
  prefs: []
  type: TYPE_NORMAL
- en: Examples are written to illustrate rules.
  prefs: []
  type: TYPE_NORMAL
- en: Examples are not intended to be production quality or to cover all tutorial
    dimensions. For example, many examples are language-technical and use names like
    `f`, `base`, and `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We try to ensure that “good” examples follow the Core Guidelines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments are often illustrating rules where they would be unnecessary and/or
    distracting in “real code.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We assume knowledge of the standard library. For example, we use plain `vector`
    rather than `std::vector`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a language manual. It is meant to be helpful, rather than complete,
    fully accurate on technical details, or a guide to existing code. Recommended
    information sources can be found in [the references](#s-references).
  prefs: []
  type: TYPE_NORMAL
- en: 'In.sec: Major sections'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[In: Introduction](#s-introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P: Philosophy](#s-philosophy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I: Interfaces](#s-interfaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F: Functions](#s-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C: Classes and class hierarchies](#s-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum: Enumerations](#s-enum)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R: Resource management](#s-resource)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES: Expressions and statements](#s-expr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per: Performance](#s-performance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP: Concurrency and parallelism](#s-concurrency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E: Error handling](#s-errors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Con: Constants and immutability](#s-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T: Templates and generic programming](#s-templates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CPL: C-style programming](#s-cpl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF: Source files](#s-source)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL: The Standard Library](#sl-the-standard-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supporting sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A: Architectural ideas](#s-a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR: Non-Rules and myths](#s-not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RF: References](#s-references)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pro: Profiles](#s-profile)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GSL: Guidelines support library](#gsl-guidelines-support-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL: Naming and layout suggestions](#s-naming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FAQ: Answers to frequently asked questions](#s-faq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix A: Libraries](#s-libraries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix B: Modernizing code](#s-modernizing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix C: Discussion](#s-discussion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix D: Supporting tools](#s-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Glossary](#s-glossary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[To-do: Unclassified proto-rules](#s-unclassified)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These sections are not orthogonal.
  prefs: []
  type: TYPE_NORMAL
- en: Each section (e.g., “P” for “Philosophy”) and each subsection (e.g., “C.hier”
    for “Class Hierarchies (OOP)”) have an abbreviation for ease of searching and
    reference. The main section abbreviations are also used in rule numbers (e.g.,
    “C.11” for “Make concrete types regular”).
  prefs: []
  type: TYPE_NORMAL
- en: 'P: Philosophy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rules in this section are very general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Philosophy rules summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[P.1: Express ideas directly in code](#rp-direct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.2: Write in ISO Standard C++](#rp-cplusplus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.3: Express intent](#rp-what)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.4: Ideally, a program should be statically type safe](#rp-typesafe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.5: Prefer compile-time checking to run-time checking](#rp-compile-time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.6: What cannot be checked at compile time should be checkable at run time](#rp-run-time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.7: Catch run-time errors early](#rp-early)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.8: Don’t leak any resources](#rp-leak)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.9: Don’t waste time or space](#rp-waste)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.10: Prefer immutable data to mutable data](#rp-mutable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.11: Encapsulate messy constructs, rather than spreading through the code](#rp-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.12: Use supporting tools as appropriate](#rp-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[P.13: Use support libraries as appropriate](#rp-lib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Philosophical rules are generally not mechanically checkable. However, individual
    rules reflecting these philosophical themes are. Without a philosophical basis,
    the more concrete/specific/checkable rules lack rationale.
  prefs: []
  type: TYPE_NORMAL
- en: 'P.1: Express ideas directly in code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compilers don’t read comments (or design documents) and neither do many programmers
    (consistently). What is expressed in code has defined semantics and can (in principle)
    be checked by compilers and other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first declaration of `month` is explicit about returning a `Month` and about
    not modifying the state of the `Date` object. The second version leaves the reader
    guessing and opens more possibilities for uncaught bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This loop is a restricted form of `std::find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A much clearer expression of intent would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A well-designed library expresses intent (what is to be done, rather than just
    how something is being done) far better than direct use of language features.
  prefs: []
  type: TYPE_NORMAL
- en: A C++ programmer should know the basics of the standard library, and use it
    where appropriate. Any programmer should know the basics of the foundation libraries
    of the project being worked on, and use them appropriately. Any programmer using
    these guidelines should know the [guidelines support library](#gsl-guidelines-support-library),
    and use it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A better approach is to be explicit about the meaning of the double (new speed
    or delta on old speed?) and the unit used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We could have accepted a plain (unit-less) `double` as a delta, but that would
    have been error-prone. If we wanted both absolute speed and deltas, we would have
    defined a `Delta` type.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Very hard in general.
  prefs: []
  type: TYPE_NORMAL
- en: use `const` consistently (check if member functions modify their object; check
    if functions modify arguments passed by pointer or reference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: flag uses of casts (casts neuter the type system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: detect code that mimics the standard library (hard)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.2: Write in ISO Standard C++'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a set of guidelines for writing ISO Standard C++.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are environments where extensions are necessary, e.g., to access system
    resources. In such cases, localize the use of necessary extensions and control
    their use with non-core Coding Guidelines. If possible, build interfaces that
    encapsulate the extensions so they can be turned off or compiled away on systems
    that do not support those extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions often do not have rigorously defined semantics. Even extensions that
    are common and implemented by multiple compilers might have slightly different
    behaviors and edge case behavior as a direct result of *not* having a rigorous
    standard definition. With sufficient use of any such extension, expected portability
    will be impacted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using valid ISO C++ does not guarantee portability (let alone correctness).
    Avoid dependence on undefined behavior (e.g., [undefined order of evaluation](#res-order))
    and be aware of constructs with implementation defined meaning (e.g., `sizeof(int)`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are environments where restrictions on use of standard C++ language or
    library features are necessary, e.g., to avoid dynamic memory allocation as required
    by aircraft control software standards. In such cases, control their (dis)use
    with an extension of these Coding Guidelines customized to the specific environment.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use an up-to-date C++ compiler (currently C++20 or C++17) with a set of options
    that do not accept extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'P.3: Express intent'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unless the intent of some code is stated (e.g., in names or comments), it is
    impossible to tell whether the code does what it is supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The intent of “just” looping over the elements of `v` is not expressed here.
    The implementation detail of an index is exposed (so that it might be misused),
    and `i` outlives the scope of the loop, which might or might not be intended.
    The reader cannot know from just this section of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, there is no explicit mention of the iteration mechanism, and the loop
    operates on a reference to `const` elements so that accidental modification cannot
    happen. If modification is desired, say so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For more details about for-statements, see [ES.71](#res-for-range). Sometimes
    better still, use a named algorithm. This example uses the `for_each` from the
    Ranges TS because it directly expresses the intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last variant makes it clear that we are not interested in the order in which
    the elements of `v` are handled.
  prefs: []
  type: TYPE_NORMAL
- en: A programmer should be familiar with
  prefs: []
  type: TYPE_NORMAL
- en: '[The guidelines support library](#gsl-guidelines-support-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The ISO C++ Standard Library](#sl-the-standard-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever foundation libraries are used for the current project(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Alternative formulation: Say what should be done, rather than just how it should
    be done.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some language constructs express intent better than others.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If two `int`s are meant to be the coordinates of a 2D point, say so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for common patterns for which there are better alternatives
  prefs: []
  type: TYPE_NORMAL
- en: simple `for` loops vs. range-`for` loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f(T*, int)` interfaces vs. `f(span<T>)` interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: loop variables in too large a scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: naked `new` and `delete`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: functions with many parameters of built-in types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a huge scope for cleverness and semi-automated program transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'P.4: Ideally, a program should be statically type safe'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ideally, a program would be completely statically (compile-time) type safe.
    Unfortunately, that is not possible. Problem areas:'
  prefs: []
  type: TYPE_NORMAL
- en: unions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: array decay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: range errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: narrowing conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: These areas are sources of serious problems (e.g., crashes and security violations).
    We try to provide alternative techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can ban, restrain, or detect the individual problem categories separately,
    as required and feasible for individual programs. Always suggest an alternative.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: unions – use `variant` (in C++17)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: casts – minimize their use; templates can help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: array decay – use `span` (from the GSL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: range errors – use `span`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: narrowing conversions – minimize their use and use `narrow` or `narrow_cast`
    (from the GSL) where they are necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.5: Prefer compile-time checking to run-time checking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Code clarity and performance. You don’t need to write error handlers for errors
    caught at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This example fails to achieve what it is trying to achieve (because overflow
    is undefined) and should be replaced with a simple `static_assert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Or better still just use the type system and replace `Int` with `int32_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: better
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Alternative formulation**: Don’t postpone to run time what can be done well
    at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for pointer arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for run-time checks for range violations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.6: What cannot be checked at compile time should be checkable at run time'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Leaving hard-to-detect errors in a program is asking for crashes and bad results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ideally, we catch all errors (that are not errors in the programmer’s logic)
    at either compile time or run time. It is impossible to catch all errors at compile
    time and often not affordable to catch all remaining errors at run time. However,
    we should endeavor to write programs that in principle can be checked, given sufficient
    resources (analysis programs, run-time checks, machine resources, time).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, a crucial bit of information (the number of elements) has been so thoroughly
    “obscured” that static analysis is probably rendered infeasible and dynamic checking
    can be very difficult when `f()` is part of an ABI so that we cannot “instrument”
    that pointer. We could embed helpful information into the free store, but that
    requires global changes to a system and maybe to the compiler. What we have here
    is a design that makes error detection very hard.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can of course pass the number of elements along with the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Passing the number of elements as an argument is better (and far more common)
    than just passing the pointer and relying on some (unstated) convention for knowing
    or discovering the number of elements. However (as shown), a simple typo can introduce
    a serious error. The connection between the two arguments of `f2()` is conventional,
    rather than explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is implicit that `f2()` is supposed to `delete` its argument (or did
    the caller make a second mistake?).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The standard library resource management pointers fail to pass the size when
    they point to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We need to pass the pointer and the number of elements as an integral object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This design carries the number of elements along as an integral part of an object,
    so that errors are unlikely and dynamic (run-time) checking is always feasible,
    if not always affordable.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How do we transfer both ownership and all information needed for validating
    use?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: show how possible checks are avoided by interfaces that pass polymorphic base
    classes around, when they actually know what they need? Or strings as “free-style”
    options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag (pointer, count)-style interfaces (this will flag a lot of examples that
    can’t be fixed for compatibility reasons)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.7: Catch run-time errors early'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid “mysterious” crashes. Avoid errors leading to (possibly unrecognized)
    wrong results.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we made a small error in `use1` that will lead to corrupted data or a
    crash. The (pointer, count)-style interface leaves `increment1()` with no realistic
    way of defending itself against out-of-range errors. If we could check subscripts
    for out of range access, then the error would not be discovered until `p[10]`
    was accessed. We could check earlier and improve the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `m <= n` can be checked at the point of call (early) rather than later.
    If all we had was a typo so that we meant to use `n` as the bound, the code could
    be further simplified (eliminating the possibility of an error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Don’t repeatedly check the same value. Don’t pass structured data as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The date is validated twice (by the `Date` constructor) and passed as a character
    string (unstructured data).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Excess checking can be costly. There are cases where checking early is inefficient
    because you might never need the value, or might only need part of the value that
    is more easily checked than the whole. Similarly, don’t add validity checks that
    change the asymptotic behavior of your interface (e.g., don’t add a `O(n)` check
    to an interface with an average complexity of `O(1)`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The physical law for a jet (`e * e < x * x + y * y + z * z`) is not an invariant
    because of the possibility for measurement errors.
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Look at pointers and arrays: Do range-checking early and not repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look at conversions: Eliminate or mark narrowing conversions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for unchecked values coming from input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for structured data (objects of classes with invariants) being converted
    into strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.8: Don’t leak any resources'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Even a slow growth in resources will, over time, exhaust the availability of
    those resources. This is particularly important for long-running programs, but
    is an essential piece of responsible programming behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Prefer [RAII](#rr-raii):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: [The resource management section](#s-resource)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A leak is colloquially “anything that isn’t cleaned up.” The more important
    classification is “anything that can no longer be cleaned up.” For example, allocating
    an object on the heap and then losing the last pointer that points to that allocation.
    This rule should not be taken as requiring that allocations within long-lived
    objects must be returned during program shutdown. For example, relying on system
    guaranteed cleanup such as file closing and memory deallocation upon process shutdown
    can simplify code. However, relying on abstractions that implicitly clean up can
    be as simple, and often safer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enforcing [the lifetime safety profile](#ss-lifetime) eliminates leaks. When
    combined with resource safety provided by [RAII](#rr-raii), it eliminates the
    need for “garbage collection” (by generating no garbage). Combine this with enforcement
    of [the type and bounds profiles](#ss-force) and you get complete type- and resource-safety,
    guaranteed by tools.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Look at pointers: Classify them into non-owners (the default) and owners. Where
    feasible, replace owners with standard-library resource handles (as in the example
    above). Alternatively, mark an owner as such using `owner` from [the GSL](#gsl-guidelines-support-library).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for naked `new` and `delete`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for known resource allocating functions returning raw pointers (such as
    `fopen`, `malloc`, and `strdup`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.9: Don’t waste time or space'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is C++.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Time and space that you spend well to achieve a goal (e.g., speed of development,
    resource safety, or simplification of testing) is not wasted. “Another benefit
    of striving for efficiency is that the process forces you to understand the problem
    in more depth.” - Alex Stepanov
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Yes, this is a caricature, but we have seen every individual mistake in production
    code, and worse. Note that the layout of `X` guarantees that at least 6 bytes
    (and most likely more) are wasted. The spurious definition of copy operations
    disables move semantics so that the return operation is slow (please note that
    the Return Value Optimization, RVO, is not guaranteed here). The use of `new`
    and `delete` for `buf` is redundant; if we really needed a local string, we should
    use a local `string`. There are several more performance bugs and gratuitous complication.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is actually an example from production code. We can see that in our condition
    we have `i < strlen(s)`. This expression will be evaluated on every iteration
    of the loop, which means that `strlen` must walk through string every loop to
    discover its length. While the string contents are changing, it’s assumed that
    `tolower` will not affect the length of the string, so it’s better to cache the
    length outside the loop and not incur that cost each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An individual example of waste is rarely significant, and where it is significant,
    it is typically easily eliminated by an expert. However, waste spread liberally
    across a code base can easily be significant and experts are not always as available
    as we would like. The aim of this rule (and the more specific rules that support
    it) is to eliminate most waste related to the use of C++ before it happens. After
    that, we can look at waste related to algorithms and requirements, but that is
    beyond the scope of these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many more specific rules aim at the overall goals of simplicity and elimination
    of gratuitous waste.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flag an unused return value from a user-defined non-defaulted postfix `operator++`
    or `operator--` function. Prefer using the prefix form instead. (Note: “User-defined
    non-defaulted” is intended to reduce noise. Review this enforcement if it’s still
    too noisy in practice.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.10: Prefer immutable data to mutable data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is easier to reason about constants than about variables. Something immutable
    cannot change unexpectedly. Sometimes immutability enables better optimization.
    You can’t have a data race on a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'See [Con: Constants and immutability](#s-const)'
  prefs: []
  type: TYPE_NORMAL
- en: 'P.11: Encapsulate messy constructs, rather than spreading through the code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Messy code is more likely to hide bugs and harder to write. A good interface
    is easier and safer to use. Messy, low-level code breeds more such code.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is low-level, verbose, and error-prone. For example, we “forgot” to test
    for memory exhaustion and assign new value to `sz`. Instead, we could use `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The standards library and the GSL are examples of this philosophy. For example,
    instead of messing with the arrays, unions, cast, tricky lifetime issues, `gsl::owner`,
    etc., that are needed to implement key abstractions, such as `vector`, `span`,
    `lock_guard`, and `future`, we use the libraries designed and implemented by people
    with more time and expertise than we usually have. Similarly, we can and should
    design and implement more specialized libraries, rather than leaving the users
    (often ourselves) with the challenge of repeatedly getting low-level code well.
    This is a variant of the [subset of superset principle](#r0) that underlies these
    guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for “messy code” such as complex pointer manipulation and casting outside
    the implementation of abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P.12: Use supporting tools as appropriate'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are many things that are done better “by machine”. Computers don’t tire
    or get bored by repetitive tasks. We typically have better things to do than repeatedly
    do routine tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Run a static analyzer to verify that your code follows the guidelines you want
    it to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See
  prefs: []
  type: TYPE_NORMAL
- en: '[Static analysis tools](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Concurrency tools](#rconc-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Testing tools](https://github.com/isocpp/CppCoreGuidelines/tree/master)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other kinds of tools, such as source code repositories, build
    tools, etc., but those are beyond the scope of these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Be careful not to become dependent on over-elaborate or over-specialized tool
    chains. Those can make your otherwise portable code non-portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'P.13: Use support libraries as appropriate'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using a well-designed, well-documented, and well-supported library saves time
    and effort; its quality and documentation are likely to be greater than what you
    could do if the majority of your time must be spent on an implementation. The
    cost (time, effort, money, etc.) of a library can be shared over many users. A
    widely used library is more likely to be kept up-to-date and ported to new systems
    than an individual application. Knowledge of a widely-used library can save time
    on other/future projects. So, if a suitable library exists for your application
    domain, use it.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Unless you are an expert in sorting algorithms and have plenty of time, this
    is more likely to be correct and to run faster than anything you write for a specific
    application. You need a reason not to use the standard library (or whatever foundational
    libraries your application uses) rather than a reason to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By default use
  prefs: []
  type: TYPE_NORMAL
- en: The [ISO C++ Standard Library](#sl-the-standard-library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Guidelines Support Library](#gsl-guidelines-support-library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If no well-designed, well-documented, and well-supported library exists for
    an important domain, maybe you should design and implement it, and then use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I: Interfaces'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface is a contract between two parts of a program. Precisely stating
    what is expected of a supplier of a service and a user of that service is essential.
    Having good (easy-to-understand, encouraging efficient use, not error-prone, supporting
    testing, etc.) interfaces is probably the most important single aspect of code
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[I.1: Make interfaces explicit](#ri-explicit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.2: Avoid non-`const` global variables](#ri-global)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.3: Avoid singletons](#ri-singleton)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.4: Make interfaces precisely and strongly typed](#ri-typed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.5: State preconditions (if any)](#ri-pre)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.6: Prefer `Expects()` for expressing preconditions](#ri-expects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.7: State postconditions](#ri-post)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.8: Prefer `Ensures()` for expressing postconditions](#ri-ensures)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.9: If an interface is a template, document its parameters using concepts](#ri-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.10: Use exceptions to signal a failure to perform a required task](#ri-except)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)](#ri-raw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.12: Declare a pointer that must not be null as `not_null`](#ri-nullptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.13: Do not pass an array as a single pointer](#ri-array)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.22: Avoid complex initialization of global objects](#ri-global-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.23: Keep the number of function arguments low](#ri-nargs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.24: Avoid adjacent parameters that can be invoked by the same arguments
    in either order with different meaning](#ri-unrelated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.25: Prefer empty abstract classes as interfaces to class hierarchies](#ri-abstract)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.26: If you want a cross-compiler ABI, use a C-style subset](#ri-abi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.27: For stable library ABI, consider the Pimpl idiom](#ri-pimpl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I.30: Encapsulate rule violations](#ri-encapsulate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F: Functions](#s-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.concrete: Concrete types](#ss-concrete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.hier: Class hierarchies](#ss-hier)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.over: Overloading and overloaded operators](#ss-overload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.con: Containers and other resource handles](#ss-containers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E: Error handling](#s-errors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T: Templates and generic programming](#s-templates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.1: Make interfaces explicit'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Correctness. Assumptions not stated in an interface are easily overlooked and
    hard to test.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Controlling the behavior of a function through a global (namespace scope) variable
    (a call mode) is implicit and potentially confusing. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It will not be obvious to a caller that the meaning of two calls of `round(7.2)`
    might give different results.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes we control the details of a set of operations by an environment variable,
    e.g., normal vs. verbose output or debug vs. optimized. The use of a non-local
    control is potentially confusing, but controls only implementation details of
    otherwise fixed semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Reporting through non-local variables (e.g., `errno`) is easily ignored. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What if the connection goes down so that no logging output is produced? See
    I.???.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Throw an exception. An exception cannot be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative formulation**: Avoid passing information across an interface
    through non-local or implicit state. Note that non-`const` member functions pass
    information to other member functions through their object’s state.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative formulation**: An interface should be a function or a set of
    functions. Functions can be function templates and sets of functions can be classes
    or class templates.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) A function should not make control-flow decisions based on the values
    of variables declared at namespace scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) A function should not write to variables declared at namespace scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.2: Avoid non-`const` global variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Non-`const` global variables hide dependencies and make the dependencies subject
    to unpredictable changes.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Who else might modify `data`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning**: The initialization of global objects is not totally ordered. If
    you use a global object initialize it with a constant. Note that it is possible
    to get undefined initialization order even for `const` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A global object is often better than a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Global constants are useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The rule against global variables applies to namespace scope variables as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: If you use global (more generally namespace scope) data to
    avoid copying, consider passing the data as an object by reference to `const`.
    Another solution is to define the data as the state of some object and the operations
    as member functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning**: Beware of data races: If one thread can access non-local data
    (or data passed by reference) while another thread executes the callee, we can
    have a data race. Every pointer or reference to mutable data is a potential data
    race.'
  prefs: []
  type: TYPE_NORMAL
- en: Using global pointers or references to access and change non-const, and otherwise
    non-global, data isn’t a better alternative to non-const global variables since
    that doesn’t solve the issues of hidden dependencies or potential race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You cannot have a race condition on immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**: See the [rules for calling functions](#ss-call).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The rule is “avoid”, not “don’t use.” Of course there will be (rare) exceptions,
    such as `cin`, `cout`, and `cerr`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Report all non-`const` variables declared at namespace scope and global
    pointers/references to non-const data.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.3: Avoid singletons'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Singletons are basically complicated global objects in disguise.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There are many variants of the singleton idea. That’s part of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you don’t want a global object to change, declare it `const` or `constexpr`.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use the simplest “singleton” (so simple that it is often not considered
    a singleton) to get initialization on first use, if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the most effective solutions to problems related to initialization
    order. In a multi-threaded environment, the initialization of the static object
    does not introduce a race condition (unless you carelessly access a shared object
    from within its constructor).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the initialization of a local `static` does not imply a race condition.
    However, if the destruction of `X` involves an operation that needs to be synchronized
    we must use a less simple solution. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now someone must `delete` that object in some suitably thread-safe way. That’s
    error-prone, so we don’t use that technique unless
  prefs: []
  type: TYPE_NORMAL
- en: '`myX` is in multi-threaded code,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that `X` object needs to be destroyed (e.g., because it releases a resource),
    and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X`’s destructor’s code needs to be synchronized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you, as many do, define a singleton as a class for which only one object
    is created, functions like `myX` are not singletons, and this useful technique
    is not an exception to the no-singleton rule.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Very hard in general.
  prefs: []
  type: TYPE_NORMAL
- en: Look for classes with names that include `singleton`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for classes for which only a single object is created (by counting objects
    or by examining constructors).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a class X has a public static function that contains a function-local static
    of the class’ type X and returns a pointer or reference to it, ban that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.4: Make interfaces precisely and strongly typed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Types are the simplest and best documentation, improve legibility due to their
    well-defined meaning, and are checked at compile time. Also, precisely typed code
    is often optimized better.
  prefs: []
  type: TYPE_NORMAL
- en: Example, don’t
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Callers are unsure what types are allowed and if the data may be mutated as
    `const` is not specified. Note all pointer types implicitly convert to `void*`,
    so it is easy for callers to provide this value.
  prefs: []
  type: TYPE_NORMAL
- en: The callee must `static_cast` data to an unverified type to use it. That is
    error-prone and verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Only use `const void*` for passing in data in designs that are indescribable
    in C++. Consider using a `variant` or a pointer to base instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Often, a template parameter can eliminate the `void*` turning
    it into a `T*` or `T&`. For generic code these `T`s can be general or concept
    constrained template parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It is clear that the caller is describing a rectangle, but it is unclear what
    parts they relate to. Also, an `int` can carry arbitrary forms of information,
    including values of many units, so we must guess about the meaning of the four
    `int`s. Most likely, the first two are an `x`,`y` coordinate pair, but what are
    the last two?
  prefs: []
  type: TYPE_NORMAL
- en: 'Comments and parameter names can help, but we could be explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we cannot catch all errors through the static type system (e.g.,
    the fact that a first argument is supposed to be a top-left point is left to convention
    (naming and comments)).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The parameter types and their values do not communicate what settings are being
    specified or what those values mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'This design is more explicit, safe and legible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For the case of a set of boolean values consider using a flags `enum`; a pattern
    that expresses a set of boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the following example, it is not clear from the interface what `time_to_blink`
    means: Seconds? Milliseconds?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::chrono::duration` types help making the unit of time duration explicit.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The function can also be written in such a way that it will accept any time
    duration unit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Report the use of `void*` as a parameter or return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Report the use of more than one `bool` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Hard to do well) Look for functions that use too many primitive type arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.5: State preconditions (if any)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Arguments have meaning that might constrain their proper use in the callee.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `x` must be non-negative. The type system cannot (easily and naturally)
    express that, so we must use other means. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Some preconditions can be expressed as assertions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Ideally, that `Expects(x >= 0)` should be part of the interface of `sqrt()`
    but that’s not easily done. For now, we place it in the definition (function body).
  prefs: []
  type: TYPE_NORMAL
- en: '**References**: `Expects()` is described in [GSL](#gsl-guidelines-support-library).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prefer a formal specification of requirements, such as `Expects(p);`. If that
    is infeasible, use English text in comments, such as `// the sequence [p:q) is
    ordered using <`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most member functions have as a precondition that some class invariant holds.
    That invariant is established by a constructor and must be reestablished upon
    exit by every member function called from outside the class. We don’t need to
    mention it for each member function.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable)
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: The rules for passing pointers. ???'
  prefs: []
  type: TYPE_NORMAL
- en: 'I.6: Prefer `Expects()` for expressing preconditions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make it clear that the condition is a precondition and to enable tool use.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Preconditions can be stated in many ways, including comments, `if`-statements,
    and `assert()`. This can make them hard to distinguish from ordinary code, hard
    to update, hard to manipulate by tools, and might have the wrong semantics (do
    you always want to abort in debug mode and check nothing in productions runs?).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Preconditions should be part of the interface rather than part of the implementation,
    but we don’t yet have the language facilities to do that. Once language support
    becomes available (e.g., see the [contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf))
    we will adopt the standard version of preconditions, postconditions, and assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`Expects()` can also be used to check a condition in the middle of an algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: No, using `unsigned` is not a good way to sidestep the problem of [ensuring
    that a value is non-negative](#res-nonnegative).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) Finding the variety of ways preconditions can be asserted
    is not feasible. Warning about those that can be easily identified (`assert()`)
    has questionable value in the absence of a language facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.7: State postconditions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To detect misunderstandings about the result and possibly catch erroneous implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we (incautiously) left out the precondition specification, so it is not
    explicit that height and width must be positive. We also left out the postcondition
    specification, so it is not obvious that the algorithm (`height * width`) is wrong
    for areas larger than the largest integer. Overflow can happen. Consider using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider a famous security bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There was no postcondition stating that the buffer should be cleared and the
    optimizer eliminated the apparently redundant `memset()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Postconditions are often informally stated in a comment that states the purpose
    of a function; `Ensures()` can be used to make this more systematic, visible,
    and checkable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Postconditions are especially important when they relate to something that is
    not directly reflected in a returned result, such as a state of a data structure
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider a function that manipulates a `Record`, using a `mutex` to avoid race
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we “forgot” to state that the `mutex` should be released, so we don’t
    know if the failure to ensure release of the `mutex` was a bug or a feature. Stating
    the postcondition would have made it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The bug is now obvious (but only to a human reading comments).
  prefs: []
  type: TYPE_NORMAL
- en: 'Better still, use [RAII](#rr-raii) to ensure that the postcondition (“the lock
    must be released”) is enforced in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ideally, postconditions are stated in the interface/declaration so that users
    can easily see them. Only postconditions related to the users can be stated in
    the interface. Postconditions related only to internal state belong in the definition/implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) This is a philosophical guideline that is infeasible to check
    directly in the general case. Domain specific checkers (like lock-holding checkers)
    exist for many toolchains.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.8: Prefer `Ensures()` for expressing postconditions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make it clear that the condition is a postcondition and to enable tool use.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Postconditions can be stated in many ways, including comments, `if`-statements,
    and `assert()`. This can make them hard to distinguish from ordinary code, hard
    to update, hard to manipulate by tools, and might have the wrong semantics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Postconditions of the form “this resource must be released”
    are best expressed by [RAII](#rr-raii).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ideally, that `Ensures` should be part of the interface, but that’s not easily
    done. For now, we place it in the definition (function body). Once language support
    becomes available (e.g., see the [contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf))
    we will adopt the standard version of preconditions, postconditions, and assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) Finding the variety of ways postconditions can be asserted
    is not feasible. Warning about those that can be easily identified (`assert()`)
    has questionable value in the absence of a language facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.9: If an interface is a template, document its parameters using concepts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Make the interface precisely specified and compile-time checkable in the (not
    so distant) future.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Use the C++20 style of requirements specification. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: [Generic programming](#ss-gp) and [concepts](#ss-concepts).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Warn if any non-variadic template parameter is not constrained by a concept
    (in its declaration or mentioned in a `requires` clause).
  prefs: []
  type: TYPE_NORMAL
- en: 'I.10: Use exceptions to signal a failure to perform a required task'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It should not be possible to ignore an error because that could leave the system
    or a computation in an undefined (or unexpected) state. This is a major source
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What is an error?
  prefs: []
  type: TYPE_NORMAL
- en: 'An error means that the function cannot achieve its advertised purpose (including
    establishing postconditions). Calling code that ignores an error could lead to
    wrong results or undefined systems state. For example, not being able to connect
    to a remote server is not by itself an error: the server can refuse a connection
    for all kinds of reasons, so the natural thing is to return a result that the
    caller should always check. However, if failing to make a connection is considered
    an error, then a failure should throw an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many traditional interface functions (e.g., UNIX signal handlers) use error
    codes (e.g., `errno`) to report what are really status codes, rather than errors.
    You don’t have a good alternative to using such, so calling these does not violate
    the rule.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you can’t use exceptions (e.g., because your code is full of old-style raw-pointer
    use or because there are hard-real-time constraints), consider using a style that
    returns a pair of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This style unfortunately leads to uninitialized variables. Since C++17 the
    “structured bindings” feature can be used to initialize variables directly from
    the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We don’t consider “performance” a valid reason not to use exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Often, explicit error checking and handling consume as much time and space as
    exception handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, cleaner code yields better performance with exceptions (simplifying the
    tracing of paths through the program and their optimization).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good rule for performance critical code is to move checking outside the [critical](#rper-critical)
    part of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the longer term, more regular code gets better optimized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always carefully [measure](#rper-measure) before making performance claims.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**: [I.5](#ri-pre) and [I.7](#ri-post) for reporting precondition
    and postcondition violations.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) This is a philosophical guideline that is infeasible to check
    directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for `errno`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If there is any doubt whether the caller or the callee owns an object, leaks
    or premature destruction will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Who deletes the returned `X`? The problem would be harder to spot if `compute`
    returned a reference. Consider returning the result by value (use move semantics
    if the result is large):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**Alternative**: [Pass ownership](#rr-smartptrparam) using a “smart pointer”,
    such as `unique_ptr` (for exclusive ownership) and `shared_ptr` (for shared ownership).
    However, that is less elegant and often less efficient than returning the object
    itself, so use smart pointers only if reference semantics are needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Sometimes older code can’t be modified because of ABI compatibility
    requirements or lack of resources. In that case, mark owning pointers using `owner`
    from the [guidelines support library](#gsl-guidelines-support-library):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This tells analysis tools that `res` is an owner. That is, its value must be
    `delete`d or transferred to another owner, as is done here by the `return`.
  prefs: []
  type: TYPE_NORMAL
- en: '`owner` is used similarly in the implementation of resource handles.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Every object passed as a raw pointer (or iterator) is assumed to be owned by
    the caller, so that its lifetime is handled by the caller. Viewed another way:
    ownership transferring APIs are relatively rare compared to pointer-passing APIs,
    so the default is “no ownership transfer.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Argument passing](#rf-conventional), [use of smart pointer arguments](#rr-smartptrparam),
    and [value return](#rf-value-return).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`. Suggest
    use of standard-library resource handle or use of `owner<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Warn on failure to either `reset` or explicitly `delete` an `owner`
    pointer on every code path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Warn if the return value of `new` or a function call with an `owner`
    return value is assigned to a raw pointer or non-`owner` reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.12: Declare a pointer that must not be null as `not_null`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To help avoid dereferencing `nullptr` errors. To improve performance by avoiding
    redundant checks for `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: By stating the intent in source, implementers and tools can provide better diagnostics,
    such as finding some classes of errors through static analysis, and perform optimizations,
    such as removing branches and null tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`not_null` is defined in the [guidelines support library](#gsl-guidelines-support-library).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The assumption that the pointer to `char` pointed to a C-style string (a zero-terminated
    string of characters) was still implicit, and a potential source of confusion
    and errors. Use `czstring` in preference to `const char*`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: `length()` is, of course, `std::strlen()` in disguise.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) If a function checks a pointer parameter against `nullptr`
    before access, on all control-flow paths, then warn it should be declared `not_null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Complex) If a function with pointer return value ensures it is not `nullptr`
    on all return paths, then warn the return type should be declared `not_null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.13: Do not pass an array as a single pointer'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (pointer, size)-style interfaces are error-prone. Also, a plain pointer (to
    array) must rely on some convention to allow the callee to determine the size.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: What if there are fewer than `n` elements in the array pointed to by `q`? Then,
    we overwrite some probably unrelated memory. What if there are fewer than `n`
    elements in the array pointed to by `p`? Then, we read some probably unrelated
    memory. Either is undefined behavior and a potentially very nasty bug.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider using explicit spans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing `10` as the `n` argument might be a mistake: the most common convention
    is to assume `[0:n)` but that is nowhere stated. Worse is that the call of `draw()`
    compiled at all: there was an implicit conversion from array to pointer (array
    decay) and then another implicit conversion from `Circle` to `Shape`. There is
    no way that `draw()` can safely iterate through that array: it has no way of knowing
    the size of the elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Use a support class that ensures that the number of elements
    is correct and prevents dangerous implicit conversions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This `draw2()` passes the same amount of information to `draw()`, but makes
    the fact that it is supposed to be a range of `Circle`s explicit. See ???.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use `zstring` and `czstring` to represent C-style, zero-terminated strings.
    But when doing so, use `std::string_view` or `span<char>` from the [GSL](#gsl-guidelines-support-library)
    to prevent range errors.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) ((Bounds)) Warn for any expression that would rely on implicit conversion
    of an array type to a pointer type. Allow exception for zstring/czstring pointer
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer
    type that results in a value of pointer type. Allow exception for zstring/czstring
    pointer types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.22: Avoid complex initialization of global objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Complex initialization can lead to undefined order of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Since `x` and `y` are in different translation units the order of calls to `f()`
    and `g()` is undefined; one will access an uninitialized `const`. This shows that
    the order-of-initialization problem for global (namespace scope) objects is not
    limited to global *variables*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Order of initialization problems become particularly difficult to handle in
    concurrent code. It is usually best to avoid global (namespace scope) objects
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag initializers of globals that call non-`constexpr` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag initializers of globals that access `extern` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.23: Keep the number of function arguments low'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having many arguments opens opportunities for confusion. Passing lots of arguments
    is often costly compared to alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The two most common reasons why functions have too many parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Missing an abstraction.* There is an abstraction missing, so that a compound
    value is being passed as individual elements instead of as a single object that
    enforces an invariant. This not only expands the parameter list, but it leads
    to errors because the component values are no longer protected by an enforced
    invariant.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Violating “one function, one responsibility.”* The function is trying to do
    more than one job and should probably be refactored.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The standard-library `merge()` is at the limit of what we can comfortably handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is because of problem 1 above – missing abstraction. Instead
    of passing a range (abstraction), STL passed iterator pairs (unencapsulated component
    values).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have four template arguments and six function arguments. To simplify
    the most frequent and simplest uses, the comparison argument can be defaulted
    to `<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn’t reduce the total complexity, but it reduces the surface complexity
    presented to many users. To really reduce the number of arguments, we need to
    bundle the arguments into higher-level abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Grouping arguments into “bundles” is a general technique to reduce the number
    of arguments and to increase the opportunities for checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could use a standard library concept to define the notion
    of three types that must be usable for merging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The safety Profiles recommend replacing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, using an abstraction has safety and robustness benefits, and naturally
    also reduces the number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How many parameters are too many? Try to use fewer than four (4) parameters.
    There are functions that are best expressed with four individual parameters, but
    not many.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Use better abstraction: Group arguments into meaningful objects
    and pass the objects (by value or by reference).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Use default arguments or overloads to allow the most common
    forms of calls to be done with fewer arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Warn when a function declares two iterators (including pointers) of the same
    type instead of a range or a view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Not enforceable) This is a philosophical guideline that is infeasible to check
    directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I.24: Avoid adjacent parameters that can be invoked by the same arguments in
    either order with different meaning'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Adjacent arguments of the same type are easily swapped by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This is a nasty variant of a K&R C-style interface. It is easy to reverse the
    “to” and “from” arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `const` for the “from” argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If the order of the parameters is not important, there is no problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Don’t pass arrays as pointers, pass an object representing a range (e.g., a
    `span`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Define a `struct` as the parameter type and name the fields for those parameters
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This tends to make invocations of this clear to future readers, as the parameters
    are often filled in by name at the call site.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Only the interface’s designer can adequately address the source of violations
    of this guideline.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement strategy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if two consecutive parameters share the same type.
  prefs: []
  type: TYPE_NORMAL
- en: We are still looking for a less-simple enforcement.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.25: Prefer empty abstract classes as interfaces to class hierarchies'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Abstract classes that are empty (have no non-static member data) are more likely
    to be stable than base classes with state.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You just knew that `Shape` would turn up somewhere :-)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This will force every derived class to compute a center – even if that’s non-trivial
    and the center is never used. Similarly, not every `Shape` has a `Color`, and
    many `Shape`s are best represented without an outline defined as a sequence of
    `Point`s. Using an abstract class is better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a pointer/reference to a class `C` is assigned to a pointer/reference
    to a base of `C` and the base class contains data members.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.26: If you want a cross-compiler ABI, use a C-style subset'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Different compilers implement different binary layouts for classes, exception
    handling, function names, and other implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Common ABIs are emerging on some platforms freeing you from the more draconian
    restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you use a single compiler, you can use full C++ in interfaces. That might
    require recompilation after an upgrade to a new compiler version.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) It is difficult to reliably identify where an interface forms
    part of an ABI.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.27: For stable library ABI, consider the Pimpl idiom'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because private data members participate in class layout and private member
    functions participate in overload resolution, changes to those implementation
    details require recompilation of all users of a class that uses them. A non-polymorphic
    interface class holding a pointer to implementation (Pimpl) can isolate the users
    of a class from changes in its implementation at the cost of an indirection.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: interface (widget.h)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: implementation (widget.cpp)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'See [GOTW #100](https://herbsutter.com/gotw/_100/) and [cppreference](https://en.cppreference.com/w/cpp/language/pimpl)
    for the trade-offs and additional implementation details associated with this
    idiom.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) It is difficult to reliably identify where an interface forms
    part of an ABI.
  prefs: []
  type: TYPE_NORMAL
- en: 'I.30: Encapsulate rule violations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To keep code simple and safe. Sometimes, ugly, unsafe, or error-prone techniques
    are necessary for logical or performance reasons. If so, keep them local, rather
    than “infecting” interfaces so that larger groups of programmers have to be aware
    of the subtleties. Implementation complexity should, if at all possible, not leak
    through interfaces into user code.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider a program that, depending on some form of input (e.g., arguments to
    `main`), should consume input from a file, from the command line, or from standard
    input. We might write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This violated the rule [against uninitialized variables](#res-always), the rule
    against [ignoring ownership](#ri-raw), and the rule [against magic constants](#res-magic).
    In particular, someone has to remember to somewhere write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We could handle this particular example by using `unique_ptr` with a special
    deleter that does nothing for `cin`, but that’s complicated for novices (who can
    easily encounter this problem) and the example is an example of a more general
    problem where a property that we would like to consider static (here, ownership)
    needs infrequently be addressed at run time. The common, most frequent, and safest
    examples can be handled statically, so we don’t want to add cost and complexity
    to those. But we must also cope with the uncommon, less-safe, and necessarily
    more expensive cases. Such examples are discussed in [[Str15]](https://www.stroustrup.com/resource-model.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: So, we write a class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Now, the dynamic nature of `istream` ownership has been encapsulated. Presumably,
    a bit of checking for potential errors would be added in real code.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Hard, it is hard to decide what rule-breaking code is essential
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag rule suppression that enable rule-violations to cross interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F: Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function specifies an action or a computation that takes the system from one
    consistent state to the next. It is the fundamental building block of programs.
  prefs: []
  type: TYPE_NORMAL
- en: It should be possible to name a function meaningfully, to specify the requirements
    of its argument, and clearly state the relationship between the arguments and
    the result. An implementation is not a specification. Try to think about what
    a function does as well as about how it does it. Functions are the most critical
    part in most interfaces, so see the interface rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function definition rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F.1: “Package” meaningful operations as carefully named functions](#rf-package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.2: A function should perform a single logical operation](#rf-logical)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.3: Keep functions short and simple](#rf-single)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.4: If a function might have to be evaluated at compile time, declare it
    `constexpr`](#rf-constexpr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.5: If a function is very small and time-critical, declare it inline](#rf-inline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.6: If your function must not throw, declare it `noexcept`](#rf-noexcept)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.7: For general use, take `T*` or `T&` arguments rather than smart pointers](#rf-smart)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.8: Prefer pure functions](#rf-pure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.9: Unused parameters should be unnamed](#rf-unused)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.10: If an operation can be reused, give it a name](#rf-name)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.11: Use an unnamed lambda if you need a simple function object in one place
    only](#rf-lambda)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameter passing expression rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F.15: Prefer simple and conventional ways of passing information](#rf-conventional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.16: For “in” parameters, pass cheaply-copied types by value and others by
    reference to `const`](#rf-in)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.17: For “in-out” parameters, pass by reference to non-`const`](#rf-inout)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.18: For “will-move-from” parameters, pass by `X&&` and `std::move` the parameter](#rf-consume)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.19: For “forward” parameters, pass by `TP&&` and only `std::forward` the
    parameter](#rf-forward)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.20: For “out” output values, prefer return values to output parameters](#rf-out)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.21: To return multiple “out” values, prefer returning a struct](#rf-out-multi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.60: Prefer `T*` over `T&` when “no argument” is a valid option](#rf-ptr-ref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameter passing semantic rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F.22: Use `T*` or `owner<T*>` to designate a single object](#rf-ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.23: Use a `not_null<T>` to indicate that “null” is not a valid value](#rf-nullptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence](#rf-range)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string](#rf-zstring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed](#rf-unique_ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.27: Use a `shared_ptr<T>` to share ownership](#rf-shared_ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value return semantic rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F.42: Return a `T*` to indicate a position (only)](#rf-return-ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.43: Never (directly or indirectly) return a pointer or a reference to a
    local object](#rf-dangle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.44: Return a `T&` when copy is undesirable and “returning no object” isn’t
    needed](#rf-return-ref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.45: Don’t return a `T&&`](#rf-return-ref-ref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.46: `int` is the return type for `main()`](#rf-main)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.47: Return `T&` from assignment operators](#rf-assignment-op)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.48: Don’t return `std::move(local)`](#rf-return-move-local)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.49: Don’t return `const T`](#rf-return-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other function rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F.50: Use a lambda when a function won’t do (to capture local variables, or
    to write a local function)](#rf-capture-vs-overload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.51: Where there is a choice, prefer default arguments over overloading](#rf-default-args)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.52: Prefer capturing by reference in lambdas that will be used locally,
    including passed to algorithms](#rf-reference-capture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.53: Avoid capturing by reference in lambdas that will be used non-locally,
    including returned, stored on the heap, or passed to another thread](#rf-value-capture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.54: When writing a lambda that captures `this` or any class data member,
    don’t use `[=]` default capture](#rf-this-capture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.55: Don’t use `va_arg` arguments](#f-varargs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.56: Avoid unnecessary condition nesting](#f-nesting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions have strong similarities to lambdas and function objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [C.lambdas: Function objects and lambdas](#ss-lambdas)'
  prefs: []
  type: TYPE_NORMAL
- en: 'F.def: Function definitions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function definition is a function declaration that also specifies the function’s
    implementation, the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.1: “Package” meaningful operations as carefully named functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Factoring out common code makes code more readable, more likely to be reused,
    and limit errors from complex code. If something is a well-specified action, separate
    it out from its surrounding code and give it a name.
  prefs: []
  type: TYPE_NORMAL
- en: Example, don’t
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Almost everything is wrong with `read_and_print`. It reads, it writes (to a
    fixed `ostream`), it writes error messages (to a fixed `ostream`), it handles
    only `int`s. There is nothing to reuse, logically separate operations are intermingled
    and local variables are in scope after the end of their logical use. For a tiny
    example, this looks OK, but if the input operation, the output operation, and
    the error handling had been more complicated the tangled mess could become hard
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you write a non-trivial lambda that potentially can be used in more than
    one place, give it a name by assigning it to a (usually non-local) variable.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Naming that lambda breaks up the expression into its logical parts and provides
    a strong hint to the meaning of the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The shortest code is not always the best for performance or maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Loop bodies, including lambdas used as loop bodies, rarely need to be named.
    However, large loop bodies (e.g., dozens of lines or dozens of pages) can be a
    problem. The rule [Keep functions short and simple](#rf-single) implies “Keep
    loop bodies short.” Similarly, lambdas used as callback arguments are sometimes
    non-trivial, yet unlikely to be reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See [Keep functions short and simple](#rf-single)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag identical and very similar lambdas used in different places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.2: A function should perform a single logical operation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A function that performs a single operation is simpler to understand, test,
    and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a monolith that is tied to a specific input and will never find another
    (different) use. Instead, break functions up into suitable logical parts and parameterize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'These can now be combined where needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If there was a need, we could further templatize `read()` and `print()` on
    the data type, the I/O mechanism, the response to errors, etc. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider functions with more than one “out” parameter suspicious. Use return
    values instead, including `tuple` for multiple return values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider “large” functions that don’t fit on one editor screen suspicious. Consider
    factoring such a function into smaller well-named suboperations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider functions with 7 or more parameters suspicious.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.3: Keep functions short and simple'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Large functions are hard to read, more likely to contain complex code, and more
    likely to have variables in larger than minimal scopes. Functions with complex
    control structures are more likely to be long and more likely to hide logical
    errors
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This is too complex. How would you know if all possible alternatives have been
    correctly handled? Yes, it breaks other rules also.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: “It doesn’t fit on a screen” is often a good practical definition of “far too
    large.” One-to-five-line functions should be considered normal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Break large functions up into smaller cohesive and named functions. Small simple
    functions are easily inlined where the cost of a function call is significant.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag functions that do not “fit on a screen.” How big is a screen? Try 60 lines
    by 140 characters; that’s roughly the maximum that’s comfortable for a book page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag functions that are too complex. How complex is too complex? You could use
    cyclomatic complexity. Try “more than 10 logical paths through.” Count a simple
    switch as one path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.4: If a function might have to be evaluated at compile time, declare it `constexpr`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`constexpr` is needed to tell the compiler to allow compile-time evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The (in)famous factorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This is C++14. For C++11, use a recursive formulation of `fac()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`constexpr` does not guarantee compile-time evaluation; it just guarantees
    that the function can be evaluated at compile time for constant expression arguments
    if the programmer requires it or the compiler decides to do so to optimize.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Don’t try to make all functions `constexpr`. Most computation is best done at
    run time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Any API that might eventually depend on high-level run-time configuration or
    business logic should not be made `constexpr`. Such customization can not be evaluated
    by the compiler, and any `constexpr` functions that depended upon that API would
    have to be refactored or drop `constexpr`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Impossible and unnecessary. The compiler gives an error if a non-`constexpr`
    function is called where a constant is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.5: If a function is very small and time-critical, declare it `inline`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some optimizers are good at inlining without hints from the programmer, but
    don’t rely on it. Measure! Over the last 40 years or so, we have been promised
    compilers that can inline better than humans without hints from humans. We are
    still waiting. Specifying inline (explicitly, or implicitly when writing member
    functions inside a class definition) encourages the compiler to do a better job.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not put an `inline` function in what is meant to be a stable interface unless
    you are certain that it will not change. An inline function is part of the ABI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`constexpr` implies `inline`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Member functions defined in-class are `inline` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Function templates (including member functions of class templates `A<T>::function()`
    and member function templates `A::function<T>()`) are normally defined in headers
    and therefore inline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider making functions out of line if they are more than three statements
    and can be declared out of line (such as class member functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'F.6: If your function must not throw, declare it `noexcept`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If an exception is not supposed to be thrown, the program cannot be assumed
    to cope with the error and should be terminated as soon as possible. Declaring
    a function `noexcept` helps optimizers by reducing the number of alternative execution
    paths. It also speeds up the exit after failure.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Put `noexcept` on every function written completely in C or in any other language
    without exceptions. The C++ Standard Library does that implicitly for all functions
    in the C Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`constexpr` functions can throw when evaluated at run time, so you might need
    conditional `noexcept` for some of those.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use `noexcept` even on functions that can throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: If `collect()` runs out of memory, the program crashes. Unless the program is
    crafted to survive memory exhaustion, that might be just the right thing to do;
    `terminate()` might generate suitable error log information (but after memory
    runs out it is hard to do anything clever).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You must be aware of the execution environment that your code is running when
    deciding whether to tag a function `noexcept`, especially because of the issue
    of throwing and allocation. Code that is intended to be perfectly general (like
    the standard library and other utility code of that sort) needs to support environments
    where a `bad_alloc` exception could be handled meaningfully. However, most programs
    and execution environments cannot meaningfully handle a failure to allocate, and
    aborting the program is the cleanest and simplest response to an allocation failure
    in those cases. If you know that your application code cannot respond to an allocation
    failure, it could be appropriate to add `noexcept` even on functions that allocate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put another way: In most programs, most functions can throw (e.g., because
    they use `new`, call functions that do, or use library functions that report failure
    by throwing), so don’t just sprinkle `noexcept` all over the place without considering
    whether the possible exceptions can be handled.'
  prefs: []
  type: TYPE_NORMAL
- en: '`noexcept` is most useful (and most clearly correct) for frequently used, low-level
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Destructors, `swap` functions, move operations, and default constructors should
    never throw. See also [C.44](#rc-default00).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Care must be taken on base virtual functions and functions part of a public
    interface because declaring a function `noexcept` is establishing a guarantee
    that all current and future implementations must abide by. For virtual function,
    all overriders must also be `noexcept` and removing `noexcept` from a function
    could break calling functions.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (hard) Flag low-level functions that are not `noexcept`, yet cannot throw.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag throwing `swap`, `move`, destructors, and default constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.7: For general use, take `T*` or `T&` arguments rather than smart pointers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Passing a smart pointer transfers or shares ownership and should only be used
    when ownership semantics are intended. A function that does not manipulate lifetime
    should take raw pointers or references instead.
  prefs: []
  type: TYPE_NORMAL
- en: Passing by smart pointer restricts the use of a function to callers that use
    smart pointers. A function that needs a `widget` should be able to accept any
    `widget` object, not just ones whose lifetimes are managed by a particular kind
    of smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a shared smart pointer (e.g., `std::shared_ptr`) implies a run-time
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can catch many common cases of dangling pointers statically (see [lifetime
    safety profile](#ss-lifetime)). Function arguments naturally live for the lifetime
    of the function call, and so have fewer lifetime problems.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '(Simple) Warn if a function takes a parameter of a smart pointer type (that
    overloads `operator->` or `operator*`) that is copyable but the function only
    calls any of: `operator*`, `operator->` or `get()`. Suggest using a `T*` or `T&`
    instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a parameter of a smart pointer type (a type that overloads `operator->`
    or `operator*`) that is copyable/movable but never copied/moved from in the function
    body, and that is never modified, and that is not passed along to another function
    that could do so. That means the ownership semantics are not used. Suggest using
    a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Prefer `T*` over `T&` when “no argument” is a valid option](#rf-ptr-ref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Smart pointer rule summary](#rr-summary-smartptrs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.8: Prefer pure functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Pure functions are easier to reason about, sometimes easier to optimize (and
    even parallelize), and sometimes can be memoized.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.9: Unused parameters should be unnamed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Suppression of unused parameter warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Allowing parameters to be unnamed was introduced in the early 1980s to address
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'If parameters are conditionally unused, declare them with the `[[maybe_unused]]`
    attribute. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag named unused parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.10: If an operation can be reused, give it a name'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Documentation, readability, opportunity for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: There is a useful function lurking here (case insensitive string comparison),
    as there often is when lambda arguments get large.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Or maybe (if you prefer to avoid the implicit name binding to n):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: whether functions, lambdas, or operators.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Lambdas logically used only locally, such as an argument to `for_each` and similar
    control flow algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas as [initializers](#???)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (hard) flag similar lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.11: Use an unnamed lambda if you need a simple function object in one place
    only'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That makes the code concise and gives better locality than alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Naming a lambda can be useful for clarity even if it is used only once.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for identical and near identical lambdas (to be replaced with named functions
    or named lambdas).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.call: Parameter passing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a variety of ways to pass parameters to a function and to return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.15: Prefer simple and conventional ways of passing information'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using “unusual and clever” techniques causes surprises, slows understanding
    by other programmers, and encourages bugs. If you really feel the need for an
    optimization beyond the common techniques, measure to ensure that it really is
    an improvement, and document/comment because the improvement might not be portable.
  prefs: []
  type: TYPE_NORMAL
- en: The following tables summarize the advice in the following Guidelines, F.16-21.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal parameter passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Normal parameter passing table](img/3da0440d953b29de9a982d019489c414.png
    "Normal parameter passing")'
  prefs: []
  type: TYPE_IMG
- en: 'Advanced parameter passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advanced parameter passing table](img/557ced2b30827f817e7baf2767426d75.png
    "Advanced parameter passing")'
  prefs: []
  type: TYPE_IMG
- en: Use the advanced techniques only after demonstrating need, and document that
    need in a comment.
  prefs: []
  type: TYPE_NORMAL
- en: For passing sequences of characters see [String](#ss-string).
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To express shared ownership using `shared_ptr` types, rather than following
    guidelines F.16-21, follow [R.34](#rr-sharedptrparam-owner), [R.35](#rr-sharedptrparam),
    and [R.36](#rr-sharedptrparam-const).
  prefs: []
  type: TYPE_NORMAL
- en: 'F.16: For “in” parameters, pass cheaply-copied types by value and others by
    reference to `const`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Both let the caller know that a function will not modify the argument, and both
    allow initialization by rvalues.
  prefs: []
  type: TYPE_NORMAL
- en: What is “cheap to copy” depends on the machine architecture, but two or three
    words (doubles, pointers, references) are usually best passed by value. When copying
    is cheap, nothing beats the simplicity and safety of copying, and for small objects
    (up to two or three words) it is also faster than passing by reference because
    it does not require an extra indirection to access from the function.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'For advanced uses (only), where you really need to optimize for rvalues passed
    to “input-only” parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: If the function is going to unconditionally move from the argument, take it
    by `&&`. See [F.18](#rf-consume).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function is going to keep a locally modifiable copy of the argument only
    for its own local use, taking it by value is fine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function is going to keep a copy of the argument to pass to another destination
    (to another function, or store in a non-local location), in addition to passing
    by `const&` (for lvalues), add an overload that passes the parameter by `&&` (for
    rvalues) and in the body `std::move`s it to its destination. Essentially this
    overloads a “will-move-from”; see [F.18](#rf-consume).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In special cases, such as multiple “input + copy” parameters, consider using
    perfect forwarding. See [F.19](#rf-forward).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Avoid “esoteric techniques” such as passing arguments as `T&&` “for efficiency”.
    Most rumors about performance advantages from passing by `&&` are false or brittle
    (but see [F.18](#rf-consume) and [F.19](#rf-forward)).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A reference can be assumed to refer to a valid object (language rule). There
    is no (legitimate) “null reference.” If you need the notion of an optional value,
    use a pointer, `std::optional`, or a special value used to denote “no value.”
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn when a parameter being passed by value has a size
    greater than `2 * sizeof(void*)`. Suggest using a reference to `const` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn when a parameter passed by reference to `const`
    has a size less or equal than `2 * sizeof(void*)`. Suggest passing by value instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn when a parameter passed by reference to `const`
    is `move`d.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To express shared ownership using `shared_ptr` types, follow [R.34](#rr-sharedptrparam-owner)
    or [R.36](#rr-sharedptrparam-const), depending on whether or not the function
    unconditionally takes a reference to the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.17: For “in-out” parameters, pass by reference to non-`const`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This makes it clear to callers that the object is assumed to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some user-defined and standard library types, such as `span<T>` or the iterators
    are [cheap to copy](#rf-in) and may be passed by value, while doing so has mutable
    (in-out) reference semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A `T&` argument can pass information into a function as well as out of it.
    Thus `T&` could be an in-out-parameter. That can in itself be a problem and a
    source of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Here, the writer of `g()` is supplying a buffer for `f()` to fill, but `f()`
    simply replaces it (at a somewhat higher cost than a simple copy of the characters).
    A bad logic error can happen if the writer of `g()` incorrectly assumes the size
    of the `buffer`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Moderate) ((Foundation)) Warn about functions regarding reference to non-`const`
    parameters that do *not* write to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn when a non-`const` parameter being passed by reference
    is `move`d.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.18: For “will-move-from” parameters, pass by `X&&` and `std::move` the parameter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s efficient and eliminates bugs at the call site: `X&&` binds to rvalues,
    which requires an explicit `std::move` at the call site if passing an lvalue.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `std::move(v)` makes it possible for `store_somewhere()` to leave
    `v` in a moved-from state. [That could be dangerous](#rc-move-semantic).
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unique owner types that are move-only and cheap-to-move, such as `unique_ptr`,
    can also be passed by value which is simpler to write and achieves the same effect.
    Passing by value does generate one extra (cheap) move operation, but prefer simplicity
    and clarity first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the “will-move-from” parameter is a `shared_ptr` follow [R.34](#rr-sharedptrparam-owner)
    and pass the `shared_ptr` by value.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all `X&&` parameters (where `X` is not a template type parameter name)
    where the function body uses them without `std::move`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag access to moved-from objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t conditionally move from objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.19: For “forward” parameters, pass by `TP&&` and only `std::forward` the
    parameter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the object is to be passed onward to other code and not directly used by
    this function, we want to make this function agnostic to the argument `const`-ness
    and rvalue-ness.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, and only that case, make the parameter `TP&&` where `TP` is a
    template type parameter – it both *ignores* and *preserves* `const`-ness and rvalue-ness.
    Therefore any code that uses a `TP&&` is implicitly declaring that it itself doesn’t
    care about the variable’s `const`-ness and rvalue-ness (because it is ignored),
    but that intends to pass the value onward to other code that does care about `const`-ness
    and rvalue-ness (because it is preserved). When used as a parameter `TP&&` is
    safe because any temporary objects passed from the caller will live for the duration
    of the function call. A parameter of type `TP&&` should essentially always be
    passed onward via `std::forward` in the body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Usually you forward the entire parameter (or parameter pack, using `...`) exactly
    once on every static control flow path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes you may forward a composite parameter piecewise, each subobject once
    on every static control flow path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a function that takes a `TP&&` parameter (where `TP` is a template type
    parameter name) and does anything with it other than `std::forward`ing it exactly
    once on every static path, or `std::forward`ing it more than once but qualified
    with a different data member exactly once on every static path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.20: For “out” output values, prefer return values to output parameters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A return value is self-documenting, whereas an `&` could be either in-out or
    out-only and is liable to be misused.
  prefs: []
  type: TYPE_NORMAL
- en: This includes large objects like standard containers that use implicit move
    operations for performance and to avoid explicit memory management.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple values to return, [use a tuple](#rf-out-multi) or similar
    multi-member type.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `struct` of many (individually cheap-to-move) elements might be in aggregate
    expensive to move.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For non-concrete types, such as types in an inheritance hierarchy, return the
    object by `unique_ptr` or `shared_ptr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a type is expensive to move (e.g., `array<BigTrivial>`), consider allocating
    it on the free store and return a handle (e.g., `unique_ptr`), or passing it in
    a reference to non-`const` target object to fill (to be used as an out-parameter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To reuse an object that carries capacity (e.g., `std::string`, `std::vector`)
    across multiple calls to the function in an inner loop: [treat it as an in/out
    parameter and pass by reference](#rf-out-multi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Assuming that `Matrix` has move operations (possibly by keeping its elements
    in a `std::vector`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The return value optimization doesn’t handle the assignment case, but the move
    assignment does.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag reference to non-`const` parameters that are not read before being written
    to and are a type that could be cheaply returned; they should be “out” return
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.21: To return multiple “out” values, prefer returning a struct'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A return value is self-documenting as an “output-only” value. Note that C++
    does have multiple return values, by convention of using tuple-like types (`struct`,
    `array`, `tuple`, etc.), possibly with the extra convenience of structured bindings
    (C++17) at the call site. Prefer using a named `struct` if possible. Otherwise,
    a `tuple` is useful in variadic templates.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'C++98’s standard library used this style in places, by returning `pair` in
    some functions. For example, given a `set<string> my_set`, consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'With C++17 we are able to use “structured bindings” to give each member a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: A `struct` with meaningful names is more common in modern C++. See for example
    `ranges::min_max_result`, `from_chars_result`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, we need to pass an object to a function to manipulate its state.
    In such cases, passing the object by reference [`T&`](#rf-inout) is usually the
    right technique. Explicitly passing an in-out parameter back out again as a return
    value is often not necessary. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Here, both `s` and `in` are used as in-out parameters. We pass `in` by (non-`const`)
    reference to be able to manipulate its state. We pass `s` to avoid repeated allocations.
    By reusing `s` (passed by reference), we allocate new memory only when we need
    to expand `s`’s capacity. This technique is sometimes called the “caller-allocated
    out” pattern and is particularly useful for types, such as `string` and `vector`,
    that need to do free store allocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare, if we passed out all values as return values, we would write something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: We consider that significantly less elegant with significantly less performance.
  prefs: []
  type: TYPE_NORMAL
- en: For a truly strict reading of this rule (F.21), the exception isn’t really an
    exception because it relies on in-out parameters, rather than the plain out parameters
    mentioned in the rule. However, we prefer to be explicit, rather than subtle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In most cases, it is useful to return a specific, user-defined type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The overly generic `pair` and `tuple` should be used only when the value returned
    represents independent entities rather than an abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use `optional<T>` or `expected<T, error_code>`, rather
    than `pair` or `tuple`. When used appropriately these types convey more information
    about what the members mean than `pair<T, bool>` or `pair<T, error_code>` do.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When the object to be returned is initialized from local variables that are
    expensive to copy, explicit `move` may be helpful to avoid copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Note this is different from the `return move(...)` anti-pattern from [ES.56](#res-move).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Output parameters should be replaced by return values. An output parameter is
    one that the function writes to, invokes a non-`const` member function, or passes
    on as a non-`const`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pair` or `tuple` return types should be replaced by `struct`, if possible.
    In variadic templates, `tuple` is often unavoidable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.60: Prefer `T*` over `T&` when “no argument” is a valid option'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pointer (`T*`) can be a `nullptr` and a reference (`T&`) cannot, there is
    no valid “null reference”. Sometimes having `nullptr` as an alternative to indicated
    “no object” is useful, but if it is not, a reference is notationally simpler and
    might yield better code.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is possible, but not valid C++ to construct a reference that is essentially
    a `nullptr` (e.g., `T* p = nullptr; T& r = *p;`). That error is very uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you prefer the pointer notation (`->` and/or `*` vs. `.`), `not_null<T*>`
    provides the same guarantee as `T&`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.22: Use `T*` or `owner<T*>` to designate a single object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Readability: it makes the meaning of a plain pointer clear. Enables significant
    tool support.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In traditional C and C++ code, plain `T*` is used for many weakly-related purposes,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify a (single) object (not to be deleted by this function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point to an object allocated on the free store (and delete it later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hold the `nullptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify a C-style string (zero-terminated array of characters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify an array with a length specified separately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify a location in an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes it hard to understand what the code does and is supposed to do. It
    complicates checking and tool support.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: better
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`owner<T*>` represents ownership, `zstring` represents a C-style string.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Also**: Assume that a `T*` obtained from a smart pointer to `T` (e.g., `unique_ptr<T>`)
    points to a single element.'
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Support library](#gsl-guidelines-support-library)'
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Do not pass an array as a single pointer](#ri-array)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer
    type that results in a value of pointer type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.23: Use a `not_null<T>` to indicate that “null” is not a valid value'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Clarity. A function with a `not_null<T>` parameter makes it clear that the caller
    of the function is responsible for any `nullptr` checks that might be necessary.
    Similarly, a function with a return value of `not_null<T>` makes it clear that
    the caller of the function does not need to check for `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`not_null<T*>` makes it obvious to a reader (human or machine) that a test
    for `nullptr` is not necessary before dereference. Additionally, when debugging,
    `owner<T*>` and `not_null<T>` can be instrumented to check for correctness.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: When I call `length(p)` should I check if `p` is `nullptr` first? Should the
    implementation of `length()` check if `p` is `nullptr`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `not_null<T*>` is assumed not to be the `nullptr`; a `T*` might be the `nullptr`;
    both can be represented in memory as a `T*` (so no run-time overhead is implied).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`not_null` is not just for built-in pointers. It works for `unique_ptr`, `shared_ptr`,
    and other pointer-like types.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a raw pointer is dereferenced without being tested against
    `nullptr` (or equivalent) within a function, suggest it is declared `not_null`
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Error if a raw pointer is sometimes dereferenced after first being
    tested against `nullptr` (or equivalent) within the function and sometimes is
    not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Warn if a `not_null` pointer is tested against `nullptr` within a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Informal/non-explicit ranges are a source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ranges are extremely common in C++ code. Typically, they are implicit and their
    correct use is very hard to ensure. In particular, given a pair of arguments `(p,
    n)` designating an array `[p:p+n)`, it is in general impossible to know if there
    really are `n` elements to access following `*p`. `span<T>` and `span_p<T>` are
    simple helper classes designating a `[p:q)` range and a range starting with `p`
    and ending with the first element for which a predicate is true, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `span` represents a range of elements, but how do we manipulate elements of
    that range?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `span<T>` object does not own its elements and is so small that it can be
    passed by value.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a `span` object as an argument is exactly as efficient as passing a
    pair of pointer arguments or passing a pointer and an integer count.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Support library](#gsl-guidelines-support-library)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Complex) Warn where accesses to pointer parameters are bounded by other parameters
    that are integral types and suggest they could use `span` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'C-style strings are ubiquitous. They are defined by convention: zero-terminated
    arrays of characters. We must distinguish C-style strings from a pointer to a
    single character or an old-fashioned pointer to an array of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t need null termination, use `string_view`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: When I call `length(s)` should I check if `s` is `nullptr` first? Should the
    implementation of `length()` check if `p` is `nullptr`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`zstring` does not represent ownership.'
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Support library](#gsl-guidelines-support-library)'
  prefs: []
  type: TYPE_NORMAL
- en: 'F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using `unique_ptr` is the cheapest way to pass a pointer safely.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [C.50](#rc-factory) regarding when to return a `shared_ptr` from
    a factory.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You need to pass a pointer rather than an object if what you are transferring
    is an object from a class hierarchy that is to be used through an interface (base
    class).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a function returns a locally allocated raw pointer. Suggest
    using either `unique_ptr` or `shared_ptr` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.27: Use a `shared_ptr<T>` to share ownership'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using `std::shared_ptr` is the standard way to represent shared ownership. That
    is, the last owner deletes the object.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prefer a `unique_ptr` over a `shared_ptr` if there is never more than one owner
    at a time. `shared_ptr` is for shared ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Note that pervasive use of `shared_ptr` has a cost (atomic operations on the
    `shared_ptr`’s reference count have a measurable aggregate cost).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Have a single object own the shared object (e.g. a scoped object) and destroy
    that (preferably implicitly) when all users have completed.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) This is a too complex pattern to reliably detect.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.42: Return a `T*` to indicate a position (only)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That’s what pointers are good for. Returning a `T*` to transfer ownership is
    a misuse.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: If it isn’t the `nullptr`, the pointer returned by `find` indicates a `Node`
    holding `s`. Importantly, that does not imply a transfer of ownership of the pointed-to
    object to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Positions can also be transferred by iterators, indices, and references. A reference
    is often a superior alternative to a pointer [if there is no need to use `nullptr`](#rf-ptr-ref)
    or [if the object referred to should not change](#s-const).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not return a pointer to something that is not in the caller’s scope; see
    [F.43](#rf-dangle).
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [discussion of dangling pointer prevention](#???)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `delete`, `std::free()`, etc. applied to a plain `T*`. Only owners should
    be deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag `new`, `malloc()`, etc. assigned to a plain `T*`. Only owners should be
    responsible for deletion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.43: Never (directly or indirectly) return a pointer or a reference to a local
    object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid the crashes and data corruption that can result from the use of such
    a dangling pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After the return from a function its local objects no longer exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Here on one popular implementation I got the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: I expected that because the call of `g()` reuses the stack space abandoned by
    the call of `f()` so `*p` refers to the space now occupied by `gx`.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine what would happen if `fx` and `gx` were of different types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine what would happen if `fx` or `gx` was a type with an invariant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine what would happen if that dangling pointer was passed around among a
    larger set of functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine what a cracker could do with that dangling pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, most (all?) modern compilers catch and warn against this simple
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This applies to references as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This applies only to non-`static` local variables. All `static` variables are
    (as their name indicates) statically allocated, so that pointers to them cannot
    dangle.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Not all examples of leaking a pointer to a local variable are that obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Here I managed to read the location abandoned by the call of `f`. The pointer
    stored in `glob` could be used much later and cause trouble in unpredictable ways.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The address of a local variable can be “returned”/leaked by a return statement,
    by a `T&` out-parameter, as a member of a returned object, as an element of a
    returned array, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Similar examples can be constructed “leaking” a pointer from an inner scope
    to an outer one; such examples are handled equivalently to leaks of pointers out
    of a function.
  prefs: []
  type: TYPE_NORMAL
- en: A slightly different variant of the problem is placing pointers in a container
    that outlives the objects pointed to.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: Another way of getting dangling pointers is [pointer invalidation](#???).
    It can be detected/prevented with similar techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compilers tend to catch return of reference to locals and could in many cases
    catch return of pointers to locals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static analysis can catch many common patterns of the use of pointers indicating
    positions (thus eliminating dangling pointers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.44: Return a `T&` when copy is undesirable and “returning no object” isn’t
    needed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The language guarantees that a `T&` refers to an object, so that testing for
    `nullptr` isn’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: The return of a reference must not imply transfer of ownership:
    [discussion of dangling pointer prevention](#???) and [discussion of ownership](#???).'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag functions where no `return` expression could yield `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.45: Don’t return a `T&&`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s asking to return a reference to a destroyed temporary object. An `&&` is
    a magnet for temporary objects.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A returned rvalue reference goes out of scope at the end of the full expression
    to which it is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: This kind of use is a frequent source of bugs, often incorrectly reported as
    a compiler bug. An implementer of a function should avoid setting such traps for
    users.
  prefs: []
  type: TYPE_NORMAL
- en: The [lifetime safety profile](#ss-lifetime) will (when completely implemented)
    catch such problems.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Returning an rvalue reference is fine when the reference to the temporary is
    being passed “downward” to a callee; then, the temporary is guaranteed to outlive
    the function call (see [F.18](#rf-consume) and [F.19](#rf-forward)). However,
    it’s not fine when passing such a reference “upward” to a larger caller scope.
    For passthrough functions that pass in parameters (by ordinary reference or by
    perfect forwarding) and want to return values, use simple `auto` return type deduction
    (not `auto&&`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that `F` returns by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::move` and `std::forward` do return `&&`, but they are just casts – used
    by convention only in expression contexts where a reference to a temporary object
    is passed along within the same expression before the temporary is destroyed.
    We don’t know of any other good examples of returning `&&`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag any use of `&&` as a return type, except in `std::move` and `std::forward`.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.46: `int` is the return type for `main()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s a language rule, but violated through “language extensions” so often that
    it is worth mentioning. Declaring `main` (the one global `main` of a program)
    `void` limits portability.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We mention this only because of the persistence of this error in the community.
    Note that despite its non-void return type, the main function does not require
    an explicit return statement.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler should do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the compiler doesn’t do it, let tools flag it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.47: Return `T&` from assignment operators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The convention for operator overloads (especially on concrete types) is for
    `operator=(const T&)` to perform the assignment and then return (non-`const`)
    `*this`. This ensures consistency with standard-library types and follows the
    principle of “do as the ints do.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Historically there was some guidance to make the assignment operator return
    `const T&`. This was primarily to avoid code of the form `(a = b) = c` – such
    code is not common enough to warrant violating consistency with standard types.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This should be enforced by tooling by checking the return type (and return value)
    of any assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.48: Don’t `return std::move(local)`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Returning a local variable implicitly moves it anyway. An explicit `std::move`
    is always a pessimization, because it prevents Return Value Optimization (RVO),
    which can eliminate the move completely.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This should be enforced by tooling by checking the return expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'F.49: Don’t return `const T`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is not recommended to return a `const` value. Such older advice is now obsolete;
    it does not add value, and it interferes with move semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The argument for adding `const` to a return value is that it prevents (very
    rare) accidental access to a temporary. The argument against is that it prevents
    (very frequent) use of move semantics.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [F.20, the general item about “out” output values](#rf-out)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag returning a `const` value. To fix: Remove `const` to return a non-`const`
    value instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.50: Use a lambda when a function won’t do (to capture local variables, or
    to write a local function)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Functions can’t capture local variables or be defined at local scope; if you
    need those things, prefer a lambda where possible, and a handwritten function
    object where not. On the other hand, lambdas and function objects don’t overload;
    if you need to overload, prefer a function (the workarounds to make lambdas overload
    are ornate). If either will work, prefer writing a function; use the simplest
    tool necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generic lambdas offer a concise way to write function templates and so can be
    useful even when a normal function template would do equally well with a little
    more syntax. This advantage will probably disappear in the future once all functions
    gain the ability to have Concept parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Warn on use of a named non-generic lambda (e.g., `auto x = [](int i) { /*...*/;
    };`) that captures nothing and appears at global scope. Write an ordinary function
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.51: Where there is a choice, prefer default arguments over overloading'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Default arguments simply provide alternative interfaces to a single implementation.
    There is no guarantee that a set of overloaded functions all implement the same
    semantics. The use of default arguments can avoid code replication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There is a choice between using default argument and overloading when the alternatives
    are from a set of arguments of the same types. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: as opposed to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'There is not a choice when a set of functions are used to do a semantically
    equivalent operation to a set of types. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Default arguments for virtual functions](#rh-virtual-default-arg)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Warn on an overload set where the overloads have a common prefix of parameters
    (e.g., `f(int)`, `f(int, const string&)`, `f(int, const string&, double)`). (Note:
    Review this enforcement if it’s too noisy in practice.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.52: Prefer capturing by reference in lambdas that will be used locally, including
    passed to algorithms'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For efficiency and correctness, you nearly always want to capture by reference
    when using the lambda locally. This includes when writing or calling parallel
    algorithms that are local because they join before returning.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The efficiency consideration is that most types are cheaper to pass by reference
    than by value.
  prefs: []
  type: TYPE_NORMAL
- en: The correctness consideration is that many calls want to perform side effects
    on the original object at the call site (see example below). Passing by value
    prevents this.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unfortunately, there is no simple way to capture by reference to `const` to
    get the efficiency for a local call but also prevent side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here, a large object (a network message) is passed to an iterative algorithm,
    and it is not efficient or correct to copy the message (which might not be copyable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a simple three-stage parallel pipeline. Each `stage` object encapsulates
    a worker thread and a queue, has a `process` function to enqueue work, and in
    its destructor automatically blocks waiting for the queue to empty before ending
    the thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag a lambda that captures by reference, but is used other than locally within
    the function scope or passed to a function by reference. (Note: This rule is an
    approximation, but does flag passing by pointer as those are more likely to be
    stored by the callee, writing to a heap location accessed via a parameter, returning
    the lambda, etc. The Lifetime rules will also provide general rules that flag
    escaping pointers and references including via lambdas.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'F.53: Avoid capturing by reference in lambdas that will be used non-locally,
    including returned, stored on the heap, or passed to another thread'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Pointers and references to locals shouldn’t outlive their scope. Lambdas that
    capture by reference are just another place to store a reference to a local object,
    and shouldn’t do so if they (or a copy) outlive the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a non-local pointer must be captured, consider using `unique_ptr`; this handles
    both lifetime and synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: If the `this` pointer must be captured, consider using `[*this]` capture, which
    creates a copy of the entire object.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn when capture-list contains a reference to a locally declared variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Complex) Flag when capture-list contains a reference to a locally declared
    variable and the lambda is passed to a non-`const` and non-local context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.54: When writing a lambda that captures `this` or any class data member,
    don’t use `[=]` default capture'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s confusing. Writing `[=]` in a member function appears to capture by value,
    but actually captures data members by reference because it actually captures the
    invisible `this` pointer by value. If you meant to do that, write `this` explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you intend to capture a copy of all class data members, consider C++17 `[*this]`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag any lambda capture-list that specifies a capture-default of `[=]` and also
    captures `this` (whether explicitly or via the default capture and a use of `this`
    in the body)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.55: Don’t use `va_arg` arguments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Reading from a `va_arg` assumes that the correct type was actually passed. Passing
    to varargs assumes the correct type will be read. This is fragile because it cannot
    generally be enforced to be safe in the language and so relies on programmer discipline
    to get it right.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Alternatives
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: variadic templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variant` arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initializer_list` (homogeneous)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Declaring a `...` parameter is sometimes useful for techniques that don’t involve
    actual argument passing, notably to declare “take-anything” functions so as to
    disable “everything else” in an overload set or express a catchall case in a template
    metaprogram.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Issue a diagnostic for using `va_list`, `va_start`, or `va_arg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Issue a diagnostic for passing an argument to a vararg parameter of a function
    that does not offer an overload for a more specific type in the position of the
    vararg. To fix: Use a different function, or `[[suppress("type")]]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F.56: Avoid unnecessary condition nesting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Shallow nesting of conditions makes the code easier to follow. It also makes
    the intent clearer. Strive to place the essential code at outermost scope, unless
    this obscures intent.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use a guard-clause to take care of exceptional cases and return early.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a redundant `else`. Flag a function whose body is simply a conditional
    statement enclosing a block.
  prefs: []
  type: TYPE_NORMAL
- en: 'C: Classes and class hierarchies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is a user-defined type, for which a programmer can define the representation,
    operations, and interfaces. Class hierarchies are used to organize related classes
    into hierarchical structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.1: Organize related data into structures (`struct`s or `class`es)](#rc-org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.2: Use `class` if the class has an invariant; use `struct` if the data members
    can vary independently](#rc-struct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.3: Represent the distinction between an interface and an implementation
    using a class](#rc-interface)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.4: Make a function a member only if it needs direct access to the representation
    of a class](#rc-member)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.5: Place helper functions in the same namespace as the class they support](#rc-helper)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.7: Don’t define a class or enum and declare a variable of its type in the
    same statement](#rc-standalone)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.8: Use `class` rather than `struct` if any member is non-public](#rc-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.9: Minimize exposure of members](#rc-private)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.concrete: Concrete types](#ss-concrete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.ctor: Constructors, assignments, and destructors](#s-ctor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.con: Containers and other resource handles](#ss-containers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.lambdas: Function objects and lambdas](#ss-lambdas)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.hier: Class hierarchies (OOP)](#ss-hier)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.over: Overloading and overloaded operators](#ss-overload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.union: Unions](#ss-union)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.1: Organize related data into structures (`struct`s or `class`es)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ease of comprehension. If data is related (for fundamental reasons), that fact
    should be reflected in code.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A simple class without virtual functions implies no space or time overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From a language perspective `class` and `struct` differ only in the default
    visibility of their members.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Probably impossible. Maybe a heuristic looking for data items used together
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.2: Use `class` if the class has an invariant; use `struct` if the data members
    can vary independently'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Ease of comprehension. The use of `class` alerts the programmer
    to the need for an invariant. This is a useful convention.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An invariant is a logical condition for the members of an object that a constructor
    must establish for the public member functions to assume. After the invariant
    is established (typically by a constructor) every member function can be called
    for the object. An invariant can be stated informally (e.g., in a comment) or
    more formally using `Expects`.
  prefs: []
  type: TYPE_NORMAL
- en: If all data members can vary independently of each other, no invariant is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'but:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a class has any `private` data, a user cannot completely initialize an object
    without the use of a constructor. Hence, the class definer will provide a constructor
    and must specify its meaning. This effectively means the definer needs to define
    an invariant.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[define a class with private data as `class`](#rc-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Prefer to place the interface first in a class](#rl-order)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize exposure of members](#rc-private)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid `protected` data](#rh-protected)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for `struct`s with all data private and `class`es with public members.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.3: Represent the distinction between an interface and an implementation using
    a class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An explicit distinction between interface and implementation improves readability
    and simplifies maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: For example, we can now change the representation of a `Date` without affecting
    its users (recompilation is likely, though).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using a class in this way to represent the distinction between interface and
    implementation is of course not the only way. For example, we can use a set of
    declarations of freestanding functions in a namespace, an abstract base class,
    or a function template with concepts to represent an interface. The most important
    issue is to explicitly distinguish between an interface and its implementation
    “details.” Ideally, and typically, an interface is far more stable than its implementation(s).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.4: Make a function a member only if it needs direct access to the representation
    of a class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Less coupling than with member functions, fewer functions that can cause trouble
    by modifying object state, reduces the number of functions that need to be modified
    after a change in representation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: The “helper functions” have no need for direct access to the representation
    of a `Date`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule becomes even better if C++ gets [“uniform function call”](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The language requires `virtual` functions to be members, and not all `virtual`
    functions directly access data. In particular, members of an abstract class rarely
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Note [multi-methods](https://web.archive.org/web/20200605021759/https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The language requires operators `=`, `()`, `[]`, and `->` to be members.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An overload set could have some members that do not directly access `private`
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Similarly, a set of functions could be designed to be used in a chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Typically, some but not all of such functions directly access `private` data.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for non-`virtual` member functions that do not touch data members directly.
    The snag is that many member functions that do not need to touch data members
    directly do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore `virtual` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore functions that are part of an overload set out of which at least one
    function accesses `private` members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore functions returning `this`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.5: Place helper functions in the same namespace as the class they support'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A helper function is a function (usually supplied by the writer of a class)
    that does not need direct access to the representation of the class, yet is seen
    as part of the useful interface to the class. Placing them in the same namespace
    as the class makes their relationship to the class obvious and allows them to
    be found by argument dependent lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is especially important for [overloaded operators](#ro-namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag global functions taking argument types from a single namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.7: Don’t define a class or enum and declare a variable of its type in the
    same statement'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Mixing a type definition and the definition of another entity in the same declaration
    is confusing and unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag if the `}` of a class or enumeration definition is not followed by a `;`.
    The `;` is missing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.8: Use `class` rather than `struct` if any member is non-public'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. To make it clear that something is being hidden/abstracted. This
    is a useful convention.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing wrong with this code as far as the C++ language rules are concerned,
    but nearly everything is wrong from a design perspective. The private data is
    hidden far from the public data. The data is split in different parts of the class
    declaration. Different parts of the data have different access. All of this decreases
    readability and complicates maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prefer to place the interface first in a class, [see NL.16](#rl-order).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag classes declared with `struct` if there is a `private` or `protected` member.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.9: Minimize exposure of members'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Encapsulation. Information hiding. Minimize the chance of unintended access.
    This simplifies maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever we do in the `//`-part, an arbitrary user of a `pair` can arbitrarily
    and independently change its `a` and `b`. In a large code base, we cannot easily
    find which code does what to the members of `pair`. This might be exactly what
    we want, but if we want to enforce a relation among members, we need to make them
    `private` and enforce that relation (invariant) through constructors and member
    functions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the set of direct users of a set of variables cannot be easily determined,
    the type or usage of that set cannot be (easily) changed/improved. For `public`
    and `protected` data, that’s usually the case.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A class can provide two interfaces to its users. One for derived classes (`protected`)
    and one for general users (`public`). For example, a derived class might be allowed
    to skip a run-time check because it has already guaranteed correctness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[`protected` data is a bad idea](#rh-protected).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prefer the order `public` members before `protected` members before `private`
    members; see [NL.16](#rl-order).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Flag protected data](#rh-protected).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag mixtures of `public` and `private` data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.concrete: Concrete types'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Concrete type rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.10: Prefer concrete types over class hierarchies](#rc-concrete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.11: Make concrete types regular](#rc-regular)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.12: Don’t make data members `const` or references in a copyable or movable
    type](#rc-constref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.10: Prefer concrete types over class hierarchies'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A concrete type is fundamentally simpler than a type in a class hierarchy:
    easier to design, easier to implement, easier to use, easier to reason about,
    smaller, and faster. You need a reason (use cases) for using a hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: If a class is part of a hierarchy, we (in real code if not necessarily in small
    examples) must manipulate its objects through pointers or references. That implies
    more memory overhead, more allocations and deallocations, and more run-time overhead
    to perform the resulting indirections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Concrete types can be stack-allocated and be members of other classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The use of indirection is fundamental for run-time polymorphic interfaces. The
    allocation/deallocation overhead is not (that’s just the most common case). We
    can use a base class as the interface of a scoped object of a derived class. This
    is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide
    a stable interface to some kinds of plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.11: Make concrete types regular'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Regular types are easier to understand and reason about than types that are
    not regular (irregularities require extra effort to understand and use).
  prefs: []
  type: TYPE_NORMAL
- en: The C++ built-in types are regular, and so are standard-library classes such
    as `string`, `vector`, and `map`. Concrete classes without assignment and equality
    can be defined, but they are (and should be) rare.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: In particular, if a concrete type is copyable, prefer to also give it an equality
    comparison operator, and ensure that `a = b` implies `a == b`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For structs intended to be shared with C code, defining `operator==` may not
    be feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Handles for resources that cannot be cloned, e.g., a `scoped_lock` for a `mutex`,
    are concrete types but typically cannot be copied (instead, they can usually be
    moved), so they can’t be regular; instead, they tend to be move-only.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.12: Don’t make data members `const` or references in a copyable or movable
    type'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`const` and reference data members are not useful in a copyable or movable
    type, and make such types difficult to use by making them at least partly uncopyable/unmovable
    for subtle reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: Example; bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The `const` and `&` data members make this class “only-sort-of-copyable” – copy-constructible
    but not copy-assignable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you need a member to point to something, use a pointer (raw or smart, and
    `gsl::not_null` if it should not be null) instead of a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a data member that is `const`, `&`, or `&&` in a type that has any copy
    or move operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.ctor: Constructors, assignments, and destructors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These functions control the lifecycle of objects: creation, copy, move, and
    destruction. Define constructors to guarantee and simplify initialization of classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are *default operations*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a default constructor: `X()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a copy constructor: `X(const X&)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a copy assignment: `operator=(const X&)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a move constructor: `X(X&&)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a move assignment: `operator=(X&&)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a destructor: `~X()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the compiler defines each of these operations if it is used, but
    the default can be suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: The default operations are a set of related operations that together implement
    the lifecycle semantics of an object. By default, C++ treats classes as value-like
    types, but not all types are value-like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set of default operations rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.20: If you can avoid defining any default operations, do](#rc-zero)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.21: If you define or `=delete` any copy, move, or destructor function, define
    or `=delete` them all](#rc-five)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.22: Make default operations consistent](#rc-matched)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Destructor rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.30: Define a destructor if a class needs an explicit action at object destruction](#rc-dtor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.31: All resources acquired by a class must be released by the class’s destructor](#rc-dtor-release)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether
    it might be owning](#rc-dtor-ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.33: If a class has an owning pointer member, define a destructor](#rc-dtor-ptr2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.35: A base class destructor should be either public and virtual, or protected
    and non-virtual](#rc-dtor-virtual)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.36: A destructor must not fail](#rc-dtor-fail)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.37: Make destructors `noexcept`](#rc-dtor-noexcept)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructor rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.40: Define a constructor if a class has an invariant](#rc-ctor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.41: A constructor should create a fully initialized object](#rc-complete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.42: If a constructor cannot construct a valid object, throw an exception](#rc-throw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.43: Ensure that a copyable class has a default constructor](#rc-default0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.44: Prefer default constructors to be simple and non-throwing](#rc-default00)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.45: Don’t define a default constructor that only initializes data members;
    use member initializers instead](#rc-default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.46: By default, declare single-argument constructors `explicit`](#rc-explicit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.47: Define and initialize data members in the order of member declaration](#rc-order)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.48: Prefer default member initializers to member initializers in constructors
    for constant initializers](#rc-in-class-initializer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.49: Prefer initialization to assignment in constructors](#rc-initialize)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.50: Use a factory function if you need “virtual behavior” during initialization](#rc-factory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.51: Use delegating constructors to represent common actions for all constructors
    of a class](#rc-delegating)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.52: Use inheriting constructors to import constructors into a derived class
    that does not need further explicit initialization](#rc-inheriting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Copy and move rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.60: Make copy assignment non-`virtual`, take the parameter by `const&`,
    and return by non-`const&`](#rc-copy-assignment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.61: A copy operation should copy](#rc-copy-semantic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.62: Make copy assignment safe for self-assignment](#rc-copy-self)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and
    return by non-`const&`](#rc-move-assignment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.64: A move operation should move and leave its source in a valid state](#rc-move-semantic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.65: Make move assignment safe for self-assignment](#rc-move-self)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.66: Make move operations `noexcept`](#rc-move-noexcept)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.67: A polymorphic class should suppress public copy/move](#rc-copy-virtual)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other default operations rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.80: Use `=default` if you have to be explicit about using the default semantics](#rc-eqdefault)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.81: Use `=delete` when you want to disable default behavior (without wanting
    an alternative)](#rc-delete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.82: Don’t call virtual functions in constructors and destructors](#rc-ctor-virtual)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.83: For value-like types, consider providing a `noexcept` swap function](#rc-swap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.84: A `swap` must not fail](#rc-swap-fail)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.85: Make `swap` `noexcept`](#rc-swap-noexcept)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.86: Make `==` symmetric with respect of operand types and `noexcept`](#rc-eq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.87: Beware of `==` on base classes](#rc-eq-base)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.89: Make a `hash` `noexcept`](#rc-hash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.90: Rely on constructors and assignment operators, not memset and memcpy](#rc-memset)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.defop: Default Operations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the language supplies the default operations with their default
    semantics. However, a programmer can disable or replace these defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.20: If you can avoid defining default operations, do'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s the simplest and gives the cleanest semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Since `std::map` and `string` have all the special functions, no further work
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is known as “the rule of zero”.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) While not enforceable, a good static analyzer can detect patterns
    that indicate a possible improvement to meet this rule. For example, a class with
    a (pointer, size) pair of members and a destructor that `delete`s the pointer
    could probably be converted to a `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.21: If you define or `=delete` any copy, move, or destructor function, define
    or `=delete` them all'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The semantics of copy, move, and destruction are closely related, so if one
    needs to be declared, the odds are that others need consideration too.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring any copy/move/destructor function, even as `=default` or `=delete`,
    will suppress the implicit declaration of a move constructor and move assignment
    operator. Declaring a move constructor or move assignment operator, even as `=default`
    or `=delete`, will cause an implicitly generated copy constructor or implicitly
    generated copy assignment operator to be defined as deleted. So as soon as any
    of these are declared, the others should all be declared to avoid unwanted effects
    like turning all potential moves into more expensive copies, or making a class
    move-only.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Given that “special attention” was needed for the destructor (here, to deallocate),
    the likelihood that the implicitly-defined copy and move assignment operators
    will be correct is low (here, we would get double deletion).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is known as “the rule of five.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you want a default implementation (while defining another), write `=default`
    to show you’re doing so intentionally for that function. If you don’t want a generated
    default function, suppress it with `=delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When a destructor needs to be declared just to make it `virtual`, it can be
    defined as defaulted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent slicing as per [C.67](#rc-copy-virtual), make the copy and move
    operations protected or `=delete`d, and add a `clone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Defining only the move operations or only the copy operations would have the
    same effect here, but stating the intent explicitly for each special member makes
    it more obvious to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compilers enforce much of this rule and ideally warn about any violation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Relying on an implicitly generated copy operation in a class with a destructor
    is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Writing these functions can be error-prone. Note their argument types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: A minor mistake (such as a misspelling, leaving out a `const`, using `&` instead
    of `&&`, or leaving out a special function) can lead to errors or warnings. To
    avoid the tedium and the possibility of errors, try to follow the [rule of zero](#rc-zero).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) A class should have a declaration (even a `=delete` one) for either
    all or none of the copy/move/destructor functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.22: Make default operations consistent'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The default operations are conceptually a matched set. Their semantics are interrelated.
    Users will be surprised if copy/move construction and copy/move assignment do
    logically different things. Users will be surprised if constructors and destructors
    do not provide a consistent view of resource management. Users will be surprised
    if copy and move don’t reflect the way constructors and destructors work.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: These operations disagree about copy semantics. This will lead to confusion
    and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Complex) A copy/move constructor and the corresponding copy/move assignment
    operator should write to the same data members at the same level of dereference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Complex) Any data members written in a copy/move constructor should also be
    initialized by all other constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Complex) If a copy/move constructor performs a deep copy of a data member,
    then the destructor should modify the data member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Complex) If a destructor is modifying a data member, that data member should
    be written in any copy/move constructors or assignment operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.dtor: Destructors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Does this class need a destructor?” is a surprisingly insightful design question.
    For most classes the answer is “no” either because the class holds no resources
    or because destruction is handled by [the rule of zero](#rc-zero); that is, its
    members can take care of themselves as concerns destruction. If the answer is
    “yes”, much of the design of the class follows (see [the rule of five](#rc-five)).
  prefs: []
  type: TYPE_NORMAL
- en: 'C.30: Define a destructor if a class needs an explicit action at object destruction'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A destructor is implicitly invoked at the end of an object’s lifetime. If the
    default destructor is sufficient, use it. Only define a non-default destructor
    if a class needs to execute code that is not already part of its members’ destructors.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: The whole purpose of `final_action` is to get a piece of code (usually a lambda)
    executed upon destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are two general categories of classes that need a user-defined destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: A class with a resource that is not already represented as a class with a destructor,
    e.g., a `vector` or a transaction class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class that exists primarily to execute an action upon destruction, such as
    a tracer or `final_action`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The default destructor does it better, more efficiently, and can’t get it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for likely “implicit resources”, such as pointers and references. Look
    for classes with destructors even though all their data members have destructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.31: All resources acquired by a class must be released by the class’s destructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prevention of resource leaks, especially in error cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For resources represented as classes with a complete set of default operations,
    this happens automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '`X`’s `ifstream` implicitly closes any file it might have open upon destruction
    of its `X`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '`X2` might leak a file handle.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What about a socket that won’t close? A destructor, close, or cleanup operation
    [should never fail](#rc-dtor-fail). If it does nevertheless, we have a problem
    that has no really good solution. For starters, the writer of a destructor does
    not know why the destructor is called and cannot “refuse to act” by throwing an
    exception. See [discussion](#sd-never-fail). To make the problem worse, many “close/release”
    operations are not retryable. Many have tried to solve this problem, but no general
    solution is known. If at all possible, consider failure to close/clean up a fundamental
    design error and terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A class can hold pointers and references to objects that it does not own. Obviously,
    such objects should not be `delete`d by the class’s destructor. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Here `p` refers to `pp` but does not own it.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) If a class has pointer or reference members that are owners (e.g.,
    deemed owners by using `gsl::owner`), then they should be referenced in its destructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Hard) Determine if pointer or reference members are owners when there is no
    explicit statement of ownership (e.g., look into the constructors).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether
    it might be owning'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is a lot of code that is non-specific about ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: The only way to determine ownership may be code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ownership should be clear in new code (and refactored legacy code) according
    to [R.20](#rr-owner) for owning pointers and [R.3](#rr-ptr) for non-owning pointers.
    References should never own [R.4](#rr-ref).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look at the initialization of raw member pointers and member references and
    see if an allocation is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.33: If a class has an owning pointer member, define a destructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An owned object must be `delete`d upon destruction of the object that owns it.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A pointer member could represent a resource. [A `T*` should not do so](#rr-ptr),
    but in older code, that’s common. Consider a `T*` a possible owner and therefore
    suspect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you define a destructor, you must define or delete [all default
    operations](#rc-five):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The default copy operation will just copy the `p1.p` into `p2.p` leading to
    a double destruction of `p1.p`. Be explicit about ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Often the simplest way to get a destructor is to replace the pointer with a
    smart pointer (e.g., `std::unique_ptr`) and let the compiler arrange for proper
    destruction to be done implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Why not just require all owning pointers to be “smart pointers”? That would
    sometimes require non-trivial code changes and might affect ABIs.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A class with a pointer data member is suspect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class with an `owner<T>` should define its default operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.35: A base class destructor should be either public and virtual, or protected
    and non-virtual'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To prevent undefined behavior. If the destructor is public, then calling code
    can attempt to destroy a derived class object through a base class pointer, and
    the result is undefined if the base class’s destructor is non-virtual. If the
    destructor is protected, then calling code cannot destroy through a base class
    pointer and the destructor does not need to be virtual; it does need to be protected,
    not private, so that derived destructors can invoke it. In general, the writer
    of a base class does not know the appropriate action to be done upon destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See [this in the Discussion section](#sd-dtor).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A virtual function defines an interface to derived classes that can be used
    without looking at the derived classes. If the interface allows destroying, it
    should be safe to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A destructor must be non-private or it will prevent using the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can imagine one case where you could want a protected virtual destructor:
    When an object of a derived type (and only of such a type) should be allowed to
    destroy *another* object (not itself) through a pointer to base. We haven’t seen
    such a case in practice, though.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A class with any virtual functions should have a destructor that is either public
    and virtual or else protected and non-virtual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a class inherits publicly from a base class, the base class should have a
    destructor that is either public and virtual or else protected and non-virtual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.36: A destructor must not fail'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In general we do not know how to write error-free code if a destructor should
    fail. The standard library requires that all classes it deals with have destructors
    that do not exit by throwing.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Many have tried to devise a fool-proof scheme for dealing with failure in destructors.
    None have succeeded to come up with a general scheme. This can be a real practical
    problem: For example, what about a socket that won’t close? The writer of a destructor
    does not know why the destructor is called and cannot “refuse to act” by throwing
    an exception. See [discussion](#sd-never-fail). To make the problem worse, many
    “close/release” operations are not retryable. If at all possible, consider failure
    to close/clean up a fundamental design error and terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Declare a destructor `noexcept`. That will ensure that it either completes normally
    or terminates the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a resource cannot be released and the program must not fail, try to signal
    the failure to the rest of the system somehow (maybe even by modifying some global
    state and hope something will notice and be able to take care of the problem).
    Be fully aware that this technique is special-purpose and error-prone. Consider
    the “my connection will not close” example. Probably there is a problem at the
    other end of the connection and only a piece of code responsible for both ends
    of the connection can properly handle the problem. The destructor could send a
    message (somehow) to the responsible part of the system, consider that to have
    closed the connection, and return normally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a destructor uses operations that could fail, it can catch exceptions and
    in some cases still complete successfully (e.g., by using a different clean-up
    mechanism from the one that threw an exception).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) A destructor should be declared `noexcept` if it could throw.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.37: Make destructors `noexcept`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[A destructor must not fail](#rc-dtor-fail). If a destructor tries to exit
    with an exception, it’s a bad design error and the program had better terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A destructor (either user-defined or compiler-generated) is implicitly declared
    `noexcept` (independently of what code is in its body) if all of the members of
    its class have `noexcept` destructors. By explicitly marking destructors `noexcept`,
    an author guards against the destructor becoming implicitly `noexcept(false)`
    through the addition or modification of a class member.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not all destructors are noexcept by default; one throwing member poisons the
    whole class hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: So, if in doubt, declare a destructor noexcept.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Why not then declare all destructors noexcept? Because that would in many cases
    – especially simple cases – be distracting clutter.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) A destructor should be declared `noexcept` if it could throw.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.ctor: Constructors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A constructor defines how an object is initialized (constructed).
  prefs: []
  type: TYPE_NORMAL
- en: 'C.40: Define a constructor if a class has an invariant'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That’s what constructors are for.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: It is often a good idea to express the invariant as an `Ensures` on the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A constructor can be used for convenience even if a class does not have an
    invariant. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The C++11 initializer list rule eliminates the need for many constructors.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: The `Rec2` constructor is redundant. Also, the default for `int` would be better
    done as a [default member initializer](#rc-in-class-initializer).
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [construct valid object](#rc-complete) and [constructor throws](#rc-throw).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag classes with user-defined copy operations but no constructor (a user-defined
    copy is a good indicator that the class has an invariant)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.41: A constructor should create a fully initialized object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A constructor establishes the invariant for a class. A user of a class should
    be able to assume that a constructed object is usable.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Compilers do not read comments.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a valid object cannot conveniently be constructed by a constructor, [use
    a factory function](#rc-factory).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Every constructor should initialize every data member (either explicitly,
    via a delegating ctor call or via default construction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Unknown) If a constructor has an `Ensures` contract, try to see if it holds
    as a postcondition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a constructor acquires a resource (to create a valid object), that resource
    should be [released by the destructor](#rc-dtor-release). The idiom of having
    constructors acquire resources and destructors release them is called [RAII](#rr-raii)
    (“Resource Acquisition Is Initialization”).
  prefs: []
  type: TYPE_NORMAL
- en: 'C.42: If a constructor cannot construct a valid object, throw an exception'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Leaving behind an invalid object is asking for trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For a variable definition (e.g., on the stack or as a member of another object)
    there is no explicit function call from which an error code could be returned.
    Leaving behind an invalid object and relying on users to consistently check an
    `is_valid()` function before use is tedious, error-prone, and inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are domains, such as some hard-real-time systems (think airplane controls)
    where (without additional tool support) exception handling is not sufficiently
    predictable from a timing perspective. There the `is_valid()` technique must be
    used. In such cases, check `is_valid()` consistently and immediately to simulate
    [RAII](#rr-raii).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you feel tempted to use some “post-constructor initialization” or “two-stage
    initialization” idiom, try not to do that. If you really have to, look at [factory
    functions](#rc-factory).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One reason people have used `init()` functions rather than doing the initialization
    work in a constructor has been to avoid code replication. [Delegating constructors](#rc-delegating)
    and [default member initialization](#rc-in-class-initializer) do that better.
    Another reason has been to delay initialization until an object is needed; the
    solution to that is often [not to declare a variable until it can be properly
    initialized](#res-init).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.43: Ensure that a copyable class has a default constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That is, ensure that if a concrete class is copyable it also satisfies the rest
    of “semiregular.”
  prefs: []
  type: TYPE_NORMAL
- en: Many language and library facilities rely on default constructors to initialize
    their elements, e.g. `T a[10]` and `std::vector<T> v(10)`. A default constructor
    often simplifies the task of defining a suitable [moved-from state](#???) for
    a type that is also copyable.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor is only auto-generated if there is no user-declared
    constructor, hence it’s impossible to initialize the vector `vd1` in the example
    above. The absence of a default value can cause surprises for users and complicate
    its use, so if one can be reasonably defined, it should be.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date` is chosen to encourage thought: There is no “natural” default date (the
    big bang is too far back in time to be useful for most people), so this example
    is non-trivial. `{0, 0, 0}` is not a valid date in most calendar systems, so choosing
    that would be introducing something like floating-point’s `NaN`. However, most
    realistic `Date` classes have a “first date” (e.g. January 1, 1970 is popular),
    so making that the default is usually trivial.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A class with members that all have default constructors implicitly gets a default
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Beware that built-in types are not properly default constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Statically allocated objects of built-in types are by default initialized to
    `0`, but local built-in variables are not. Beware that your compiler might default
    initialize local built-in variables, whereas an optimized build will not. Thus,
    code like the example above might appear to work, but it relies on undefined behavior.
    Assuming that you want initialization, an explicit default initialization can
    help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Classes that don’t have a reasonable default construction are usually not copyable
    either, so they don’t fall under this guideline.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a base class should not be copyable, and so does not necessarily
    need a default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'A class that must acquire a caller-provided resource during construction often
    cannot have a default constructor, but it does not fall under this guideline because
    such a class is usually not copyable anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'A class that has a “special state” that must be handled separately from other
    states by member functions or users causes extra work (and most likely more errors).
    Such a type can naturally use the special state as a default constructed value,
    whether or not it is copyable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Similar special-state types that are copyable, such as copyable smart pointers
    that have the special state “==nullptr”, should use the special state as their
    default constructed value.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is preferable to have a default constructor default to a meaningful
    state such as `std::string`s `""` and `std::vector`s `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag classes that are copyable by `=` without a default constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag classes that are comparable with `==` but not copyable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.44: Prefer default constructors to be simple and non-throwing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Being able to set a value to “the default” without operations that might fail
    simplifies error handling and reasoning about move operations.
  prefs: []
  type: TYPE_NORMAL
- en: Example, problematic
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: This is nice and general, but setting a `Vector0` to empty after an error involves
    an allocation, which might fail. Also, having a default `Vector` represented as
    `{new T[0], 0, 0}` seems wasteful. For example, `Vector0<int> v[100]` costs 100
    allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Using `{nullptr, nullptr, nullptr}` makes `Vector1{}` cheap, but a special case
    and implies run-time checks. Setting a `Vector1` to empty after detecting an error
    is trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag throwing default constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.45: Don’t define a default constructor that only initializes data members;
    use default member initializers instead'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using default member initializers lets the compiler generate the function for
    you. The compiler-generated function can be more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Flag if a default constructor’s explicit member initializer is a constant,
    and recommend that the constant should be written as a data member initializer
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.46: By default, declare single-argument constructors explicit'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid unintended conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you really want an implicit conversion from the constructor argument type
    to the class type, don’t use `explicit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: [Discussion of implicit conversions](#ro-conversion)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Copy and move constructors should not be made `explicit` because they do not
    perform conversions. Explicit copy/move constructors make passing and returning
    by value difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Single-argument constructors should be declared `explicit`. Good single
    argument non-`explicit` constructors are rare in most code bases. Warn for all
    that are not on a “positive list”.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.47: Define and initialize data members in the order of member declaration'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To minimize confusion and errors. That is the order in which the initialization
    happens (independent of the order of member initializers).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) A member initializer list should mention the members in the same order
    they are declared.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Discussion](#sd-order)'
  prefs: []
  type: TYPE_NORMAL
- en: 'C.48: Prefer default member initializers to member initializers in constructors
    for constant initializers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Makes it explicit that the same value is expected to be used in all constructors.
    Avoids repetition. Avoids maintenance problems. It leads to the shortest and most
    efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: How would a maintainer know whether `j` was deliberately uninitialized (probably
    a bad idea anyway) and whether it was intentional to give `s` the default value
    `""` in one case and `qqq` in another (almost certainly a bug)? The problem with
    `j` (forgetting to initialize a member) often happens when a new member is added
    to an existing class.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '**Alternative**: We can get part of the benefits from default arguments to
    constructors, and that is not uncommon in older code. However, that is less explicit,
    causes more arguments to be passed, and is repetitive when there is more than
    one constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Every constructor should initialize every data member (either explicitly,
    via a delegating ctor call or via default construction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Default arguments to constructors suggest a default member initializer
    might be more appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.49: Prefer initialization to assignment in constructors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An initialization explicitly states that initialization, rather than assignment,
    is done and can be more elegant and efficient. Prevents “use before set” errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Example, better still
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Instead of those `const char*`s we could use C++17 `std::string_view` or `gsl::span<char>`
    as [a more general way to present arguments to a function](#rstr-view):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'C.50: Use a factory function if you need “virtual behavior” during initialization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the state of a base class object must depend on the state of a derived part
    of the object, we need to use a virtual function (or equivalent) while minimizing
    the window of opportunity to misuse an imperfectly constructed object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The return type of the factory should normally be `unique_ptr` by default; if
    some uses are shared, the caller can `move` the `unique_ptr` into a `shared_ptr`.
    However, if the factory author knows that all uses of the returned object will
    be shared uses, return `shared_ptr` and use `make_shared` in the body to save
    an allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '`make_shared` requires that the constructor is public. By requiring a protected
    `Token` the constructor cannot be publicly called anymore, so we avoid an incompletely
    constructed object escaping into the wild. By providing the factory function `create()`,
    we make construction (on the free store) convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Conventional factory functions allocate on the free store, rather than on the
    stack or in an enclosing object.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Discussion](#sd-factory)'
  prefs: []
  type: TYPE_NORMAL
- en: 'C.51: Use delegating constructors to represent common actions for all constructors
    of a class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid repetition and accidental differences.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: The common action gets tedious to write and might accidentally not be common.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: If the “repeated action” is a simple initialization, consider
    [a default member initializer](#rc-in-class-initializer).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Moderate) Look for similar constructor bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.52: Use inheriting constructors to import constructors into a derived class
    that does not need further explicit initialization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you need those constructors for a derived class, re-implementing them is
    tedious and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::vector` has a lot of tricky constructors, so if I want my own `vector`,
    I don’t want to reimplement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Make sure that every member of the derived class is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.copy: Copy and move'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concrete types should generally be copyable, but interfaces in a class hierarchy
    should not. Resource handles might or might not be copyable. Types can be defined
    to move for logical as well as performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.60: Make copy assignment non-`virtual`, take the parameter by `const&`, and
    return by non-`const&`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is simple and efficient. If you want to optimize for rvalues, provide an
    overload that takes an `&&` (see [F.18](#rf-consume)).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `swap` implementation technique offers the [strong guarantee](#Abrahams01).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'But what if you can get significantly better performance by not making a temporary
    copy? Consider a simple `Vector` intended for a domain where assignment of large,
    equal-sized `Vector`s is common. In this case, the copy of elements implied by
    the `swap` implementation technique could cause an order of magnitude increase
    in cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: By writing directly to the target elements, we will get only [the basic guarantee](#Abrahams01)
    rather than the strong guarantee offered by the `swap` technique. Beware of [self-assignment](#rc-copy-self).
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternatives**: If you think you need a `virtual` assignment operator, and
    understand why that’s deeply problematic, don’t call it `operator=`. Make it a
    named function like `virtual void assign(const Foo&)`. See [copy constructor vs.
    `clone()`](#rc-copy-virtual).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) An assignment operator should not be virtual. Here be dragons!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) An assignment operator should return `T&` to enable chaining, not alternatives
    like `const T&` which interfere with composability and putting objects in containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Moderate) An assignment operator should (implicitly or explicitly) invoke all
    base and member assignment operators. Look at the destructor to determine if the
    type has pointer semantics or value semantics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.61: A copy operation should copy'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That is the generally assumed semantics. After `x = y`, we should have `x ==
    y`. After a copy `x` and `y` can be independent objects (value semantics, the
    way non-pointer built-in types and the standard-library types work) or refer to
    a shared object (pointer semantics, the way pointers work).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prefer value semantics unless you are building a “smart pointer”. Value semantics
    is the simplest to reason about and what the standard-library facilities expect.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable)
  prefs: []
  type: TYPE_NORMAL
- en: 'C.62: Make copy assignment safe for self-assignment'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If `x = x` changes the value of `x`, people will be surprised and bad errors
    will occur (often including leaks).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The standard-library containers handle self-assignment elegantly and efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The default assignment generated from members that handle self-assignment correctly
    handles self-assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can handle self-assignment by explicitly testing for self-assignment, but
    often it is faster and more elegant to cope without such a test (e.g., [using
    `swap`](#rc-swap)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'This is obviously safe and apparently efficient. However, what if we do one
    self-assignment per million assignments? That’s about a million redundant tests
    (but since the answer is essentially always the same, the computer’s branch predictor
    will guess right essentially every time). Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '`std::string` is safe for self-assignment and so are `int`. All the cost is
    carried by the (rare) case of self-assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Assignment operators should not contain the pattern `if (this == &a)
    return *this;` ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and return
    by non-`const&`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is simple and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**See**: [The rule for copy-assignment](#rc-copy-assignment).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Equivalent to what is done for [copy-assignment](#rc-copy-assignment).
  prefs: []
  type: TYPE_NORMAL
- en: (Simple) An assignment operator should not be virtual. Here be dragons!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) An assignment operator should return `T&` to enable chaining, not alternatives
    like `const T&` which interfere with composability and putting objects in containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Moderate) A move assignment operator should (implicitly or explicitly) invoke
    all base and member move assignment operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.64: A move operation should move and leave its source in a valid state'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That is the generally assumed semantics. After `y = std::move(x)` the value
    of `y` should be the value `x` had and `x` should be in a valid state.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ideally, that moved-from should be the default value of the type. Ensure that
    unless there is an exceptionally good reason not to. However, not all types have
    a default value and for some types establishing the default value can be expensive.
    The standard requires only that the moved-from object can be destroyed. Often,
    we can easily and cheaply do better: The standard library assumes that it is possible
    to assign to a moved-from object. Always leave the moved-from object in some (necessarily
    specified) valid state.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unless there is an exceptionally strong reason not to, make `x = std::move(y);
    y = z;` work with the conventional semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Not enforceable) Look for assignments to members in the move operation. If
    there is a default constructor, compare those assignments to the initializations
    in the default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.65: Make move assignment safe for self-assignment'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If `x = x` changes the value of `x`, people will be surprised and bad errors
    can occur. However, people don’t usually directly write a self-assignment that
    turns into a move, but it can occur. However, `std::swap` is implemented using
    move operations so if you accidentally do `swap(a, b)` where `a` and `b` refer
    to the same object, failing to handle self-move could be a serious and subtle
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: The one-in-a-million argument against `if (this == &a) return *this;` tests
    from the discussion of [self-assignment](#rc-copy-self) is even more relevant
    for self-move.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is no known general way of avoiding an `if (this == &a) return *this;`
    test for a move assignment and still getting a correct answer (i.e., after `x
    = x` the value of `x` is unchanged).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ISO standard guarantees only a “valid but unspecified” state for the standard-library
    containers. Apparently this has not been a problem in about 10 years of experimental
    and production use. Please contact the editors if you find a counter example.
    The rule here is more caution and insists on complete safety.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here is a way to move a pointer without a test (imagine it as code in the implementation
    a move assignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Moderate) In the case of self-assignment, a move assignment operator should
    not leave the object holding pointer members that have been `delete`d or set to
    `nullptr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Not enforceable) Look at the use of standard-library container types (incl.
    `string`) and consider them safe for ordinary (not life-critical) uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.66: Make move operations `noexcept`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A throwing move violates most people’s reasonable assumptions. A non-throwing
    move will be used more efficiently by standard-library and language facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: These operations do not throw.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: This `Vector2` is not just inefficient, but since a vector copy requires allocation,
    it can throw.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) A move operation should be marked `noexcept`.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.67: A polymorphic class should suppress public copy/move'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *polymorphic class* is a class that defines or inherits at least one virtual
    function. It is likely that it will be used as a base class for other derived
    classes with polymorphic behavior. If it is accidentally passed by value, with
    the implicitly generated copy constructor and assignment, we risk slicing: only
    the base portion of a derived object will be copied, and the polymorphic behavior
    will be corrupted.'
  prefs: []
  type: TYPE_NORMAL
- en: If the class has no data, `=delete` the copy/move functions. Otherwise, make
    them protected.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you need to create deep copies of polymorphic objects, use `clone()` functions:
    see [C.130](#rh-copy).'
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Classes that represent exception objects need both to be polymorphic and copy-constructible.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a polymorphic class with a public copy operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag an assignment of polymorphic class objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.other: Other default operation rules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the operations for which the language offers default implementations,
    there are a few operations that are so foundational that specific rules for their
    definition are needed: comparisons, `swap`, and `hash`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C.80: Use `=default` if you have to be explicit about using the default semantics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler is more likely to get the default semantics right and you cannot
    implement these functions better than the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Because we defined the destructor, we must define the copy and move operations.
    The `= default` is the best and simplest way of doing that.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: Writing out the bodies of the copy and move operations is verbose, tedious,
    and error-prone. A compiler does it better.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Moderate) The body of a user-defined operation should not have the same semantics
    as the compiler-generated version, because that would be redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.81: Use `=delete` when you want to disable default behavior (without wanting
    an alternative)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a few cases, a default operation is not desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A `unique_ptr` can be moved, but not copied. To achieve that its copy operations
    are deleted. To avoid copying it is necessary to `=delete` its copy operations
    from lvalues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Note that deleted functions should be public.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The elimination of a default operation is (should be) based on the desired semantics
    of the class. Consider such classes suspect, but maintain a “positive list” of
    classes where a human has asserted that the semantics is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.82: Don’t call virtual functions in constructors and destructors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The function called will be that of the object constructed so far, rather than
    a possibly overriding function in a derived class. This can be most confusing.
    Worse, a direct or indirect call to an unimplemented pure virtual function from
    a constructor or destructor results in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Note that calling a specific explicitly qualified function is not a virtual
    call even if the function is `virtual`.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also** [factory functions](#rc-factory) for how to achieve the effect
    of a call to a derived class function without risking undefined behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is nothing inherently wrong with calling virtual functions from constructors
    and destructors. The semantics of such calls is type safe. However, experience
    shows that such calls are rarely needed, easily confuse maintainers, and become
    a source of errors when used by novices.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag calls of virtual functions from constructors and destructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.83: For value-like types, consider providing a `noexcept` swap function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `swap` can be handy for implementing a number of idioms, from smoothly moving
    objects around to implementing assignment easily to providing a guaranteed commit
    function that enables strongly error-safe calling code. Consider using swap to
    implement copy assignment in terms of copy construction. See also [destructors,
    deallocation, and swap must never fail](#re-never-fail).
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Providing a non-member `swap` function in the same namespace as your type for
    callers’ convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Non-trivially copyable types should provide a member swap or a free swap overload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) When a class has a `swap` member function, it should be declared `noexcept`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.84: A `swap` function must not fail'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`swap` is widely used in ways that are assumed never to fail and programs cannot
    easily be written to work correctly in the presence of a failing `swap`. The standard-library
    containers and algorithms will not work correctly if a swap of an element type
    fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: This is not just slow, but if a memory allocation occurs for the elements in
    `tmp`, this `swap` could throw and would make STL algorithms fail if used with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) When a class has a `swap` member function, it should be declared `noexcept`.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.85: Make `swap` `noexcept`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[A `swap` must not fail](#rc-swap-fail). If a `swap` tries to exit with an
    exception, it’s a bad design error and the program had better terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) When a class has a `swap` member function, it should be declared `noexcept`.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.86: Make `==` symmetric with respect to operand types and `noexcept`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Asymmetric treatment of operands is surprising and a source of errors where
    conversions are possible. `==` is a fundamental operation and programmers should
    be able to use it without fear of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '`B`’s comparison accepts conversions for its second operand, but not its first.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a class has a failure state, like `double`’s `NaN`, there is a temptation
    to make a comparison against the failure state throw. The alternative is to make
    two failure states compare equal and any valid state compare false against the
    failure state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`,
    and `>=`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag an `operator==()` for which the argument types differ; same for other
    comparison operators: `!=`, `<`, `<=`, `>`, and `>=`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flag member `operator==()`s; same for other comparison operators: `!=`, `<`,
    `<=`, `>`, and `>=`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.87: Beware of `==` on base classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is really hard to write a foolproof and useful `==` for a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '`B`’s comparison accepts conversions for its second operand, but not its first.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Of course there are ways of making `==` work in a hierarchy, but the naive approaches
    do not scale.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`,
    `>=`, and `<=>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag a virtual `operator==()`; same for other comparison operators: `!=`, `<`,
    `<=`, `>`, `>=`, and `<=>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.89: Make a `hash` `noexcept`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Users of hashed containers use hash indirectly and don’t expect simple access
    to throw. It’s a standard-library requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: If you have to define a `hash` specialization, try simply to let it combine
    standard-library `hash` specializations with `^` (xor). That tends to work better
    than “cleverness” for non-specialists.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag throwing `hash`es.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.90: Rely on constructors and assignment operators, not `memset` and `memcpy`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The standard C++ mechanism to construct an instance of a type is to call its
    constructor. As specified in guideline [C.41](#rc-complete): a constructor should
    create a fully initialized object. No additional initialization, such as by `memcpy`,
    should be required. A type will provide a copy constructor and/or copy assignment
    operator to appropriately make a copy of the class, preserving the type’s invariants.
    Using memcpy to copy a non-trivially copyable type has undefined behavior. Frequently
    this results in slicing, or data corruption.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: This is type-unsafe and overwrites the vtable.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: This is also type-unsafe and overwrites the vtable.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag passing a non-trivially-copyable type to `memset` or `memcpy`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.con: Containers and other resource handles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A container is an object holding a sequence of objects of some type; `std::vector`
    is the archetypical container. A resource handle is a class that owns a resource;
    `std::vector` is the typical resource handle; its resource is its sequence of
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary of container rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.100: Follow the STL when defining a container](#rcon-stl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.101: Give a container value semantics](#rcon-val)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.102: Give a container move operations](#rcon-move)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.103: Give a container an initializer list constructor](#rcon-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.104: Give a container a default constructor that sets it to empty](#rcon-empty)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.109: If a resource handle has pointer semantics, provide `*` and `->`](#rcon-ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**: [Resources](#s-resource)'
  prefs: []
  type: TYPE_NORMAL
- en: 'C.100: Follow the STL when defining a container'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The STL containers are familiar to most C++ programmers and a fundamentally
    sound design.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are of course other fundamentally sound design styles and sometimes reasons
    to depart from the style of the standard library, but in the absence of a solid
    reason to differ, it is simpler and easier for both implementers and users to
    follow the standard.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, `std::vector` and `std::map` provide useful relatively simple
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Here, the STL style is followed, but incompletely. That’s not uncommon. Provide
    only as much functionality as makes sense for a specific container. The key is
    to define the conventional constructors, assignments, destructors, and iterators
    (as meaningful for the specific container) with their conventional semantics.
    From that base, the container can be expanded as needed. Here, special constructors
    from `std::vector` were added.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.101: Give a container value semantics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Regular objects are simpler to think and reason about than irregular ones. Familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If meaningful, make a container `Regular` (the concept). In particular, ensure
    that an object compares equal to its copy.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.102: Give a container move operations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Containers tend to get large; without a move constructor and a copy constructor
    an object can be expensive to move around, thus tempting people to pass pointers
    to it around and getting into resource management problems.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: A user can reasonably assume that returning a standard-like container is cheap.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.103: Give a container an initializer list constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: People expect to be able to initialize a container with a set of values. Familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.104: Give a container a default constructor that sets it to empty'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make it `Regular`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.109: If a resource handle has pointer semantics, provide `*` and `->`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That’s what is expected from pointers. Familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.lambdas: Function objects and lambdas'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function object is an object supplying an overloaded `()` so that you can
    call it. A lambda expression (colloquially often shortened to “a lambda”) is a
    notation for generating a function object. Function objects should be cheap to
    copy (and therefore [passed by value](#rf-in)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F.10: If an operation can be reused, give it a name](#rf-name)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.11: Use an unnamed lambda if you need a simple function object in one place
    only](#rf-lambda)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.50: Use a lambda when a function won’t do (to capture local variables, or
    to write a local function)](#rf-capture-vs-overload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.52: Prefer capturing by reference in lambdas that will be used locally,
    including passed to algorithms](#rf-reference-capture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.53: Avoid capturing by reference in lambdas that will be used non-locally,
    including returned, stored on the heap, or passed to another thread](#rf-value-capture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.28: Use lambdas for complex initialization, especially of `const` variables](#res-lambda-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.hier: Class hierarchies (OOP)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class hierarchy is constructed to represent a set of hierarchically organized
    concepts (only). Typically base classes act as interfaces. There are two major
    uses for hierarchies, often named implementation inheritance and interface inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class hierarchy rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.120: Use class hierarchies to represent concepts with inherent hierarchical
    structure (only)](#rh-domain)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.121: If a base class is used as an interface, make it a pure abstract class](#rh-abstract)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.122: Use abstract classes as interfaces when complete separation of interface
    and implementation is needed](#rh-separation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Designing rules for classes in a hierarchy summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.126: An abstract class typically doesn’t need a user-written constructor](#rh-abstract-ctor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.127: A class with a virtual function should have a virtual or protected
    destructor](#rh-dtor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.128: Virtual functions should specify exactly one of `virtual`, `override`,
    or `final`](#rh-override)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.129: When designing a class hierarchy, distinguish between implementation
    inheritance and interface inheritance](#rh-kind)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.130: For making deep copies of polymorphic classes prefer a virtual `clone`
    function instead of public copy construction/assignment](#rh-copy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.131: Avoid trivial getters and setters](#rh-get)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.132: Don’t make a function `virtual` without reason](#rh-virtual)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.133: Avoid `protected` data](#rh-protected)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.134: Ensure all non-`const` data members have the same access level](#rh-public)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.135: Use multiple inheritance to represent multiple distinct interfaces](#rh-mi-interface)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.136: Use multiple inheritance to represent the union of implementation attributes](#rh-mi-implementation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.137: Use `virtual` bases to avoid overly general base classes](#rh-vbase)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.138: Create an overload set for a derived class and its bases with `using`](#rh-using)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.139: Use `final` on classes sparingly](#rh-final)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.140: Do not provide different default arguments for a virtual function and
    an overrider](#rh-virtual-default-arg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Accessing objects in a hierarchy rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.145: Access polymorphic objects through pointers and references](#rh-poly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable](#rh-dynamic_cast)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.147: Use `dynamic_cast` to a reference type when failure to find the required
    class is considered an error](#rh-ref-cast)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.148: Use `dynamic_cast` to a pointer type when failure to find the required
    class is considered a valid alternative](#rh-ptr-cast)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects
    created using `new`](#rh-smart)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s](#rh-make_unique)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s](#rh-make_shared)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.152: Never assign a pointer to an array of derived class objects to a pointer
    to its base](#rh-array)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.153: Prefer virtual function to casting](#rh-use-virtual)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.120: Use class hierarchies to represent concepts with inherent hierarchical
    structure (only)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Direct representation of ideas in code eases comprehension and maintenance.
    Make sure the idea represented in the base class exactly matches all derived types
    and there is not a better way to express it than using the tight coupling of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Do *not* use inheritance when simply having a data member will do. Usually this
    means that the derived type needs to override a base virtual function or needs
    access to a protected member.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do *not* represent non-hierarchical domain concepts as class hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Here most overriding classes cannot implement most of the functions required
    in the interface well. Thus the base class becomes an implementation burden. Furthermore,
    the user of `Container` cannot rely on the member functions actually performing
    meaningful operations reasonably efficiently; it might throw an exception instead.
    Thus users have to resort to run-time checking and/or not using this (over)general
    interface in favor of a particular interface found by a run-time type inquiry
    (e.g., a `dynamic_cast`).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for classes with lots of members that do nothing but throw.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flag every use of a non-public base class `B` where the derived class `D` does
    not override a virtual function or access a protected member in `B`, and `B` is
    not one of the following: empty, a template parameter or parameter pack of `D`,
    a class template specialized with `D`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.121: If a base class is used as an interface, make it a pure abstract class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A class is more stable (less brittle) if it does not contain data. Interfaces
    should normally be composed entirely of public pure virtual functions and a default/empty
    virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: The `Derived` is `delete`d through its `Goof` interface, so its `string` is
    leaked. Give `Goof` a virtual destructor and all is well.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Warn on any class that contains data members and also has an overridable (non-`final`)
    virtual function that wasn’t inherited from a base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.122: Use abstract classes as interfaces when complete separation of interface
    and implementation is needed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Such as on an ABI (link) boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: A user can now use `D1`s and `D2`s interchangeably through the interface provided
    by `Device`. Furthermore, we can update `D1` and `D2` in ways that are not binary
    compatible with older versions as long as all access goes through `Device`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'C.hierclass: Designing classes in a hierarchy:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C.126: An abstract class typically doesn’t need a user-written constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An abstract class typically does not have any data for a constructor to initialize.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A base class constructor that does work, such as registering an object somewhere,
    might need a constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In extremely rare cases, you might find it reasonable for an abstract class
    to have a bit of data shared by all derived classes (e.g., use statistics data,
    debug information, etc.); such classes tend to have constructors. But be warned:
    Such classes also tend to be prone to requiring virtual inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag abstract classes with constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.127: A class with a virtual function should have a virtual or protected destructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A class with a virtual function is usually (and in general) used via a pointer
    to base. Usually, the last user has to call delete on a pointer to base, often
    via a smart pointer to base, so the destructor should be public and virtual. Less
    commonly, if deletion through a pointer to base is not intended to be supported,
    the destructor should be protected and non-virtual; see [C.35](#rc-dtor-virtual).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are people who don’t follow this rule because they plan to use a class
    only through a `shared_ptr`: `std::shared_ptr<B> p = std::make_shared<D>(args);`
    Here, the shared pointer will take care of deletion, so no leak will occur from
    an inappropriate `delete` of the base. People who do this consistently can get
    a false positive, but the rule is important – what if one was allocated using
    `make_unique`? It’s not safe unless the author of `B` ensures that it can never
    be misused, such as by making all constructors private and providing a factory
    function to enforce the allocation with `make_shared`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A class with any virtual functions should have a destructor that is either public
    and virtual or else protected and non-virtual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag `delete` of a class with a virtual function but no virtual destructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.128: Virtual functions should specify exactly one of `virtual`, `override`,
    or `final`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Detection of mistakes. Writing explicit `virtual`, `override`,
    or `final` is self-documenting and enables the compiler to catch mismatch of types
    and/or names between base and derived classes. However, writing more than one
    of these three is both redundant and a potential source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s simple and clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '`virtual` means exactly and only “this is a new virtual function.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`override` means exactly and only “this is a non-final overrider.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`final` means exactly and only “this is a final overrider.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We want to eliminate two particular classes of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**implicit virtual**: the programmer intended the function to be implicitly
    virtual and it is (but readers of the code can’t tell); or the programmer intended
    the function to be implicitly virtual but it isn’t (e.g., because of a subtle
    parameter list mismatch); or the programmer did not intend the function to be
    virtual but it is (because it happens to have the same signature as a virtual
    in the base class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**implicit override**: the programmer intended the function to be implicitly
    an overrider and it is (but readers of the code can’t tell); or the programmer
    intended the function to be implicitly an overrider but it isn’t (e.g., because
    of a subtle parameter list mismatch); or the programmer did not intend the function
    to be an overrider but it is (because it happens to have the same signature as
    a virtual in the base class – note this problem arises whether or not the function
    is explicitly declared virtual, because the programmer might have intended to
    create either a new virtual function or a new non-virtual function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: On a class defined as `final`, each individual virtual function should
    use either `override` or `final`; there is no semantic difference in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Use `final` on functions sparingly. It does not necessarily lead to optimization,
    and it precludes further overriding.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compare virtual function names in base and derived classes and flag uses of
    the same name that do not override.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag overrides with neither `override` nor `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag function declarations that use more than one of `virtual`, `override`,
    and `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.129: When designing a class hierarchy, distinguish between implementation
    inheritance and interface inheritance'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Implementation details in an interface make the interface brittle; that is,
    make its users vulnerable to having to recompile after changes in the implementation.
    Data in a base class increases the complexity of implementing the base and can
    lead to replication of code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Definition:'
  prefs: []
  type: TYPE_NORMAL
- en: interface inheritance is the use of inheritance to separate users from implementations,
    in particular to allow derived classes to be added and changed without affecting
    the users of base classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: implementation inheritance is the use of inheritance to simplify implementation
    of new facilities by making useful operations available for implementers of related
    new operations (sometimes called “programming by difference”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pure interface class is simply a set of pure virtual functions; see [I.25](#ri-abstract).
  prefs: []
  type: TYPE_NORMAL
- en: In early OOP (e.g., in the 1980s and 1990s), implementation inheritance and
    interface inheritance were often mixed and bad habits die hard. Even now, mixtures
    are not uncommon in old code bases and in old-style teaching material.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of keeping the two kinds of inheritance increases
  prefs: []
  type: TYPE_NORMAL
- en: with the size of a hierarchy (e.g., dozens of derived classes),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: with the length of time the hierarchy is used (e.g., decades), and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: with the number of distinct organizations in which a hierarchy is used (e.g.,
    it can be difficult to distribute an update to a base class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'Problems:'
  prefs: []
  type: TYPE_NORMAL
- en: As the hierarchy grows and more data is added to `Shape`, the constructors get
    harder to write and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why calculate the center for the `Triangle`? We might never use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a data member to `Shape` (e.g., drawing style or canvas) and all classes
    derived from `Shape` and all code using `Shape` will need to be reviewed, possibly
    changed, and probably recompiled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of `Shape::move()` is an example of implementation inheritance:
    we have defined `move()` once and for all, for all derived classes. The more code
    there is in such base class member function implementations and the more data
    is shared by placing it in the base, the more benefits we gain - and the less
    stable the hierarchy is.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This Shape hierarchy can be rewritten using interface inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that a pure interface rarely has constructors: there is nothing to construct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: The interface is now less brittle, but there is more work in implementing the
    member functions. For example, `center` has to be implemented by every class derived
    from `Shape`.
  prefs: []
  type: TYPE_NORMAL
- en: Example, dual hierarchy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How can we gain the benefit of stable hierarchies from interface hierarchies
    and the benefit of implementation reuse from implementation inheritance? One popular
    technique is dual hierarchies. There are many ways of implementing the idea of
    dual hierarchies; here, we use a multiple-inheritance variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we devise a hierarchy of interface classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this interface useful, we must provide its implementation classes (here,
    named equivalently, but in the `Impl` namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Now `Shape` is a poor example of a class with an implementation, but bear with
    us because this is just a simple example of a technique aimed at more complex
    hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'And we could extend the hierarchies by adding a Smiley class (:-)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'There are now two hierarchies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'interface: Smiley -> Circle -> Shape'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'implementation: Impl::Smiley -> Impl::Circle -> Impl::Shape'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since each implementation is derived from its interface as well as its implementation
    base class we get a lattice (DAG):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned, this is just one way to construct a dual hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation hierarchy can be used directly, rather than through the abstract
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful when the implementation class has members that are not offered
    in the abstract interface or if direct use of a member offers optimization opportunities
    (e.g., if an implementation member function is `final`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another (related) technique for separating interface and implementation is [Pimpl](#ri-pimpl).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is often a choice between offering common functionality as (implemented)
    base class functions and freestanding functions (in an implementation namespace).
    Base classes give a shorter notation and easier access to shared data (in the
    base) at the cost of the functionality being available only to users of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a derived to base conversion to a base with both data and virtual functions
    (except for calls from a derived class member to a base class member)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.130: For making deep copies of polymorphic classes prefer a virtual `clone`
    function instead of public copy construction/assignment'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Copying a polymorphic class is discouraged due to the slicing problem, see
    [C.67](#rc-copy-virtual). If you really need copy semantics, copy deeply: Provide
    a virtual `clone` function that will copy the actual most-derived type and return
    an owning pointer to the new object, and then in derived classes return the derived
    type (use a covariant return type).'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, it is recommended to use smart pointers to represent ownership (see
    [R.20](#rr-owner)). However, because of language rules, the covariant return type
    cannot be a smart pointer: `D::clone` can’t return a `unique_ptr<D>` while `B::clone`
    returns `unique_ptr<B>`. Therefore, you either need to consistently return `unique_ptr<B>`
    in all overrides, or use `owner<>` utility from the [Guidelines Support Library](#ss-views).'
  prefs: []
  type: TYPE_NORMAL
- en: 'C.131: Avoid trivial getters and setters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A trivial getter or setter adds no semantic value; the data item could just
    as well be `public`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Consider making such a class a `struct` – that is, a behaviorless bunch of variables,
    all public data and no member functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can put default initializers on data members: [C.49: Prefer initialization
    to assignment in constructors](#rc-initialize).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The key to this rule is whether the semantics of the getter/setter are trivial.
    While it is not a complete definition of “trivial”, consider whether there would
    be any difference beyond syntax if the getter/setter was a public data member
    instead. Examples of non-trivial semantics would be: maintaining a class invariant
    or converting between an internal type and an interface type.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag multiple `get` and `set` member functions that simply access a member without
    additional semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.132: Don’t make a function `virtual` without reason'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Redundant `virtual` increases run-time and object-code size. A virtual function
    can be overridden and is thus open to mistakes in a derived class. A virtual function
    ensures code replication in a templated hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: This kind of “vector” isn’t meant to be used as a base class at all.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a class with virtual functions but no derived classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a class where all member functions are virtual and have implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.133: Avoid `protected` data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Alternative formulation**: Make member data `public` or (preferably) `private`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`protected` data is a source of complexity and errors. `protected` data complicates
    the statement of invariants. `protected` data inherently violates the guidance
    against putting data in base classes, which usually leads to having to deal with
    virtual inheritance as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is up to every derived `Shape` to manipulate the protected data correctly.
    This has been popular, but also a major source of maintenance problems. In a large
    class hierarchy, the consistent use of protected data is hard to maintain because
    there can be a lot of code, spread over a lot of classes. The set of classes that
    can touch that data is open: anyone can derive a new class and start manipulating
    the protected data. Often, it is not possible to examine the complete set of classes,
    so any change to the representation of the class becomes infeasible. There is
    no enforced invariant for the protected data; it is much like a set of global
    variables. The protected data has de facto become global to a large body of code.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Protected data often looks tempting to enable arbitrary improvements through
    derivation. Often, what you get is unprincipled changes and errors. [Prefer `private`
    data](#rc-private) with a well-specified and enforced invariant. Alternatively,
    and often better, [keep data out of any class used as an interface](#rh-abstract).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Protected member function can be just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag classes with `protected` data.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.134: Ensure all non-`const` data members have the same access level'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prevention of logical confusion leading to errors. If the non-`const` data members
    don’t have the same access level, the type is confused about what it’s trying
    to do. Is it a type that maintains an invariant or simply a collection of values?
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The core question is: What code is responsible for maintaining a meaningful/correct
    value for that variable?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are exactly two kinds of data members:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Ones that don’t participate in the object’s invariant. Any combination of
    values for these members is valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'B: Ones that do participate in the object’s invariant. Not every combination
    of values is meaningful (else there’d be no invariant). Therefore all code that
    has write access to these variables must know about the invariant, know the semantics,
    and know (and actively implement and enforce) the rules for keeping the values
    correct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data members in category A should just be `public` (or, more rarely, `protected`
    if you only want derived classes to see them). They don’t need encapsulation.
    All code in the system might as well see and manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data members in category B should be `private` or `const`. This is because
    encapsulation is important. To make them non-`private` and non-`const` would mean
    that the object can’t control its own state: An unbounded amount of code beyond
    the class would need to know about the invariant and participate in maintaining
    it accurately – if these data members were `public`, that would be all calling
    code that uses the object; if they were `protected`, it would be all the code
    in current and future derived classes. This leads to brittle and tightly coupled
    code that quickly becomes a nightmare to maintain. Any code that inadvertently
    sets the data members to an invalid or unexpected combination of values would
    corrupt the object and all subsequent uses of the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most classes are either all A or all B:'
  prefs: []
  type: TYPE_NORMAL
- en: '*All public*: If you’re writing an aggregate bundle-of-variables without an
    invariant across those variables, then all the variables should be `public`. [By
    convention, declare such classes `struct` rather than `class`](#rc-struct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*All private*: If you’re writing a type that maintains an invariant, then all
    the non-`const` variables should be private – it should be encapsulated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Occasionally classes will mix A and B, usually for debug reasons. An encapsulated
    object might contain something like non-`const` debug instrumentation that isn’t
    part of the invariant and so falls into category A – it isn’t really part of the
    object’s value or meaningful observable state either. In that case, the A parts
    should be treated as A’s (made `public`, or in rarer cases `protected` if they
    should be visible only to derived classes) and the B parts should still be treated
    like B’s (`private` or `const`).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag any class that has non-`const` data members with different access levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.135: Use multiple inheritance to represent multiple distinct interfaces'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not all classes will necessarily support all interfaces, and not all callers
    will necessarily want to deal with all operations. Especially to break apart monolithic
    interfaces into “aspects” of behavior supported by a given derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '`istream` provides the interface to input operations; `ostream` provides the
    interface to output operations. `iostream` provides the union of the `istream`
    and `ostream` interfaces and the synchronization needed to allow both on a single
    stream.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a very common use of inheritance because the need for multiple different
    interfaces to an implementation is common and such interfaces are often not easily
    or naturally organized into a single-rooted hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Such interfaces are typically abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.136: Use multiple inheritance to represent the union of implementation attributes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some forms of mixins have state and often operations on that state. If the operations
    are virtual the use of inheritance is necessary, if not using inheritance can
    avoid boilerplate and forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '`istream` provides the interface to input operations (and some data); `ostream`
    provides the interface to output operations (and some data). `iostream` provides
    the union of the `istream` and `ostream` interfaces and the synchronization needed
    to allow both on a single stream.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a relatively rare use because implementation can often be organized
    into a single-rooted hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes, an “implementation attribute” is more like a “mixin” that determines
    the behavior of an implementation and injects members to enable the implementation
    of the policies it requires. For example, see `std::enable_shared_from_this` or
    various bases from boost.intrusive (e.g. `list_base_hook` or `intrusive_ref_counter`).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.137: Use `virtual` bases to avoid overly general base classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Allow separation of shared data and interface. To avoid all shared data to being
    put into an ultimate base class.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: Factoring out `Utility` makes sense if many derived classes share significant
    “implementation details.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Obviously, the example is too “theoretical”, but it is hard to find a *small*
    realistic example. `Interface` is the root of an [interface hierarchy](#rh-abstract)
    and `Utility` is the root of an [implementation hierarchy](#rh-kind). Here is
    [a slightly more realistic example](https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck)
    with an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Often, linearization of a hierarchy is a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag mixed interface and implementation hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.138: Create an overload set for a derived class and its bases with `using`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Without a using declaration, member functions in the derived class hide the
    entire inherited overload sets.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This issue affects both virtual and non-virtual member functions
  prefs: []
  type: TYPE_NORMAL
- en: For variadic bases, C++17 introduced a variadic form of the using-declaration,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Diagnose name hiding
  prefs: []
  type: TYPE_NORMAL
- en: 'C.139: Use `final` on classes sparingly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Capping a hierarchy with `final` classes is rarely needed for logical reasons
    and can be damaging to the extensibility of a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not every class is meant to be a base class. Most standard-library classes are
    examples of that (e.g., `std::vector` and `std::string` are not designed to be
    derived from). This rule is about using `final` on classes with virtual functions
    meant to be interfaces for a class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Claims of performance improvements from `final` should be substantiated. Too
    often, such claims are based on conjecture or experience with other languages.
  prefs: []
  type: TYPE_NORMAL
- en: There are examples where `final` can be important for both logical and performance
    reasons. One example is a performance-critical AST hierarchy in a compiler or
    language analysis tool. New derived classes are not added every year and only
    by library implementers. However, misuses are (or at least have been) far more
    common.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `final` on classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.140: Do not provide different default arguments for a virtual function and
    an overrider'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'That can cause confusion: An overrider does not inherit default arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag default arguments on virtual functions if they differ between base and
    derived declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.hier-access: Accessing objects in a hierarchy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C.145: Access polymorphic objects through pointers and references'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you have a class with a virtual function, you don’t (in general) know which
    class provided the function to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Both `d`s are sliced.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can safely access a named polymorphic object in the scope of its definition,
    just don’t slice it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[A polymorphic class should suppress copying](#rc-copy-virtual)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`dynamic_cast` is checked at run time.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'Use of the other casts can violate type safety and cause the program to access
    a variable that is actually of type `X` to be accessed as if it were of an unrelated
    type `Z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like other casts, `dynamic_cast` is overused. [Prefer virtual functions to casting](#rh-use-virtual).
    Prefer [static polymorphism](#???) to hierarchy navigation where it is possible
    (no run-time resolution necessary) and reasonably convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some people use `dynamic_cast` where a `typeid` would have been more appropriate;
    `dynamic_cast` is a general “is kind of” operation for discovering the best interface
    to an object, whereas `typeid` is a “give me the exact type of this object” operation
    to discover the actual type of an object. The latter is an inherently simpler
    operation that ought to be faster. The latter (`typeid`) is easily hand-crafted
    if necessary (e.g., if working on a system where RTTI is – for some reason – prohibited),
    the former (`dynamic_cast`) is far harder to implement correctly in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: The result of `pb2->id() == "D"` is actually implementation defined. We added
    it to warn of the dangers of home-brew RTTI. This code might work as expected
    for years, just to fail on a new machine, new compiler, or a new linker that does
    not unify character literals.
  prefs: []
  type: TYPE_NORMAL
- en: If you implement your own RTTI, be careful.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your implementation provided a really slow `dynamic_cast`, you might have
    to use a workaround. However, all workarounds that cannot be statically resolved
    involve explicit casting (typically `static_cast`) and are error-prone. You will
    basically be crafting your own special-purpose `dynamic_cast`. So, first make
    sure that your `dynamic_cast` really is as slow as you think it is (there are
    a fair number of unsupported rumors about) and that your use of `dynamic_cast`
    is really performance critical.
  prefs: []
  type: TYPE_NORMAL
- en: We are of the opinion that current implementations of `dynamic_cast` are unnecessarily
    slow. For example, under suitable conditions, it is possible to perform a `dynamic_cast`
    in [fast constant time](https://www.stroustrup.com/fast_dynamic_casting.pdf).
    However, compatibility makes changes difficult even if all agree that an effort
    to optimize is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: In very rare cases, if you have measured that the `dynamic_cast` overhead is
    material, you have other means to statically guarantee that a downcast will succeed
    (e.g., you are using CRTP carefully), and there is no virtual inheritance involved,
    consider tactically resorting `static_cast` with a prominent comment and disclaimer
    summarizing this paragraph and that human attention is needed under maintenance
    because the type system can’t verify correctness. Even so, in our experience such
    “I know what I’m doing” situations are still a known bug source.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all uses of `static_cast` for downcasts, including C-style casts that perform
    a `static_cast`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule is part of the [type-safety profile](#pro-type-downcast).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.147: Use `dynamic_cast` to a reference type when failure to find the required
    class is considered an error'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Casting to a reference expresses that you intend to end up with a valid object,
    so the cast must succeed. `dynamic_cast` will then throw if it does not succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.148: Use `dynamic_cast` to a pointer type when failure to find the required
    class is considered a valid alternative'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `dynamic_cast` conversion allows to test whether a pointer is pointing at
    a polymorphic object that has a given class in its hierarchy. Since failure to
    find the class merely returns a null value, it can be tested during run time.
    This allows writing code that can choose alternative paths depending on the results.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast with [C.147](#rh-ref-cast), where failure is an error, and should not
    be used for conditional execution.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The example below describes the `add` function of a `Shape_owner` that takes
    ownership of constructed `Shape` objects. The objects are also sorted into views,
    according to their geometric attributes. In this example, `Shape` does not inherit
    from `Geometric_attributes`. Only its subclasses do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A failure to find the required class will cause `dynamic_cast` to return a null
    value, and de-referencing a null-valued pointer will lead to undefined behavior.
    Therefore the result of the `dynamic_cast` should always be treated as if it might
    contain a null value, and tested.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Complex) Unless there is a null test on the result of a `dynamic_cast` of a
    pointer type, warn upon dereference of the pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects
    created using `new`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid resource leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag initialization of a naked pointer with the result of a `new`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag `delete` of local variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [R.23](#rr-make_unique)
  prefs: []
  type: TYPE_NORMAL
- en: 'C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [R.22](#rr-make_shared)
  prefs: []
  type: TYPE_NORMAL
- en: 'C.152: Never assign a pointer to an array of derived class objects to a pointer
    to its base'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Subscripting the resulting base pointer will lead to invalid object access and
    probably to memory corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all combinations of array decay and base to derived conversions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass an array as a `span` rather than as a pointer, and don’t let the array
    name suffer a derived-to-base conversion before getting into the `span`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.153: Prefer virtual function to casting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A virtual function call is safe, whereas casting is error-prone. A virtual function
    call reaches the most derived function, whereas a cast might reach an intermediate
    class and therefore give a wrong result (especially as a hierarchy is modified
    during maintenance).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See [C.146](#rh-dynamic_cast) and ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.over: Overloading and overloaded operators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can overload ordinary functions, function templates, and operators. You
    cannot overload function objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overload rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.160: Define operators primarily to mimic conventional usage](#ro-conventional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.161: Use non-member functions for symmetric operators](#ro-symmetric)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.162: Overload operations that are roughly equivalent](#ro-equivalent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.163: Overload only for operations that are roughly equivalent](#ro-equivalent-2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.164: Avoid implicit conversion operators](#ro-conversion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.165: Use `using` for customization points](#ro-custom)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.166: Overload unary `&` only as part of a system of smart pointers and references](#ro-address-of)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.167: Use an operator for an operation with its conventional meaning](#ro-overload)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.168: Define overloaded operators in the namespace of their operands](#ro-namespace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.170: If you feel like overloading a lambda, use a generic lambda](#ro-lambda)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.160: Define operators primarily to mimic conventional usage'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Minimize surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the conventional semantics is maintained: [Copies compare equal](#ss-copy).'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Non-member operators should be either friends or defined in [the same namespace
    as their operands](#ro-namespace). [Binary operators should treat their operands
    equivalently](#ro-symmetric).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Possibly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.161: Use non-member functions for symmetric operators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you use member functions, you need two. Unless you use a non-member function
    for (say) `==`, `a == b` and `b == a` will be subtly different.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag member operator functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.162: Overload operations that are roughly equivalent'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having different names for logically equivalent operations on different argument
    types is confusing, leads to encoding type information in function names, and
    inhibits generic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'These three functions all print their arguments (appropriately). Conversely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: These three functions all print their arguments (appropriately). Adding to the
    name just introduced verbosity and inhibits generic code.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.163: Overload only for operations that are roughly equivalent'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having the same name for logically different functions is confusing and leads
    to errors when using generic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'The two operations are fundamentally different (and unrelated) so it is good
    that their names differ. Conversely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: The two operations are still fundamentally different (and unrelated) but the
    names have been reduced to their (common) minimum, opening opportunities for confusion.
    Fortunately, the type system will catch many such mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Be particularly careful about common and popular names, such as `open`, `move`,
    `+`, and `==`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.164: Avoid implicit conversion operators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Implicit conversions can be essential (e.g., `double` to `int`) but often cause
    surprises (e.g., `String` to C-style string).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prefer explicitly named conversions until a serious need is demonstrated. By
    “serious need” we mean a reason that is fundamental in the application domain
    (such as an integer to complex number conversion) and frequently needed. Do not
    introduce implicit conversions (through conversion operators or non-`explicit`
    constructors) just to gain a minor convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: The surprising and potentially damaging implicit conversion can occur in arbitrarily
    hard-to spot contexts, e.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: The string returned by `ff()` is destroyed before the returned pointer into
    it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all non-explicit conversion operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.165: Use `using` for customization points'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To find function objects and functions defined in a separate namespace to “customize”
    a common function.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider `swap`. It is a general (standard-library) function with a definition
    that will work for just about any type. However, it is desirable to define specific
    `swap()`s for specific types. For example, the general `swap()` will copy the
    elements of two `vector`s being swapped, whereas a good specific implementation
    will not copy elements at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::swap()` in `f1()` does exactly what we asked it to do: it calls the
    `swap()` in namespace `std`. Unfortunately, that’s probably not what we wanted.
    How do we get `N::X` considered?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'But that might not be what we wanted for generic code. There, we typically
    want the specific function if it exists and the general function if not. This
    is done by including the general function in the lookup for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unlikely, except for known customization points, such as `swap`. The problem
    is that the unqualified and qualified lookups both have uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.166: Overload unary `&` only as part of a system of smart pointers and references'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `&` operator is fundamental in C++. Many parts of the C++ semantics assume
    its default meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you “mess with” operator `&` be sure that its definition has matching meanings
    for `->`, `[]`, `*`, and `.` on the result type. Note that operator `.` currently
    cannot be overloaded so a perfect system is impossible. We hope to remedy that:
    [Operator Dot (R2)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf).
    Note that `std::addressof()` always yields a built-in pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Tricky. Warn if `&` is user-defined without also defining `->` for the result
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.167: Use an operator for an operation with its conventional meaning'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Convention. Reusability. Support for generic code
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'By itself, `cout_my_class` would be OK, but it is not usable/composable with
    code that relies on the `<<` convention for output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are strong and vigorous conventions for the meaning of most operators,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: comparisons (`==`, `!=`, `<`, `<=`, `>`, `>=`, and `<=>`),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: arithmetic operations (`+`, `-`, `*`, `/`, and `%`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: access operations (`.`, `->`, unary `*`, and `[]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: assignment (`=`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t define those unconventionally and don’t invent your own names for them.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Tricky. Requires semantic insight.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.168: Define overloaded operators in the namespace of their operands'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Ability for find operators using ADL. Avoiding inconsistent definition
    in different namespaces
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Here, the meaning of `!s` differs in `N` and `M`. This can be most confusing.
    Remove the definition of `namespace M` and the confusion is replaced by an opportunity
    to make the mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a binary operator is defined for two types that are defined in different
    namespaces, you cannot follow this rule. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: This might be something best avoided.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a special case of the rule that [helper functions should be defined
    in the same namespace as their class](#rc-helper).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag operator definitions that are not in the namespace of their operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.170: If you feel like overloading a lambda, use a generic lambda'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You cannot overload by defining two different lambdas with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler catches the attempt to overload a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'C.union: Unions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `union` is a `struct` where all members start at the same address so that
    it can hold only one member at a time. A `union` does not keep track of which
    member is stored so the programmer has to get it right; this is inherently error-prone,
    but there are ways to compensate.
  prefs: []
  type: TYPE_NORMAL
- en: A type that is a `union` plus an indicator of which member is currently held
    is called a *tagged union*, a *discriminated union*, or a *variant*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Union rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[C.180: Use `union`s to save Memory](#ru-union)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.181: Avoid “naked” `union`s](#ru-naked)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.182: Use anonymous `union`s to implement tagged unions](#ru-anonymous)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C.183: Don’t use a `union` for type punning](#ru-pun)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C.180: Use `union`s to save memory'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `union` allows a single piece of memory to be used for different types of
    objects at different times. Consequently, it can be used to save memory when we
    have several objects that are never used at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'But heed the warning: [Avoid “naked” `union`s](#ru-naked)'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.181: Avoid “naked” `union`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *naked union* is a union without an associated indicator which member (if
    any) it holds, so that the programmer has to keep track. Naked unions are a source
    of type errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good, but we can easily misuse the `union`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Note that the type error happened without any explicit cast. When we tested
    that program the last value printed was `1683627180` which is the integer value
    for the bit pattern for `987.654`. What we have here is an “invisible” type error
    that happens to give a result that could easily look innocent.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, talking about “invisible”, this code produced no output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Wrap a `union` in a class together with a type field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++17 `variant` type (found in `<variant>`) does that for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.182: Use anonymous `union`s to implement tagged unions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A well-designed tagged union is type safe. An *anonymous* union simplifies the
    definition of a class with a (tag, union) pair.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This example is mostly borrowed from TC++PL4, pp. 216–218. You can look there
    for an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The code is somewhat elaborate. Handling a type with user-defined assignment
    and destructor is tricky. Saving programmers from having to write such code is
    one reason for including `variant` in the standard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C.183: Don’t use a `union` for type punning'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is undefined behavior to read a `union` member with a different type from
    the one with which it was written. Such punning is invisible, or at least harder
    to spot than using a named cast. Type punning using a `union` is a source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: The idea of `Pun` is to be able to look at the character representation of an
    `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to see the bytes of an `int`, use a (named) cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the result of a `reinterpret_cast` from the object’s declared type
    to `char*`, `unsigned char*`, or `std::byte*` is defined behavior. (Using `reinterpret_cast`
    is discouraged, but at least we can see that something tricky is going on.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unfortunately, `union`s are commonly used for type punning. We don’t consider
    “sometimes, it works as expected” a conclusive argument.
  prefs: []
  type: TYPE_NORMAL
- en: Modern C++ introduced `std::byte` (C++17) and `std::bit_cast` (C++20) to facilitate
    operations on raw object representations. Use `reinterpret_cast` along with `std::byte`
    instead of `unsigned char` or `char` for these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum: Enumerations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerations are used to define sets of integer values and for defining types
    for such sets of values. There are two kinds of enumerations, “plain” `enum`s
    and `class enum`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumeration rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Enum.1: Prefer enumerations over macros](#renum-macro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum.2: Use enumerations to represent sets of related named constants](#renum-set)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum.3: Prefer `enum class`es over “plain” `enum`s](#renum-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum.4: Define operations on enumerations for safe and simple use](#renum-oper)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum.5: Don’t use `ALL_CAPS` for enumerators](#renum-caps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum.6: Avoid unnamed enumerations](#renum-unnamed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum.7: Specify the underlying type of an enumeration only when necessary](#renum-underlying)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum.8: Specify enumerator values only when necessary](#renum-value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enum.1: Prefer enumerations over macros'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Macros do not obey scope and type rules. Also, macro names are removed during
    preprocessing and so usually don’t appear in tools like debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First some bad old code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead use an `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: We used an `enum class` to avoid name clashes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Also consider `constexpr` and `const inline` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag macros that define integer values. Use `enum` or `const inline` or another
    non-macro alternative instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum.2: Use enumerations to represent sets of related named constants'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An enumeration shows the enumerators to be related and can be a named type.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Switching on an enumeration is common and the compiler can warn against unusual
    patterns of case labels. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: Such off-by-one `switch`-statements are often the results of an added enumerator
    and insufficient testing.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `switch`-statements where the `case`s cover most but not all enumerators
    of an enumeration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag `switch`-statements where the `case`s cover a few enumerators of an enumeration,
    but there is no `default`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enum.3: Prefer class enums over “plain” enums'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To minimize surprises: traditional enums convert to int too readily.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead use an `enum class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn on any non-class `enum` definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum.4: Define operations on enumerations for safe and simple use'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Convenience of use and avoidance of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: The use of a `static_cast` is not pretty, but
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: is an infinite recursion, and writing it without a cast, using a `switch` on
    all cases is long-winded.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag repeated expressions cast back into an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum.5: Don’t use `ALL_CAPS` for enumerators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid clashes with macros.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag ALL_CAPS enumerators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum.6: Avoid unnamed enumerations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you can’t name an enumeration, the values are not related
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Such code is not uncommon in code written before there were convenient alternative
    ways of specifying integer constants.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Use `constexpr` values instead. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag unnamed enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum.7: Specify the underlying type of an enumeration only when necessary'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The default is the easiest to read and write. `int` is the default integer type.
    `int` is compatible with C `enum`s.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Specifying the underlying type is necessary to forward-declare an enum or enum
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'or to ensure that values of that type have a specified bit-precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ????
  prefs: []
  type: TYPE_NORMAL
- en: 'Enum.8: Specify enumerator values only when necessary'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s the simplest. It avoids duplicate enumerator values. The default gives
    a consecutive set of values that is good for `switch`-statement implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Specifying values is necessary to match conventional values (e.g., `Month`)
    and where consecutive values are undesirable (e.g., to get separate bits as in
    `Base_flag`).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag duplicate enumerator values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag explicitly specified all-consecutive enumerator values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R: Resource management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section contains rules related to resources. A resource is anything that
    must be acquired and (explicitly or implicitly) released, such as memory, file
    handles, sockets, and locks. The reason it must be released is typically that
    it can be in short supply, so even delayed release might do harm. The fundamental
    aim is to ensure that we don’t leak any resources and that we don’t hold a resource
    longer than we need to. An entity that is responsible for releasing a resource
    is called an owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few cases where leaks can be acceptable or even optimal: If you
    are writing a program that simply produces an output based on an input and the
    amount of memory needed is proportional to the size of the input, the optimal
    strategy (for performance and ease of programming) is sometimes simply never to
    delete anything. If you have enough memory to handle your largest input, leak
    away, but be sure to give a good error message if you are wrong. Here, we ignore
    such cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource management rule summary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.1: Manage resources automatically using resource handles and RAII (Resource
    Acquisition Is Initialization)](#rr-raii)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.2: In interfaces, use raw pointers to denote individual objects (only)](#rr-use-ptr)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.3: A raw pointer (a `T*`) is non-owning](#rr-ptr)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.4: A raw reference (a `T&`) is non-owning](#rr-ref)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.5: Prefer scoped objects, don’t heap-allocate unnecessarily](#rr-scoped)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.6: Avoid non-`const` global variables](#rr-global)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allocation and deallocation rule summary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.10: Avoid `malloc()` and `free()`](#rr-mallocfree)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.11: Avoid calling `new` and `delete` explicitly](#rr-newdelete)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.12: Immediately give the result of an explicit resource allocation to a
    manager object](#rr-immediate-alloc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.13: Perform at most one explicit resource allocation in a single expression
    statement](#rr-single-alloc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.14: Avoid `[]` parameters, prefer `span`](#rr-ap)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.15: Always overload matched allocation/deallocation pairs](#rr-pair)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smart pointer rule summary:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.20: Use `unique_ptr` or `shared_ptr` to represent ownership](#rr-owner)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership](#rr-unique)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.22: Use `make_shared()` to make `shared_ptr`s](#rr-make_shared)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.23: Use `make_unique()` to make `unique_ptr`s](#rr-make_unique)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s](#rr-weak_ptr)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.30: Take smart pointers as parameters only to explicitly express lifetime
    semantics](#rr-smartptrparam)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.31: If you have non-`std` smart pointers, follow the basic pattern from
    `std`](#rr-smart)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes
    ownership of a `widget`](#rr-uniqueptrparam)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats
    the `widget`](#rr-reseat)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.34: Take a `shared_ptr<widget>` parameter to express shared ownership](#rr-sharedptrparam-owner)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.35: Take a `shared_ptr<widget>&` parameter to express that a function might
    reseat the shared pointer](#rr-sharedptrparam)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.36: Take a `const shared_ptr<widget>&` parameter to express that it might
    retain a reference count to the object ???](#rr-sharedptrparam-const)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[R.37: Do not pass a pointer or reference obtained from an aliased smart pointer](#rr-smartptrget)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.1: Manage resources automatically using resource handles and RAII (Resource
    Acquisition Is Initialization)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid leaks and the complexity of manual resource management. C++’s language-enforced
    constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release
    function pairs such as `fopen`/`fclose`, `lock`/`unlock`, and `new`/`delete`.
    Whenever you deal with a resource that needs paired acquire/release function calls,
    encapsulate that resource in an object that enforces pairing for you – acquire
    the resource in its constructor, and release it in its destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: In this code, you have to remember to `unlock`, `close_port`, and `delete` on
    all paths, and do each exactly once. Further, if any of the code marked `...`
    throws an exception, then `x` is leaked and `my_mutex` remains locked.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: Now all resource cleanup is automatic, performed once on all paths whether or
    not there is an exception. As a bonus, the function now advertises that it takes
    over ownership of the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is `Port`? A handy wrapper that encapsulates the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Where a resource is “ill-behaved” in that it isn’t represented as a class with
    a destructor, wrap it in a class or use [`finally`](#re-finally)
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [RAII](#re-raii)'
  prefs: []
  type: TYPE_NORMAL
- en: 'R.2: In interfaces, use raw pointers to denote individual objects (only)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Arrays are best represented by a container type (e.g., `vector` (owning)) or
    a `span` (non-owning). Such containers and views hold sufficient information to
    do range checking.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: The compiler does not read comments, and without reading other code you do not
    know whether `p` really points to `n` elements. Use a `span` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C-style strings are passed as single pointers to a zero-terminated sequence
    of characters. Use `zstring` rather than `char*` to indicate that you rely on
    that convention.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many current uses of pointers to a single element could be references. However,
    where `nullptr` is a possible value, a reference might not be a reasonable alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag pointer arithmetic (including `++`) on a pointer that is not part of a
    container, view, or iterator. This rule would generate a huge number of false
    positives if applied to an older code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag array names passed as simple pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.3: A raw pointer (a `T*`) is non-owning'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is nothing (in the C++ standard or in most code) to say otherwise and
    most raw pointers are non-owning. We want owning pointers identified so that we
    can reliably and efficiently delete the objects pointed to by owning pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: The `unique_ptr` protects against leaks by guaranteeing the deletion of its
    object (even in the presence of exceptions). The `T*` does not.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix that problem by making ownership explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A major class of exception is legacy code, especially code that must remain
    compilable as C or interface with C and C-style C++ through ABIs. The fact that
    there are billions of lines of code that violate this rule against owning `T*`s
    cannot be ignored. We’d love to see program transformation tools turning 20-year-old
    “legacy” code into shiny modern code, we encourage the development, deployment
    and use of such tools, we hope the guidelines will help the development of such
    tools, and we even contributed (and contribute) to the research and development
    in this area. However, it will take time: “legacy code” is generated faster than
    we can renovate old code, and so it will be for a few years.'
  prefs: []
  type: TYPE_NORMAL
- en: This code cannot all be rewritten (even assuming good code transformation software),
    especially not soon. This problem cannot be solved (at scale) by transforming
    all owning pointers to `unique_ptr`s and `shared_ptr`s, partly because we need/use
    owning “raw pointers” as well as simple pointers in the implementation of our
    fundamental resource handles. For example, common `vector` implementations have
    one owning pointer and two non-owning pointers. Many ABIs (and essentially all
    interfaces to C code) use `T*`s, some of them owning. Some interfaces cannot be
    simply annotated with `owner` because they need to remain compilable as C (although
    this would be a rare good use for a macro, that expands to `owner` in C++ mode
    only).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`owner<T*>` has no default semantics beyond `T*`. It can be used without changing
    any code using it and without affecting ABIs. It is simply an indicator to programmers
    and analysis tools. For example, if an `owner<T*>` is a member of a class, that
    class better have a destructor that `delete`s it.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Returning a (raw) pointer imposes a lifetime management uncertainty on the caller;
    that is, who deletes the pointed-to object?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to suffering from the problem of [leak](#rp-leak), this adds a
    spurious allocation and deallocation operation, and is needlessly verbose. If
    Gadget is cheap to move out of a function (i.e., is small or has an efficient
    move operation), just return it “by value” (see [“out” return values](#rf-out)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule applies to factory functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If pointer semantics are required (e.g., because the return type needs to refer
    to a base class of a class hierarchy (an interface)), return a “smart pointer.”
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Moderate) Warn on failure to either `reset` or explicitly `delete` an `owner<T>`
    pointer on every code path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Warn if the return value of `new` is assigned to a raw pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Warn if a function returns an object that was allocated within the
    function but has a move constructor. Suggest considering returning it by value
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.4: A raw reference (a `T&`) is non-owning'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is nothing (in the C++ standard or in most code) to say otherwise and
    most raw references are non-owning. We want owners identified so that we can reliably
    and efficiently delete the objects pointed to by owning pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: [The raw pointer rule](#rr-ptr)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See [the raw pointer rule](#rr-ptr)
  prefs: []
  type: TYPE_NORMAL
- en: 'R.5: Prefer scoped objects, don’t heap-allocate unnecessarily'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A scoped object is a local object, a global object, or a member. This implies
    that there is no separate allocation and deallocation cost in excess of that already
    used for the containing scope or object. The members of a scoped object are themselves
    scoped and the scoped object’s constructor and destructor manage the members’
    lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following example is inefficient (because it has unnecessary allocation
    and deallocation), vulnerable to exception throws and returns in the `...` part
    (leading to leaks), and verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Moderate) Warn if an object is allocated and then deallocated on all paths
    within a function. Suggest it should be a local stack object instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Simple) Warn if a local `Unique_pointer` or `Shared_pointer` that is not moved,
    copied, reassigned or `reset` before its lifetime ends is not declared `const`.
    Exception: Do not produce such a warning on a local `Unique_pointer` to an unbounded
    array. (See below.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your stack space is limited, it is OK to create a local `const unique_ptr<BigObject>`
    to store the object on the heap instead of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.6: Avoid non-`const` global variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [I.2](#ri-global)
  prefs: []
  type: TYPE_NORMAL
- en: 'R.alloc: Allocation and deallocation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'R.10: Avoid `malloc()` and `free()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`malloc()` and `free()` do not support construction and destruction, and do
    not mix well with `new` and `delete`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: In some implementations that `delete` and that `free()` might work, or maybe
    they will cause run-time errors.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are applications and sections of code where exceptions are not acceptable.
    Some of the best such examples are in life-critical hard-real-time code. Beware
    that many bans on exception use are based on superstition (bad) or by concerns
    for older code bases with unsystematic resource management (unfortunately, but
    sometimes necessary). In such cases, consider the `nothrow` versions of `new`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag explicit use of `malloc` and `free`.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.11: Avoid calling `new` and `delete` explicitly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The pointer returned by `new` should belong to a resource handle (that can call
    `delete`). If the pointer returned by `new` is assigned to a plain/naked pointer,
    the object can be leaked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In a large program, a naked `delete` (that is a `delete` in application code,
    rather than part of code devoted to resource management) is a likely bug: if you
    have N `delete`s, how can you be certain that you don’t need N+1 or N-1? The bug
    might be latent: it might emerge only during maintenance. If you have a naked
    `new`, you probably need a naked `delete` somewhere, so you probably have a bug.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn on any explicit use of `new` and `delete`. Suggest using `make_unique`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.12: Immediately give the result of an explicit resource allocation to a manager
    object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you don’t, an exception or a return might lead to a leak.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: The allocation of `buf` might fail and leak the file handle.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: The use of the file handle (in `ifstream`) is simple, efficient, and safe.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag explicit allocations used to initialize pointers (problem: how many direct
    resource allocations can we recognize?)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.13: Perform at most one explicit resource allocation in a single expression
    statement'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you perform two explicit resource allocations in one statement, you could
    leak resources because the order of evaluation of many subexpressions, including
    function arguments, is unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'This `fun` can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exception-unsafe because the compiler might reorder the two expressions
    building the function’s two arguments. In particular, the compiler can interleave
    execution of the two expressions: Memory allocation (by calling `operator new`)
    could be done first for both objects, followed by attempts to call the two `Widget`
    constructors. If one of the constructor calls throws an exception, then the other
    object’s memory will never be released!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This subtle problem has a simple solution: Never perform more than one explicit
    resource allocation in a single expression statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'The best solution is to avoid explicit allocation entirely, use factory functions
    that return owning objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Write your own factory wrapper if there is not one already.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag expressions with multiple explicit resource allocations (problem: how
    many direct resource allocations can we recognize?)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.14: Avoid `[]` parameters, prefer `span`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An array decays to a pointer, thereby losing its size, opening the opportunity
    for range errors. Use `span` to preserve size information.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `[]` parameters. Use `span` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.15: Always overload matched allocation/deallocation pairs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Otherwise you get mismatched operations and chaos.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you want memory that cannot be deallocated, `=delete` the deallocation operation.
    Don’t leave it undeclared.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag incomplete pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.smart: Smart pointers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'R.20: Use `unique_ptr` or `shared_ptr` to represent ownership'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: They can prevent resource leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: This will leak the object used to initialize `p1` (only).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if the return value of `new` is assigned to a raw pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) Warn if the result of a function returning a raw owning pointer is
    assigned to a raw pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `unique_ptr` is conceptually simpler and more predictable (you know when destruction
    happens) and faster (you don’t implicitly maintain a use count).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This needlessly adds and maintains a reference count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a function uses a `Shared_pointer` with an object allocated
    within the function, but never returns the `Shared_pointer` or passes it to a
    function requiring a `Shared_pointer`. Suggest using `unique_ptr` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.22: Use `make_shared()` to make `shared_ptr`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`make_shared` gives a more concise statement of the construction. It also gives
    an opportunity to eliminate a separate allocation for the reference counts, by
    placing the `shared_ptr`’s use counts next to its object. It also ensures exception
    safety in complex expressions (in pre-C++17 code).'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: The `make_shared()` version mentions `X` only once, so it is usually shorter
    (as well as faster) than the version with the explicit `new`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a `shared_ptr` is constructed from the result of `new` rather
    than `make_shared`.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.23: Use `make_unique()` to make `unique_ptr`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`make_unique` gives a more concise statement of the construction. It also ensures
    exception safety in complex expressions (in pre-C++17 code).'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a `unique_ptr` is constructed from the result of `new` rather
    than `make_unique`.
  prefs: []
  type: TYPE_NORMAL
- en: 'R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`shared_ptr`s rely on use counting and the use count for a cyclic structure
    never goes to zero, so we need a mechanism to be able to destroy a cyclic structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '??? (HS: A lot of people say “to break cycles”, while I think “temporary shared
    ownership” is more to the point.) ???(BS: breaking cycles is what you must do;
    temporarily sharing ownership is how you do it. You could “temporarily share ownership”
    simply by using another `shared_ptr`.)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? probably impossible. If we could statically detect cycles, we wouldn’t need
    `weak_ptr`
  prefs: []
  type: TYPE_NORMAL
- en: 'R.30: Take smart pointers as parameters only to explicitly express lifetime
    semantics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [F.7](#rf-smart).
  prefs: []
  type: TYPE_NORMAL
- en: 'R.31: If you have non-`std` smart pointers, follow the basic pattern from `std`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The rules in the following section also work for other kinds of third-party
    and custom smart pointers and are very useful for diagnosing common smart pointer
    errors that cause performance and correctness problems. You want the rules to
    work on all the smart pointers you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any type (including primary template or specialization) that overloads unary
    `*` and `->` is considered a smart pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: If it is copyable, it is recognized as a reference-counted `shared_ptr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is not copyable, it is recognized as a unique `unique_ptr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: 'Both cases are an error under the [`sharedptrparam` guideline](#rr-smartptrparam):
    `p` is a `Shared_pointer`, but nothing about its sharedness is used here and passing
    it by value is a silent pessimization; these functions should accept a smart pointer
    only if they need to participate in the widget’s lifetime management. Otherwise
    they should accept a `widget*`, if it can be `nullptr`. Otherwise, and ideally,
    the function should accept a `widget&`. These smart pointers match the `Shared_pointer`
    concept, so these guideline enforcement rules work on them out of the box and
    expose this common pessimization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes
    ownership of a `widget`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using `unique_ptr` in this way both documents and enforces the function call’s
    ownership transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a function takes a `Unique_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats
    the `widget`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using `unique_ptr` in this way both documents and enforces the function call’s
    reseating semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: “reseat” means “making a pointer or a smart pointer refer to a different object.”
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a function takes a `Unique_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.34: Take a `shared_ptr<widget>` parameter to express shared ownership'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This makes the function’s ownership sharing explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value
    or by reference to `const` and does not copy or move it to another `Shared_pointer`
    on at least one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue
    reference. Suggesting taking it by value instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.35: Take a `shared_ptr<widget>&` parameter to express that a function might
    reseat the shared pointer'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This makes the function’s reseating explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: “reseat” means “making a reference or a smart pointer refer to a different object.”
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value
    or by reference to `const` and does not copy or move it to another `Shared_pointer`
    on at least one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue
    reference. Suggesting taking it by value instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.36: Take a `const shared_ptr<widget>&` parameter to express that it might
    retain a reference count to the object ???'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This makes the function’s ??? explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value
    or by reference to `const` and does not copy or move it to another `Shared_pointer`
    on at least one code path. Suggest taking a `T*` or `T&` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue
    reference. Suggesting taking it by value instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'R.37: Do not pass a pointer or reference obtained from an aliased smart pointer'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Violating this rule is the number one cause of losing reference counts and finding
    yourself with a dangling pointer. Functions should prefer to pass raw pointers
    and references down call chains. At the top of the call tree where you obtain
    the raw pointer or reference from a smart pointer that keeps the object alive.
    You need to be sure that the smart pointer cannot inadvertently be reset or reassigned
    from within the call tree below.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To do this, sometimes you need to take a local copy of a smart pointer, which
    firmly keeps the object alive for the duration of the function and the call tree.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'The following should not pass code review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is simple – take a local copy of the pointer to “keep a ref count”
    for your call tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: (Simple) Warn if a pointer or reference obtained from a smart pointer variable
    (`Unique_pointer` or `Shared_pointer`) that is non-local, or that is local but
    potentially aliased, is used in a function call. If the smart pointer is a `Shared_pointer`
    then suggest taking a local copy of the smart pointer and obtain a pointer or
    reference from that instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES: Expressions and statements'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions and statements are the lowest and most direct way of expressing
    actions and computation. Declarations in local scopes are statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For naming, commenting, and indentation rules, see [NL: Naming and layout](#s-naming).'
  prefs: []
  type: TYPE_NORMAL
- en: 'General rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ES.1: Prefer the standard library to other libraries and to “handcrafted code”](#res-lib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.2: Prefer suitable abstractions to direct use of language features](#res-abstr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.3: Don’t repeat yourself, avoid redundant code](#res-dry)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declaration rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ES.5: Keep scopes small](#res-scope)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.6: Declare names in for-statement initializers and conditions to limit
    scope](#res-cond)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.7: Keep common and local names short, and keep uncommon and non-local names
    longer](#res-name-length)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.8: Avoid similar-looking names](#res-name-similar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.9: Avoid `ALL_CAPS` names](#res-not-caps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.10: Declare one name (only) per declaration](#res-name-one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.11: Use `auto` to avoid redundant repetition of type names](#res-auto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.12: Do not reuse names in nested scopes](#res-reuse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.20: Always initialize an object](#res-always)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.21: Don’t introduce a variable (or constant) before you need to use it](#res-introduce)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.22: Don’t declare a variable until you have a value to initialize it with](#res-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.23: Prefer the `{}`-initializer syntax](#res-list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.24: Use a `unique_ptr<T>` to hold pointers](#res-unique)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.25: Declare an object `const` or `constexpr` unless you want to modify
    its value later on](#res-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.26: Don’t use a variable for two unrelated purposes](#res-recycle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.27: Use `std::array` or `stack_array` for arrays on the stack](#res-stack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.28: Use lambdas for complex initialization, especially of `const` variables](#res-lambda-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.30: Don’t use macros for program text manipulation](#res-macros)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.31: Don’t use macros for constants or “functions”](#res-macros2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.32: Use `ALL_CAPS` for all macro names](#res-all_caps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.33: If you must use macros, give them unique names](#res-macros3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.34: Don’t define a (C-style) variadic function](#res-ellipses)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expression rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ES.40: Avoid complicated expressions](#res-complicated)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.41: If in doubt about operator precedence, parenthesize](#res-parens)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.42: Keep use of pointers simple and straightforward](#res-ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.43: Avoid expressions with undefined order of evaluation](#res-order)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.44: Don’t depend on order of evaluation of function arguments](#res-order-fct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.45: Avoid “magic constants”; use symbolic constants](#res-magic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.46: Avoid narrowing conversions](#res-narrowing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.47: Use `nullptr` rather than `0` or `NULL`](#res-nullptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.48: Avoid casts](#res-casts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.49: If you must use a cast, use a named cast](#res-casts-named)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.50: Don’t cast away `const`](#res-casts-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.55: Avoid the need for range checking](#res-range-checking)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.56: Write `std::move()` only when you need to explicitly move an object
    to another scope](#res-move)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.60: Avoid `new` and `delete` outside resource management functions](#res-new)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.61: Delete arrays using `delete[]` and non-arrays using `delete`](#res-del)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.62: Don’t compare pointers into different arrays](#res-arr2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.63: Don’t slice](#res-slice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.64: Use the `T{e}`notation for construction](#res-construct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.65: Don’t dereference an invalid pointer](#res-deref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Statement rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice](#res-switch-if)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a
    choice](#res-for-range)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious
    loop variable](#res-for-while)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious
    loop variable](#res-while-for)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement](#res-for-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.75: Avoid `do`-statements](#res-do)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.76: Avoid `goto`](#res-goto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.77: Minimize the use of `break` and `continue` in loops](#res-continue)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.78: Don’t rely on implicit fallthrough in `switch` statements](#res-break)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.79: Use `default` to handle common cases (only)](#res-default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.84: Don’t try to declare a local variable with no name](#res-noname)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.85: Make empty statements visible](#res-empty)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.86: Avoid modifying loop control variables inside the body of raw for-loops](#res-loop-counter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.87: Don’t add redundant `==` or `!=` to conditions](#res-if)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arithmetic rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ES.100: Don’t mix signed and unsigned arithmetic](#res-mix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.101: Use unsigned types for bit manipulation](#res-unsigned)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.102: Use signed types for arithmetic](#res-signed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.103: Don’t overflow](#res-overflow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.104: Don’t underflow](#res-underflow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.105: Don’t divide by integer zero](#res-zero)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.106: Don’t try to avoid negative values by using `unsigned`](#res-nonnegative)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.107: Don’t use `unsigned` for subscripts, prefer `gsl::index`](#res-subscripts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.1: Prefer the standard library to other libraries and to “handcrafted code”'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Code using a library can be much easier to write than code working directly
    with language features, much shorter, tend to be of a higher level of abstraction,
    and the library code is presumably already tested. The ISO C++ Standard Library
    is among the most widely known and best tested libraries. It is available as part
    of all C++ implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: 'a range version of `accumulate` would be even better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'but don’t hand-code a well-known algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Large parts of the standard library rely on dynamic allocation (free store).
    These parts, notably the containers but not the algorithms, are unsuitable for
    some hard-real-time and embedded applications. In such cases, consider providing/using
    similar facilities, e.g., a standard-library-style container implemented using
    a pool allocator.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not easy. ??? Look for messy loops, nested loops, long functions, absence of
    function calls, lack of use of built-in types. Cyclomatic complexity?
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.2: Prefer suitable abstractions to direct use of language features'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A “suitable abstraction” (e.g., library or class) is closer to the application
    concepts than the bare language, leads to shorter and clearer code, and is likely
    to be better tested.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'The more traditional and lower-level near-equivalent is longer, messier, harder
    to get right, and most likely slower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: Once the checking for overflow and error handling has been added that code gets
    quite messy, and there is the problem remembering to `delete` the returned pointer
    and the C-style strings that array contains.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not easy. ??? Look for messy loops, nested loops, long functions, absence of
    function calls, lack of use of built-in types. Cyclomatic complexity?
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.3: Don’t repeat yourself, avoid redundant code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Duplicated or otherwise redundant code obscures intent, makes it harder to understand
    the logic, and makes maintenance harder, among other problems. It often arises
    from cut-and-paste programming.
  prefs: []
  type: TYPE_NORMAL
- en: Use standard algorithms where appropriate, instead of writing some own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [SL.1](#rsl-lib), [ES.11](#res-auto)'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use a static analyzer. It will catch at least some redundant constructs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.dcl: Declarations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A declaration is a statement. A declaration introduces a name into a scope and
    might cause the construction of a named object.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.5: Keep scopes small'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Minimize resource retention. Avoid accidental misuse of value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative formulation**: Don’t declare a name in an unnecessarily large
    scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is by most measures too long anyway, but the point is that the
    resources used by `fn` and the file handle held by `is` are retained for much
    longer than needed and that unanticipated use of `is` and `fn` could happen later
    in the function. In this case, it might be a good idea to factor out the read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag loop variable declared outside a loop and not used after the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag when expensive resources, such as file handles and locks are not used for
    N-lines (for some suitable N)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.6: Declare names in for-statement initializers and conditions to limit scope'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Limit the loop variable visibility to the scope of the loop. Avoid
    using the loop variable for other purposes after the loop. Minimize resource retention.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: Example, don’t
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: [Don’t use a variable for two unrelated purposes](#res-recycle)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Warn when a variable modified inside the `for`-statement is declared outside
    the loop and not being used outside the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (hard) Flag loop variables declared before the loop and used after the loop
    for an unrelated purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discussion**: Scoping the loop variable to the loop body also helps code
    optimizers greatly. Recognizing that the induction variable is only accessible
    in the loop body unblocks optimizations such as hoisting, strength reduction,
    loop-invariant code motion, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: C++17 and C++20 example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Note: C++17 and C++20 also add `if`, `switch`, and range-`for` initializer
    statements. These require C++17 and C++20 support.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: C++17 and C++20 enforcement (if using a C++17 or C++20 compiler)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag selection/loop variables declared before the body and not used after the
    body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (hard) Flag selection/loop variables declared before the body and used after
    the body for an unrelated purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.7: Keep common and local names short, and keep uncommon and non-local names
    longer'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Lowering the chance of clashes between unrelated non-local names.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Conventional short, local names increase readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: An index is conventionally called `i` and there is no hint about the meaning
    of the vector in this generic function, so `v` is as good a name as any. Compare
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it is a caricature, but we have seen worse.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unconventional and short non-local names obscure code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'Better, give non-local entities readable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: Here, there is a chance that the reader knows what `trim_tail` means and that
    the reader can remember it after looking it up.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Argument names of large functions are de facto non-local and should be meaningful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: We recommend keeping functions short, but that rule isn’t universally adhered
    to and naming should reflect that.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Check length of local and non-local names. Also take function length into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.8: Avoid similar-looking names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Code clarity and readability. Too-similar names slow down comprehension and
    increase the likelihood of error.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not declare a non-type with the same name as a type in the same scope. This
    removes the need to disambiguate with a keyword such as `struct` or `enum`. It
    also removes a source of errors, as `struct X` can implicitly declare `X` if lookup
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Antique header files might declare non-types and types with the same name in
    the same scope.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Check names against a list of known confusing letter and digit combinations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a declaration of a variable, function, or enumerator that hides a class
    or enumeration declared in the same scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.9: Avoid `ALL_CAPS` names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Such names are commonly used for macros. Thus, `ALL_CAPS` name are vulnerable
    to unintended macro substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not use `ALL_CAPS` for constants just because constants used to be macros.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and
    flag all non-all-CAPS macro names.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.10: Declare one name (only) per declaration'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One declaration per line increases readability and avoids mistakes related to
    the C/C++ grammar. It also leaves room for a more descriptive end-of-line comment.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A function declaration can contain several function argument declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A structured binding (C++17) is specifically designed to introduce several
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'or better using concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: In a long list of declarators it is easy to overlook an uninitialized variable.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag variable and constant declarations with multiple declarators (e.g., `int*
    p, q;`)
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.11: Use `auto` to avoid redundant repetition of type names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Simple repetition is tedious and error-prone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use `auto`, the name of the declared entity is in a fixed position
    in the declaration, increasing readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a function template declaration the return type can be a member type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: In each case, we save writing a longish, hard-to-remember type that the compiler
    already knows but a programmer could get wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid `auto` for initializer lists and in cases where you know exactly which
    type you want and where an initializer might require conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As of C++20, we can (and should) use concepts to be more specific about the
    type we are deducing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: Example (C++17)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag redundant repetition of type names in a declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.12: Do not reuse names in nested scopes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is easy to get confused about which variable is used. Can cause maintenance
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: If this is a large `if`-statement, it is easy to overlook that a new `d` has
    been introduced in the inner scope. This is a known source of bugs. Sometimes
    such reuse of a name in an inner scope is called “shadowing”.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Shadowing is primarily a problem when functions are too large and too complex.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Shadowing of function arguments in the outermost block is disallowed by the
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Reuse of a member name as a local variable can also be a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We often reuse function names from a base class in a derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: This is error-prone. For example, had we forgotten the using declaration, a
    call `d.f(1)` would not have found the `int` version of `f`.
  prefs: []
  type: TYPE_NORMAL
- en: ??? Do we need a specific rule about shadowing/hiding in class hierarchies?
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag reuse of a name in nested local scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag reuse of a member name as a local variable in a member function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag reuse of a global name as a local variable or a member name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag reuse of a base class member name in a derived class (except for function
    names)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.20: Always initialize an object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid used-before-set errors and their associated undefined behavior. Avoid
    problems with comprehension of complex initialization. Simplify refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'No, `i = 7` does not initialize `i`; it assigns to it. Also, `i` can be read
    in the `...` part. Better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *always initialize* rule is deliberately stronger than the *an object must
    be set before used* language rule. The latter, more relaxed rule, catches the
    technical bugs, but:'
  prefs: []
  type: TYPE_NORMAL
- en: It leads to less readable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It encourages people to declare names in greater than necessary scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leads to harder to read code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leads to logic bugs by encouraging complex code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It hampers refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *always initialize* rule is a style rule aimed to improve maintainability
    as well as a rule protecting against used-before-set errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Here is an example that is often considered to demonstrate the need for a more
    relaxed rule for initialization
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: This cannot trivially be rewritten to initialize `i` and `j` with initializers.
    Note that for types with a default constructor, attempting to postpone initialization
    simply leads to a default initialization followed by an assignment. A popular
    reason for such examples is “efficiency”, but a compiler that can detect whether
    we made a used-before-set error can also eliminate any redundant double initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that there is a logical connection between `i` and `j`, that connection
    should probably be expressed in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `make_related_widgets` function is otherwise redundant, we can eliminate
    it by using a lambda [ES.28](#res-lambda-init):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a value representing “uninitialized” is a symptom of a problem and not
    a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the compiler cannot even simply detect a used-before-set. Further, we’ve
    introduced complexity in the state space for widget: which operations are valid
    on an `uninit` widget and which are not?'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Complex initialization has been popular with clever programmers for decades.
    It has also been a major source of errors and complexity. Many such errors are
    introduced during maintenance years after the initial implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule covers data members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will flag the uninitialized `cm3` because it is a `const`, but
    it will not catch the lack of initialization of `m3`. Usually, a rare spurious
    member initialization is worth the absence of errors from lack of initialization
    and often an optimizer can eliminate a redundant initialization (e.g., an initialization
    that occurs immediately before an assignment).
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you are declaring an object that is just about to be initialized from input,
    initializing it would cause a double initialization. However, beware that this
    might leave uninitialized data beyond the input – and that has been a fertile
    source of errors and security breaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: The cost of initializing that array could be significant in some situations.
    However, such examples do tend to leave uninitialized variables accessible, so
    they should be treated with suspicion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: Because of the restrictive initialization rules for arrays and `std::array`,
    they offer the most compelling examples of the need for this exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'When feasible use a library function that is known not to overflow. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t consider simple variables that are targets for input operations exceptions
    to this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: In the not uncommon case where the input target and the input operation get
    separated (as they should not) the possibility of used-before-set opens up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: A good optimizer should know about input operations and eliminate the redundant
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, a lambda can be used as an initializer to avoid an uninitialized
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'or maybe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: [ES.28](#res-lambda-init)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag every uninitialized variable. Don’t flag variables of user-defined types
    with default constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that an uninitialized buffer is written into *immediately* after declaration.
    Passing an uninitialized variable as a reference to non-`const` argument can be
    assumed to be a write into the variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.21: Don’t introduce a variable (or constant) before you need to use it'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. To limit the scope in which the variable can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag declarations that are distant from their first use.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.22: Don’t declare a variable until you have a value to initialize it with'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Limit the scope in which a variable can be used. Don’t risk used-before-set.
    Initialization is often more efficient than assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: This would be fine if there was a default initialization for `SomeLargeType`
    that wasn’t too expensive. Otherwise, a programmer might very well wonder if every
    possible path through the maze of conditions has been covered. If not, we have
    a “use before set” bug. This is a maintenance trap.
  prefs: []
  type: TYPE_NORMAL
- en: For initializers of moderate complexity, including for `const` variables, consider
    using a lambda to express the initializer; see [ES.28](#res-lambda-init).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag declarations with default initialization that are assigned to before they
    are first read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag any complicated computation after an uninitialized variable and before
    its use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.23: Prefer the `{}`-initializer syntax'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prefer `{}`. The rules for `{}` initialization are simpler, more general, less
    ambiguous, and safer than for other forms of initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Use `=` only when you are sure that there can be no narrowing conversions. For
    built-in arithmetic types, use `=` only with `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid `()` initialization, which allows parsing ambiguities.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For containers, there is a tradition for using `{...}` for a list of elements
    and `(...)` for sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`{}`-initializers do not allow narrowing conversions (and that is usually a
    good thing) and allow explicit constructors (which is fine, we’re intentionally
    initializing a new variable).'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`{}` initialization can be used for nearly all initialization; other forms
    of initialization can’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: For that reason, `{}`-initialization is often called “uniform initialization”
    (though there unfortunately are a few irregularities left).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Initialization of a variable declared using `auto` with a single value, e.g.,
    `{v}`, had surprising results until C++17. The C++17 rules are somewhat less surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: Use `={...}` if you really want an `initializer_list<T>`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`={}` gives copy initialization whereas `{}` gives direct initialization. Like
    the distinction between copy-initialization and direct-initialization itself,
    this can lead to surprises. `{}` accepts `explicit` constructors; `={}` does not.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Use plain `{}`-initialization unless you specifically want to disable explicit
    constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '**See also**: [Discussion](#???)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `=` to initialize arithmetic types where narrowing occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag uses of `()` initialization syntax that are actually declarations. (Many
    compilers should warn on this already.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.24: Use a `unique_ptr<T>` to hold pointers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Using `std::unique_ptr` is the simplest way to avoid leaks. It is reliable,
    it makes the type system do much of the work to validate ownership safety, it
    increases readability, and it has zero or near zero run-time cost.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: If `leak == true` the object pointed to by `p2` is leaked and the object pointed
    to by `p1` is not. The same is the case when `at()` throws. In both cases, the
    `delete p2` statement is not reached.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for raw pointers that are targets of `new`, `malloc()`, or functions that
    might return such pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.25: Declare an object `const` or `constexpr` unless you want to modify its
    value later on'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That way you can’t change the value by mistake. That way might offer the compiler
    optimization opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look to see if a variable is actually mutated, and flag it if not. Unfortunately,
    it might be impossible to detect when a non-`const` was not *intended* to vary
    (vs when it merely did not vary).
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.26: Don’t use a variable for two unrelated purposes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability and safety.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As an optimization, you might want to reuse a buffer as a scratch pad, but even
    then prefer to limit the variable’s scope as much as possible and be careful not
    to cause bugs from data left in a recycled buffer as this is a common source of
    security bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag recycled variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.27: Use `std::array` or `stack_array` for arrays on the stack'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: They are readable and don’t implicitly convert to pointers. They are not confused
    with non-standard extensions of built-in arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The definition of `a1` is legal C++ and has always been. There is a lot of such
    code. It is error-prone, though, especially when the bound is non-local. Also,
    it is a “popular” source of errors (buffer overflow, pointers from array decay,
    etc.). The definition of `a2` is C but not C++ and is considered a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag arrays with non-constant bounds (C-style VLAs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag arrays with non-local constant bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.28: Use lambdas for complex initialization, especially of `const` variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It nicely encapsulates local initialization, including cleaning up scratch variables
    needed only for the initialization, without needing to create a needless non-local
    yet non-reusable function. It also works for variables that should be `const`
    but only after some initialization work.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: If at all possible, reduce the conditions to a simple set of alternatives (e.g.,
    an `enum`) and don’t mix up selection and initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Hard. At best a heuristic. Look for an uninitialized variable followed by a
    loop assigning to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.30: Don’t use macros for program text manipulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Macros are a major source of bugs. Macros don’t obey the usual scope and type
    rules. Macros ensure that the human reader sees something different from what
    the compiler sees. Macros complicate tool building.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: This innocuous-looking macro makes a single lower case `c` instead of a `C`
    into a bad flow-control bug.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule does not ban the use of macros for “configuration control” use in
    `#ifdef`s, etc.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, modules are likely to eliminate the need for macros in configuration
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This rule is meant to also discourage use of `#` for stringification and `##`
    for concatenation. As usual for macros, there are uses that are “mostly harmless”,
    but even these can create problems for tools, such as auto completers, static
    analyzers, and debuggers. Often the desire to use fancy macros is a sign of an
    overly complex design. Also, `#` and `##` encourages the definition and use of
    macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: 'There are workarounds for low-level string manipulation using macros. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: This is not as convenient as a macro to define, but as easy to use, has zero
    overhead, and is typed and scoped.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, static reflection is likely to eliminate the last needs for the
    preprocessor for program text manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Scream when you see a macro that isn’t just used for source control (e.g., `#ifdef`)
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.31: Don’t use macros for constants or “functions”'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Macros are a major source of bugs. Macros don’t obey the usual scope and type
    rules. Macros don’t obey the usual rules for argument passing. Macros ensure that
    the human reader sees something different from what the compiler sees. Macros
    complicate tool building.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if we hadn’t left a well-known bug in `SQUARE` there are much better behaved
    alternatives; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Scream when you see a macro that isn’t just used for source control (e.g., `#ifdef`)
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.32: Use `ALL_CAPS` for all macro names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Convention. Readability. Distinguishing macros.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Scream when you see a lower case macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.33: If you must use macros, give them unique names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Macros do not obey scope rules.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Avoid macros if you can: [ES.30](#res-macros), [ES.31](#res-macros2), and [ES.32](#res-all_caps).
    However, there are billions of lines of code littered with macros and a long tradition
    for using and overusing macros. If you are forced to use macros, use long names
    and supposedly unique prefixes (e.g., your organization’s name) to lower the likelihood
    of a clash.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Warn against short macro names.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.34: Don’t define a (C-style) variadic function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not type safe. Requires messy cast-and-macro-laden code to get working right.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '**Alternative**: Overloading. Templates. Variadic templates.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is basically the way `printf` is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag definitions of C-style variadic functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag `#include <cstdarg>` and `#include <stdarg.h>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.expr: Expressions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expressions manipulate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.40: Avoid complicated expressions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Complicated expressions are error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: Some of these expressions are unconditionally bad (e.g., they rely on undefined
    behavior). Others are simply so complicated and/or unusual that even good programmers
    could misunderstand them or overlook a problem when in a hurry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C++17 tightens up the rules for the order of evaluation (left-to-right except
    right-to-left in assignments, and the order of evaluation of function arguments
    is unspecified; [see ES.43](#res-order)), but that doesn’t change the fact that
    complicated expressions are potentially confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A programmer should know and use the basic rules for expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Tricky. How complicated must an expression be to be considered complicated?
    Writing computations as statements with one operation each is also confusing.
    Things to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'side effects: side effects on multiple non-local variables (for some definition
    of non-local) can be suspect, especially if the side effects are in separate subexpressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: writes to aliased variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: more than N operators (and what should N be?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reliance of subtle precedence rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uses undefined behavior (can we catch all undefined behavior?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: implementation defined behavior?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.41: If in doubt about operator precedence, parenthesize'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid errors. Readability. Not everyone has the operator table memorized.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: We recommend that programmers know their precedence table for the arithmetic
    operations, the logical operations, but consider mixing bitwise logical operations
    with other operators in need of parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You should know enough not to need parentheses for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag combinations of bitwise-logical operators and other operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag assignment operators not as the leftmost operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.42: Keep use of pointers simple and straightforward'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Complicated pointer manipulation is a major source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use `gsl::span` instead. Pointers should [only refer to single objects](#ri-array).
    Pointer arithmetic is fragile and easy to get wrong, the source of many, many
    bad bugs and security violations. `span` is a bounds-checked, safe type for accessing
    arrays of data. Access into an array with known bounds using a constant as a subscript
    can be validated by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Subscripting with a variable is difficult for both tools and humans to validate
    as safe. `span` is a run-time bounds-checked, safe type for accessing arrays of
    data. `at()` is another alternative that ensures single accesses are bounds-checked.
    If iterators are needed to access an array, use the iterators from a `span` constructed
    over the array.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Use a `span`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `at()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Use a `span`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a `span` and range-`for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `at()` for access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a range-`for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Tooling can offer rewrites of array accesses that involve dynamic index expressions
    to use `at()` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Turning an array into a pointer (as the language does essentially always) removes
    opportunities for checking, so avoid it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to pass an array, say so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag any arithmetic operation on an expression of pointer type that results
    in a value of pointer type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag any indexing expression on an expression or variable of array type (either
    static array or `std::array`) where the indexer is not a compile-time constant
    expression with a value between `0` and the upper bound of the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag any expression that would rely on implicit conversion of an array type
    to a pointer type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule is part of the [bounds-safety profile](#ss-bounds).
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.43: Avoid expressions with undefined order of evaluation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You have no idea what such code does. Portability. Even if it does something
    sensible for you, it might do something different on another compiler (e.g., the
    next release of your compiler) or with a different optimizer setting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'C++17 tightens up the rules for the order of evaluation: left-to-right except
    right-to-left in assignments, and the order of evaluation of function arguments
    is unspecified.'
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that your code might be compiled with a pre-C++17 compiler
    (e.g., through cut-and-paste) so don’t be too clever.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: A good rule of thumb is that you should not read a value twice in an expression
    where you write to it.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Can be detected by a good analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.44: Don’t depend on order of evaluation of function arguments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because that order is unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C++17 tightens up the rules for the order of evaluation, but the order of evaluation
    of function arguments is still unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: Before C++17, the behavior is undefined, so the behavior could be anything (e.g.,
    `f(2, 2)`). Since C++17, this code does not have undefined behavior, but it is
    still not specified which argument is evaluated first. The call will be `f(1,
    2)` or `f(2, 1)`, but you don’t know which.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Overloaded operators can lead to order of evaluation problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: In C++17, these examples work as expected (left to right) and assignments are
    evaluated right to left (just as =’s binding is right-to-left)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Can be detected by a good analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.45: Avoid “magic constants”; use symbolic constants'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unnamed constants embedded in expressions are easily overlooked and often hard
    to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: 'No, we don’t all know that there are 12 months, numbered 1..12, in a year.
    Better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: 'Better still, don’t expose constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag literals in code. Give a pass to `0`, `1`, `nullptr`, `\n`, `""`, and others
    on a positive list.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A narrowing conversion destroys information, often unexpectedly so.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A key example is basic narrowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The guidelines support library offers a `narrow_cast` operation for specifying
    that narrowing is acceptable and a `narrow` (“narrow if”) that throws an exception
    if a narrowing would throw away legal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'We also include lossy arithmetic casts, such as from a negative floating point
    type to an unsigned integral type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This rule does not apply to [contextual conversions to bool](https://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A good analyzer can detect all narrowing conversions. However, flagging all
    narrowing conversions will lead to a lot of false positives. Suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Flag all floating-point to integer conversions. (Maybe only `float`->`char`
    and `double`->`int`. Here be dragons! We need data.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag all `long`->`char`. (I suspect `int`->`char` is very common. Here be dragons!
    We need data.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider narrowing conversions for function arguments especially suspect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.47: Use `nullptr` rather than `0` or `NULL`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Readability. Minimize surprises: `nullptr` cannot be confused with an `int`.
    `nullptr` also has a well-specified (very restrictive) type, and thus works in
    more scenarios where type deduction might do the wrong thing on `NULL` or `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `0` and `NULL` for pointers. The transformation might be helped
    by simple program transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.48: Avoid casts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Casts are a well-known source of errors and make some optimizations unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: What would you think this fragment prints? The result is at best implementation
    defined. I got
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: Adding
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: I got
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: Surprised? It is actually undefined behavior, and so could also have crashed
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Programmers who write casts typically assume that they know what they are doing,
    or that writing a cast makes the program “easier to read”. In fact, they often
    disable the general rules for using values. Overload resolution and template instantiation
    usually pick the right function if there is a right function to pick. If there
    is not, maybe there ought to be, rather than applying a local fix (cast).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Casts are necessary in a systems programming language. For example, how else
    would we get the address of a device register into a pointer? However, casts are
    seriously overused as well as a major source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel the need for a lot of casts, there might be a fundamental design
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: The [type profile](#pro-type-reinterpretcast) bans `reinterpret_cast` and C-style
    casts.
  prefs: []
  type: TYPE_NORMAL
- en: Never cast to `(void)` to ignore a `[[nodiscard]]`return value. If you deliberately
    want to discard such a result, first think hard about whether that is really a
    good idea (there is usually a good reason the author of the function or of the
    return type used `[[nodiscard]]` in the first place). If you still think it’s
    appropriate and your code reviewer agrees, use `std::ignore =` to turn off the
    warning which is simple, portable, and easy to grep.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Casts are widely (mis)used. Modern C++ has rules and constructs that eliminate
    the need for casts in many contexts, such as
  prefs: []
  type: TYPE_NORMAL
- en: Use templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::variant`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rely on the well-defined, safe, implicit conversions between pointer types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::ignore =` to ignore `[[nodiscard]]` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all C-style casts, including to `void`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag functional style casts using `Type(value)`. Use `Type{value}` instead which
    is not narrowing. (See [ES.64](#res-construct).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag [identity casts](#pro-type-identitycast) between pointer types, where the
    source and target types are the same (#pro-type-identitycast).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag an explicit pointer cast that could be [implicit](#pro-type-implicitpointercast).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.49: If you must use a cast, use a named cast'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Error avoidance. Named casts are more specific than a C-style or
    functional cast, allowing the compiler to catch some errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The named casts are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reinterpret_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic_cast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::move` // `move(x)` is an rvalue reference to `x`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::forward` // `forward<T>(x)` is an rvalue or an lvalue reference to `x`
    depending on `T`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gsl::narrow_cast` // `narrow_cast<T>(x)` is `static_cast<T>(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gsl::narrow` // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x)
    == x` or it throws `narrowing_error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: The example was synthesized from real-world bugs where `D` used to be derived
    from `B`, but someone refactored the hierarchy. The C-style cast is dangerous
    because it can do any kind of conversion, depriving us of any protection from
    mistakes (now or in the future).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When converting between types with no information loss (e.g. from `float` to
    `double` or from `int32` to `int64`), brace initialization might be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: This makes it clear that the type conversion was intended and also prevents
    conversions between types that might result in loss of precision. (It is a compilation
    error to try to initialize a `float` from a `double` in this fashion, for example.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`reinterpret_cast` can be essential, but the essential uses (e.g., turning
    a machine address into pointer) are not type safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all C-style casts, including to `void`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag functional style casts using `Type(value)`. Use `Type{value}` instead which
    is not narrowing. (See [ES.64](#res-construct).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [type profile](#pro-type-reinterpretcast) bans `reinterpret_cast`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [type profile](#pro-type-arithmeticcast) warns when using `static_cast`
    between arithmetic types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.50: Don’t cast away `const`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It makes a lie out of `const`. If the variable is actually declared `const`,
    modifying it results in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes, you might be tempted to resort to `const_cast` to avoid code duplication,
    such as when two accessor functions that differ only in `const`-ness have similar
    implementations. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, prefer to share implementations. Normally, you can just have the non-`const`
    function call the `const` function. However, when there is complex logic this
    can lead to the following pattern that still resorts to a `const_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: Although this pattern is safe when applied correctly, because the caller must
    have had a non-`const` object to begin with, it’s not ideal because the safety
    is hard to enforce automatically as a checker rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, prefer to put the common code in a common helper function – and make
    it a template so that it deduces `const`. This doesn’t use any `const_cast` at
    all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: Don’t do large non-dependent work inside a template, which leads to code
    bloat. For example, a further improvement would be if all or part of `get_bar_impl`
    can be non-dependent and factored out into a common non-template function, for
    a potentially big reduction in code size.'
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might need to cast away `const` when calling `const`-incorrect functions.
    Prefer to wrap such functions in inline `const`-correct wrappers to encapsulate
    the cast in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes, “cast away `const`” is to allow the updating of some transient information
    of an otherwise immutable object. Examples are caching, memoization, and precomputation.
    Such examples are often handled as well or better using `mutable` or an indirection
    than with a `const_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider keeping previously computed results around for a costly operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `get_val()` is logically constant, so we would like to make it a `const`
    member. To do this we still need to mutate `cache`, so people sometimes resort
    to a `const_cast`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, there is a better solution: State that `cache` is mutable even
    for a `const` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative solution would be to store a pointer to the `cache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: That solution is the most flexible, but requires explicit construction and destruction
    of `*cache` (most likely in the constructor and destructor of `X`).
  prefs: []
  type: TYPE_NORMAL
- en: In any variant, we must guard against data races on the `cache` in multi-threaded
    code, possibly using a `std::mutex`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `const_cast`s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule is part of the [type-safety profile](#pro-type-constcast) for the
    related Profile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.55: Avoid the need for range checking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Constructs that cannot overflow do not overflow (and usually run faster):'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for explicit range checks and heuristically suggest alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.56: Write `std::move()` only when you need to explicitly move an object
    to another scope'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We move, rather than copy, to avoid duplication and for improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: A move typically leaves behind an empty object ([C.64](#rc-move-semantic)),
    which can be surprising or even dangerous, so we try to avoid moving from lvalues
    (they might be accessed later).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Moving is done implicitly when the source is an rvalue (e.g., value in a `return`
    treatment or a function result), so don’t pointlessly complicate code in those
    cases by writing `move` explicitly. Instead, write short functions that return
    values, and both the function’s return and the caller’s accepting of the return
    will be optimized naturally.
  prefs: []
  type: TYPE_NORMAL
- en: In general, following the guidelines in this document (including not making
    variables’ scopes needlessly large, writing short functions that return values,
    returning local variables) help eliminate most need for explicit `std::move`.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit `move` is needed to explicitly move an object to another scope, notably
    to pass it to a “sink” function and in the implementations of the move operations
    themselves (move constructor, move assignment operator) and swap operations.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: Usually, a `std::move()` is used as an argument to an `&&` parameter. And after
    you do that, assume the object has been moved from (see [C.64](#rc-move-semantic))
    and don’t read its state again until you first set it to a new value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::move()` is a cast to `&&` in disguise; it doesn’t itself move anything,
    but marks a named object as a candidate that can be moved from. The language already
    knows the common cases where objects can be moved from, especially when returning
    values from functions, so don’t complicate code with redundant `std::move()`s.'
  prefs: []
  type: TYPE_NORMAL
- en: Never write `std::move()` just because you’ve heard “it’s more efficient.” In
    general, don’t believe claims of “efficiency” without data (???). In general,
    don’t complicate your code without reason (??). Never write `std::move()` on a
    const object, it is silently transformed into a copy (see Item 23 in [Meyers15](#Meyers15))
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: Never write `return move(local_variable);`, because the language already knows
    the variable is a move candidate. Writing `move` in this code won’t help, and
    can actually be detrimental because on some compilers it interferes with RVO (the
    return value optimization) by creating an additional reference alias to the local
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: Never write `move` on a returned value such as `x = move(f());` where `f` returns
    by value. The language already knows that a returned value is a temporary object
    that can be moved from.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag use of `std::move(x)` where `x` is an rvalue or the language will already
    treat it as an rvalue, including `return std::move(local_variable);` and `std::move(f())`
    on a function that returns by value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag functions taking an `S&&` parameter if there is no `const S&` overload
    to take care of lvalues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a `std::move`d argument passed to a parameter, except when the parameter
    type is an `X&&` rvalue reference or the type is move-only and the parameter is
    passed by value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag when `std::move` is applied to a forwarding reference (`T&&` where `T`
    is a template parameter type). Use `std::forward` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag when `std::move` is applied to other than an rvalue reference to non-const.
    (More general case of the previous rule to cover the non-forwarding cases.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag when `std::forward` is applied to an rvalue reference (`X&&` where `X`
    is a non-template parameter type). Use `std::move` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag when `std::forward` is applied to other than a forwarding reference. (More
    general case of the previous rule to cover the non-moving cases.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag when an object is potentially moved from and the next operation is a `const`
    operation; there should first be an intervening non-`const` operation, ideally
    assignment, to first reset the object’s value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.60: Avoid `new` and `delete` outside resource management functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Direct resource management in application code is error-prone and tedious.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is also known as the rule of “No naked `new`!”
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: There can be code in the `...` part that causes the `delete` never to happen.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [R: Resource management](#s-resource)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag naked `new`s and naked `delete`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.61: Delete arrays using `delete[]` and non-arrays using `delete`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That’s what the language requires, and mismatches can lead to resource release
    errors and/or memory corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This example not only violates the [no naked `new` rule](#res-new) as in the
    previous example, it has many more problems.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag mismatched `new` and `delete` if they are in the same scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag mismatched `new` and `delete` if they are in a constructor/destructor pair.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.62: Don’t compare pointers into different arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The result of doing so is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This example has many more problems.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.63: Don’t slice'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Slicing – that is, copying only part of an object using assignment or initialization
    – most often leads to errors because the object was meant to be considered as
    a whole. In the rare cases where the slicing was deliberate the code can be surprising.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: The result will be meaningless because the center and radius will not be copied
    from `c` into `s`. The first defense against this is to [define the base class
    `Shape` not to allow this](#rc-copy-virtual).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you mean to slice, define an explicit operation to do so. This saves readers
    from confusion. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Warn against slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.64: Use the `T{e}`notation for construction'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `T{e}` construction syntax makes it explicit that construction is desired.
    The `T{e}` construction syntax doesn’t allow narrowing. `T{e}` is the only safe
    and general expression for constructing a value of type `T` from an expression
    `e`. The casts notations `T(e)` and `(T)e` are neither safe nor general.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For built-in types, the construction notation protects against narrowing and
    reinterpretation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: The integer to/from pointer conversions are implementation defined when using
    the `T(e)` or `(T)e` notations, and non-portable between platforms with different
    integer and pointer sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Avoid casts](#res-casts) (explicit type conversion) and if you must [prefer
    named casts](#res-casts-named).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When unambiguous, the `T` can be left out of `T{e}`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The construction notation is the most general [initializer notation](#res-list).
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::vector` and other containers were defined before we had `{}` as a notation
    for construction. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: How do we get a `vector` of 10 default initialized `int`s?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `()` rather than `{}` for number of elements is conventional (going
    back to the early 1980s), hard to change, but still a design error: for a container
    where the element type can be confused with the number of elements, we have an
    ambiguity that must be resolved. The conventional resolution is to interpret `{10}`
    as a list of one element and use `(10)` to distinguish a size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This mistake need not be repeated in new code. We can define a type to represent
    the number of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: The main problem left is to find a suitable name for `Count`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag the C-style `(T)e` and functional-style `T(e)` casts.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.65: Don’t dereference an invalid pointer'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Dereferencing an invalid pointer, such as `nullptr`, is undefined behavior,
    typically leading to immediate crashes, wrong results, or memory corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By pointer here we mean any indirection to an object, including equivalently
    an iterator or view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule is an obvious and well-known language rule, but can be hard to follow.
    It takes good coding style, library support, and static analysis to eliminate
    violations without major overhead. This is a major part of the discussion of [C++’s
    model for type- and resource-safety](#Stroustrup15).
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**:'
  prefs: []
  type: TYPE_NORMAL
- en: Use [RAII](#rr-raii) to avoid lifetime problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use [unique_ptr](#rf-unique_ptr) to avoid lifetime problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use [shared_ptr](#rf-shared_ptr) to avoid lifetime problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use [references](#rf-ptr-ref) when `nullptr` isn’t a possibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use [not_null](#rf-nullptr) to catch unexpected `nullptr` early.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the [bounds profile](#ss-bounds) to avoid range errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: To resolve the problem, either extend the lifetime of the object the pointer
    is intended to refer to, or shorten the lifetime of the pointer (move the dereference
    to before the pointed-to object’s lifetime ends).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, most invalid pointer problems are harder to spot and harder to
    fix.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a huge amount of such code. Most works – after lots of testing – but
    in isolation it is impossible to tell whether `p` could be the `nullptr`. Consequently,
    this is also a major source of errors. There are many approaches to dealing with
    this potential problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two potential problems with testing for `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: it is not always obvious what to do if we find `nullptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the test can be redundant and/or relatively expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it is not obvious if the test is to protect against a violation or part of the
    required logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: 'This would carry a cost only when the assertion checking was enabled and would
    give a compiler/analyzer useful information. This would work even better if/when
    C++ gets direct support for contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we could use `gsl::not_null` to ensure that `p` is not the `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: These remedies take care of `nullptr` only. Remember that there are other ways
    of getting an invalid pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule is part of the [lifetime safety profile](#ss-lifetime)
  prefs: []
  type: TYPE_NORMAL
- en: Flag a dereference of a pointer that points to an object that has gone out of
    scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a dereference of a pointer that might have been invalidated by assigning
    a `nullptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a dereference of a pointer that might have been invalidated by a `delete`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a dereference to a pointer to a container element that might have been
    invalidated by dereference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.stmt: Statements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Statements control the flow of control (except for function calls and exception
    throws, which are expressions).
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Efficiency: A `switch` compares against constants and is usually better optimized
    than a series of tests in an `if`-`then`-`else` chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `switch` enables some heuristic consistency checking. For example, have all
    values of an `enum` been covered? If not, is there a `default`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'rather than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `if`-`then`-`else` chains that check against constants (only).
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a
    choice'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Error prevention. Efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: A human or a good static analyzer might determine that there really isn’t a
    side effect on `v` in `f(v, &v[i])` so that the loop can be rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: “Messing with the loop variable” in the body of a loop is typically best avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Don’t use expensive copies of the loop variable of a range-`for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'This will copy each element of `vs` into `s`. Better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'Better still, if the loop variable isn’t modified or copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look at loops, if a traditional loop just looks at each element of a sequence,
    and there are no side effects on what it does with the elements, rewrite the loop
    to a ranged-`for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious
    loop variable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Readability: the complete logic of the loop is visible “up front”. The scope
    of the loop variable can be limited.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious
    loop variable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: The “event loop” is misleading because the `events` counter has nothing to do
    with the loop condition (`wait_for_event()`). Better
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag actions in `for`-initializers and `for`-increments that do not relate to
    the `for`-condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [ES.6](#res-cond)
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.75: Avoid `do`-statements'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability, avoidance of errors. The termination condition is at the end (where
    it can be overlooked) and the condition is not checked the first time through.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Yes, there are genuine examples where a `do`-statement is a clear statement
    of a solution, but also many bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `do`-statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.76: Avoid `goto`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability, avoidance of errors. There are better control structures for humans;
    `goto` is for machine generated code.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Breaking out of a nested loop. In that case, always jump forwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There is a fair amount of use of the C goto-exit idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: This is an ad-hoc simulation of destructors. Declare your resources with handles
    with destructors that clean up. If for some reason you cannot handle all cleanup
    with destructors for the variables used, consider `gsl::finally()` as a cleaner
    and more reliable alternative to `goto exit`
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `goto`. Better still flag all `goto`s that do not jump from a nested loop
    to the statement immediately after a nest of loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.77: Minimize the use of `break` and `continue` in loops'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a non-trivial loop body, it is easy to overlook a `break` or a `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: A `break` in a loop has a dramatically different meaning than a `break` in a
    `switch`-statement (and you can have `switch`-statement in a loop and a loop in
    a `switch`-case).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Often, a loop that requires a `break` is a good candidate for a function (algorithm),
    in which case the `break` becomes a `return`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: Often, a loop that uses `continue` can equivalently and as clearly be expressed
    by an `if`-statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you really need to break out a loop, a `break` is typically better than
    alternatives such as [modifying the loop variable](#res-loop-counter) or a [`goto`](#res-goto):'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.78: Don’t rely on implicit fallthrough in `switch` statements'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Always end a non-empty `case` with a `break`. Accidentally leaving out a `break`
    is a fairly common bug. A deliberate fallthrough can be a maintenance hazard and
    should be rare and explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple case labels of a single statement is OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: 'Return statements in a case label are also OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In rare cases if fallthrough is deemed appropriate, be explicit and use the
    `[[fallthrough]]` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all implicit fallthroughs from non-empty `case`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.79: Use `default` to handle common cases (only)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Code clarity. Improved opportunities for error detection.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: Here it is clear that there is a default action and that cases `a` and `b` are
    special.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'But what if there is no default action and you mean to handle only specific
    cases? In that case, have an empty default or else it is impossible to know if
    you meant to handle all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: 'If you leave out the `default`, a maintainer and/or a compiler might reasonably
    assume that you intended to handle all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: Did you forget case `d` or deliberately leave it out? Forgetting a case typically
    happens when a case is added to an enumeration and the person doing so fails to
    add it to every switch over the enumerators.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `switch`-statements over an enumeration that don’t handle all enumerators
    and do not have a `default`. This might yield too many false positives in some
    code bases; if so, flag only `switch`es that handle most but not all cases (that
    was the strategy of the very first C++ compiler).
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.84: Don’t try to declare a local variable with no name'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is no such thing. What looks to a human like a variable without a name
    is to the compiler a statement consisting of a temporary that immediately goes
    out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: This declares an unnamed `lock_guard` object that immediately goes out of scope
    at the point of the semicolon. This is not an uncommon mistake. In particular,
    this particular example can lead to hard-to-find race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unnamed function arguments are fine.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag statements that are just a temporary.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.85: Make empty statements visible'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag empty statements that are not blocks and don’t contain comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.86: Avoid modifying loop control variables inside the body of raw for-loops'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The loop control up front should enable correct reasoning about what is happening
    inside the loop. Modifying loop counters in both the iteration-expression and
    inside the body of the loop is a perennial source of surprises and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag variables that are potentially updated (have a non-`const` use) in both
    the loop control iteration-expression and the loop body.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.87: Don’t add redundant `==` or `!=` to conditions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Doing so avoids verbosity and eliminates some opportunities for mistakes. Helps
    make style consistent and conventional.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By definition, a condition in an `if`-statement, `while`-statement, or a `for`-statement
    selects between `true` and `false`. A numeric value is compared to `0` and a pointer
    value to `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: Often, `if (p)` is read as “if `p` is valid” which is a direct expression of
    the programmers intent, whereas `if (p != nullptr)` would be a long-winded workaround.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule is especially useful when a declaration is used as a condition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Note that implicit conversions to bool are applied in conditions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: This invokes `istream`’s `operator bool()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Explicit comparison of an integer to `0` is in general not redundant. The reason
    is that (as opposed to pointers and Booleans) an integer often has more than two
    reasonable values. Furthermore `0` (zero) is often used to indicate success. Consequently,
    it is best to be specific about the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: Always remember that an integer can have more than two values.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It has been noted that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: is a common beginners error. If you use C-style strings, you must know the `<cstring>`
    functions well. Being verbose and writing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: would not in itself save you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The opposite condition is most easily expressed using a negation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Easy, just check for redundant use of `!=` and `==` in conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES.100: Don’t mix signed and unsigned arithmetic'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid wrong results.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: It is harder to spot the problem in more realistic examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unfortunately, C++ uses signed integers for array subscripts and the standard
    library uses unsigned integers for container subscripts. This precludes consistency.
    Use `gsl::index` for subscripts; [see ES.107](#res-subscripts).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compilers already know and sometimes warn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one
    of the arguments is `sizeof` or a call to container `.size()` and the other is
    `ptrdiff_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.101: Use unsigned types for bit manipulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unsigned types support bit manipulation without surprises from sign bits.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unsigned types can also be useful for modular arithmetic. However, if you want
    modular arithmetic add comments as necessary noting the reliance on wraparound
    behavior, as such code can be surprising for many programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Just about impossible in general because of the use of unsigned subscripts in
    the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.102: Use signed types for arithmetic'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because most arithmetic is assumed to be signed; `x - y` yields a negative number
    when `y > x` except in the rare cases where you really want modular arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unsigned arithmetic can yield surprising results if you are not expecting it.
    This is even more true for mixed signed and unsigned arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: Here we have been very explicit about what’s happening, but if you had seen
    `us - (s + 2)` or `s += 2; ...; us - s`, would you reliably have suspected that
    the result would print as `4294967294`?
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use unsigned types if you really want modular arithmetic - add comments as necessary
    noting the reliance on overflow behavior, as such code is going to be surprising
    for many programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The standard library uses unsigned types for subscripts. The built-in array
    uses signed types for subscripts. This makes surprises (and bugs) inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: Use `gsl::index` for subscripts; [see ES.107](#res-subscripts).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag mixed signed and unsigned arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag results of unsigned arithmetic assigned to or printed as signed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag negative literals (e.g. `-2`) used as container subscripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one
    of the arguments is `sizeof` or a call to container `.size()` and the other is
    `ptrdiff_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.103: Don’t overflow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Overflow usually makes your numeric algorithm meaningless. Incrementing a value
    beyond a maximum value can lead to memory corruption and undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use unsigned types if you really want modular arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: For critical applications that can afford some overhead, use
    a range-checked integer and/or floating-point type.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.104: Don’t underflow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Decrementing a value beyond a minimum value can lead to memory corruption and
    undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use unsigned types if you really want modular arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.105: Don’t divide by integer zero'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The result is undefined and probably a crash.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This also applies to `%`.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '**Alternative**: For critical applications that can afford some overhead, use
    a range-checked integer and/or floating-point type.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag division by an integral value that could be zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ES.106: Don’t try to avoid negative values by using `unsigned`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Choosing `unsigned` implies many changes to the usual behavior of integers,
    including modular arithmetic, can suppress warnings related to overflow, and opens
    the door for errors related to signed/unsigned mixes. Using `unsigned` doesn’t
    actually eliminate the possibility of negative values.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: 'These problems with such (perfectly legal) constructs are hard to spot in real
    code and are the source of many real-world errors. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `-1` when assigned to an `unsigned int` becomes the largest `unsigned
    int`. Also, since unsigned arithmetic is modular arithmetic the multiplication
    didn’t overflow, it wrapped around.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: Had `x` been a signed `short`, we could have warned about the undefined behavior
    upon overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: use signed integers and check for `x >= 0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use a positive integer type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use an integer subrange type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert(-1 < x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See ES.100 Enforcements.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES.107: Don’t use `unsigned` for subscripts, prefer `gsl::index`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid signed/unsigned confusion. To enable better optimization. To enable
    better error detection. To avoid the pitfalls with `auto` and `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The built-in array allows signed subscripts. The standard-library containers
    use unsigned subscripts. Thus, no perfect and fully compatible solution is possible
    (unless and until the standard-library containers change to use signed subscripts
    someday in the future). Given the known problems with unsigned and signed/unsigned
    mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed
    by `gsl::index`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: Alternatives
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Alternatives for users
  prefs: []
  type: TYPE_NORMAL
- en: use algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use range-for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use iterators/pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Very tricky as long as the standard-library containers get it wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one
    of the arguments is `sizeof` or a call to container `.size()` and the other is
    `ptrdiff_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Per: Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ??? should this section be in the main guide???
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains rules for people who need high performance or low-latency.
    That is, these are rules that relate to how to use as little time and as few resources
    as possible to achieve a task in a predictably short time. The rules in this section
    are more restrictive and intrusive than what is needed for many (most) applications.
    Do not naïvely try to follow them in general code: achieving the goals of low
    latency requires extra work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Per.1: Don’t optimize without reason](#rper-reason)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.2: Don’t optimize prematurely](#rper-knuth)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.3: Don’t optimize something that’s not performance critical](#rper-critical)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.4: Don’t assume that complicated code is necessarily faster than simple
    code](#rper-simple)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.5: Don’t assume that low-level code is necessarily faster than high-level
    code](#rper-low)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.6: Don’t make claims about performance without measurements](#rper-measure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.7: Design to enable optimization](#rper-efficiency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.10: Rely on the static type system](#rper-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.11: Move computation from run time to compile time](#rper-comp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.12: Eliminate redundant aliases](#rper-alias)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.13: Eliminate redundant indirections](#rper-indirect)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.14: Minimize the number of allocations and deallocations](#rper-alloc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.15: Do not allocate on a critical branch](#rper-alloc0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.16: Use compact data structures](#rper-compact)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.17: Declare the most used member of a time-critical struct first](#rper-struct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.18: Space is time](#rper-space)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.19: Access memory predictably](#rper-access)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Per.30: Avoid context switches on the critical path](#rper-context)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Per.1: Don’t optimize without reason'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If there is no need for optimization, the main result of the effort will be
    more errors and higher maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some people optimize out of habit or because it’s fun.
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.2: Don’t optimize prematurely'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Elaborately optimized code is usually larger and harder to change than unoptimized
    code.
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.3: Don’t optimize something that’s not performance critical'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Optimizing a non-performance-critical part of a program has no effect on system
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your program spends most of its time waiting for the web or for a human,
    optimization of in-memory computation is probably useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put another way: If your program spends 4% of its processing time doing computation
    A and 40% of its time doing computation B, a 50% improvement on A is only as impactful
    as a 5% improvement on B. (If you don’t even know how much time is spent on A
    or B, see [Per.1](#rper-reason) and [Per.2](#rper-knuth).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.4: Don’t assume that complicated code is necessarily faster than simple
    code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Simple code can be very fast. Optimizers sometimes do marvels with simple code
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.5: Don’t assume that low-level code is necessarily faster than high-level
    code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Low-level code sometimes inhibits optimizations. Optimizers sometimes do marvels
    with high-level code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.6: Don’t make claims about performance without measurements'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The field of performance is littered with myth and bogus folklore. Modern hardware
    and optimizers defy naive assumptions; even experts are regularly surprised.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Getting good performance measurements can be hard and require specialized tools.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A few simple microbenchmarks using Unix `time` or the standard-library `<chrono>`
    can help dispel the most obvious myths. If you can’t measure your complete system
    accurately, at least try to measure a few of your key operations and algorithms.
    A profiler can help tell you which parts of your system are performance critical.
    Often, you will be surprised.
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.7: Design to enable optimization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because we often need to optimize the initial design. Because a design that
    ignores the possibility of later improvement is hard to change.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'From the C (and C++) standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: When did you even want to sort memory? Really, we sort sequences of elements,
    typically stored in containers. A call to `qsort` throws away much useful information
    (e.g., the element type), forces the user to repeat information already known
    (e.g., the element size), and forces the user to write extra code (e.g., a function
    to compare `double`s). This implies added work for the programmer, is error-prone,
    and deprives the compiler of information needed for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: From the point of view of interface design, `qsort` throws away useful information.
  prefs: []
  type: TYPE_NORMAL
- en: We can do better (in C++98)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the compiler’s knowledge about the size of the array, the type
    of elements, and how to compare `double`s.
  prefs: []
  type: TYPE_NORMAL
- en: With C++20, we can do better still
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: 'The key is to pass sufficient information for a good implementation to be chosen.
    In this, the `sort` interfaces shown here still have a weakness: They implicitly
    rely on the element type having less-than (`<`) defined. To complete the interface,
    we need a second version that accepts a comparison criterion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: The standard-library specification of `sort` offers those two versions, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Premature optimization is said to be [the root of all evil](#rper-knuth), but
    that’s not a reason to despise performance. It is never premature to consider
    what makes a design amenable to improvement, and improved performance is a commonly
    desired improvement. Aim to build a set of habits that by default results in efficient,
    maintainable, and optimizable code. In particular, when you write a function that
    is not a one-off implementation detail, consider
  prefs: []
  type: TYPE_NORMAL
- en: 'Information passing: Prefer clean [interfaces](#s-interfaces) carrying sufficient
    information for later improvement of implementation. Note that information flows
    into and out of an implementation through the interfaces we provide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Compact data: By default, [use compact data](#rper-compact), such as `std::vector`
    and [access it in a systematic fashion](#rper-access). If you think you need a
    linked structure, try to craft the interface so that this structure isn’t seen
    by users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function argument passing and return: Distinguish between mutable and non-mutable
    data. Don’t impose a resource management burden on your users. Don’t impose spurious
    run-time indirections on your users. Use [conventional ways](#rf-conventional)
    of passing information through an interface; unconventional and/or “optimized”
    ways of passing data can seriously complicate later reimplementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Abstraction: Don’t overgeneralize; a design that tries to cater for every possible
    use (and misuse) and defers every design decision for later (using compile-time
    or run-time indirections) is usually a complicated, bloated, hard-to-understand
    mess. Generalize from concrete examples, preserving performance as we generalize.
    Do not generalize based on mere speculation about future needs. The ideal is zero-overhead
    generalization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Libraries: Use libraries with good interfaces. If no library is available build
    one yourself and imitate the interface style from a good library. The [standard
    library](#sl-the-standard-library) is a good first place to look for inspiration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Isolation: Isolate your code from messy and/or old-style code by providing
    an interface of your choosing to it. This is sometimes called “providing a wrapper”
    for the useful/necessary but messy code. Don’t let bad designs “bleed into” your
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '`binary_search(begin(c), end(c), 7)` will tell you whether `7` is in `c` or
    not. However, it will not tell you where that `7` is or whether there are more
    than one `7`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, just passing the minimal amount of information back (here, `true`
    or `false`) is sufficient, but a good interface passes needed information back
    to the caller. Therefore, the standard library also offers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '`lower_bound` returns an iterator to the first match if any, otherwise to the
    first element greater than `val`, or `last` if no such element is found.'
  prefs: []
  type: TYPE_NORMAL
- en: However, `lower_bound` still doesn’t return enough information for all uses,
    so the standard library also offers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '`equal_range` returns a `pair` of iterators specifying the first and one beyond
    last match.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, these three interfaces are implemented by the same basic code. They
    are simply three ways of presenting the basic binary search algorithm to users,
    ranging from the simplest (“make simple things simple!”) to returning complete,
    but not always needed, information (“don’t hide useful information”). Naturally,
    crafting such a set of interfaces requires experience and domain knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not simply craft the interface to match the first implementation and the
    first use case you think of. Once your first initial implementation is complete,
    review it; once you deploy it, mistakes will be hard to remedy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A need for efficiency does not imply a need for [low-level code](#rper-low).
    High-level code isn’t necessarily slow or bloated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Things have costs. Don’t be paranoid about costs (modern computers really are
    very fast), but have a rough idea of the order of magnitude of cost of what you
    use. For example, have a rough idea of the cost of a memory access, a function
    call, a string comparison, a system call, a disk access, and a message through
    a network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you can only think of one implementation, you probably don’t have something
    for which you can devise a stable interface. Maybe, it is just an implementation
    detail - not every piece of code needs a stable interface - but pause and consider.
    One question that can be useful is “what interface would be needed if this operation
    should be implemented using multiple threads? be vectorized?”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule does not contradict the [Don’t optimize prematurely](#rper-knuth)
    rule. It complements it, encouraging developers to enable later - appropriate
    and non-premature - optimization, if and where needed.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Tricky. Maybe looking for `void*` function arguments will find examples of interfaces
    that hinder later optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.10: Rely on the static type system'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Type violations, weak types (e.g. `void*`s), and low-level code (e.g., manipulation
    of sequences as individual bytes) make the job of the optimizer much harder. Simple
    code often optimizes better than hand-crafted complex code.
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.11: Move computation from run time to compile time'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To decrease code size and run time. To avoid data races by using constants.
    To catch errors at compile time (and thus eliminate the need for error-handling
    code).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: 'Code like the initialization of `s2` isn’t uncommon, especially for initialization
    that’s a bit more complicated than `square()`. However, compared to the initialization
    of `s3` there are two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: we suffer the overhead of a function call at run time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s2` just might be accessed by another thread before the initialization happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: you can’t have a data race on a constant.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Consider a popular technique for providing a handle for storing small objects
    in the handle itself and larger ones on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: Assume that `Scoped` and `On_heap` provide compatible user interfaces. Here
    we compute the optimal type to use at compile time. There are similar techniques
    for selecting the optimal function to call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ideal is *not* to try to execute everything at compile time. Obviously,
    most computations depend on inputs, so they can’t be moved to compile time, but
    beyond that logical constraint is the fact that complex compile-time computation
    can seriously increase compile times and complicate debugging. It is even possible
    to slow down code by compile-time computation. This is admittedly rare, but by
    factoring out a general computation into separate optimal sub-calculations, it
    is possible to render the instruction cache less effective.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for simple functions that might be constexpr (but are not).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for functions called with all constant-expression arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for macros that could be constexpr.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Per.12: Eliminate redundant aliases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.13: Eliminate redundant indirections'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.14: Minimize the number of allocations and deallocations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.15: Do not allocate on a critical branch'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.16: Use compact data structures'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Performance is typically dominated by memory access times.
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.17: Declare the most used member of a time-critical struct first'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.18: Space is time'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Performance is typically dominated by memory access times.
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Per.19: Access memory predictably'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Performance is very sensitive to cache performance, and cache algorithms favor
    simple (usually linear) access to adjacent data.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: 'Per.30: Avoid context switches on the critical path'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP: Concurrency and parallelism'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often want our computers to do many tasks at the same time (or at least appear
    to do them at the same time). The reasons for doing so vary (e.g., waiting for
    many events using only a single processor, processing many data streams simultaneously,
    or utilizing many hardware facilities) and so do the basic facilities for expressing
    concurrency and parallelism. Here, we articulate principles and rules for using
    the ISO standard C++ facilities for expressing basic concurrency and parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Threads are the machine-level foundation for concurrent and parallel programming.
    Threads allow running multiple sections of a program independently, while sharing
    the same memory. Concurrent programming is tricky, because protecting shared data
    between threads is easier said than done. Making existing single-threaded code
    execute concurrently can be as trivial as adding `std::async` or `std::thread`
    strategically, or it can necessitate a full rewrite, depending on whether the
    original code was written in a thread-friendly way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concurrency/parallelism rules in this document are designed with three
    goals in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: To help in writing code that is amenable to being used in a threaded environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To show clean, safe ways to use the threading primitives offered by the standard
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To offer guidance on what to do when concurrency and parallelism aren’t giving
    the performance gains needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also important to note that concurrency in C++ is an unfinished story.
    C++11 introduced many core concurrency primitives, C++14 and C++17 improved on
    them, and there is much interest in making the writing of concurrent programs
    in C++ even easier. We expect some of the library-related guidance here to change
    significantly over time.
  prefs: []
  type: TYPE_NORMAL
- en: This section needs a lot of work (obviously). Please note that we start with
    rules for relative non-experts. Real experts must wait a bit; contributions are
    welcome, but please think about the majority of programmers who are struggling
    to get their concurrent programs correct and performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concurrency and parallelism rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CP.1: Assume that your code will run as part of a multi-threaded program](#rconc-multi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.2: Avoid data races](#rconc-races)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.3: Minimize explicit sharing of writable data](#rconc-data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.4: Think in terms of tasks, rather than threads](#rconc-task)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.8: Don’t try to use `volatile` for synchronization](#rconc-volatile)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.9: Whenever feasible use tools to validate your concurrent code](#rconc-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CP.con: Concurrency](#sscp-con)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.coro: Coroutines](#sscp-coro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.par: Parallelism](#sscp-par)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.mess: Message passing](#sscp-mess)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.vec: Vectorization](#sscp-vec)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.free: Lock-free programming](#sscp-free)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.etc: Etc. concurrency rules](#sscp-etc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.1: Assume that your code will run as part of a multi-threaded program'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s hard to be certain that concurrency isn’t used now or won’t be used sometime
    in the future. Code gets reused. Libraries not using threads might be used from
    some other part of a program that does use threads. Note that this rule applies
    most urgently to library code and least urgently to stand-alone applications.
    However, over time, code fragments can turn up in unexpected places.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: Although `cached_computation` works perfectly in a single-threaded environment,
    in a multi-threaded environment the two `static` variables result in data races
    and thus undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the cache is stored as member data of a `ComputationCache` object, rather
    than as shared static state. This refactoring essentially delegates the concern
    upward to the caller: a single-threaded program might still choose to have one
    global `ComputationCache`, while a multi-threaded program might have one `ComputationCache`
    instance per thread, or one per “context” for any definition of “context.” The
    refactored function no longer attempts to manage the allocation of `cached_x`.
    In that sense, this is an application of the Single Responsibility Principle.'
  prefs: []
  type: TYPE_NORMAL
- en: In this specific example, refactoring for thread-safety also improved reusability
    in single-threaded programs. It’s not hard to imagine that a single-threaded program
    might want two `ComputationCache` instances for use in different parts of the
    program, without having them overwrite each other’s cached data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other ways one might add thread-safety to code written for
    a standard multi-threaded environment (that is, one where the only form of concurrency
    is `std::thread`):'
  prefs: []
  type: TYPE_NORMAL
- en: Mark the state variables as `thread_local` instead of `static`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement concurrency control, for example, protecting access to the two `static`
    variables with a `static std::mutex`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refuse to build and/or run in a multi-threaded environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide two implementations: one for single-threaded environments and another
    for multi-threaded environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Code that is never run in a multi-threaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful: there are many examples where code that was “known” to never run
    in a multi-threaded program was run as part of a multi-threaded program, often
    years later. Typically, such programs lead to a painful effort to remove data
    races. Therefore, code that is never intended to run in a multi-threaded environment
    should be clearly labeled as such and ideally come with compile or run-time enforcement
    mechanisms to catch those usage bugs early.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.2: Avoid data races'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unless you do, nothing is guaranteed to work and subtle errors will persist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a nutshell, if two threads can access the same object concurrently (without
    synchronization), and at least one is a writer (performing a non-`const` operation),
    you have a data race. For further information of how to use synchronization well
    to eliminate data races, please consult a good book about concurrency (see [Carefully
    study the literature](#rconc-literature)).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are many examples of data races that exist, some of which are running
    in production software at this very moment. One very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: 'The increment here is an example of a data race. This can go wrong in many
    ways, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread A loads the value of `id`, the OS context switches A out for some period,
    during which other threads create hundreds of IDs. Thread A is then allowed to
    run again, and `id` is written back to that location as A’s read of `id` plus
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread A and B load `id` and increment it simultaneously. They both get the
    same ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local static variables are a common source of data races.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example, bad:'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a (nasty) data race on the elements of `buf` (`sort` will both
    read and write). All data races are nasty. Here, we managed to get a data race
    on data on the stack. Not all data races are as easy to spot as this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example, bad:'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a compiler that does not know that `val` can change will most likely implement
    that `switch` using a jump table with five entries. Then, a `val` outside the
    `[0..4]` range will cause a jump to an address that could be anywhere in the program,
    and execution would proceed there. Really, “all bets are off” if you get a data
    race. Actually, it can be worse still: by looking at the generated code you might
    be able to determine where the stray jump will go for a given value; this can
    be a security risk.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some is possible, do at least something. There are commercial and open-source
    tools that try to address this problem, but be aware that solutions have costs
    and blind spots. Static tools often have many false positives and run-time tools
    often have a significant cost. We hope for better tools. Using multiple tools
    can catch more problems than a single one.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other ways you can mitigate the chance of data races:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid global data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `static` variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More use of concrete types on the stack (and don’t pass pointers around too
    much)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More use of immutable data (literals, `constexpr`, and `const`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.3: Minimize explicit sharing of writable data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you don’t share writable data, you can’t have a data race. The less sharing
    you do, the less chance you have to forget to synchronize access (and get data
    races). The less sharing you do, the less chance you have to wait on a lock (so
    performance can improve).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: Without those `const`s, we would have to review every asynchronously invoked
    function for potential data races on `surface_readings`. Making `surface_readings`
    be `const` (with respect to this function) allows reasoning using only the function
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Immutable data can be safely and efficiently shared. No locking is needed:
    You can’t have a data race on a constant. See also [CP.mess: Message Passing](#sscp-mess)
    and [CP.31: prefer pass by value](#rconc-data-by-value).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.4: Think in terms of tasks, rather than threads'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `thread` is an implementation concept, a way of thinking about the machine.
    A task is an application notion, something you’d like to do, preferably concurrently
    with other tasks. Application concepts are easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With the exception of `async()`, the standard-library facilities are low-level,
    machine-oriented, threads-and-lock level. This is a necessary foundation, but
    we have to try to raise the level of abstraction: for productivity, for reliability,
    and for performance. This is a potent argument for using higher level, more applications-oriented
    libraries (if possible, built on top of standard-library facilities).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.8: Don’t try to use `volatile` for synchronization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In C++, unlike some other languages, `volatile` does not provide atomicity,
    does not synchronize between threads, and does not prevent instruction reordering
    (neither compiler nor hardware). It simply has nothing to do with concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example, bad:'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a problem: This is perfectly good code in a single-threaded program,
    but have two threads execute this and there is a race condition on `free_slots`
    so that two threads might get the same value and `free_slots`. That’s (obviously)
    a bad data race, so people trained in other languages might try to fix it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: 'This has no effect on synchronization: The data race is still there!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ mechanism for this is `atomic` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Now the `--` operation is atomic, rather than a read-increment-write sequence
    where another thread might get in-between the individual operations.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use `atomic` types where you might have used `volatile` in some other language.
    Use a `mutex` for more complicated examples.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[(rare) proper uses of `volatile`](#rconc-volatile2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.9: Whenever feasible use tools to validate your concurrent code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Experience shows that concurrent code is exceptionally hard to get right and
    that compile-time checking, run-time checks, and testing are less effective at
    finding concurrency errors than they are at finding errors in sequential code.
    Subtle concurrency errors can have dramatically bad effects, including memory
    corruption, deadlocks, and security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Thread safety is challenging, often getting the better of experienced programmers:
    tooling is an important strategy to mitigate those risks. There are many tools
    “out there”, both commercial and open-source tools, both research and production
    tools. Unfortunately people’s needs and constraints differ so dramatically that
    we cannot make specific recommendations, but we can mention:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static enforcement tools: both [clang](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html)
    and some older versions of [GCC](https://gcc.gnu.org/wiki/ThreadSafetyAnnotation)
    have some support for static annotation of thread safety properties. Consistent
    use of this technique turns many classes of thread-safety errors into compile-time
    errors. The annotations are generally local (marking a particular data member
    as guarded by a particular mutex), and are usually easy to learn. However, as
    with many static tools, it can often present false negatives; cases that should
    have been caught but were allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dynamic enforcement tools: Clang’s [Thread Sanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)
    (aka TSAN) is a powerful example of dynamic tools: it changes the build and execution
    of your program to add bookkeeping on memory access, absolutely identifying data
    races in a given execution of your binary. The cost for this is both memory (5-10x
    in most cases) and CPU slowdown (2-20x). Dynamic tools like this are best when
    applied to integration tests, canary pushes, or unit tests that operate on multiple
    threads. Workload matters: When TSAN identifies a problem, it is effectively always
    an actual data race, but it can only identify races seen in a given execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is up to an application builder to choose which support tools are valuable
    for a particular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.con: Concurrency'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section focuses on relatively ad-hoc uses of multiple threads communicating
    through shared data.
  prefs: []
  type: TYPE_NORMAL
- en: For parallel algorithms, see [parallelism](#sscp-par)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For inter-task communication without explicit sharing, see [messaging](#sscp-mess)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For vector parallel code, see [vectorization](#sscp-vec)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For lock-free programming, see [lock free](#sscp-free)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concurrency rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CP.20: Use RAII, never plain `lock()`/`unlock()`](#rconc-raii)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es](#rconc-lock)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.22: Never call unknown code while holding a lock (e.g., a callback)](#rconc-unknown)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.23: Think of a joining `thread` as a scoped container](#rconc-join)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.24: Think of a `thread` as a global container](#rconc-detach)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.25: Prefer `gsl::joining_thread` over `std::thread`](#rconc-joining_thread)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.26: Don’t `detach()` a thread](#rconc-detached_thread)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.31: Pass small amounts of data between threads by value, rather than by
    reference or pointer](#rconc-data-by-value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.32: To share ownership between unrelated `thread`s use `shared_ptr`](#rconc-shared)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.40: Minimize context switching](#rconc-switch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.41: Minimize thread creation and destruction](#rconc-create)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.42: Don’t `wait` without a condition](#rconc-wait)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.43: Minimize time spent in a critical section](#rconc-time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.44: Remember to name your `lock_guard`s and `unique_lock`s](#rconc-name)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>`
    where possible](#rconc-mutex)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? when to use a spinlock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? when to use `try_lock()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? when to prefer `lock_guard` over `unique_lock`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? Time multiplexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? when/how to use `new thread`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.20: Use RAII, never plain `lock()`/`unlock()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoids nasty errors from unreleased locks.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Sooner or later, someone will forget the `mtx.unlock()`, place a `return` in
    the `... do stuff ...`, throw an exception, or something.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag calls of member `lock()` and `unlock()`. ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid deadlocks on multiple `mutex`es.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is asking for deadlock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use `lock()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: 'or (better, but C++17 only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: Here, the writers of `thread1` and `thread2` are still not agreeing on the order
    of the `mutex`es, but order no longer matters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In real code, `mutex`es are rarely named to conveniently remind the programmer
    of an intended relation and intended order of acquisition. In real code, `mutex`es
    are not always conveniently acquired on consecutive lines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In C++17 it’s possible to write plain
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: and have the `mutex` type deduced.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Detect the acquisition of multiple `mutex`es. This is undecidable in general,
    but catching common simple examples (like the one above) is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.22: Never call unknown code while holding a lock (e.g., a callback)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you don’t know what a piece of code does, you are risking deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t know what `Foo::act` does (maybe it is a virtual function invoking
    a derived class member of a class not yet written), it might call `do_this` (recursively)
    and cause a deadlock on `my_mutex`. Maybe it will lock on a different mutex and
    not return in a reasonable time, causing delays to any code calling `do_this`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A common example of the “calling unknown code” problem is a call to a function
    that tries to gain locked access to the same object. Such problem can often be
    solved by using a `recursive_mutex`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: If, as it is likely, `f()` invokes operations on `*this`, we must make sure
    that the object’s invariant holds before the call.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag calling a virtual function with a non-recursive `mutex` held
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag calling a callback with a non-recursive `mutex` held
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.23: Think of a joining `thread` as a scoped container'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To maintain pointer safety and avoid leaks, we need to consider what pointers
    are used by a `thread`. If a `thread` joins, we can safely pass pointers to objects
    in the scope of the `thread` and its enclosing scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: A `gsl::joining_thread` is a `std::thread` with a destructor that joins and
    that cannot be `detached()`. By “OK” we mean that the object will be in scope
    (“live”) for as long as a `thread` can use the pointer to it. The fact that `thread`s
    run concurrently doesn’t affect the lifetime or ownership issues here; these `thread`s
    can be seen as just a function object called from `some_fct`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ensure that `joining_thread`s don’t `detach()`. After that, the usual lifetime
    and ownership (for local objects) enforcement applies.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.24: Think of a `thread` as a global container'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To maintain pointer safety and avoid leaks, we need to consider what pointers
    are used by a `thread`. If a `thread` is detached, we can safely pass pointers
    to static and free store objects (only).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: By “OK” we mean that the object will be in scope (“live”) for as long as a `thread`
    can use the pointers to it. By “bad” we mean that a `thread` might use a pointer
    after the pointed-to object is destroyed. The fact that `thread`s run concurrently
    doesn’t affect the lifetime or ownership issues here; these `thread`s can be seen
    as just a function object called from `some_fct`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Even objects with static storage duration can be problematic if used from detached
    threads: if the thread continues until the end of the program, it might be running
    concurrently with the destruction of objects with static storage duration, and
    thus accesses to such objects might race.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule is redundant if you [don’t `detach()`](#rconc-detached_thread) and
    [use `gsl::joining_thread`](#rconc-joining_thread). However, converting code to
    follow those guidelines could be difficult and even impossible for third-party
    libraries. In such cases, the rule becomes essential for lifetime safety and type
    safety.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is undecidable whether a `detach()` is executed for a `thread`,
    but simple common cases are easily detected. If we cannot prove that a `thread`
    does not `detach()`, we must assume that it does and that it outlives the scope
    in which it was constructed; after that, the usual lifetime and ownership (for
    global objects) enforcement applies.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag attempts to pass local variables to a thread that might `detach()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.25: Prefer `gsl::joining_thread` over `std::thread`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `joining_thread` is a thread that joins at the end of its scope. Detached
    threads are hard to monitor. It is harder to ensure absence of errors in detached
    threads (and potentially detached threads).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Make “immortal threads” globals, put them in an enclosing scope, or put them
    on the free store rather than `detach()`. [Don’t `detach`](#rconc-detached_thread).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because of old code and third party libraries using `std::thread`, this rule
    can be hard to introduce.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag uses of `std::thread`:'
  prefs: []
  type: TYPE_NORMAL
- en: Suggest use of `gsl::joining_thread` or C++20 `std::jthread`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggest [“exporting ownership”](#rconc-detached_thread) to an enclosing scope
    if it detaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warn if it is not obvious whether a thread joins or detaches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.26: Don’t `detach()` a thread'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Often, the need to outlive the scope of its creation is inherent in the `thread`s
    task, but implementing that idea by `detach` makes it harder to monitor and communicate
    with the detached thread. In particular, it is harder (though not impossible)
    to ensure that the thread completed as expected or lives for as long as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: This is a reasonable use of a thread, for which `detach()` is commonly used.
    There are problems, though. How do we monitor the detached thread to see if it
    is alive? Something might go wrong with the heartbeat, and losing a heartbeat
    can be very serious in a system for which it is needed. So, we need to communicate
    with the heartbeat thread (e.g., through a stream of messages or notification
    events using a `condition_variable`).
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative, and usually superior solution is to control its lifetime by
    placing it in a scope outside its point of creation (or activation). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: This heartbeat will (barring error, hardware problems, etc.) run for as long
    as the program does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to separate the point of creation from the point of ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Flag `detach()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.31: Pass small amounts of data between threads by value, rather than by
    reference or pointer'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A small amount of data is cheaper to copy and access than to share it using
    some locking mechanism. Copying naturally gives unique ownership (simplifies code)
    and eliminates the possibility of data races.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Defining “small amount” precisely is impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: The call of `modify1` involves copying two `string` values; the call of `modify2`
    does not. On the other hand, the implementation of `modify1` is exactly as we
    would have written it for single-threaded code, whereas the implementation of
    `modify2` will need some form of locking to avoid data races. If the string is
    short (say 10 characters), the call of `modify1` can be surprisingly fast; essentially
    all the cost is in the `thread` switch. If the string is long (say 1,000,000 characters),
    copying it twice is probably not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this argument has nothing to do with `async` as such. It applies equally
    to considerations about whether to use message passing or shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.32: To share ownership between unrelated `thread`s use `shared_ptr`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If threads are unrelated (that is, not known to be in the same scope or one
    within the lifetime of the other) and they need to share free store memory that
    needs to be deleted, a `shared_ptr` (or equivalent) is the only safe way to ensure
    proper deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A static object (e.g. a global) can be shared because it is not owned in the
    sense that some thread is responsible for its deletion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object on free store that is never to be deleted can be shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object owned by one thread can be safely shared with another as long as that
    second thread doesn’t outlive the owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.40: Minimize context switching'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Context switches are expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.41: Minimize thread creation and destruction'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Thread creation is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: This spawns a `thread` per message, and the `run_list` is presumably managed
    to destroy those tasks once they are finished.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we could have a set of pre-created worker threads processing the messages
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If your system has a good thread pool, use it. If your system has a good message
    queue, use it.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.42: Don’t `wait` without a condition'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `wait` without a condition can miss a wakeup or wake up simply to find that
    there is no work to do.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: Here, if some other `thread` consumes `thread1`’s notification, `thread2` can
    wait forever.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: Now if the queue is empty when a thread executing `get()` wakes up (e.g., because
    another thread has gotten to `get()` before it), it will immediately go back to
    sleep, waiting.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all `wait`s without conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.43: Minimize time spent in a critical section'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The less time is spent with a `mutex` taken, the less chance that another `thread`
    has to wait, and `thread` suspension and resumption are expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are holding the lock for longer than necessary: We should not have
    taken the lock before we needed it and should have released it again before starting
    the cleanup. We could rewrite this to'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'But that compromises safety and violates the [use RAII](#rconc-raii) rule.
    Instead, add a block for the critical section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Impossible in general. Flag “naked” `lock()` and `unlock()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.44: Remember to name your `lock_guard`s and `unique_lock`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An unnamed local object is a temporary that immediately goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: This looks innocent enough, but it isn’t. At (A), `m1` is a default-constructed
    local `unique_lock`, which shadows the global `::m1` (and does not lock it). At
    (B) an unnamed temporary `lock_guard` is constructed and locks `::m2`, but immediately
    goes out of scope and unlocks `::m2` again. For the rest of the function `f()`
    neither mutex is locked.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all unnamed `lock_guard`s and `unique_lock`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>`
    where possible'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It should be obvious to a reader that the data is to be guarded and how. This
    decreases the chance of the wrong mutex being locked, or the mutex not being locked.
  prefs: []
  type: TYPE_NORMAL
- en: Using a `synchronized_value<T>` ensures that the data has a mutex, and the right
    mutex is locked when the data is accessed. See the [WG21 proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0290r4.html)
    to add `synchronized_value` to a future TS or revision of the C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? Possible?
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.coro: Coroutines'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section focuses on uses of coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coroutine rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CP.51: Do not use capturing lambdas that are coroutines](#rcoro-capture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.52: Do not hold locks or other synchronization primitives across suspension
    points](#rcoro-locks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.53: Parameters to coroutines should not be passed by reference](#rcoro-reference-parameters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.51: Do not use capturing lambdas that are coroutines'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Usage patterns that are correct with normal lambdas are hazardous with coroutine
    lambdas. The obvious pattern of capturing variables will result in accessing freed
    memory after the first suspension point, even for refcounted smart pointers and
    copyable types.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda results in a closure object with storage, often on the stack, that
    will go out of scope at some point. When the closure object goes out of scope
    the captures will also go out of scope. Normal lambdas will have finished executing
    by this time so it is not a problem. Coroutine lambdas may resume from suspension
    after the closure object has destructed and at that point all captures will be
    use-after-free memory access.
  prefs: []
  type: TYPE_NORMAL
- en: Example, Bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: Example, Better
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: Example, Best
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use a function for coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a lambda that is a coroutine and has a non-empty capture list.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.52: Do not hold locks or other synchronization primitives across suspension
    points'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This pattern creates a significant risk of deadlocks. Some types of waits will
    allow the current thread to perform additional work until the asynchronous operation
    has completed. If the thread holding the lock performs work that requires the
    same lock then it will deadlock because it is trying to acquire a lock that it
    is already holding.
  prefs: []
  type: TYPE_NORMAL
- en: If the coroutine completes on a different thread from the thread that acquired
    the lock then that is undefined behavior. Even with an explicit return to the
    original thread an exception might be thrown before coroutine resumes and the
    result will be that the lock guard is not destructed.
  prefs: []
  type: TYPE_NORMAL
- en: Example, Bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Example, Good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This pattern is also bad for performance. When a suspension point is reached,
    such as co_await, execution of the current function stops and other code begins
    to run. It may be a long period of time before the coroutine resumes. For that
    entire duration the lock will be held and cannot be acquired by other threads
    to perform work.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all lock guards that are not destructed before a coroutine suspends.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.53: Parameters to coroutines should not be passed by reference'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once a coroutine reaches the first suspension point, such as a co_await, the
    synchronous portion returns. After that point any parameters passed by reference
    are dangling. Any usage beyond that is undefined behavior which may include writing
    to freed memory.
  prefs: []
  type: TYPE_NORMAL
- en: Example, Bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: Example, Good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This problem does not apply to reference parameters that are only accessed before
    the first suspension point. Subsequent changes to the function may add or move
    suspension points which would reintroduce this class of bug. Some types of coroutines
    have the suspension point before the first line of code in the coroutine executes,
    in which case reference parameters are always unsafe. It is safer to always pass
    by value because the copied parameter will live in the coroutine frame that is
    safe to access throughout the coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The same danger applies to output parameters. [F.20: For “out” output values,
    prefer return values to output parameters](#rf-out) discourages output parameters.
    Coroutines should avoid them entirely.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all reference parameters to a coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.par: Parallelism'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By “parallelism” we refer to performing a task (more or less) simultaneously
    (“in parallel with”) on many data items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallelism rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where appropriate, prefer the standard-library parallel algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use algorithms that are designed for parallelism, not algorithms with unnecessary
    dependency on linear evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.mess: Message passing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard-library facilities are quite low-level, focused on the needs of
    close-to-the-hardware critical programming using `thread`s, `mutex`es, `atomic`
    types, etc. Most people shouldn’t work at this level: it’s error-prone and development
    is slow. If possible, use a higher level facility: messaging libraries, parallel
    algorithms, and vectorization. This section looks at passing messages so that
    a programmer doesn’t have to do explicit synchronization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message passing rules summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CP.60: Use a `future` to return a value from a concurrent task](#rconc-future)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.61: Use `async()` to spawn concurrent tasks](#rconc-async)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: messaging libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???? should there be a “use X rather than `std::async`” where X is something
    that would use a better specified thread pool?
  prefs: []
  type: TYPE_NORMAL
- en: ??? Is `std::async` worth using in light of future (and even existing, as libraries)
    parallelism facilities? What should the guidelines recommend if someone wants
    to parallelize, e.g., `std::accumulate` (with the additional precondition of commutativity),
    or merge sort?
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.60: Use a `future` to return a value from a concurrent task'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `future` preserves the usual function call return semantics for asynchronous
    tasks. There is no explicit locking and both correct (value) return and error
    (exception) return are handled simply.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.61: Use `async()` to spawn concurrent tasks'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Similar to [R.12](#rr-immediate-alloc), which tells you to avoid raw owning
    pointers, you should also avoid raw threads and raw promises where possible. Use
    a factory function such as `std::async`, which handles spawning or reusing a thread
    without exposing raw threads to your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unfortunately, `std::async` is not perfect. For example, it doesn’t use a thread
    pool, which means that it might fail due to resource exhaustion, rather than queuing
    up your tasks to be executed later. However, even if you cannot use `std::async`,
    you should prefer to write your own `future`-returning factory function, rather
    than using raw promises.
  prefs: []
  type: TYPE_NORMAL
- en: Example (bad)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This example shows two different ways to succeed at using `std::future`, but
    to fail at avoiding raw `std::thread` management.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: Example (good)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This example shows one way you could follow the general pattern set by `std::async`,
    in a context where `std::async` itself was unacceptable for use in production.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: Any threads spawned to execute the code of `read_value` are hidden behind the
    call to `WorkQueue::enqueue`. The user code deals only with `future` objects,
    never with raw `thread`, `promise`, or `packaged_task` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.vec: Vectorization'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vectorization is a technique for executing a number of tasks concurrently without
    introducing explicit synchronization. An operation is simply applied to elements
    of a data structure (a vector, an array, etc.) in parallel. Vectorization has
    the interesting property of often requiring no non-local changes to a program.
    However, vectorization works best with simple data structures and with algorithms
    specifically crafted to enable it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vectorization rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.free: Lock-free programming'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Synchronization using `mutex`es and `condition_variable`s can be relatively
    expensive. Furthermore, it can lead to deadlock. For performance and to eliminate
    the possibility of deadlock, we sometimes have to use the tricky low-level “lock-free”
    facilities that rely on briefly gaining exclusive (“atomic”) access to memory.
    Lock-free programming is also used to implement higher-level concurrency mechanisms,
    such as `thread`s and `mutex`es.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lock-free programming rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CP.100: Don’t use lock-free programming unless you absolutely have to](#rconc-lockfree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.101: Distrust your hardware/compiler combination](#rconc-distrust)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.102: Carefully study the literature](#rconc-literature)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how/when to use atomics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: avoid starvation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use a lock-free data structure rather than hand-crafting specific lock-free
    access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.110: Do not write your own double-checked locking for initialization](#rconc-double)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.111: Use a conventional pattern if you really need double-checked locking](#rconc-double-pattern)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how/when to compare and swap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.100: Don’t use lock-free programming unless you absolutely have to'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s error-prone and requires expert level knowledge of language features, machine
    architecture, and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: Spot the bug. It would be really hard to find through testing. Read up on the
    ABA problem.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Atomic variables](#???) can be used simply and safely, as long as you are
    using the sequentially consistent memory model (memory_order_seq_cst), which is
    the default.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Higher-level concurrency mechanisms, such as `thread`s and `mutex`es are implemented
    using lock-free programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Use lock-free data structures implemented by others as part
    of some library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.101: Distrust your hardware/compiler combination'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The low-level hardware interfaces used by lock-free programming are among the
    hardest to implement well and among the areas where the most subtle portability
    problems occur. If you are doing lock-free programming for performance, you need
    to check for regressions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Instruction reordering (static and dynamic) makes it hard for us to think effectively
    at this level (especially if you use relaxed memory models). Experience, (semi)formal
    models and model checking can be useful. Testing - often to an extreme extent
    - is essential. “Don’t fly too close to the sun.”
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Have strong rules for re-testing in place that covers any change in hardware,
    operating system, compiler, and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.102: Carefully study the literature'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With the exception of atomics and a few other standard patterns, lock-free programming
    is really an expert-only topic. Become an expert before shipping lock-free code
    for others to use.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Anthony Williams: C++ concurrency in action. Manning Publications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boehm, Adve, You Don’t Know Jack About Shared Variables or Memory Models, Communications
    of the ACM, Feb 2012.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boehm, “Threads Basics”, HPL TR 2009-259.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adve, Boehm, “Memory Models: A Case for Rethinking Parallel Languages and Hardware”,
    Communications of the ACM, August 2010.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boehm, Adve, “Foundations of the C++ Concurrency Memory Model”, PLDI 08.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, “Mathematizing
    C++ Concurrency”, POPL 2011.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and
    Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs.
    13th IEEE Computer Society ISORC 2010 Symposium. May 2010.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects
    for Mission Critical Code. ACM OOPSLA’09\. October 2009'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup:
    Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th
    Annual IEEE International Conference and Workshop on the Engineering of Computer
    Based Systems (IEEE ECBS). April 2009.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maurice Herlihy, Nir Shavit, Victor Luchangco, Michael Spear, “The Art of Multiprocessor
    Programming”, 2nd ed. September 2020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.110: Do not write your own double-checked locking for initialization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since C++11, static local variables are now initialized in a thread-safe way.
    When combined with the RAII pattern, static local variables can replace the need
    for writing your own double-checked locking for initialization. std::call_once
    can also achieve the same purpose. Use either static local variables of C++11
    or std::call_once instead of writing your own double-checked locking for initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Example with std::call_once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Example with thread-safe static local variables of C++11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? Is it possible to detect the idiom?
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.111: Use a conventional pattern if you really need double-checked locking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Double-checked locking is easy to mess up. If you really need to write your
    own double-checked locking, in spite of the rules [CP.110: Do not write your own
    double-checked locking for initialization](#rconc-double) and [CP.100: Don’t use
    lock-free programming unless you absolutely have to](#rconc-lockfree), then do
    it in a conventional pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The uses of the double-checked locking pattern that are not in violation of
    [CP.110: Do not write your own double-checked locking for initialization](#rconc-double)
    arise when a non-thread-safe action is both hard and rare, and there exists a
    fast thread-safe test that can be used to guarantee that the action is not needed,
    but cannot be used to guarantee the converse.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The use of volatile does not make the first check thread-safe, see also [CP.200:
    Use `volatile` only to talk to non-C++ memory](#rconc-volatile2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: Fine-tuned memory order might be beneficial where acquire load is more efficient
    than sequentially-consistent load
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? Is it possible to detect the idiom?
  prefs: []
  type: TYPE_NORMAL
- en: 'CP.etc: Etc. concurrency rules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These rules defy simple categorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CP.200: Use `volatile` only to talk to non-C++ memory](#rconc-volatile2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CP.201: ??? Signals](#rconc-signal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.200: Use `volatile` only to talk to non-C++ memory'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`volatile` is used to refer to objects that are shared with “non-C++” code
    or hardware that does not follow the C++ memory model.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: 'This describes a register constantly updated by a clock circuit. `clock` is
    `volatile` because its value will change without any action from the C++ program
    that uses it. For example, reading `clock` twice will often yield two different
    values, so the optimizer had better not optimize away the second read in this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '`clock` is `const` because the program should not try to write to `clock`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unless you are writing the lowest level code manipulating hardware directly,
    consider `volatile` an esoteric feature that is best avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Usually C++ code receives `volatile` memory that is owned elsewhere (hardware
    or another language):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes C++ code allocates the `volatile` memory and shares it with “elsewhere”
    (hardware or another language) by deliberately escaping a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`volatile` local variables are nearly always wrong – how can they be shared
    with other languages or hardware if they’re ephemeral? The same applies almost
    as strongly to data members, for the same reason.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In C++, unlike in some other languages, `volatile` has [nothing to do with synchronization](#rconc-volatile).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `volatile T` local and data members; almost certainly you intended to use
    `atomic<T>` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CP.201: ??? Signals'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???UNIX signal handling???. Might be worth reminding how little is async-signal-safe,
    and how to communicate with a signal handler (best is probably “not at all”)
  prefs: []
  type: TYPE_NORMAL
- en: 'E: Error handling'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error handling involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transmitting information about an error to some handler code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving a valid state of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding resource leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to recover from all errors. If recovery from an error is
    not possible, it is important to quickly “get out” in a well-defined way. A strategy
    for error handling must be simple, or it becomes a source of even worse errors.
    Untested and rarely executed error-handling code is itself the source of many
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules are designed to help avoid several kinds of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Type violations (e.g., misuse of `union`s and casts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource leaks (including memory leaks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounds errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetime errors (e.g., accessing an object after it has been `delete`d)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity errors (logical errors made likely by overly complex expression of
    ideas)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface errors (e.g., an unexpected value is passed through an interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Error-handling rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[E.1: Develop an error-handling strategy early in a design](#re-design)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.2: Throw an exception to signal that a function can’t perform its assigned
    task](#re-throw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.3: Use exceptions for error handling only](#re-errors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.4: Design your error-handling strategy around invariants](#re-design-invariants)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.5: Let a constructor establish an invariant, and throw if it cannot](#re-invariant)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.6: Use RAII to prevent leaks](#re-raii)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.7: State your preconditions](#re-precondition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.8: State your postconditions](#re-postcondition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.12: Use `noexcept` when exiting a function because of a `throw` is impossible
    or unacceptable](#re-noexcept)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.13: Never throw while being the direct owner of an object](#re-never-throw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.14: Use purpose-designed user-defined types as exceptions (not built-in
    types)](#re-exception-types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.15: Throw by value, catch exceptions from a hierarchy by reference](#re-exception-ref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.16: Destructors, deallocation, `swap`, and exception type copy/move construction
    must never fail](#re-never-fail)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.17: Don’t try to catch every exception in every function](#re-not-always)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.18: Minimize the use of explicit `try`/`catch`](#re-catch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.19: Use a `final_action` object to express cleanup if no suitable resource
    handle is available](#re-finally)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.25: If you can’t throw exceptions, simulate RAII for resource management](#re-no-throw-raii)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.26: If you can’t throw exceptions, consider failing fast](#re-no-throw-crash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.27: If you can’t throw exceptions, use error codes systematically](#re-no-throw-codes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.28: Avoid error handling based on global state (e.g. `errno`)](#re-no-throw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.30: Don’t use exception specifications](#re-specifications)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[E.31: Properly order your `catch`-clauses](#re_catch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.1: Develop an error-handling strategy early in a design'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A consistent and complete strategy for handling errors and resource leaks is
    hard to retrofit into a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.2: Throw an exception to signal that a function can’t perform its assigned
    task'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make error handling systematic, robust, and non-repetitive.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: Here, `vector` and `string`s constructors might not be able to allocate sufficient
    memory for their elements, `vector`s constructor might not be able to copy the
    `Thing`s in its initializer list, and `File_handle` might not be able to open
    the required file. In each case, they throw an exception for `use()`’s caller
    to handle. If `use()` could handle the failure to construct `bar` it can take
    control using `try`/`catch`. In either case, `Foo`’s constructor correctly destroys
    constructed members before passing control to whatever tried to create a `Foo`.
    Note that there is no return value that could contain an error code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `File_handle` constructor might be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It is often said that exceptions are meant to signal exceptional events and
    failures. However, that’s a bit circular because “what is exceptional?” Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A precondition that cannot be met
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that cannot construct an object (failure to establish its class’s
    [invariant](#rc-struct))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An out-of-range error (e.g., `v[v.size()] = 7`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inability to acquire a resource (e.g., the network is down)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, termination of an ordinary loop is not exceptional. Unless the
    loop was meant to be infinite, termination is normal and expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Don’t use a `throw` as simply an alternative way of returning a value from a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some systems, such as hard-real-time systems require a guarantee that an action
    is taken in a (typically short) constant maximum time known before execution starts.
    Such systems can use exceptions only if there is tool support for accurately predicting
    the maximum time to recover from a `throw`.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [RAII](#re-raii)'
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [discussion](#sd-noexcept)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before deciding that you cannot afford or don’t like exception-based error handling,
    have a look at the [alternatives](#re-no-throw-raii); they have their own complexities
    and problems. Also, as far as possible, measure before making claims about efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.3: Use exceptions for error handling only'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To keep error handling separated from “ordinary code.” C++ implementations tend
    to be optimized based on the assumption that exceptions are rare.
  prefs: []
  type: TYPE_NORMAL
- en: Example, don’t
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: This is more complicated and most likely runs much slower than the obvious alternative.
    There is nothing exceptional about finding a value in a `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Would need to be heuristic. Look for exception values “leaked” out of `catch`
    clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.4: Design your error-handling strategy around invariants'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To use an object it must be in a valid state (defined formally or informally
    by an invariant) and to recover from an error every object not destroyed must
    be in a valid state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An [invariant](#rc-struct) is a logical condition for the members of an object
    that a constructor must establish for the public member functions to assume.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'E.5: Let a constructor establish an invariant, and throw if it cannot'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Leaving an object without its invariant established is asking for trouble. Not
    all member functions can be called.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: The class invariant - here stated as a comment - is established by the constructors.
    `new` throws if it cannot allocate the required memory. The operators, notably
    the subscript operator, rely on the invariant.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [If a constructor cannot construct a valid object, throw an exception](#rc-throw)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag classes with `private` state without a constructor (public, protected,
    or private).
  prefs: []
  type: TYPE_NORMAL
- en: 'E.6: Use RAII to prevent leaks'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Leaks are typically unacceptable. Manual resource release is error-prone. RAII
    (“Resource Acquisition Is Initialization”) is the simplest, most systematic way
    of preventing leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: 'We could carefully release the resource before the throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: This is verbose. In larger code with multiple possible `throw`s explicit releases
    become repetitive and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this works even when the `throw` is implicit because it happened
    in a called function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you really need pointer semantics, use a local resource object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: That’s even simpler and safer, and often more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If there is no obvious resource handle and for some reason defining a proper
    RAII object/handle is infeasible, as a last resort, cleanup actions can be represented
    by a [`final_action`](#re-finally) object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'But what do we do if we are writing a program where exceptions cannot be used?
    First challenge that assumption; there are many anti-exceptions myths around.
    We know of only a few good reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We are on a system so small that the exception support would eat up most of
    our 2K memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are in a hard-real-time system and we don’t have tools that guarantee us
    that an exception is handled within the required time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are in a system with tons of legacy code using lots of pointers in difficult-to-understand
    ways (in particular without a recognizable ownership strategy) so that exceptions
    could cause leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our implementation of the C++ exception mechanisms is unreasonably poor (slow,
    memory consuming, failing to work correctly for dynamically linked libraries,
    etc.). Complain to your implementation purveyor; if no user complains, no improvement
    will happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get fired if we challenge our manager’s ancient wisdom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only the first of these reasons is fundamental, so whenever possible, use exceptions
    to implement RAII, or design your RAII objects to never fail. When exceptions
    cannot be used, simulate RAII. That is, systematically check that objects are
    valid after construction and still release all resources in the destructor. One
    strategy is to add a `valid()` operation to every resource handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this increases the size of the code, doesn’t allow for implicit propagation
    of “exceptions” (`valid()` checks), and `valid()` checks can be forgotten. Prefer
    to use exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Use of `noexcept`](#re-noexcept)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'E.7: State your preconditions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid interface errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [precondition rule](#ri-pre)'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.8: State your postconditions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid interface errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [postcondition rule](#ri-post)'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.12: Use `noexcept` when exiting a function because of a `throw` is impossible
    or unacceptable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To make error handling systematic, robust, and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Here, we know that `compute` will not throw because it is composed out of operations
    that don’t throw. By declaring `compute` to be `noexcept`, we give the compiler
    and human readers information that can make it easier for them to understand and
    manipulate `compute`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many standard-library functions are `noexcept` including all the standard-library
    functions “inherited” from the C Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: The `noexcept` here states that I am not willing or able to handle the situation
    where I cannot construct the local `vector`. That is, I consider memory exhaustion
    a serious design error (on par with hardware failures) so that I’m willing to
    crash the program if it happens.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not use traditional [exception-specifications](#re-specifications).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[discussion](#sd-noexcept).'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.13: Never throw while being the direct owner of an object'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That would be a leak.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'One way of avoiding such problems is to use resource handles consistently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'Another solution (often better) would be to use a local variable to eliminate
    explicit use of pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you have a local “thing” that requires cleanup, but is not represented by
    an object with a destructor, such cleanup must also be done before a `throw`.
    Sometimes, [`finally()`](#re-finally) can make such unsystematic cleanup a bit
    more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.14: Use purpose-designed user-defined types as exceptions (not built-in types)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A user-defined type can better transmit information about an error to a handler.
    Information can be encoded into the type itself and the type is unlikely to clash
    with other people’s exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'Deriving from `std::exception` gives the flexibility to catch the specific
    exception or handle generally through `std::exception`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'Exceptions do not need to be derived from `std::exception`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'Library types derived from `std::exception` can be used as generic exceptions
    if no useful information can be added at the point of detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '`enum` classes are also allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Catch `throw` of built-in types and `std::exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.15: Throw by value, catch exceptions from a hierarchy by reference'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Throwing by value (not by pointer) and catching by reference prevents copying,
    especially slicing base subobjects.
  prefs: []
  type: TYPE_NORMAL
- en: Example; bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: 'or - typically better still - a `const` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: Most handlers do not modify their exception and in general we [recommend use
    of `const`](#res-const).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Catch by value can be appropriate for a small value type such as an `enum` value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To rethrow a caught exception use `throw;` not `throw e;`. Using `throw e;`
    would throw a new copy of `e` (sliced to the static type `std::exception`, when
    the exception is caught by `catch (const std::exception& e)`) instead of rethrowing
    the original exception of type `std::runtime_error`. (But keep [Don’t try to catch
    every exception in every function](#re-not-always) and [Minimize the use of explicit
    `try`/`catch`](#re-catch) in mind.)
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag catching by value of a type that has a virtual function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag throwing raw pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.16: Destructors, deallocation, `swap`, and exception type copy/move construction
    must never fail'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We don’t know how to write reliable programs if a destructor, a swap, a memory
    deallocation, or attempting to copy/move-construct an exception object fails;
    that is, if it exits by an exception or simply doesn’t perform its required action.
  prefs: []
  type: TYPE_NORMAL
- en: Example, don’t
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many have tried to write reliable code violating this rule for examples, such
    as a network connection that “refuses to close”. To the best of our knowledge
    nobody has found a general way of doing this. Occasionally, for very specific
    examples, you can get away with setting some state for future cleanup. For example,
    we might put a socket that does not want to close on a “bad socket” list, to be
    examined by a regular sweep of the system state. Every example we have seen of
    this is error-prone, specialized, and often buggy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The standard library assumes that destructors, deallocation functions (e.g.,
    `operator delete`), and `swap` do not throw. If they do, basic standard-library
    invariants are broken.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Deallocation functions, including `operator delete`, must be `noexcept`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap` functions must be `noexcept`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most destructors are implicitly `noexcept` by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, [make move operations `noexcept`](#rc-move-noexcept).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If writing a type intended to be used as an exception type, ensure its copy
    constructor is `noexcept`. In general we cannot mechanically enforce this, because
    we do not know whether a type is intended to be used as an exception type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try not to `throw` a type whose copy constructor is not `noexcept`. In general
    we cannot mechanically enforce this, because even `throw std::string(...)` could
    throw but does not in practice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Catch destructors, deallocation operations, and `swap`s that `throw`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch such operations that are not `noexcept`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**: [discussion](#sd-never-fail)'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.17: Don’t try to catch every exception in every function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Catching an exception in a function that cannot take a meaningful recovery action
    leads to complexity and waste. Let an exception propagate until it reaches a function
    that can handle it. Let cleanup actions on the unwinding path be handled by [RAII](#re-raii).
  prefs: []
  type: TYPE_NORMAL
- en: Example, don’t
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag nested try-blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flag source code files with a too high ratio of try-blocks to functions. (???
    Problem: define “too high”)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'E.18: Minimize the use of explicit `try`/`catch`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`try`/`catch` is verbose and non-trivial uses are error-prone. `try`/`catch`
    can be a sign of unsystematic and/or low-level resource management or error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, Bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is messy. There could be a leak from the naked pointer in the `try`
    block. Not all exceptions are handled. `deleting` an object that failed to construct
    is almost certainly a mistake. Better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: Alternatives
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: proper resource handles and [RAII](#re-raii)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`finally`](#re-finally)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? hard, needs a heuristic
  prefs: []
  type: TYPE_NORMAL
- en: 'E.19: Use a `final_action` object to express cleanup if no suitable resource
    handle is available'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`finally` from the [GSL](#gsl-guidelines-support-library) is less verbose and
    harder to get wrong than `try`/`catch`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`finally` is not as messy as `try`/`catch`, but it is still ad-hoc. Prefer
    [proper resource management objects](#re-raii). Consider `finally` a last resort.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use of `finally` is a systematic and reasonably clean alternative to the old
    [`goto exit;` technique](#re-no-throw-codes) for dealing with cleanup where resource
    management is not systematic.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Heuristic: Detect `goto exit;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.25: If you can’t throw exceptions, simulate RAII for resource management'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Even without exceptions, [RAII](#re-raii) is usually the best and most systematic
    way of dealing with resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Error handling using exceptions is the only complete and systematic way of handling
    non-local errors in C++. In particular, non-intrusively signaling failure to construct
    an object requires an exception. Signaling errors in a way that cannot be ignored
    requires exceptions. If you can’t use exceptions, simulate their use as best you
    can.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of fear of exceptions is misguided. When used for exceptional circumstances
    in code that is not littered with pointers and complicated control structures,
    exception handling is almost always affordable (in time and space) and almost
    always leads to better code. This, of course, assumes a good implementation of
    the exception handling mechanisms, which is not available on all systems. There
    are also cases where the problems above do not apply, but exceptions cannot be
    used for other reasons. Some hard-real-time systems are an example: An operation
    has to be completed within a fixed time with an error or a correct answer. In
    the absence of appropriate time estimation tools, this is hard to guarantee for
    exceptions. Such systems (e.g. flight control software) typically also ban the
    use of dynamic (heap) memory.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the primary guideline for error handling is “use exceptions and [RAII](#re-raii).”
    This section deals with the cases where you either do not have an efficient implementation
    of exceptions, or have such a rat’s nest of old-style code (e.g., lots of pointers,
    ill-defined ownership, and lots of unsystematic error handling based on tests
    of error codes) that it is infeasible to introduce simple and systematic exception
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Before condemning exceptions or complaining too much about their cost, consider
    examples of the use of [error codes](#re-no-throw-codes). Consider the cost and
    complexity of the use of error codes. If performance is your worry, measure.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Assume you wanted to write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `gadget` isn’t correctly constructed, `func` exits with an exception.
    If we cannot throw an exception, we can simulate this RAII style of resource handling
    by adding a `valid()` member function to `Gadget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: The problem is of course that the caller now has to remember to test the return
    value. To encourage doing so, consider adding a `[[nodiscard]]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Discussion](#sd-???)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Possible (only) for specific versions of this idea: e.g., test for systematic
    test of `valid()` after resource handle construction'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.26: If you can’t throw exceptions, consider failing fast'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you can’t do a good job at recovering, at least you can get out before too
    much consequential damage is done.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Simulating RAII](#re-no-throw-raii)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you cannot be systematic about error handling, consider “crashing” as a response
    to any error that cannot be handled locally. That is, if you cannot recover from
    an error in the context of the function that detected it, call `abort()`, `quick_exit()`,
    or a similar function that will trigger some sort of system restart.
  prefs: []
  type: TYPE_NORMAL
- en: In systems where you have lots of processes and/or lots of computers, you need
    to expect and handle fatal crashes anyway, say from hardware failures. In such
    cases, “crashing” is simply leaving error handling to the next level of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: Most programs cannot handle memory exhaustion gracefully anyway. This is roughly
    equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: Typically, it is a good idea to log the reason for the “crash” before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Awkward
  prefs: []
  type: TYPE_NORMAL
- en: 'E.27: If you can’t throw exceptions, use error codes systematically'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Systematic use of any error-handling strategy minimizes the chance of forgetting
    to handle an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Simulating RAII](#re-no-throw-raii)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are several issues to be addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you transmit an error indicator from out of a function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you release all resources from a function before doing an error exit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do you use as an error indicator?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In general, returning an error indicator implies returning two values: The
    result and an error indicator. The error indicator can be part of the object,
    e.g. an object can have a `valid()` indicator or a pair of values can be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: This approach fits with [simulated RAII resource management](#re-no-throw-raii).
    The `valid()` function could return an `error_indicator` (e.g. a member of an
    `error_indicator` enumeration).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'What if we cannot or do not want to modify the `Gadget` type? In that case,
    we must return a pair of values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, `std::pair` is a possible return type. Some people prefer a specific
    type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: One reason to prefer a specific return type is to have names for its members,
    rather than the somewhat cryptic `first` and `second` and to avoid confusion with
    other uses of `std::pair`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In general, you must clean up before an error exit. This can be messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'Simulating RAII can be non-trivial, especially in functions with multiple resources
    and multiple possible errors. A not uncommon technique is to gather cleanup at
    the end of the function to avoid repetition (note that the extra scope around
    `g2` is undesirable but necessary to make the `goto` version compile):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: The larger the function, the more tempting this technique becomes. `finally`
    can [ease the pain a bit](#re-finally). Also, the larger the program becomes the
    harder it is to apply an error-indicator-based error-handling strategy systematically.
  prefs: []
  type: TYPE_NORMAL
- en: We [prefer exception-based error handling](#re-throw) and recommend [keeping
    functions short](#rf-single).
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Discussion](#sd-???)'
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Returning multiple values](#rf-out-multi)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Awkward.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.28: Avoid error handling based on global state (e.g. `errno`)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Global state is hard to manage and it is easy to forget to check it. When did
    you last test the return value of `printf()`?
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Simulating RAII](#re-no-throw-raii)'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C-style error handling is based on the global variable `errno`, so it is essentially
    impossible to avoid this style completely.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Awkward.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.30: Don’t use exception specifications'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Exception specifications make error handling brittle, impose a run-time cost,
    and have been removed from the C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: If `f()` throws an exception different from `X` and `Y` the unexpected handler
    is invoked, which by default terminates. That’s OK, but say that we have checked
    that this cannot happen and `f` is changed to throw a new exception `Z`, we now
    have a crash on our hands unless we change `use()` (and re-test everything). The
    snag is that `f()` might be in a library we do not control and the new exception
    is not anything that `use()` can do anything about or is in any way interested
    in. We can change `use()` to pass `Z` through, but now `use()`’s callers probably
    need to be modified. This quickly becomes unmanageable. Alternatively, we can
    add a `try`-`catch` to `use()` to map `Z` into an acceptable exception. This,
    too, quickly becomes unmanageable. Note that changes to the set of exceptions
    often happen at the lowest level of a system (e.g., because of changes to a network
    library or some middleware), so changes “bubble up” through long call chains.
    In a large code base, this could mean that nobody could update to a new version
    of a library until the last user was modified. If `use()` is part of a library,
    it might not be possible to update it because a change could affect unknown clients.
  prefs: []
  type: TYPE_NORMAL
- en: The policy of letting exceptions propagate until they reach a function that
    potentially can handle it has proven itself over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: No. This would not be any better had exception specifications been statically
    enforced. For example, see [Stroustrup94](#Stroustrup94).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If no exception can be thrown, use [`noexcept`](#re-noexcept).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag every exception specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.31: Properly order your `catch`-clauses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`catch`-clauses are evaluated in the order they appear and one clause can hide
    another.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: If `Derived`is derived from `Base` the `Derived`-handler will never be invoked.
    The “catch everything” handler ensured that the `std::exception`-handler will
    never be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all “hiding handlers”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Con: Constants and immutability'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can’t have a race condition on a constant. It is easier to reason about
    a program when many of the objects cannot change their values. Interfaces that
    promise “no change” of objects passed as arguments greatly increase readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Con.1: By default, make objects immutable](#rconst-immutable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Con.2: By default, make member functions `const`](#rconst-fct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Con.3: By default, pass pointers and references to `const`s](#rconst-ref)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Con.4: Use `const` to define objects with values that do not change after
    construction](#rconst-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Con.5: Use `constexpr` for values that can be computed at compile time](#rconst-constexpr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con.1: By default, make objects immutable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Immutable objects are easier to reason about, so make objects non-`const` only
    when there is a need to change their value. Prevents accidental or hard-to-notice
    change of value.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A local variable that is returned by value and is cheaper to move than copy
    should not be declared `const` because it can force an unnecessary copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: Function parameters passed by value are rarely mutated, but also rarely declared
    `const`. To avoid confusion and lots of false positives, don’t enforce this rule
    for function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: Note that a function parameter is a local variable so changes to it are local.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag non-`const` variables that are not modified (except for parameters to avoid
    many false positives and returned local variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con.2: By default, make member functions `const`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A member function should be marked `const` unless it changes the object’s observable
    state. This gives a more precise statement of design intent, better readability,
    more errors caught by the compiler, and sometimes more optimization opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is not inherently bad to pass a pointer or reference to non-`const`, but
    that should be done only when the called function is supposed to modify the object.
    A reader of code must assume that a function that takes a “plain” `T*` or `T&`
    will modify the object referred to. If it doesn’t now, it might do so later without
    forcing recompilation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are code/libraries that offer functions that declare a `T*` even though
    those functions do not modify that `T`. This is a problem for people modernizing
    code. You can
  prefs: []
  type: TYPE_NORMAL
- en: update the library to be `const`-correct; preferred long-term solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “cast away `const`”; [best avoided](#res-casts-const)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: provide a wrapper function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: Note that this wrapper solution is a patch that should be used only when the
    declaration of `f()` cannot be modified, e.g. because it is in a library that
    you cannot modify.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A `const` member function can modify the value of an object that is `mutable`
    or accessed through a pointer member. A common use is to maintain a cache rather
    than repeatedly do a complicated computation. For example, here is a `Date` that
    caches (memoizes) its string representation to simplify repeated uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: Another way of saying this is that `const`ness is not transitive. It is possible
    for a `const` member function to change the value of `mutable` members and the
    value of objects accessed through non-`const` pointers. It is the job of the class
    to ensure such mutation is done only when it makes sense according to the semantics
    (invariants) it offers to its users.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [Pimpl](#ri-pimpl)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a member function that is not marked `const`, but that does not perform
    a non-`const` operation on any data member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con.3: By default, pass pointers and references to `const`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid a called function unexpectedly changing the value. It’s far easier
    to reason about programs when called functions don’t modify state.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is not inherently bad to pass a pointer or reference to non-`const`, but
    that should be done only when the called function is supposed to modify the object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Do not cast away `const`](#res-casts-const).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a function that does not modify an object passed by pointer or reference
    to non-`const`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag a function that (using a cast) modifies an object passed by pointer or
    reference to `const`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con.4: Use `const` to define objects with values that do not change after construction'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prevent surprises from unexpectedly changed object values.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: As `x` is not `const`, we must assume that it is modified somewhere in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag unmodified non-`const` variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con.5: Use `constexpr` for values that can be computed at compile time'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Better performance, better compile-time checking, guaranteed compile-time evaluation,
    no possibility of race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See F.4.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `const` definitions with constant expression initializers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T: Templates and generic programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic programming is programming using types and algorithms parameterized
    by types, values, and algorithms. In C++, generic programming is supported by
    the `template` language mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments to generic functions are characterized by sets of requirements on
    the argument types and values involved. In C++, these requirements are expressed
    by compile-time predicates called concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Templates can also be used for meta-programming; that is, programs that compose
    code at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: A central notion in generic programming is “concepts”; that is, requirements
    on template arguments presented as compile-time predicates. “Concepts” were standardized
    in C++20, although they were first made available, in slightly older syntax, in
    GCC 6.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template use rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.1: Use templates to raise the level of abstraction of code](#rt-raise)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.2: Use templates to express algorithms that apply to many argument types](#rt-algo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.3: Use templates to express containers and ranges](#rt-cont)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.4: Use templates to express syntax tree manipulation](#rt-expr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.5: Combine generic and OO techniques to amplify their strengths, not their
    costs](#rt-generic-oo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concept use rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.10: Specify concepts for all template arguments](#rt-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.11: Whenever possible use standard concepts](#rt-std-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.12: Prefer concept names over `auto` for local variables](#rt-auto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.13: Prefer the shorthand notation for simple, single-type argument concepts](#rt-shorthand)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concept definition rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.20: Avoid “concepts” without meaningful semantics](#rt-low)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.21: Require a complete set of operations for a concept](#rt-complete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.22: Specify axioms for concepts](#rt-axiom)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.23: Differentiate a refined concept from its more general case by adding
    new use patterns](#rt-refine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.24: Use tag classes or traits to differentiate concepts that differ only
    in semantics](#rt-tag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.25: Avoid complementary constraints](#rt-not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.26: Prefer to define concepts in terms of use-patterns rather than simple
    syntax](#rt-use)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.30: Use concept negation (`!C<T>`) sparingly to express a minor difference](#rt-???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.31: Use concept disjunction (`C1<T> || C2<T>`) sparingly to express alternatives](#rt-???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template interface rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.40: Use function objects to pass operations to algorithms](#rt-fo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.41: Require only essential properties in a template’s concepts](#rt-essential)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.42: Use template aliases to simplify notation and hide implementation details](#rt-alias)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.43: Prefer `using` over `typedef` for defining aliases](#rt-using)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.44: Use function templates to deduce class template argument types (where
    feasible)](#rt-deduce)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.46: Require template arguments to be at least semiregular](#rt-regular)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.47: Avoid highly visible unconstrained templates with common names](#rt-visible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.48: If your compiler does not support concepts, fake them with `enable_if`](#rt-concept-def)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.49: Where possible, avoid type-erasure](#rt-erasure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template definition rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.60: Minimize a template’s context dependencies](#rt-depend)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.61: Do not over-parameterize members (SCARY)](#rt-scary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.62: Place non-dependent class template members in a non-templated base class](#rt-nondependent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.64: Use specialization to provide alternative implementations of class templates](#rt-specialization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.65: Use tag dispatch to provide alternative implementations of functions](#rt-tag-dispatch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.67: Use specialization to provide alternative implementations for irregular
    types](#rt-specialization2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.68: Use `{}` rather than `()` within templates to avoid ambiguities](#rt-cast)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.69: Inside a template, don’t make an unqualified non-member function call
    unless you intend it to be a customization point](#rt-customization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Template and hierarchy rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.80: Do not naively templatize a class hierarchy](#rt-hier)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.81: Do not mix hierarchies and arrays](#rt-array) // ??? somewhere in “hierarchies”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.82: Linearize a hierarchy when virtual functions are undesirable](#rt-linear)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.83: Do not declare a member function template virtual](#rt-virtual)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.84: Use a non-template core implementation to provide an ABI-stable interface](#rt-abi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.??: ????](#rt-???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variadic template rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.100: Use variadic templates when you need a function that takes a variable
    number of arguments of a variety of types](#rt-variadic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.101: ??? How to pass arguments to a variadic template ???](#rt-variadic-pass)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.102: ??? How to process arguments to a variadic template ???](#rt-variadic-process)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.103: Don’t use variadic templates for homogeneous argument lists](#rt-variadic-not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.??: ????](#rt-???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Metaprogramming rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.120: Use template metaprogramming only when you really need to](#rt-metameta)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.121: Use template metaprogramming primarily to emulate concepts](#rt-emulate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.122: Use templates (usually template aliases) to compute types at compile
    time](#rt-tmp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.123: Use `constexpr` functions to compute values at compile time](#rt-fct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.124: Prefer to use standard-library TMP facilities](#rt-std-tmp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.125: If you need to go beyond the standard-library TMP facilities, use an
    existing library](#rt-lib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.??: ????](#rt-???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other template rules summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.140: If an operation can be reused, give it a name](#rt-name)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.141: Use an unnamed lambda if you need a simple function object in one place
    only](#rt-lambda)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.142: Use template variables to simplify notation](#rt-var)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.143: Don’t write unintentionally non-generic code](#rt-non-generic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.144: Don’t specialize function templates](#rt-specialize-function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.150: Check that a class matches a concept using `static_assert`](#rt-check-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.??: ????](#rt-???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.gp: Generic programming'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generic programming is programming using types and algorithms parameterized
    by types, values, and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.1: Use templates to raise the level of abstraction of code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generality. Reuse. Efficiency. Encourages consistent definition of user types.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Conceptually, the following requirements are wrong because what we want of
    `T` is more than just the very low-level concepts of “can be incremented” or “can
    be added”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that `Incrementable` does not support `+` and `Simple_number` does
    not support `+=`, we have overconstrained implementers of `sum1` and `sum2`. And,
    in this case, missed an opportunity for a generalization.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that `Arithmetic` requires both `+` and `+=`, we have constrained the
    user of `sum` to provide a complete arithmetic type. That is not a minimal requirement,
    but it gives the implementer of algorithms much needed freedom and ensures that
    any `Arithmetic` type can be used for a wide variety of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For additional generality and reusability, we could also use a more general
    `Container` or `Range` concept instead of committing to only one container, `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we define a template to require exactly the operations required for a single
    implementation of a single algorithm (e.g., requiring just `+=` rather than also
    `=` and `+`) and only those, we have overconstrained maintainers. We aim to minimize
    requirements on template arguments, but the absolutely minimal requirements of
    an implementation is rarely a meaningful concept.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Templates can be used to express essentially everything (they are Turing complete),
    but the aim of generic programming (as expressed using templates) is to efficiently
    generalize operations/algorithms over a set of types with similar semantic properties.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag algorithms with “overly simple” requirements, such as direct use of specific
    operators without a concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not flag the definition of the “overly simple” concepts themselves; they
    might simply be building blocks for more useful concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.2: Use templates to express algorithms that apply to many argument types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generality. Minimizing the amount of source code. Interoperability. Reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'That’s the foundation of the STL. A single `find` algorithm easily works with
    any kind of input range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Don’t use a template unless you have a realistic need for more than one template
    argument type. Don’t overabstract.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? tough, probably needs a human
  prefs: []
  type: TYPE_NORMAL
- en: 'T.3: Use templates to express containers and ranges'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Containers need an element type, and expressing that as a template argument
    is general, reusable, and type safe. It also avoids brittle or inefficient workarounds.
    Convention: That’s the way the STL does it.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: This doesn’t directly express the intent of the programmer and hides the structure
    of the program from the type system and optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the `void*` behind macros simply obscures the problems and introduces
    new opportunities for confusion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exceptions**: If you need an ABI-stable interface, you might have to provide
    a base implementation and express the (type-safe) template in terms of that. See
    [Stable base](#rt-abi).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `void*`s and casts outside low-level implementation code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.4: Use templates to express syntax tree manipulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '**Exceptions**: ???'
  prefs: []
  type: TYPE_NORMAL
- en: 'T.5: Combine generic and OO techniques to amplify their strengths, not their
    costs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generic and OO techniques are complementary.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Static helps dynamic: Use static polymorphism to implement dynamically polymorphic
    interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Dynamic helps static: Offer a generic, comfortable, statically bound interface,
    but internally dispatch dynamically, so you offer a uniform object layout. Examples
    include type erasure as with `std::shared_ptr`’s deleter (but [don’t overuse type
    erasure](#rt-erasure)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a class template, non-virtual functions are only instantiated if they’re
    used – but virtual functions are instantiated every time. This can bloat code
    size, and might overconstrain a generic type by instantiating functionality that
    is never needed. Avoid this, even though the standard-library facets made this
    mistake.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ref ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ref ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ref ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See the reference to more specific rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.concepts: Concept rules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concepts is a C++20 facility for specifying requirements for template arguments.
    They are crucial in the thinking about generic programming and the basis of much
    work on future C++ libraries (standard and other).
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes concept support
  prefs: []
  type: TYPE_NORMAL
- en: 'Concept use rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.10: Specify concepts for all template arguments](#rt-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.11: Whenever possible use standard concepts](#rt-std-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.12: Prefer concept names over `auto`](#rt-auto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.13: Prefer the shorthand notation for simple, single-type argument concepts](#rt-shorthand)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concept definition rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[T.20: Avoid “concepts” without meaningful semantics](#rt-low)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.21: Require a complete set of operations for a concept](#rt-complete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.22: Specify axioms for concepts](#rt-axiom)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.23: Differentiate a refined concept from its more general case by adding
    new use patterns](#rt-refine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.24: Use tag classes or traits to differentiate concepts that differ only
    in semantics](#rt-tag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.25: Avoid complimentary constraints](#rt-not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[T.26: Prefer to define concepts in terms of use-patterns rather than simple
    syntax](#rt-use)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.con-use: Concept use'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'T.10: Specify concepts for all template arguments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Correctness and readability. The assumed meaning (syntax and semantics) of a
    template argument is fundamental to the interface of a template. A concept dramatically
    improves documentation and error handling for the template. Specifying concepts
    for template arguments is a powerful design tool.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: 'or equivalently and more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Plain `typename` (or `auto`) is the least constraining concept. It should be
    used only rarely when nothing more than “it’s a type” can be assumed. This is
    typically only needed when (as part of template metaprogramming code) we manipulate
    pure expression trees, postponing type checking.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**: TC++PL4'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag template type arguments without concepts
  prefs: []
  type: TYPE_NORMAL
- en: 'T.11: Whenever possible use standard concepts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: “Standard” concepts (as provided by the [GSL](#gsl-guidelines-support-library)
    and the ISO standard itself) save us the work of thinking up our own concepts,
    are better thought out than we can manage to do in a hurry, and improve interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unless you are creating a new generic library, most of the concepts you need
    will already be defined by the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Ordered_container` is quite plausible, but it is very similar to the
    `sortable` concept in the standard library. Is it better? Is it right? Does it
    accurately reflect the standard’s requirements for `sort`? It is better and simpler
    just to use `sortable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The set of “standard” concepts is evolving as we approach an ISO standard including
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Designing a useful concept is challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Hard.
  prefs: []
  type: TYPE_NORMAL
- en: Look for unconstrained arguments, templates that use “unusual”/non-standard
    concepts, templates that use “homebrew” concepts without axioms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a concept-discovery tool (e.g., see [an early experiment](https://www.stroustrup.com/sle2010_webversion.pdf)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.12: Prefer concept names over `auto` for local variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`auto` is the weakest concept. Concept names convey more meaning than just
    `auto`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.13: Prefer the shorthand notation for simple, single-type argument concepts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Direct expression of an idea.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To say “`T` is `sortable`”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: The shorter versions better match the way we speak. Note that many templates
    don’t need to use the `template` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not feasible in the short term when people convert from the `<typename T>` and
    `<class T`> notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, flag declarations that first introduce a typename and then constrain
    it with a simple, single-type-argument concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.concepts.def: Concept definition rules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining good concepts is non-trivial. Concepts are meant to represent fundamental
    concepts in an application domain (hence the name “concepts”). Similarly throwing
    together a set of syntactic constraints to be used for the arguments for a single
    class or algorithm is not what concepts were designed for and will not give the
    full benefits of the mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, defining concepts is most useful for code that can use an implementation
    (e.g., C++20 or later) but defining concepts is in itself a useful design technique
    and helps catch conceptual errors and clean up the concepts (sic!) of an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.20: Avoid “concepts” without meaningful semantics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Concepts are meant to express semantic notions, such as “a number”, “a range”
    of elements, and “totally ordered.” Simple constraints, such as “has a `+` operator”
    and “has a `>` operator” cannot be meaningfully specified in isolation and should
    be used only as building blocks for meaningful concepts, rather than in user code.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe the concatenation was expected. More likely, it was an accident. Defining
    minus equivalently would give dramatically different sets of accepted types. This
    `Addable` violates the mathematical rule that addition is supposed to be commutative:
    `a+b == b+a`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ability to specify meaningful semantics is a defining characteristic of
    a true concept, as opposed to a syntactic constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Concepts with multiple operations have far lower chance of accidentally matching
    a type than a single-operation concept.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag single-operation `concepts` when used outside the definition of other `concepts`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag uses of `enable_if` that appear to simulate single-operation `concepts`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.21: Require a complete set of operations for a concept'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Ease of comprehension. Improved interoperability. Helps implementers and maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a specific variant of the general rule that [a concept must make semantic
    sense](#rt-low).
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: This makes no semantic sense. You need at least `+` to make `-` meaningful and
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of complete sets are
  prefs: []
  type: TYPE_NORMAL
- en: '`Arithmetic`: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Comparable`: `<`, `>`, `<=`, `>=`, `==`, `!=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This rule applies whether we use direct language support for concepts or not.
    It is a general design rule that even applies to non-templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: This is minimal, but surprising and constraining for users. It could even be
    less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The rule supports the view that a concept should reflect a (mathematically)
    coherent set of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: It can be a nuisance to define all operators, but not hard. Ideally, that rule
    should be language supported by giving you comparison operators by default.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag classes that support “odd” subsets of a set of operators, e.g., `==` but
    not `!=` or `+` but not `-`. Yes, `std::string` is “odd”, but it’s too late to
    change that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.22: Specify axioms for concepts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A meaningful/useful concept has a semantic meaning. Expressing these semantics
    in an informal, semi-formal, or formal way makes the concept comprehensible to
    readers and the effort to express it can catch conceptual errors. Specifying semantics
    is a powerful design tool.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is an axiom in the mathematical sense: something that can be assumed without
    proof. In general, axioms are not provable, and when they are the proof is often
    beyond the capability of a compiler. An axiom might not be general, but the template
    writer can assume that it holds for all inputs actually used (similar to a precondition).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this context axioms are Boolean expressions. See the [Palo Alto TR](#s-references)
    for examples. Currently, C++ does not support axioms (even the ISO Concepts TS),
    so we have to make do with comments for a longish while. Once language support
    is available, the `//` in front of the axiom can be removed
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges
    TS.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Early versions of a new “concept” still under development will often just define
    simple sets of constraints without a well-specified semantics. Finding good semantics
    can take effort and time. An incomplete set of constraints can still be very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: So a `Balancer` must supply at least these operations on a tree `Node`, but
    we are not yet ready to specify detailed semantics because a new kind of balanced
    tree might require more operations and the precise general semantics for all nodes
    is hard to pin down in the early stages of design.
  prefs: []
  type: TYPE_NORMAL
- en: A “concept” that is incomplete or without a well-specified semantics can still
    be useful. For example, it allows for some checking during initial experimentation.
    However, it should not be assumed to be stable. Each new use case might require
    such an incomplete concept to be improved.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Look for the word “axiom” in concept definition comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.23: Differentiate a refined concept from its more general case by adding
    new use patterns.'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Otherwise they cannot be distinguished automatically by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: The compiler can determine refinement based on the sets of required operations
    (here, suffix `++`). This decreases the burden on implementers of these types
    since they do not need any special declarations to “hook into the concept”. If
    two concepts have exactly the same requirements, they are logically equivalent
    (there is no refinement).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag a concept that has exactly the same requirements as another already-seen
    concept (neither is more refined). To disambiguate them, see [T.24](#rt-tag).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.24: Use tag classes or traits to differentiate concepts that differ only
    in semantics.'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Two concepts requiring the same syntax but having different semantics lead to
    ambiguity unless the programmer differentiates them.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: The programmer (in a library) must define `is_contiguous` (a trait) appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapping a tag class into a concept leads to a simpler expression of this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: The programmer (in a library) must define `is_contiguous` (a trait) appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Traits can be trait classes or type traits. These can be user-defined or standard-library
    ones. Prefer the standard-library ones.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler flags ambiguous use of identical concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag the definition of identical concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.25: Avoid complementary constraints'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Clarity. Maintainability. Functions with complementary requirements expressed
    using negation are brittle.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Initially, people will try to define functions with complementary requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: 'This is better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will choose the unconstrained template only when `C<T>` is unsatisfied.
    If you do not want to (or cannot) define an unconstrained version of `f()`, then
    delete it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will select the overload, or emit an appropriate error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Complementary constraints are unfortunately common in `enable_if` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Complementary requirements on one requirement are sometimes (wrongly) considered
    manageable. However, for two or more requirements the number of definitions needs
    can go up exponentially (2,4,8,16,…):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: Now the opportunities for errors multiply.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag pairs of functions with `C<T>` and `!C<T>` constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.26: Prefer to define concepts in terms of use-patterns rather than simple
    syntax'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The definition is more readable and corresponds directly to what a user has
    to write. Conversions are taken into account. You don’t have to remember the names
    of all the type traits.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You might be tempted to define a concept `Equality` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, it would be better and easier just to use the standard `equality_comparable`,
    but - just as an example - if you had to define such a concept, prefer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: as opposed to defining two meaningless concepts `has_equal` and `has_not_equal`
    just as helpers in the definition of `Equality`. By “meaningless” we mean that
    we cannot specify the semantics of `has_equal` in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Template interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the years, programming with templates has suffered from a weak distinction
    between the interface of a template and its implementation. Before concepts, that
    distinction had no direct language support. However, the interface to a template
    is a critical concept - a contract between a user and an implementer - and should
    be carefully designed.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.40: Use function objects to pass operations to algorithms'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Function objects can carry more information through an interface than a “plain”
    pointer to function. In general, passing function objects gives better performance
    than passing pointers to functions.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, of course, generalize those functions using `auto` or concepts. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Lambdas generate function objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The performance argument depends on compiler and optimizer technology.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag pointer to function template arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag pointers to functions passed as arguments to a template (risk of false
    positives).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.41: Require only essential properties in a template’s concepts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Keep interfaces simple and stable.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Consider, a `sort` instrumented with (oversimplified) simple debug support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: 'Should this be rewritten to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: After all, there is nothing in `sortable` that requires `iostream` support.
    On the other hand, there is nothing in the fundamental idea of sorting that says
    anything about debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we require every operation used to be listed among the requirements, the
    interface becomes unstable: Every time we change the debug facilities, the usage
    data gathering, testing support, error reporting, etc., the definition of the
    template would need change and every use of the template would have to be recompiled.
    This is cumbersome, and in some environments infeasible.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if we use an operation in the implementation that is not guaranteed
    by concept checking, we might get a late compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: By not using concept checking for properties of a template argument that is
    not considered essential, we delay checking until instantiation time. We consider
    this a worthwhile tradeoff.
  prefs: []
  type: TYPE_NORMAL
- en: Note that using non-local, non-dependent names (such as `debug` and `cerr`)
    also introduces context dependencies that might lead to “mysterious” errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It can be hard to decide which properties of a type are essential and which
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.42: Use template aliases to simplify notation and hide implementation details'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Improved readability. Implementation hiding. Note that template aliases replace
    many uses of traits to compute a type. They can also be used to wrap a trait.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: This saves the user of `Matrix` from having to know that its elements are stored
    in a `vector` and also saves the user from repeatedly typing `typename std::vector<T>::`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: This saves the user of `Value_type` from having to know the technique used to
    implement `value_type`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A simple, common use could be expressed: “Wrap traits!”'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag use of `typename` as a disambiguator outside `using` declarations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.43: Prefer `using` over `typedef` for defining aliases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Improved readability: With `using`, the new name comes first rather than being
    embedded somewhere in a declaration. Generality: `using` can be used for template
    aliases, whereas `typedef`s can’t easily be templates. Uniformity: `using` is
    syntactically similar to `auto`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `typedef`. This will give a lot of “hits” :-(
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.44: Use function templates to deduce class template argument types (where
    feasible)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Writing the template argument types explicitly can be tedious and unnecessarily
    verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `s` suffix to ensure that the string is a `std::string`,
    rather than a C-style string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since you can trivially write a `make_T` function, so could the compiler. Thus,
    `make_T` functions might become redundant in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Sometimes there isn’t a good way of getting the template arguments deduced
    and sometimes, you want to specify the arguments explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Note that C++17 will make this rule redundant by allowing the template arguments
    to be deduced directly from constructor arguments: [Template parameter deduction
    for constructors (Rev. 3)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html).
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses where an explicitly specialized type exactly matches the types of
    the arguments used.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.46: Require template arguments to be at least semiregular'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Preventing surprises and errors. Most uses support that anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Semiregular requires default constructible.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag types used as template arguments that are not at least semiregular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.47: Avoid highly visible unconstrained templates with common names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An unconstrained template argument is a perfect match for anything so such a
    template can be preferred over more specific types that require minor conversions.
    This is particularly annoying/dangerous when ADL is used. Common names make this
    problem more likely.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: This prints `T0` and `Bad`.
  prefs: []
  type: TYPE_NORMAL
- en: Now the `==` in `Bad` was designed to cause trouble, but would you have spotted
    the problem in real code? The problem is that `v.size()` returns an `unsigned`
    integer so that a conversion is needed to call the local `==`; the `==` in `Bad`
    requires no conversions. Realistic types, such as the standard-library iterators
    can be made to exhibit similar anti-social tendencies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If an unconstrained template is defined in the same namespace as a type, that
    unconstrained template can be found by ADL (as happened in the example). That
    is, it is highly visible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule should not be necessary, but the committee cannot agree to exclude
    unconstrained templates from ADL.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately this will get many false positives; the standard library violates
    this widely, by putting many unconstrained templates and types into the single
    namespace `std`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag templates defined in a namespace where concrete types are also defined
    (maybe not feasible until we have concepts).
  prefs: []
  type: TYPE_NORMAL
- en: 'T.48: If your compiler does not support concepts, fake them with `enable_if`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because that’s the best we can do without direct concept support. `enable_if`
    can be used to conditionally define functions and to select among a set of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Beware of [complementary constraints](#rt-not). Faking concept overloading using
    `enable_if` sometimes forces us to use that error-prone design technique.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.49: Where possible, avoid type-erasure'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Type erasure incurs an extra level of indirection by hiding type information
    behind a separate compilation boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: '**Exceptions**: Type erasure is sometimes appropriate, such as for `std::function`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'T.def: Template definitions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A template definition (class or function) can contain arbitrary code, so only
    a comprehensive review of C++ programming techniques would cover this topic. However,
    this section focuses on what is specific to template implementation. In particular,
    it focuses on a template definition’s dependence on its context.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.60: Minimize a template’s context dependencies'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Eases understanding. Minimizes errors from unexpected dependencies. Eases tool
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Templates typically appear in header files so their context dependencies are
    more vulnerable to `#include` order dependencies than functions in `.cpp` files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Having a template operate only on its arguments would be one way of reducing
    the number of dependencies to a minimum, but that would generally be unmanageable.
    For example, algorithms usually use other algorithms and invoke operations that
    do not exclusively operate on arguments. And don’t get us started on macros!
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [T.69](#rt-customization)'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? Tricky
  prefs: []
  type: TYPE_NORMAL
- en: 'T.61: Do not over-parameterize members (SCARY)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A member that does not depend on a template parameter cannot be used except
    for a specific template argument. This limits use and typically increases code
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: This looks innocent enough, but now `Link` formally depends on the allocator
    (even though it doesn’t use the allocator). This forces redundant instantiations
    that can be surprisingly costly in some real-world scenarios. Typically, the solution
    is to make what would have been a nested class non-local, with its own minimal
    set of template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: 'Some people found the idea that the `Link` no longer was hidden inside the
    list scary, so we named the technique [SCARY](https://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf).
    From that academic paper: “The acronym SCARY describes assignments and initializations
    that are Seemingly erroneous (appearing Constrained by conflicting generic parameters),
    but Actually work with the Right implementation (unconstrained bY the conflict
    due to minimized dependencies).”'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This also applies to lambdas that don’t depend on all of the template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag member types that do not depend on every template parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag member functions that do not depend on every template parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag lambdas or variable templates that do not depend on every template parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.62: Place non-dependent class template members in a non-templated base class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Allow the base class members to be used without specifying template arguments
    and without template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A more general version of this rule would be “If a class template member depends
    on only N template parameters out of M, place it in a base class with only N parameters.”
    For N == 1, we have a choice of a base class of a class in the surrounding scope
    as in [T.61](#rt-scary).
  prefs: []
  type: TYPE_NORMAL
- en: ??? What about constants? class statics?
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.64: Use specialization to provide alternative implementations of class templates'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A template defines a general interface. Specialization offers a powerful mechanism
    for providing alternative implementations of that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.65: Use tag dispatch to provide alternative implementations of a function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A template defines a general interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag dispatch allows us to select implementations based on specific properties
    of an argument type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a simplified version of `std::copy` (ignoring the possibility of non-contiguous
    sequences)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: This is a general and powerful technique for compile-time algorithm selection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With C++20 constraints, such alternatives can be distinguished directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.67: Use specialization to provide alternative implementations for irregular
    types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.68: Use `{}` rather than `()` within templates to avoid ambiguities'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`()` is vulnerable to grammar ambiguities.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: flag `()` initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: flag function-style casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.69: Inside a template, don’t make an unqualified non-member function call
    unless you intend it to be a customization point'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Provide only intended flexibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid vulnerability to accidental environmental changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are three major ways to let calling code customize a template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: A trait is usually a type alias to compute a type, a `constexpr` function to
    compute a value, or a traditional traits template to be specialized on the user’s
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you intend to call your own helper function `helper(t)` with a value `t`
    that depends on a template type parameter, put it in a `::detail` namespace and
    qualify the call as `detail::helper(t);`. An unqualified call becomes a customization
    point where any function `helper` in the namespace of `t`’s type can be invoked;
    this can cause problems like [unintentionally invoking unconstrained function
    templates](#rt-visible).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a template, flag an unqualified call to a non-member function that passes
    a variable of dependent type when there is a non-member function of the same name
    in the template’s namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.temp-hier: Template and hierarchy rules:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Templates are the backbone of C++’s support for generic programming and class
    hierarchies the backbone of its support for object-oriented programming. The two
    language mechanisms can be used effectively in combination, but a few design pitfalls
    must be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.80: Do not naively templatize a class hierarchy'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Templating a class hierarchy that has many functions, especially many virtual
    functions, can lead to code bloat.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: It is probably a bad idea to define a `sort` as a member function of a container,
    but it is not unheard of and it makes a good example of what not to do.
  prefs: []
  type: TYPE_NORMAL
- en: Given this, the compiler cannot know if `vector<int>::sort()` is called, so
    it must generate code for it. Similar for `vector<string>::sort()`. Unless those
    two functions are called that’s code bloat. Imagine what this would do to a class
    hierarchy with dozens of member functions and dozens of derived classes with many
    instantiations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In many cases you can provide a stable interface by not parameterizing a base;
    see [“stable base”](#rt-abi) and [OO and GP](#rt-generic-oo)
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag virtual functions that depend on a template argument. ??? False positives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.81: Do not mix hierarchies and arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An array of derived classes can implicitly “decay” to a pointer to a base class
    with potential disastrous results.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Assume that `Apple` and `Pear` are two kinds of `Fruit`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: Probably, `aa[0]` will be a `Pear` (without the use of a cast!). If `sizeof(Apple)
    != sizeof(Pear)` the access to `aa[1]` will not be aligned to the proper start
    of an object in the array. We have a type violation and possibly (probably) a
    memory corruption. Never write such code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `maul()` violates the a [`T*` points to an individual object rule](#rf-ptr).
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Use a proper (templatized) container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: Note that the assignment in `maul2()` violated the [no-slicing rule](#res-slice).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Detect this horror!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.82: Linearize a hierarchy when virtual functions are undesirable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.83: Do not declare a member function template virtual'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C++ does not support that. If it did, vtbls could not be generated until link
    time. And in general, implementations must deal with dynamic linking.
  prefs: []
  type: TYPE_NORMAL
- en: Example, don’t
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need a rule because people keep asking about this
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Double dispatch, visitors, calculate which function to call
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler handles that.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.84: Use a non-template core implementation to provide an ABI-stable interface'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Improve stability of code. Avoid code bloat.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It could be a base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: Now there is only one copy of the operations linking and unlinking elements
    of a `List`. The `Link` and `List` classes do nothing but type manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using a separate “base” type, another common technique is to specialize
    for `void` or `void*` and have the general template for `T` be just the safely-encapsulated
    casts to and from the core `void` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative**: Use a [Pimpl](#ri-pimpl) implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.var: Variadic template rules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.100: Use variadic templates when you need a function that takes a variable
    number of arguments of a variety of types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Variadic templates is the most general mechanism for that, and is both efficient
    and type-safe. Don’t use C varargs.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `va_arg` in user code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.101: ??? How to pass arguments to a variadic template ???'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.102: How to process arguments to a variadic template'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.103: Don’t use variadic templates for homogeneous argument lists'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are more precise ways of specifying a homogeneous sequence, such as an
    `initializer_list`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.meta: Template metaprogramming (TMP)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Templates provide a general mechanism for compile-time programming.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming is programming where at least one input or one result is a type.
    Templates offer Turing-complete (modulo memory capacity) duck typing at compile
    time. The syntax and techniques needed are pretty horrendous.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.120: Use template metaprogramming only when you really need to'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Template metaprogramming is hard to get right, slows down compilation, and is
    often very hard to maintain. However, there are real-world examples where template
    metaprogramming provides better performance than any alternative short of expert-level
    assembly code. Also, there are real-world examples where template metaprogramming
    expresses the fundamental ideas better than run-time code. For example, if you
    really need AST manipulation at compile time (e.g., for optional matrix operation
    folding) there might be no other way in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: Instead, use concepts. But see [How to emulate concepts if you don’t have language
    support](#rt-emulate).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: '**Alternative**: If the result is a value, rather than a type, use a [`constexpr`
    function](#rt-fct).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you feel the need to hide your template metaprogramming in macros, you have
    probably gone too far.
  prefs: []
  type: TYPE_NORMAL
- en: 'T.121: Use template metaprogramming primarily to emulate concepts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Where C++20 is not available, we need to emulate them using TMP. Use cases that
    require concepts (e.g. overloading based on concepts) are among the most common
    (and simple) uses of TMP.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Such code is much simpler using concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.122: Use templates (usually template aliases) to compute types at compile
    time'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Template metaprogramming is the only directly supported and half-way principled
    way of generating types at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: “Traits” techniques are mostly replaced by template aliases to compute types
    and `constexpr` functions to compute values.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.123: Use `constexpr` functions to compute values at compile time'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A function is the most obvious and conventional way of expressing the computation
    of a value. Often a `constexpr` function implies less compile-time overhead than
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: “Traits” techniques are mostly replaced by template aliases to compute types
    and `constexpr` functions to compute values.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag template metaprograms yielding a value. These should be replaced with `constexpr`
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.124: Prefer to use standard-library TMP facilities'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Facilities defined in the standard, such as `conditional`, `enable_if`, and
    `tuple`, are portable and can be assumed to be known.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.125: If you need to go beyond the standard-library TMP facilities, use an
    existing library'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Getting advanced TMP facilities is not easy and using a library makes you part
    of a (hopefully supportive) community. Write your own “advanced TMP support” only
    if you really have to.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Other template rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'T.140: If an operation can be reused, give it a name'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [F.10](#rf-name)
  prefs: []
  type: TYPE_NORMAL
- en: 'T.141: Use an unnamed lambda if you need a simple function object in one place
    only'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [F.11](#rf-lambda)
  prefs: []
  type: TYPE_NORMAL
- en: 'T.142?: Use template variables to simplify notation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Improved readability.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'T.143: Don’t write unintentionally non-generic code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generality. Reusability. Don’t gratuitously commit to details; use the most
    general facilities available.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use `!=` instead of `<` to compare iterators; `!=` works for more objects because
    it doesn’t rely on ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: Of course, range-`for` is better still where it does what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use the least-derived class that has the functionality you need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag comparison of iterators using `<` instead of `!=`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag `x.size() == 0` when `x.empty()` or `x.is_empty()` is available. Emptiness
    works for more containers than size(), because some containers don’t know their
    size or are conceptually of unbounded size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag functions that take a pointer or reference to a more-derived type but only
    use functions declared in a base type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.144: Don’t specialize function templates'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can’t partially specialize a function template per language rules. You can
    fully specialize a function template but you almost certainly want to overload
    instead – because function template specializations don’t participate in overloading,
    they don’t act as you probably wanted. Rarely, you should actually specialize
    by delegating to a class template that you can specialize properly.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: '**Exceptions**: If you do have a valid reason to specialize a function template,
    just write a single function template that delegates to a class template, then
    specialize the class template (including the ability to write partial specializations).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all specializations of a function template. Overload instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'T.150: Check that a class matches a concept using `static_assert`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you intend for a class to match a concept, verifying that early saves users’
    pain.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhere, possibly in an implementation file, let the compiler check the desired
    properties of `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Not feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'CPL: C-style programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C and C++ are closely related languages. They both originate in “Classic C”
    from 1978 and have evolved in ISO committees since then. Many attempts have been
    made to keep them compatible, but neither is a subset of the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'C rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[CPL.1: Prefer C++ to C](#rcpl-c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CPL.2: If you must use C, use the common subset of C and C++, and compile
    the C code as C++](#rcpl-subset)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CPL.3: If you must use C for interfaces, use C++ in the calling code using
    such interfaces](#rcpl-interface)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPL.1: Prefer C++ to C'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C++ provides better type checking and more notational support. It provides better
    support for high-level programming and often generates faster code.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: The rules for implicit casting to and from `void*` in C are subtle and unenforced.
    In particular, this example violates a rule against converting to a type with
    stricter alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use a C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'CPL.2: If you must use C, use the common subset of C and C++, and compile the
    C code as C++'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That subset can be compiled with both C and C++ compilers, and when compiled
    as C++ is better type checked than “pure C.”
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag if using a build mode that compiles code as C.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ compiler will enforce that the code is valid C++ unless you use C extension
    options.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPL.3: If you must use C for interfaces, use C++ in the calling code using
    such interfaces'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C++ is more expressive than C and offers better support for many types of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For example, to use a 3rd party C library or C systems interface, define the
    low-level interface in the common subset of C and C++ for better type checking.
    Whenever possible encapsulate the low-level interface in an interface that follows
    the C++ guidelines (for better abstraction, memory safety, and resource safety)
    and use that C++ interface in C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can call C from C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can call C++ from C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: None needed
  prefs: []
  type: TYPE_NORMAL
- en: 'SF: Source files'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distinguish between declarations (used as interfaces) and definitions (used
    as implementations). Use header files to represent interfaces and to emphasize
    logical structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source file rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your
    project doesn’t already follow another convention](#rs-file-suffix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.2: A header file must not contain object definitions or non-inline function
    definitions](#rs-inline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.3: Use header files for all declarations used in multiple source files](#rs-declaration-header)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.4: Include header files before other declarations in a file](#rs-include-order)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.5: A `.cpp` file must include the header file(s) that defines its interface](#rs-consistency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.6: Use `using namespace` directives for transition, for foundation libraries
    (such as `std`), or within a local scope (only)](#rs-using)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.7: Don’t write `using namespace` at global scope in a header file](#rs-using-directive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.8: Use `#include` guards for all header files](#rs-guards)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.9: Avoid cyclic dependencies among source files](#rs-cycles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.10: Avoid dependencies on implicitly `#include`d names](#rs-implicit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.11: Header files should be self-contained](#rs-contained)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.12: Prefer the quoted form of `#include` for files relative to the including
    file and the angle bracket form everywhere else](#rs-incform)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.13: Use portable header identifiers in `#include` statements](#rs-portable-header-id)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.20: Use `namespace`s to express logical structure](#rs-namespace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.21: Don’t use an unnamed (anonymous) namespace in a header](#rs-unnamed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SF.22: Use an unnamed (anonymous) namespace for all internal/non-exported
    entities](#rs-unnamed2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your
    project doesn’t already follow another convention'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [NL.27](#rl-file-suffix)
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.2: A header file must not contain object definitions or non-inline function
    definitions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Including entities subject to the one-definition rule leads to linkage errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: Linking `file1.cpp` and `file2.cpp` will give two linker errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative formulation**: A header file must contain only:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#include`s of other header files (possibly with include guards)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: class definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: function declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extern` declarations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inline` function definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constexpr` definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using` alias definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Check the positive list above.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.3: Use header files for all declarations used in multiple source files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Maintainability. Readability.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: A maintainer of `bar` cannot find all declarations of `bar` if its type needs
    changing. The user of `bar` cannot know if the interface used is complete and
    correct. At best, error messages come (late) from the linker.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag declarations of entities in other source files not placed in a `.h`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SF.4: Include header files before other declarations in a file'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Minimize context dependencies and increase readability.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This applies to both `.h` and `.cpp` files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is an argument for insulating code from declarations and macros in header
    files by `#including` headers *after* the code we want to protect (as in the example
    labeled “bad”). However
  prefs: []
  type: TYPE_NORMAL
- en: 'that only works for one file (at one level): Use that technique in a header
    included with other headers and the vulnerability reappears.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a namespace (an “implementation namespace”) can protect against many context
    dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: full protection and flexibility require modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working Draft, Extensions to C++ for Modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Modules, Componentization, and Transition](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.5: A `.cpp` file must include the header file(s) that defines its interface'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This enables the compiler to do an early consistency check.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: The errors will not be caught until link time for a program calling `bar` or
    `foobar`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: The return-type error for `foobar` is now caught immediately when `foo.cpp`
    is compiled. The argument-type error for `bar` cannot be caught until link time
    because of the possibility of overloading, but systematic use of `.h` files increases
    the likelihood that it is caught earlier by the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.6: Use `using namespace` directives for transition, for foundation libraries
    (such as `std`), or within a local scope (only)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`using namespace` can lead to name clashes, so it should be used sparingly.
    However, it is not always possible to qualify every name from a namespace in user
    code (e.g., during transition) and sometimes a namespace is so fundamental and
    prevalent in a code base, that consistent qualification would be verbose and distracting.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: Here (obviously), the standard library is used pervasively and apparently no
    other library is used, so requiring `std::` everywhere could be distracting.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The use of `using namespace std;` leaves the programmer open to a name clash
    with a name from the standard library
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not particularly likely to lead to a resolution that is not
    an error and people who use `using namespace std` are supposed to know about `std`
    and about this risk.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `.cpp` file is a form of local scope. There is little difference in the opportunities
    for name clashes in an N-line `.cpp` containing a `using namespace X`, an N-line
    function containing a `using namespace X`, and M functions each containing a `using
    namespace X` with N lines of code in total.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Don’t write `using namespace` at global scope in a header file](#rs-using-directive).'
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.7: Don’t write `using namespace` at global scope in a header file'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Doing so takes away an `#include`r’s ability to effectively disambiguate and
    to use alternatives. It also makes `#include`d headers order-dependent as they
    might have different meaning when included in different orders.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An exception is `using namespace std::literals;`. This is necessary to use string
    literals in header files and given [the rules](https://eel.is/c++draft/over.literal)
    - users are required to name their own UDLs `operator""_x` - they will not collide
    with the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `using namespace` at global scope in a header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.8: Use `#include` guards for all header files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid files being `#include`d several times.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid include guard collisions, do not just name the guard after
    the filename. Be sure to also include a key and good differentiator, such as the
    name of library or component the header file is part of.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `.h` files without `#include` guards.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some implementations offer vendor extensions like `#pragma once` as alternative
    to include guards. It is not standard and it is not portable. It injects the hosting
    machine’s filesystem semantics into your program, in addition to locking you down
    to a vendor. Our recommendation is to write in ISO C++: See [rule P.2](#rp-cplusplus).'
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.9: Avoid cyclic dependencies among source files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Cycles complicate comprehension and slow down compilation. They also complicate
    conversion to use language-supported modules (when they become available).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Eliminate cycles; don’t just break them with `#include` guards.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.10: Avoid dependencies on implicitly `#include`d names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid surprises. Avoid having to change `#include`s if an `#include`d header
    changes. Avoid accidentally becoming dependent on implementation details and logically
    separate entities included in a header.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: '`<iostream>` exposes the definition of `std::string` (“why?” makes for a fun
    trivia question), but it is not required to do so by transitively including the
    entire `<string>` header, resulting in the popular beginner question “why doesn’t
    `getline(cin,s);` work?” or even an occasional “`string`s cannot be compared with
    `==`”).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to explicitly `#include <string>`:'
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some headers exist exactly to collect a set of consistent declarations from
    a variety of headers. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: a user can now get that set of declarations with a single `#include`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: This rule against implicit inclusion is not meant to prevent such deliberate
    aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enforcement would require some knowledge about what in a header is meant to
    be “exported” to users and what is there to enable implementation. No really good
    solution is possible until we have modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.11: Header files should be self-contained'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Usability, headers should be simple to use and work when included on their own.
    Headers should encapsulate the functionality they provide. Avoid clients of a
    header having to manage that header’s dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Failing to follow this results in difficult to diagnose errors for clients of
    a header.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A header should include all its dependencies. Be careful about using relative
    paths because C++ implementations diverge on their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A test should verify that the header file itself compiles or that a cpp file
    which only includes the header file compiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.12: Prefer the quoted form of `#include` for files relative to the including
    file and the angle bracket form everywhere else'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The [standard](https://eel.is/c++draft/cpp.include) provides flexibility for
    compilers to implement the two forms of `#include` selected using the angle (`<>`)
    or quoted (`""`) syntax. Vendors take advantage of this and use different search
    algorithms and methods for specifying the include path.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the guidance is to use the quoted form for including files that
    exist at a relative path to the file containing the `#include` statement (from
    within the same component or project) and to use the angle bracket form everywhere
    else, where possible. This encourages being clear about the locality of the file
    relative to files that include it, or scenarios where the different search algorithm
    is required. It makes it easy to understand at a glance whether a header is being
    included from a local relative file versus a standard library header or a header
    from the alternate search path (e.g. a header from another library or a common
    set of includes).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Failing to follow this results in difficult to diagnose errors due to picking
    up the wrong file by incorrectly specifying the scope when it is included. For
    example, in a typical case where the `#include ""` search algorithm might search
    for a file existing at a local relative path first, then using this form to refer
    to a file that is not locally relative could mean that if a file ever comes into
    existence at the local relative path (e.g. the including file is moved to a new
    location), it will now be found ahead of the previous include file and the set
    of includes will have been changed in an unexpected way.
  prefs: []
  type: TYPE_NORMAL
- en: Library creators should put their headers in a folder and have clients include
    those files using the relative path `#include <some_library/common.h>`
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A test should identify whether headers referenced via `""` could be referenced
    with `<>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.13: Use portable header identifiers in `#include` statements'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The [standard](https://eel.is/c++draft/cpp.include) does not specify how compilers
    uniquely locate headers from an identifier in an `#include` directive, nor does
    it specify what constitutes uniqueness. For example, whether the implementation
    considers the identifiers to be case-sensitive, or whether the identifiers are
    file system paths to a header file, and if so, how a hierarchical file system
    path is delimited.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maximize the portability of `#include` directives across compilers, guidance
    is to:'
  prefs: []
  type: TYPE_NORMAL
- en: use case-sensitivity for the header identifier, matching how the header is defined
    by the standard, specification, implementation, or file that provides the header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when the header identifier is a hierarchical file path, use forward-slash `/`
    to delimit path components as this is the most widely-accepted path-delimiting
    character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is only possible to enforce on implementations where header identifiers are
    case-sensitive and which only support `/` as a file path delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.20: Use `namespace`s to express logical structure'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SF.21: Don’t use an unnamed (anonymous) namespace in a header'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is almost always a bug to mention an unnamed namespace in a header file.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag any use of an anonymous namespace in a header file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SF.22: Use an unnamed (anonymous) namespace for all internal/non-exported entities'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Nothing external can depend on an entity in a nested unnamed namespace. Consider
    putting every definition in an implementation source file in an unnamed namespace
    unless that is defining an “external/exported” entity.
  prefs: []
  type: TYPE_NORMAL
- en: Example; bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: Example; good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An API class and its members can’t live in an unnamed namespace; but any “helper”
    class or function that is defined in an implementation source file should be at
    an unnamed namespace scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL: The Standard Library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using only the bare language, every task is tedious (in any language). Using
    a suitable library any task can be reasonably simple.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library has steadily grown over the years. Its description in the
    standard is now larger than that of the language features. So, it is likely that
    this library section of the guidelines will eventually grow in size to equal or
    exceed all the rest.
  prefs: []
  type: TYPE_NORMAL
- en: « ??? We need another level of rule numbering ??? »
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ Standard Library component summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SL.con: Containers](#ss-con)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str: String](#ss-string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.io: Iostream](#ss-io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.regex: Regex](#ss-regex)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.chrono: Time](#ss-chrono)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.C: The C Standard Library](#ss-clib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Standard-library rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SL.1: Use libraries wherever possible](#rsl-lib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.2: Prefer the standard library to other libraries](#rsl-sl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.3: Do not add non-standard entities to namespace `std`](#sl-std)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.4: Use the standard library in a type-safe manner](#sl-safe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.1: Use libraries wherever possible'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Save time. Don’t re-invent the wheel. Don’t replicate the work of others. Benefit
    from other people’s work when they make improvements. Help other people when you
    make improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.2: Prefer the standard library to other libraries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: More people know the standard library. It is more likely to be stable, well-maintained,
    and widely available than your own code or most other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.3: Do not add non-standard entities to namespace `std`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Adding to `std` might change the meaning of otherwise standards conforming code.
    Additions to `std` might clash with future versions of the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Possible, but messy and likely to cause problems with platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.4: Use the standard library in a type-safe manner'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because, obviously, breaking this rule can lead to undefined behavior, memory
    corruption, and all kinds of other bad errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a semi-philosophical meta-rule, which needs many supporting concrete
    rules. We need it as an umbrella for the more specific rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary of more specific rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SL.4: Use the standard library in a type-safe manner](#sl-safe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.con: Containers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Container rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SL.con.1: Prefer using STL `array` or `vector` instead of a C array](#rsl-arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.con.2: Prefer using STL `vector` by default unless you have a reason to
    use a different container](#rsl-vector)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.con.3: Avoid bounds errors](#rsl-bounds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.con.4: don’t use `memset` or `memcpy` for arguments that are not trivially-copyable](#rsl-copy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.con.1: Prefer using STL `array` or `vector` instead of a C array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C arrays are less safe, and have no advantages over `array` and `vector`. For
    a fixed-length array, use `std::array`, which does not degenerate to a pointer
    when passed to a function and does know its size. Also, like a built-in array,
    a stack-allocated `std::array` keeps its elements on the stack. For a variable-length
    array, use `std::vector`, which additionally can change its size and handles memory
    allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use `gsl::span` for non-owning references into a container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Comparing the performance of a fixed-sized array allocated on the stack against
    a `vector` with its elements on the free store is bogus. You could just as well
    compare a `std::array` on the stack against the result of a `malloc()` accessed
    through a pointer. For most code, even the difference between stack allocation
    and free-store allocation doesn’t matter, but the convenience and safety of `vector`
    does. People working with code for which that difference matters are quite capable
    of choosing between `array` and `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag declaration of a C array inside a function or class that also declares
    an STL container (to avoid excessive noisy warnings on legacy non-STL code). To
    fix: At least change the C array to a `std::array`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.con.2: Prefer using STL `vector` by default unless you have a reason to
    use a different container'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`vector` and `array` are the only standard containers that offer the following
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: the fastest general-purpose access (random access, including being vectorization-friendly);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly);
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the lowest space overhead (contiguous layout has zero per-element overhead,
    which is cache-friendly).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually you need to add and remove elements from the container, so use `vector`
    by default; if you don’t need to modify the container’s size, use `array`.
  prefs: []
  type: TYPE_NORMAL
- en: Even when other containers seem more suited, such as `map` for O(log N) lookup
    performance or a `list` for efficient insertion in the middle, a `vector` will
    usually still perform better for containers up to a few KB in size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`string` should not be used as a container of individual characters. A `string`
    is a textual string; if you want a container of characters, use `vector</*char_type*/>`
    or `array</*char_type*/>` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you have a good reason to use another container, use that instead. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: If `vector` suits your needs but you don’t need the container to be variable
    size, use `array` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want a dictionary-style lookup container that guarantees O(K) or O(log
    N) lookups, the container will be larger (more than a few KB) and you perform
    frequent inserts so that the overhead of maintaining a sorted `vector` is infeasible,
    go ahead and use an `unordered_map` or `map` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To initialize a vector with a number of elements, use `()`-initialization. To
    initialize a vector with a list of elements, use `{}`-initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: '[Prefer the {}-initializer syntax](#res-list).'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Flag a `vector` whose size never changes after construction (such as because
    it’s `const` or because no non-`const` functions are called on it). To fix: Use
    an `array` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.con.3: Avoid bounds errors'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Read or write beyond an allocated range of elements typically leads to bad errors,
    wrong results, crashes, and security violations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The standard-library functions that apply to ranges of elements all have (or
    could have) bounds-safe overloads that take `span`. Standard types such as `vector`
    can be modified to perform bounds-checks under the bounds profile (in a compatible
    way, such as by adding contracts), or used with `at()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, the in-bounds guarantee should be statically enforced. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: a range-`for` cannot loop beyond the range of the container to which it is applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a `v.begin(),v.end()` is easily determined to be bounds safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such loops are as fast as any unchecked/unsafe equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Often a simple pre-check can eliminate the need for checking of individual indices.
    For example
  prefs: []
  type: TYPE_NORMAL
- en: for `v.begin(),v.begin()+i` the `i` can easily be checked against `v.size()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such loops can be much faster than individually checked element accesses.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: Also, `std::array<>::fill()` or `std::fill()` or even an empty initializer are
    better candidates than `memset()`.
  prefs: []
  type: TYPE_NORMAL
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If code is using an unmodified standard library, then there are still workarounds
    that enable use of `std::array` and `std::vector` in a bounds-safe manner. Code
    can call the `.at()` member function on each class, which will result in an `std::out_of_range`
    exception being thrown. Alternatively, code can call the `at()` free function,
    which will result in fail-fast (or a customized action) on a bounds violation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Issue a diagnostic for any call to a standard-library function that is not bounds-checked.
    ??? insert link to a list of banned functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule is part of the [bounds profile](#ss-bounds).
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.con.4: don’t use `memset` or `memcpy` for arguments that are not trivially-copyable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Doing so messes the semantics of the objects (e.g., by overwriting a `vptr`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Similarly for (w)memset, (w)memcpy, (w)memmove, and (w)memcmp
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: Instead, define proper default initialization, copy, and comparison functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag the use of those functions for types that are not trivially copyable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TODO Notes**:'
  prefs: []
  type: TYPE_NORMAL
- en: Impact on the standard library will require close coordination with WG21, if
    only to ensure compatibility even if never standardized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are considering specifying bounds-safe overloads for stdlib (especially C
    stdlib) functions like `memcmp` and shipping them in the GSL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For existing stdlib functions and types like `vector` that are not fully bounds-checked,
    the goal is for these features to be bounds-checked when called from code with
    the bounds profile on, and unchecked when called from legacy code, possibly using
    contracts (concurrently being proposed by several WG21 members).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.str: String'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text manipulation is a huge topic. `std::string` doesn’t cover all of it. This
    section primarily tries to clarify `std::string`’s relation to `char*`, `zstring`,
    `string_view`, and `gsl::span<char>`. The important issue of non-ASCII character
    sets and encodings (e.g., `wchar_t`, Unicode, and UTF-8) will be covered elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [regular expressions](#ss-regex)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use “sequence of characters” or “string” to refer to a sequence of
    characters meant to be read as text (somehow, eventually). We don’t consider ???
  prefs: []
  type: TYPE_NORMAL
- en: 'String summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SL.str.1: Use `std::string` to own character sequences](#rstr-string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str.2: Use `std::string_view` or `gsl::span<char>` to refer to character
    sequences](#rstr-view)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated,
    sequence of characters](#rstr-zstring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str.4: Use `char*` to refer to a single character](#rstr-charp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str.5: Use `std::byte` to refer to byte values that do not necessarily
    represent characters](#rstr-byte)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str.10: Use `std::string` when you need to perform locale-sensitive string
    operations](#rstr-locale)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str.11: Use `gsl::span<char>` rather than `std::string_view` when you need
    to mutate a string](#rstr-span)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.str.12: Use the `s` suffix for string literals meant to be standard-library
    `string`s](#rstr-s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**See also**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F.24 span](#rf-range)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F.25 zstring](#rf-zstring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.str.1: Use `std::string` to own character sequences'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`string` correctly handles allocation, ownership, copying, gradual expansion,
    and offers a variety of useful operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: Note how `>>` and `!=` are provided for `string` (as examples of useful operations)
    and there are no explicit allocations, deallocations, or range checks (`string`
    takes care of those).
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++17, we might use `string_view` as the argument, rather than `const string&`
    to allow more flexibility to callers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Don’t use C-style strings for operations that require non-trivial memory management
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: Did we get that right? Will the caller remember to `free()` the returned pointer?
    Will this code pass a security review?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not assume that `string` is slower than lower-level techniques without measurement
    and remember that not all code is performance critical. [Don’t optimize prematurely](#rper-knuth)
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.str.2: Use `std::string_view` or `gsl::span<char>` to refer to character
    sequences'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::string_view` or `gsl::span<char>` provides simple and (potentially) safe
    access to character sequences independently of how those sequences are allocated
    and stored.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::string_view` (C++17) is read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated,
    sequence of characters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Statement of intent. A plain `char*` can be a pointer to a single
    character, a pointer to an array of characters, a pointer to a C-style (zero-terminated)
    string, or even to a small integer. Distinguishing these alternatives prevents
    misunderstandings and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: All we know is that it is supposed to be the nullptr or point to at least one
    character
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Don’t convert a C-style string to `string` unless there is a reason to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like any other “plain pointer”, a `zstring` should not represent ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are billions of lines of C++ “out there”, most use `char*` and `const
    char*` without documenting intent. They are used in a wide variety of ways, including
    to represent ownership and as generic pointers to memory (instead of `void*`).
    It is hard to separate these uses, so this guideline is hard to follow. This is
    one of the major sources of bugs in C and C++ programs, so it is worthwhile to
    follow this guideline wherever feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `[]` on a `char*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag uses of `delete` on a `char*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag uses of `free()` on a `char*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.str.4: Use `char*` to refer to a single character'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The variety of uses of `char*` in current code is a major source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: The array `arr` is not a C-style string because it is not zero-terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See [`zstring`](#rstr-zstring), [`string`](#rstr-string), and [`string_view`](#rstr-view).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag uses of `[]` on a `char*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent
    characters'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use of `char*` to represent a pointer to something that is not necessarily a
    character causes confusion and disables valuable optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: C++17
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.str.10: Use `std::string` when you need to perform locale-sensitive string
    operations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::string` supports standard-library [`locale` facilities](#rstr-locale)'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.str.11: Use `gsl::span<char>` rather than `std::string_view` when you need
    to mutate a string'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`std::string_view` is read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The compiler will flag attempts to write to a `string_view`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.str.12: Use the `s` suffix for string literals meant to be standard-library
    `string`s'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Direct expression of an idea minimizes mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.io: Iostream'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`iostream`s is a type safe, extensible, formatted and unformatted I/O library
    for streaming I/O. It supports multiple (and user extensible) buffering strategies
    and multiple locales. It can be used for conventional I/O, reading and writing
    to memory (string streams), and user-defined extensions, such as streaming across
    networks (asio: not yet standardized).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iostream rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SL.io.1: Use character-level input only when you have to](#rio-low)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.io.2: When reading, always consider ill-formed input](#rio-validate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.io.3: Prefer iostreams for I/O](#rio-streams)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`](#rio-sync)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SL.io.50: Avoid `endl`](#rio-endl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.io.1: Use character-level input only when you have to'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unless you genuinely just deal with individual characters, using character-level
    input leads to the user code performing potentially error-prone and potentially
    inefficient composition of tokens out of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: 'Better (much simpler and probably faster):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: and the `reserve(128)` is probably not worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.io.2: When reading, always consider ill-formed input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Errors are typically best handled as soon as possible. If input isn’t validated,
    every function must be written to cope with bad data (and that is not practical).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.io.3: Prefer `iostream`s for I/O'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`iostream`s are safe, flexible, and extensible.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: '`complex` is a user-defined type and its I/O is defined without modifying the
    `iostream` library.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ??? performance ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: `iostream`s vs. the `printf()` family'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It is often (and often correctly) pointed out that the `printf()` family has
    two advantages compared to `iostream`s: flexibility of formatting and performance.
    This has to be weighed against `iostream`s advantages of extensibility to handle
    user-defined types, resilience against security violations, implicit memory management,
    and `locale` handling.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need I/O performance, you can almost always do better than `printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`gets()`, `scanf()` using `%s`, and `printf()` using `%s` are security hazards
    (vulnerable to buffer overflow and generally error-prone). C11 defines some “optional
    extensions” that do extra checking of their arguments. If present in your C library,
    `gets_s()`, `scanf_s()`, and `printf_s()` might be safer alternatives, but they
    are still not type safe.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Optionally flag `<cstdio>` and `<stdio.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Synchronizing `iostreams` with `printf-style` I/O can be costly. `cin` and `cout`
    are by default synchronized with `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.io.50: Avoid `endl`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `endl` manipulator is mostly equivalent to `'\n'` and `"\n"`; as most commonly
    used it simply slows down output by doing redundant `flush()`s. This slowdown
    can be significant compared to `printf`-style output.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For `cin`/`cout` (and equivalent) interaction, there is no reason to flush;
    that’s done automatically. For writing to a file, there is rarely a need to `flush`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For string streams (specifically `ostringstream`), the insertion of an `endl`
    is entirely equivalent to the insertion of a `'\n'` character, but also in this
    case, `endl` might be significantly slower.
  prefs: []
  type: TYPE_NORMAL
- en: '`endl` does *not* take care of producing a platform specific end-of-line sequence
    (like `"\r\n"` on Windows). So for a string stream, `s << endl` just inserts a
    *single* character, `''\n''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Apart from the (occasionally important) issue of performance, the choice between
    `'\n'` and `endl` is almost completely aesthetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.regex: Regex'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`<regex>` is the standard C++ regular expression library. It supports a variety
    of regular expression pattern conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.chrono: Time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`<chrono>` (defined in namespace `std::chrono`) provides the notions of `time_point`
    and `duration` together with functions for outputting time in various units. It
    provides clocks for registering `time_points`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SL.C: The C Standard Library'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'C Standard Library rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SL.C.1: Don’t use setjmp/longjmp](#rclib-jmp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SL.C.1: Don’t use setjmp/longjmp'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: a `longjmp` ignores destructors, thus invalidating all resource-management strategies
    relying on RAII
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag all occurrences of `longjmp`and `setjmp`
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Architectural ideas'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section contains ideas about higher-level architectural ideas and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Architectural rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A.1: Separate stable code from less stable code](#ra-stable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A.2: Express potentially reusable parts as a library](#ra-lib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A.4: There should be no cycles among libraries](#ra-dag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[???](#???)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A.1: Separate stable code from less stable code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Isolating less stable code facilitates its unit testing, interface improvement,
    refactoring, and eventual deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A.2: Express potentially reusable parts as a library'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A library is a collection of declarations and definitions maintained, documented,
    and shipped together. A library could be a set of headers (a “header-only library”)
    or a set of headers plus a set of object files. You can statically or dynamically
    link a library into a program, or you can `#include` a header-only library.
  prefs: []
  type: TYPE_NORMAL
- en: 'A.4: There should be no cycles among libraries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A cycle complicates the build process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cycles are hard to understand and might introduce indeterminism (unspecified
    behavior).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A library can contain cyclic references in the definition of its components.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: However, a library should not depend on another that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'NR: Non-Rules and myths'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section contains rules and guidelines that are popular somewhere, but that
    we deliberately don’t recommend. We know perfectly well that there have been times
    and places where these rules made sense, and we have used them ourselves at times.
    However, in the context of the styles of programming we recommend and support
    with the guidelines, these “non-rules” would do harm.
  prefs: []
  type: TYPE_NORMAL
- en: Even today, there can be contexts where the rules make sense. For example, lack
    of suitable tool support can make exceptions unsuitable in hard-real-time systems,
    but please don’t naïvely trust “common wisdom” (e.g., unsupported statements about
    “efficiency”); such “wisdom” might be based on decades-old information or experiences
    from languages with very different properties than C++ (e.g., C or Java).
  prefs: []
  type: TYPE_NORMAL
- en: The positive arguments for alternatives to these non-rules are listed in the
    rules offered as “Alternatives”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[NR.1: Don’t insist that all declarations should be at the top of a function](#rnr-top)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR.2: Don’t insist on having only a single `return`-statement in a function](#rnr-single-return)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR.3: Don’t avoid exceptions](#rnr-no-exceptions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR.4: Don’t insist on placing each class definition in its own source file](#rnr-lots-of-files)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR.5: Don’t use two-phase initialization](#rnr-two-phase-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR.6: Don’t place all cleanup actions at the end of a function and `goto exit`](#rnr-goto-exit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NR.7: Don’t make data members `protected`](#rnr-protected-data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NR.1: Don’t insist that all declarations should be at the top of a function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The “all declarations on top” rule is a legacy of old programming languages
    that didn’t allow initialization of variables and constants after a statement.
    This leads to longer programs and more errors caused by uninitialized and wrongly
    initialized variables.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: The larger the distance between the uninitialized variable and its use, the
    larger the chance of a bug. Fortunately, compilers catch many “used before set”
    errors. Unfortunately, compilers cannot catch all such errors and unfortunately,
    the bugs aren’t always as simple to spot as in this small example.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Always initialize an object](#res-always)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ES.21: Don’t introduce a variable (or constant) before you need to use it](#res-introduce)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NR.2: Don’t insist on having only a single `return`-statement in a function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The single-return rule can lead to unnecessarily convoluted code and the introduction
    of extra state variables. In particular, the single-return rule makes it harder
    to concentrate error checking at the top of a function.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: to use a single return only we would have to do something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: This is both longer and likely to be less efficient. The larger and more complicated
    the function is, the more painful the workarounds get. Of course many simple functions
    will naturally have just one `return` because of their simpler inherent logic.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: If we applied the rule, we’d get something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: Note that we (deliberately) violated the rule against uninitialized variables
    because this style commonly leads to that. Also, this style is a temptation to
    use the [goto exit](#rnr-goto-exit) non-rule.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Keep functions short and simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to use multiple `return` statements (and to throw exceptions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NR.3: Don’t avoid exceptions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There seem to be four main reasons given for not using exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: exceptions are inefficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exceptions lead to leaks and errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exception performance is not predictable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the exception-handling run-time support takes up too much space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no way we can settle this issue to the satisfaction of everybody. After
    all, the discussions about exceptions have been going on for 40+ years. Some languages
    cannot be used without exceptions, but others do not support them. This leads
    to strong traditions for the use and non-use of exceptions, and to heated debates.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can briefly outline why we consider exceptions the best alternative
    for general-purpose programming and in the context of these guidelines. Simple
    arguments for and against are often inconclusive. There are specialized applications
    where exceptions indeed can be inappropriate (e.g., hard-real-time systems without
    support for reliable estimates of the cost of handling an exception).
  prefs: []
  type: TYPE_NORMAL
- en: Consider the major objections to exceptions in turn
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are inefficient: Compared to what? When comparing make sure that
    the same set of errors are handled and that they are handled equivalently. In
    particular, do not compare a program that immediately terminates on seeing an
    error to a program that carefully cleans up resources before logging an error.
    Yes, some systems have poor exception handling implementations; sometimes, such
    implementations force us to use other error-handling approaches, but that’s not
    a fundamental problem with exceptions. When using an efficiency argument - in
    any context - be careful that you have good data that actually provides insight
    into the problem under discussion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions lead to leaks and errors. They do not. If your program is a rat’s
    nest of pointers without an overall strategy for resource management, you have
    a problem whatever you do. If your system consists of a million lines of such
    code, you probably will not be able to use exceptions, but that’s a problem with
    excessive and undisciplined pointer use, rather than with exceptions. In our opinion,
    you need RAII to make exception-based error handling simple and safe – simpler
    and safer than alternatives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception performance is not predictable. If you are in a hard-real-time system
    where you must guarantee completion of a task in a given time, you need tools
    to back up such guarantees. As far as we know such tools are not available (at
    least not to most programmers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception-handling run-time support takes up too much space. This can be
    the case in small (usually embedded) systems. However, before abandoning exceptions
    consider what space consistent error-handling using error-codes would require
    and what failure to catch an error would cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many, possibly most, problems with exceptions stem from historical needs to
    interact with messy old code.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental arguments for the use of exceptions are
  prefs: []
  type: TYPE_NORMAL
- en: They clearly differentiate between erroneous return and ordinary return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot be forgotten or ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used systematically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are for reporting errors (in C++; other languages can have different
    uses for exceptions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions are not for errors that can be handled locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t try to catch every exception in every function (that’s tedious, clumsy,
    and leads to slow code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions are not for errors that require instant termination of a module/system
    after a non-recoverable error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[RAII](#re-raii)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contracts/assertions: Use GSL’s `Expects` and `Ensures` (until we get language
    support for contracts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NR.4: Don’t insist on placing each class definition in its own source file'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The resulting number of files from placing each class in its own file are hard
    to manage and can slow down compilation. Individual classes are rarely a good
    logical unit of maintenance and distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use namespaces containing logically cohesive sets of classes and functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NR.5: Don’t use two-phase initialization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Splitting initialization into two leads to weaker invariants, more complicated
    code (having to deal with semi-constructed objects), and errors (when we didn’t
    deal correctly with semi-constructed objects consistently).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes also called two-stage construction.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Always establish a class invariant in a constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t define an object before it is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NR.6: Don’t place all cleanup actions at the end of a function and `goto exit`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`goto` is error-prone. This technique is a pre-exception technique for RAII-like
    resource and error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: and spot the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use exceptions and [RAII](#re-raii)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for non-RAII resources, use [`finally`](#re-finally).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NR.7: Don’t make data members `protected`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`protected` data is a source of errors. `protected` data can be manipulated
    from an unbounded amount of code in various places. `protected` data is the class
    hierarchy equivalent to global data.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: Alternative
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Avoid `protected` data](#rh-protected)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RF: References'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many coding standards, rules, and guidelines have been written for C++, and
    especially for specialized uses of C++. Many
  prefs: []
  type: TYPE_NORMAL
- en: focus on lower-level issues, such as the spelling of identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: are written by C++ novices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: see “stopping programmers from doing unusual things” as their primary aim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aim at portability across many compilers (some 10 years old)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: are written to preserve decades old code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: aim at a single application domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: are downright counterproductive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: are ignored (must be ignored by programmers to get their work done well)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A bad coding standard is worse than no coding standard. However an appropriate
    set of guidelines are much better than no standards: “Form is liberating.”'
  prefs: []
  type: TYPE_NORMAL
- en: Why can’t we just have a language that allows all we want and disallows all
    we don’t want (“a perfect language”)? Fundamentally, because affordable languages
    (and their tool chains) also serve people with needs that differ from yours and
    serve more needs than you have today. Also, your needs change over time and a
    general-purpose language is needed to allow you to adapt. A language that is ideal
    for today would be overly restrictive tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: Coding guidelines adapt the use of a language to specific needs. Thus, there
    cannot be a single coding style for everybody. We expect different organizations
    to provide additions, typically with more restrictions and firmer style rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reference sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[RF.rules: Coding rules](#ss-rules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RF.books: Books with coding guidelines](#ss-books)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RF.C++: C++ Programming (C++11/C++14/C++17)](#ss-cplusplus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RF.web: Websites](#ss-web)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RS.video: Videos about “modern C++”](#ss-vid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RF.man: Manuals](#ss-man)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RF.core: Core Guidelines materials](#ss-core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RF.rules: Coding rules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[AUTOSAR Guidelines for the use of the C++14 language in critical and safety-related
    systems v22.11](https://www.autosar.org/fileadmin/standards/R22-11/AP/AUTOSAR_RS_CPP14Guidelines.pdf)
    (obsolete, replaced by [MISRA C++:2023](https://misra.org.uk/product/misra-cpp2023/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Boost Library Requirements and Guidelines](https://www.boost.org/development/requirements.html).
    ???.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bloomberg: BDE C++ Coding](https://github.com/bloomberg/bde/wiki/CodingStandards.pdf).
    Has a strong emphasis on code organization and layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Facebook: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GCC Coding Conventions](https://gcc.gnu.org/codingconventions.html). C++03
    and (reasonably) a bit backwards looking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).
    Geared toward C++17 and (also) older code bases. Google experts are now actively
    collaborating here on helping to improve these Guidelines, and hopefully to merge
    efforts so these can be a modern common set they could also recommend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS](https://www.stroustrup.com/JSF-AV-rules.pdf).
    Document Number 2RDU00001 Rev C. December 2005. For flight control software. For
    hard-real-time. This means that it is necessarily very restrictive (“if the program
    fails somebody dies”). For example, no free store allocation or deallocation is
    allowed to occur after the plane takes off (no memory overflow and no fragmentation
    allowed). No exception is allowed to be used (because there was no available tool
    for guaranteeing that an exception would be handled within a fixed short time).
    Libraries used have to have been approved for mission critical applications. Any
    similarities to this set of guidelines are unsurprising because Bjarne Stroustrup
    was an author of JSF++. Recommended, but note its very specific focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MISRA C++:2023 Guidelines for the use C++17 in critical systems](https://misra.org.uk/product/misra-cpp2023/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using C++ in Mozilla Code](https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html).
    As the name indicates, this aims for portability across many (old) compilers.
    As such, it is restrictive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Geosoft.no: C++ Programming Style Guidelines](https://geosoft.no/development/cppstyle.html).
    ???.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Possibility.com: C++ Coding Standard](https://www.possibility.com/Cpp/CppCodingStandard.html).
    ???.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SEI CERT: Secure C++ Coding Standard](https://wiki.sei.cmu.edu/confluence/x/Wnw-BQ).
    A very nicely done set of rules (with examples and rationales) done for security-sensitive
    code. Many of their rules apply generally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[High Integrity C++ Coding Standard](https://www.codingstandard.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[llvm](https://llvm.org/docs/CodingStandards.html). Somewhat brief, based on
    C++14, and (not unreasonably) adjusted to its domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RF.books: Books with coding guidelines'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Meyers96](#Meyers96) Scott Meyers: *More Effective C++*. Addison-Wesley 1996.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers97](#Meyers97) Scott Meyers: *Effective C++, Second Edition*. Addison-Wesley
    1997.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers01](#Meyers01) Scott Meyers: *Effective STL*. Addison-Wesley 2001.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers05](#Meyers05) Scott Meyers: *Effective C++, Third Edition*. Addison-Wesley
    2005.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers15](#Meyers15) Scott Meyers: *Effective Modern C++*. O’Reilly 2015.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SuttAlex05](#SuttAlex05) Sutter and Alexandrescu: *C++ Coding Standards*.
    Addison-Wesley 2005\. More a set of meta-rules than a set of rules. Pre-C++11.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup05](#Stroustrup05) Bjarne Stroustrup: [A rationale for semantically
    enhanced library languages](https://www.stroustrup.com/SELLrationale.pdf). LCSD05\.
    October 2005.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup14](#Stroustrup05) Stroustrup: [A Tour of C++](https://www.stroustrup.com/Tour.html).
    Addison-Wesley 2014. Each chapter ends with an advice section consisting of a
    set of recommendations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup13](#Stroustrup13) Stroustrup: [The C++ Programming Language (4th
    Edition)](https://www.stroustrup.com/4th.html). Addison-Wesley 2013. Each chapter
    ends with an advice section consisting of a set of recommendations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stroustrup: [Style Guide](https://www.stroustrup.com/Programming/PPP-style.pdf)
    for [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html).
    Mostly low-level naming and layout rules. Primarily a teaching tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RF.C++: C++ Programming (C++11/C++14)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[TC++PL4](https://www.stroustrup.com/4th.html): A thorough description of the
    C++ language and standard libraries for experienced programmers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tour++](https://www.stroustrup.com/Tour.html): An overview of the C++ language
    and standard libraries for experienced programmers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html):
    A textbook for beginners and relative novices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RF.web: Websites'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[isocpp.org](https://isocpp.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bjarne Stroustrup’s home pages](https://www.stroustrup.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WG21](https://www.open-std.org/jtc1/sc22/wg21/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Boost](https://www.boost.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adobe open source](https://opensource.adobe.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Poco libraries](https://pocoproject.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sutter’s Mill?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RS.video: Videos about “modern C++”'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [C++11 Style](https://learn.microsoft.com/en-us/shows/goingnative-2012/keynote-bjarne-stroustrup-cpp11-style).
    2012.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [The Essence of C++: With Examples in C++84, C++98, C++11,
    and C++14](https://learn.microsoft.com/en-us/shows/goingnative-2013/opening-keynote-bjarne-stroustrup).
    2013'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the talks from [CppCon ’14](https://isocpp.org/blog/2014/11/cppcon-videos-c9)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [The essence of C++](https://www.youtube.com/watch?v=86xWVb4XIyE)
    at the University of Edinburgh. 2014.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [The Evolution of C++ Past, Present and Future](https://www.youtube.com/watch?v=_wzc7a3McOs).
    CppCon 2016 keynote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [Make Simple Tasks Simple!](https://www.youtube.com/watch?v=nesCaocNjtQ).
    CppCon 2014 keynote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A).
    CppCon 2015 keynote about the Core Guidelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Herb Sutter: [Writing Good C++14… By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA).
    CppCon 2015 keynote about the Core Guidelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CppCon 15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? C++ Next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? Meting C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ??? more ???
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RF.man: Manuals'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ISO C++ Standard C++11.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISO C++ Standard C++14.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ISO C++ Standard C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf).
    Committee Draft.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Palo Alto “Concepts” TR](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ISO C++ Concepts TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WG21 Ranges report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf).
    Draft.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RF.core: Core Guidelines materials'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section contains materials that have been useful for presenting the core
    guidelines and the ideas behind them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Our documents directory](https://github.com/isocpp/CppCoreGuidelines/tree/master/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stroustrup, Sutter, and Dos Reis: [A brief introduction to C++’s model for
    type- and resource-safety](https://www.stroustrup.com/resource-model.pdf). A paper
    with lots of examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sergey Zubkov: [a Core Guidelines talk](https://www.youtube.com/watch?v=DyLwdl_6vmU)
    and here are the [slides](https://www.slideshare.net/slideshow/c-core-guidelines-72335317/72335317).
    In Russian. 2017.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Neil MacIntosh: [The Guideline Support Library: One Year Later](https://www.youtube.com/watch?v=_GhNnCuaEjo).
    CppCon 2016.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A).
    CppCon 2015 keynote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Herb Sutter: [Writing Good C++14… By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA).
    CppCon 2015 keynote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Peter Sommerlad: [C++ Core Guidelines - Modernize your C++ Code Base](https://www.youtube.com/watch?v=fQ926v4ZzAM).
    ACCU 2017.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bjarne Stroustrup: [No Littering!](https://www.youtube.com/watch?v=01zI9kV4h8c).
    Bay Area ACCU 2016. It gives some idea of the ambition level for the Core Guidelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that slides for CppCon presentations are available (links with the posted
    videos).
  prefs: []
  type: TYPE_NORMAL
- en: Contributions to this list would be most welcome.
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thanks to the many people who contributed rules, suggestions, supporting information,
    references, etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Juhl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neil MacIntosh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axel Naumann
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Andrew Pardoe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gabriel Dos Reis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zhuang, Jiangang (Jeff)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sergey Zubkov
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and see the contributor list on the github.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro: Profiles'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, we would follow all of the guidelines. That would give the cleanest,
    most regular, least error-prone, and often the fastest code. Unfortunately, that
    is usually impossible because we have to fit our code into large code bases and
    use existing libraries. Often, such code has been written over decades and does
    not follow these guidelines. We must aim for [gradual adoption](#s-modernizing).
  prefs: []
  type: TYPE_NORMAL
- en: Whatever strategy for gradual adoption we adopt, we need to be able to apply
    sets of related guidelines to address some set of problems first and leave the
    rest until later. A similar idea of “related guidelines” becomes important when
    some, but not all, guidelines are considered relevant to a code base or if a set
    of specialized guidelines is to be applied for a specialized application area.
    We call such a set of related guidelines a “profile”. We aim for such a set of
    guidelines to be coherent so that they together help us reach a specific goal,
    such as “absence of range errors” or “static type safety.” Each profile is designed
    to eliminate a class of errors. Enforcement of “random” rules in isolation is
    more likely to be disruptive to a code base than delivering a definite improvement.
  prefs: []
  type: TYPE_NORMAL
- en: A “profile” is a set of deterministic and portably enforceable subset of rules
    (i.e., restrictions) that are designed to achieve a specific guarantee. “Deterministic”
    means they require only local analysis and could be implemented in a compiler
    (though they don’t need to be). “Portably enforceable” means they are like language
    rules, so programmers can count on different enforcement tools giving the same
    answer for the same code.
  prefs: []
  type: TYPE_NORMAL
- en: Code written to be warning-free using such a language profile is considered
    to conform to the profile. Conforming code is considered to be safe by construction
    with regard to the safety properties targeted by that profile. Conforming code
    will not be the root cause of errors for that property, although such errors might
    be introduced into a program by other code, libraries or the external environment.
    A profile might also introduce additional library types to ease conformance and
    encourage correct code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Profiles summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pro.type: Type safety](#ss-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pro.bounds: Bounds safety](#ss-bounds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pro.lifetime: Lifetime safety](#ss-lifetime)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the future, we expect to define many more profiles and add more checks to
    existing profiles. Candidates include:'
  prefs: []
  type: TYPE_NORMAL
- en: narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic
    profile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: arithmetic cast from negative floating point to unsigned integral type (ditto)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'selected undefined behavior: Start with Gabriel Dos Reis’s UB list developed
    for the WG21 study group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'selected unspecified behavior: Addressing portability concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const` violations: Mostly done by compilers already, but we can catch inappropriate
    casting and underuse of `const`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling a profile is implementation defined; typically, it is set in the analysis
    tool used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To suppress enforcement of a profile check, place a `suppress` annotation on
    a language contract. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: Now `raw_find()` can scramble memory to its heart’s content. Obviously, suppression
    should be very rare.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro.safety: Type-safety profile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This profile makes it easier to construct code that uses types correctly and
    avoids inadvertent type punning. It does so by focusing on removing the primary
    sources of type violations, including unsafe uses of casts and unions.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this section, type-safety is defined to be the property
    that a variable is not used in a way that doesn’t obey the rules for the type
    of its definition. Memory accessed as a type `T` should not be valid memory that
    actually contains an object of an unrelated type `U`. Note that the safety is
    intended to be complete when combined also with [Bounds safety](#ss-bounds) and
    [Lifetime safety](#ss-lifetime).
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of this profile shall recognize the following patterns in
    source code as non-conforming and issue a diagnostic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type safety profile summary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type.1: [Avoid casts](#res-casts):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use `reinterpret_cast`; A strict version of [Avoid casts](#res-casts)
    and [prefer named casts](#res-casts-named).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t use `static_cast` for arithmetic types; A strict version of [Avoid casts](#res-casts)
    and [prefer named casts](#res-casts-named).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t cast between pointer types where the source type and the target type are
    the same; A strict version of [Avoid casts](#res-casts).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t cast between pointer types when the conversion could be implicit; A strict
    version of [Avoid casts](#res-casts).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type.2: Don’t use `static_cast` to downcast: [Use `dynamic_cast` instead](#rh-dynamic_cast).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type.3: Don’t use `const_cast` to cast away `const` (i.e., at all): [Don’t
    cast away const](#res-casts-const).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type.4: Don’t use C-style `(T)expression` or functional `T(expression)` casts:
    Prefer [construction](#res-construct) or [named casts](#res-casts-named) or `T{expression}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type.5: Don’t use a variable before it has been initialized: [always initialize](#res-always).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type.6: Always initialize a data member: [always initialize](#res-always),
    possibly using [default constructors](#rc-default0) or [default member initializers](#rc-in-class-initializer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type.7: Avoid naked union: [Use `variant` instead](#ru-naked).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type.8: Avoid varargs: [Don’t use `va_arg` arguments](#f-varargs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Impact
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With the type-safety profile you can trust that every operation is applied to
    a valid object. An exception can be thrown to indicate errors that cannot be detected
    statically (at compile time). Note that this type-safety can be complete only
    if we also have [Bounds safety](#ss-bounds) and [Lifetime safety](#ss-lifetime).
    Without those guarantees, a region of memory could be accessed independent of
    which object, objects, or parts of objects are stored in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro.bounds: Bounds safety profile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This profile makes it easier to construct code that operates within the bounds
    of allocated blocks of memory. It does so by focusing on removing the primary
    sources of bounds violations: pointer arithmetic and array indexing. One of the
    core features of this profile is to restrict pointers to only refer to single
    objects, not arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: We define bounds-safety to be the property that a program does not use an object
    to access memory outside of the range that was allocated for it. Bounds safety
    is intended to be complete only when combined with [Type safety](#ss-type) and
    [Lifetime safety](#ss-lifetime), which cover other unsafe operations that allow
    bounds violations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bounds safety profile summary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bounds.1: Don’t use pointer arithmetic. Use `span` instead: [Pass pointers
    to single objects (only)](#ri-array) and [Keep pointer arithmetic simple](#res-ptr).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bounds.2: Only index into arrays using constant expressions: [Pass pointers
    to single objects (only)](#ri-array) and [Keep pointer arithmetic simple](#res-ptr).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bounds.3: No array-to-pointer decay: [Pass pointers to single objects (only)](#ri-array)
    and [Keep pointer arithmetic simple](#res-ptr).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bounds.4: Don’t use standard-library functions and types that are not bounds-checked:
    [Use the standard library in a type-safe manner](#rsl-bounds).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Impact
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Bounds safety implies that access to an object - notably arrays - does not access
    beyond the object’s memory allocation. This eliminates a large class of insidious
    and hard-to-find errors, including the (in)famous “buffer overflow” errors. This
    closes security loopholes as well as a prominent source of memory corruption (when
    writing out of bounds). Even if an out-of-bounds access is “just a read”, it can
    lead to invariant violations (when the accessed isn’t of the assumed type) and
    “mysterious values.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro.lifetime: Lifetime safety profile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing through a pointer that doesn’t point to anything is a major source
    of errors, and very hard to avoid in many traditional C or C++ styles of programming.
    For example, a pointer might be uninitialized, the `nullptr`, point beyond the
    range of an array, or to a deleted object.
  prefs: []
  type: TYPE_NORMAL
- en: '[See the current design specification here.](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lifetime safety profile summary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lifetime.1: Don’t dereference a possibly invalid pointer: [detect or avoid](#res-deref).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Impact
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once completely enforced through a combination of style rules, static analysis,
    and library support, this profile
  prefs: []
  type: TYPE_NORMAL
- en: eliminates one of the major sources of nasty errors in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: eliminates a major source of potential security violations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: improves performance by eliminating redundant “paranoia” checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: increases confidence in correctness of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: avoids undefined behavior by enforcing a key C++ language rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GSL: Guidelines support library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GSL is a small library of facilities designed to support this set of guidelines.
    Without these facilities, the guidelines would have to be far more restrictive
    on language details.
  prefs: []
  type: TYPE_NORMAL
- en: The Core Guidelines support library is defined in namespace `gsl` and the names
    might be aliases for standard library or other well-known library names. Using
    the (compile-time) indirection through the `gsl` namespace allows for experimentation
    and for local variants of the support facilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GSL is header only, and can be found at [GSL: Guidelines support library](https://github.com/Microsoft/GSL).
    The support library facilities are designed to be extremely lightweight (zero-overhead)
    so that they impose no overhead compared to using conventional alternatives. Where
    desirable, they can be “instrumented” with additional functionality (e.g., checks)
    for tasks such as debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: These Guidelines use types from the standard (e.g., C++17) in addition to ones
    from the GSL. For example, we assume a `variant` type, but this is not currently
    in GSL. Eventually, use [the one voted into C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the GSL types listed below might not be supported in the library you
    use due to technical reasons such as limitations in the current versions of C++.
    Therefore, please consult your GSL documentation to find out more.
  prefs: []
  type: TYPE_NORMAL
- en: For each GSL type below we state an invariant for that type. That invariant
    holds as long as user code only changes the state of a GSL object using the type’s
    provided member/free functions (i.e., user code does not bypass the type’s interface
    to change the object’s value/bits by violating any other Guidelines rule).
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary of GSL components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[GSL.view: Views](#ss-views)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GSL.owner: Ownership pointers](#ss-ownership)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GSL.assert: Assertions](#ss-assertions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GSL.util: Utilities](#ss-utilities)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GSL.concept: Concepts](#ss-gsl-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We plan for a “ISO C++ standard style” semi-formal specification of the GSL.
  prefs: []
  type: TYPE_NORMAL
- en: We rely on the ISO C++ Standard Library and hope for parts of the GSL to be
    absorbed into the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'GSL.view: Views'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These types allow the user to distinguish between owning and non-owning pointers
    and between pointers to a single object and pointers to the first element of a
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: These “views” are never owners.
  prefs: []
  type: TYPE_NORMAL
- en: 'References are never owners (see [R.4](#rr-ref)). Note: References have many
    opportunities to outlive the objects they refer to (returning a local variable
    by reference, holding a reference to an element of a vector and doing `push_back`,
    binding to `std::max(x, y + 1)`, etc). The Lifetime safety profile aims to address
    those things, but even so `owner<T&>` does not make sense and is discouraged.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names are mostly ISO standard-library style (lower case and underscore):'
  prefs: []
  type: TYPE_NORMAL
- en: '`T*` // The `T*` is not an owner, might be null; assumed to be pointing to
    a single element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T&` // The `T&` is not an owner and can never be a “null reference”; references
    are always bound to objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “raw-pointer” notation (e.g. `int*`) is assumed to have its most common
    meaning; that is, a pointer points to an object, but does not own it. Owners should
    be converted to resource handles (e.g., `unique_ptr` or `vector<T>`) or marked
    `owner<T*>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`owner<T*>` // a `T*` that owns the object pointed/referred to; might be `nullptr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner` is used to mark owning pointers in code that cannot be upgraded to
    use proper resource handles. Reasons for that include:'
  prefs: []
  type: TYPE_NORMAL
- en: Cost of conversion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pointer is used with an ABI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pointer is part of the implementation of a resource handle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `owner<T>` differs from a resource handle for a `T` by still requiring an
    explicit `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: An `owner<T>` is assumed to refer to an object on the free store (heap).
  prefs: []
  type: TYPE_NORMAL
- en: 'If something is not supposed to be `nullptr`, say so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`not_null<T>` // `T` is usually a pointer type (e.g., `not_null<int*>` and
    `not_null<owner<Foo*>>`) that must not be `nullptr`. `T` can be any type for which
    `==nullptr` is meaningful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span<T>` // `[p:p+n)`, constructor from `{p, q}` and `{p, n}`; `T` is the
    pointer type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span_p<T>` // `{p, predicate}` `[p:q)` where `q` is the first element for
    which `predicate(*p)` is true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `span<T>` refers to zero or more mutable `T`s unless `T` is a `const` type.
    All accesses to elements of the span, notably via `operator[]`, are guaranteed
    to be bounds-checked by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: GSL’s `span` (initially called `array_view`) was proposed for inclusion
    in the C++ standard library, and was adopted (with changes to its name and interface)
    except only that `std::span` does not provide for guaranteed bounds checking.
    Therefore GSL changed `span`’s name and interface to track `std::span` and should
    be exactly the same as `std::span`, and the only difference should be that GSL
    `span` is fully bounds-safe by default. If bounds-safety might affect its interface,
    then those change proposals should be brought back via the ISO C++ committee to
    keep `gsl::span` interface-compatible with `std::span`. If a future evolution
    of `std::span` adds bounds checking, `gsl::span` can be removed.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Pointer arithmetic” is best done within `span`s. A `char*` that points to more
    than one `char` but is not a C-style string (e.g., a pointer into an input buffer)
    should be represented by a `span`.
  prefs: []
  type: TYPE_NORMAL
- en: '`zstring` // a `char*` supposed to be a C-style string; that is, a zero-terminated
    sequence of `char` or `nullptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`czstring` // a `const char*` supposed to be a C-style string; that is, a zero-terminated
    sequence of `const` `char` or `nullptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logically, those last two aliases are not needed, but we are not always logical,
    and they make the distinction between a pointer to one `char` and a pointer to
    a C-style string explicit. A sequence of characters that is not assumed to be
    zero-terminated should be a `span<char>`, or if that is impossible because of
    ABI issues a `char*`, rather than a `zstring`.
  prefs: []
  type: TYPE_NORMAL
- en: Use `not_null<zstring>` for C-style strings that cannot be `nullptr`. ??? Do
    we need a name for `not_null<zstring>`? or is its ugliness a feature?
  prefs: []
  type: TYPE_NORMAL
- en: 'GSL.owner: Ownership pointers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`unique_ptr<T>` // unique ownership: `std::unique_ptr<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared_ptr<T>` // shared ownership: `std::shared_ptr<T>` (a counted pointer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stack_array<T>` // A stack-allocated array. The number of elements is determined
    at construction and fixed thereafter. The elements are mutable unless `T` is a
    `const` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dyn_array<T>` // A container, non-growing dynamically allocated array. The
    number of elements is determined at construction and fixed thereafter. The elements
    are mutable unless `T` is a `const` type. Basically a `span` that allocates and
    owns its elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GSL.assert: Assertions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Expects` // precondition assertion. Currently placed in function bodies. Later,
    should be moved to declarations. // `Expects(p)` terminates the program unless
    `p == true` // `Expects` is under control of some options (enforcement, error
    message, alternatives to terminate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ensures` // postcondition assertion. Currently placed in function bodies.
    Later, should be moved to declarations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These assertions are currently macros (yuck!) and must appear in function definitions
    (only) pending standard committee decisions on contracts and assertion syntax.
    See [the contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf);
    using the attribute syntax, for example, `Expects(p)` will become `[[expects:
    p]]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GSL.util: Utilities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`finally` // `finally(f)` makes a `final_action{f}` with a destructor that
    invokes `f`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`narrow_cast` // `narrow_cast<T>(x)` is `static_cast<T>(x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`narrow` // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x) ==
    x` with no signedness promotions, or it throws `narrowing_error` (e.g., `narrow<unsigned>(-42)`
    throws)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[implicit]]` // “Marker” to put on single-argument constructors to explicitly
    make them non-explicit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`move_owner` // `p = move_owner(q)` means `p = q` but ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joining_thread` // a RAII style version of `std::thread` that joins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index` // a type to use for all container and array indexing (currently an
    alias for `ptrdiff_t`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GSL.concept: Concepts'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These concepts (type predicates) are borrowed from Andrew Sutton’s Origin library,
    the Range proposal, and the ISO WG21 Palo Alto TR. Many of them are very similar
    to what became part of the ISO C++ standard in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Range` // in C++20, `std::ranges::range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sortable` // in C++20, `std::sortable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EqualityComparable` // in C++20, `std::equality_comparable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Convertible` // in C++20, `std::convertible_to`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Common` // in C++20, `std::common_with`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Integral` // in C++20, `std::integral`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SignedIntegral` // in C++20, `std::signed_integral`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SemiRegular` // in C++20, `std::semiregular`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Regular` // in C++20, `std::regular`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotallyOrdered` // in C++20, `std::totally_ordered`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Function` // in C++20, `std::invocable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularFunction` // in C++20, `std::regular_invocable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Predicate` // in C++20, `std::predicate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Relation` // in C++20, `std::relation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GSL.ptr: Smart pointer concepts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Pointer` // A type with `*`, `->`, `==`, and default construction (default
    construction is assumed to set the singular “null” value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unique_pointer` // A type that matches `Pointer`, is movable, and is not copyable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shared_pointer` // A type that matches `Pointer`, and is copyable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NL: Naming and layout suggestions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consistent naming and layout are helpful. If for no other reason because it
    minimizes “my style is better than your style” arguments. However, there are many,
    many, different styles around and people are passionate about them (pro and con).
    Also, most real-world projects include code from many sources, so standardizing
    on a single style for all code is often impossible. After many requests for guidance
    from users, we present a set of rules that you might use if you have no better
    ideas, but the real aim is consistency, rather than any particular rule set. IDEs
    and tools can help (as well as hinder).
  prefs: []
  type: TYPE_NORMAL
- en: 'Naming and layout rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[NL.1: Don’t say in comments what can be clearly stated in code](#rl-comments)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.2: State intent in comments](#rl-comments-intent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.3: Keep comments crisp](#rl-comments-crisp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.4: Maintain a consistent indentation style](#rl-indent)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.5: Avoid encoding type information in names](#rl-name-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.7: Make the length of a name roughly proportional to the length of its
    scope](#rl-name-length)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.8: Use a consistent naming style](#rl-name)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.9: Use `ALL_CAPS` for macro names only](#rl-all-caps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.10: Prefer `underscore_style` names](#rl-camel)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.11: Make literals readable](#rl-literals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.15: Use spaces sparingly](#rl-space)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.16: Use a conventional class member declaration order](#rl-order)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.17: Use K&R-derived layout](#rl-knr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.18: Use C++-style declarator layout](#rl-ptr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.19: Avoid names that are easily misread](#rl-misread)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.20: Don’t place two statements on the same line](#rl-stmt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.21: Declare one name (only) per declaration](#rl-dcl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.25: Don’t use `void` as an argument type](#rl-void)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.26: Use conventional `const` notation](#rl-const)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NL.27: Use a `.cpp` suffix for code files and `.h` for interface files](#rl-file-suffix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these rules are aesthetic and programmers hold strong opinions. IDEs
    also tend to have defaults and a range of alternatives. These rules are suggested
    defaults to follow unless you have reasons not to.
  prefs: []
  type: TYPE_NORMAL
- en: We have had comments to the effect that naming and layout are so personal and/or
    arbitrary that we should not try to “legislate” them. We are not “legislating”
    (see the previous paragraph). However, we have had many requests for a set of
    naming and layout conventions to use when there are no external constraints.
  prefs: []
  type: TYPE_NORMAL
- en: More specific and detailed rules are easier to enforce.
  prefs: []
  type: TYPE_NORMAL
- en: 'These rules bear a strong resemblance to the recommendations in the [PPP Style
    Guide](https://www.stroustrup.com/Programming/PPP-style.pdf) written in support
    of Stroustrup’s [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.1: Don’t say in comments what can be clearly stated in code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Compilers do not read comments. Comments are less precise than code. Comments
    are not updated as consistently as code.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Build an AI program that interprets colloquial English text and see if what
    is said could be better expressed in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.2: State intent in comments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Code says what is done, not what is supposed to be done. Often intent can be
    stated more clearly and concisely than the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the comment and the code disagree, both are likely to be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.3: Keep comments crisp'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Verbosity slows down understanding and makes the code harder to read by spreading
    it around in the source file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use intelligible English. I might be fluent in Danish, but most programmers
    are not; the maintainers of my code might not be. Avoid SMS lingo and watch your
    grammar, punctuation, and capitalization. Aim for professionalism, not “cool.”
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.4: Maintain a consistent indentation style'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Avoidance of “silly mistakes.”
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Always indenting the statement after `if (...)`, `for (...)`, and `while (...)`
    is usually a good idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use a tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.5: Avoid encoding type information in names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rationale
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If names reflect types rather than functionality, it becomes hard to change
    the types used to provide that functionality. Also, if the type of a variable
    is changed, code using it will have to be modified. Minimize unintentional conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: Example, good
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Names with types encoded are either verbose or cryptic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: Requiring techniques like Hungarian notation to encode a type has been used
    in untyped languages, but is generally unnecessary and actively harmful in a strongly
    statically-typed language like C++, because the annotations get out of date (the
    warts are just like comments and rot just like them) and they interfere with good
    use of the language (use the same name and overload resolution instead).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some styles use very general (not type-specific) prefixes to denote the general
    use of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: This is not harmful and does not fall under this guideline because it does not
    encode type information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some styles distinguish members from local variable, and/or from global variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: This is not harmful and does not fall under this guideline because it does not
    encode type information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like C++, some styles distinguish types from non-types. For example, by capitalizing
    type names, but not the names of functions and variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: This is not harmful and does not fall under this guideline because it does not
    encode type information.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.7: Make the length of a name roughly proportional to the length of its scope'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Rationale**: The larger the scope the greater the chance of confusion and
    of an unintended name clash.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: The use of `p` for pointer and `x` for a floating-point variable is conventional
    and non-confusing in a restricted scope.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.8: Use a consistent naming style'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Rationale**: Consistency in naming and naming style increases readability.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are many styles and when you use multiple libraries, you can’t follow
    all their different conventions. Choose a “house style”, but leave “imported”
    libraries with their original style.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'ISO Standard, use lower case only and digits, separate words with underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid identifier names that contain double underscores `__` or that start with
    an underscore followed by a capital letter (e.g., `_Throws`). Such identifiers
    are reserved for the C++ implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Stroustrup](https://www.stroustrup.com/Programming/PPP-style.pdf): ISO Standard,
    but with upper case used for your own types and concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`My_map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'CamelCase: capitalize each word in a multi-word identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some conventions capitalize the first letter, some don’t.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Try to be consistent in your use of acronyms and lengths of identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Would be possible except for the use of libraries with varying conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.9: Use `ALL_CAPS` for macro names only'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid confusing macros with names that obey scope and type rules.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In particular, this avoids confusing macros with non-macro symbolic constants
    (see also [Enum.5: Don’t use `ALL_CAPS` for enumerators](#renum-caps))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag macros with lower-case letters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag `ALL_CAPS` non-macro names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NL.10: Prefer `underscore_style` names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The use of underscores to separate parts of a name is the original C and C++
    style and used in the C++ Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This rule is a default to use only if you have a choice. Often, you don’t have
    a choice and must follow an established style for [consistency](#rl-name). The
    need for consistency beats personal taste.
  prefs: []
  type: TYPE_NORMAL
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Stroustrup](https://www.stroustrup.com/Programming/PPP-style.pdf): ISO Standard,
    but with upper case used for your own types and concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vector`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`My_map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.11: Make literals readable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use digit separators to avoid long strings of digits
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use literal suffixes where clarification is needed
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Literals should not be sprinkled all over the code as [“magic constants”](#res-magic),
    but it is still a good idea to make them readable where they are defined. It is
    easy to make a typo in a long string of integers.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag long digit sequences. The trouble is to define “long”; maybe 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.15: Use spaces sparingly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Too much space makes the text larger and distracts.
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some IDEs have their own opinions and add distracting space.
  prefs: []
  type: TYPE_NORMAL
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We value well-placed whitespace as a significant help for readability. Just
    don’t overdo it.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.16: Use a conventional class member declaration order'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A conventional order of members improves readability.
  prefs: []
  type: TYPE_NORMAL
- en: When declaring a class use the following order
  prefs: []
  type: TYPE_NORMAL
- en: 'types: classes, enums, and aliases (`using`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: constructors, assignments, destructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `public` before `protected` before `private` order.
  prefs: []
  type: TYPE_NORMAL
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes, the default order of members conflicts with a desire to separate
    the public interface from implementation details. In such cases, private types
    and functions can be placed with private data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Avoid multiple blocks of declarations of one access (e.g., `public`) dispersed
    among blocks of declarations with different access (e.g. `private`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: The use of macros to declare groups of members often leads to violation of any
    ordering rules. However, using macros obscures what is being expressed anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag departures from the suggested order. There will be a lot of old code that
    doesn’t follow this rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.17: Use K&R-derived layout'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is the original C and C++ layout. It preserves vertical space well. It
    distinguishes different language constructs (such as functions and classes) well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the context of C++, this style is often called “Stroustrup”.
  prefs: []
  type: TYPE_NORMAL
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: Note the space between `if` and `(`
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Use separate lines for each statement, the branches of an `if`, and the body
    of a `for`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `{` for a `class` and a `struct` is *not* on a separate line, but the `{`
    for a function is.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Capitalize the names of your user-defined types to distinguish them from standards-library
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do not capitalize function names.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you want enforcement, use an IDE to reformat.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.18: Use C++-style declarator layout'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The C-style layout emphasizes use in expressions and grammar, whereas the C++-style
    emphasizes types. The use in expressions argument doesn’t hold for references.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Impossible in the face of history.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.19: Avoid names that are easily misread'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Not everyone has screens and printers that make it easy to distinguish
    all characters. We easily confuse similarly spelled and slightly misspelled words.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.20: Don’t place two statements on the same line'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. It is really easy to overlook a statement when there is more on
    a line.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.21: Declare one name (only) per declaration'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Readability. Minimizing confusion with the declarator syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For details, see [ES.10](#res-name-one).
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.25: Don’t use `void` as an argument type'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s verbose and only needed where C compatibility matters.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Even Dennis Ritchie deemed `void f(void)` an abomination. You can make an argument
    for that abomination in C when function prototypes were rare so that banning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: would have caused major problems, but not in the 21st century and in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.26: Use conventional `const` notation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Conventional notation is more familiar to more programmers. Consistency in large
    code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We are well aware that you could claim the “bad” examples are more logical than
    the ones marked “OK”, but they also confuse more people, especially novices relying
    on teaching material using the far more common, conventional OK style.
  prefs: []
  type: TYPE_NORMAL
- en: As ever, remember that the aim of these naming and layout rules is consistency
    and that aesthetics vary immensely.
  prefs: []
  type: TYPE_NORMAL
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag `const` used as a suffix for a type.
  prefs: []
  type: TYPE_NORMAL
- en: 'NL.27: Use a `.cpp` suffix for code files and `.h` for interface files'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s a longstanding convention. But consistency is more important, so if your
    project uses something else, follow that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This convention reflects a common use pattern: Headers are more often shared
    with C to compile as both C++ and C, which typically uses `.h`, and it’s easier
    to name all headers `.h` instead of having different extensions for just those
    headers that are intended to be shared with C. On the other hand, implementation
    files are rarely shared with C and so should typically be distinguished from `.c`
    files, so it’s normally best to name all C++ implementation files something else
    (such as `.cpp`).'
  prefs: []
  type: TYPE_NORMAL
- en: The specific names `.h` and `.cpp` are not required (just recommended as a default)
    and other names are in widespread use. Examples are `.hh`, `.C`, and `.cxx`. Use
    such names equivalently. In this document, we refer to `.h` and `.cpp` as a shorthand
    for header and implementation files, even though the actual extension might be
    different.
  prefs: []
  type: TYPE_NORMAL
- en: Your IDE (if you use one) might have strong opinions about suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: '`foo.h` provides the interface to `foo.cpp`. Global variables are best avoided.'
  prefs: []
  type: TYPE_NORMAL
- en: Example, bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: '`#include <foo.h>` twice in a program and you get a linker error for two one-definition-rule
    violations.'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Flag non-conventional file names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that `.h` and `.cpp` (and equivalents) follow the rules below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FAQ: Answers to frequently asked questions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers answers to frequently asked questions about these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.1: What do these guidelines aim to achieve?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the [top of this page](#s-abstract). This is an open-source project to maintain
    modern authoritative guidelines for writing C++ code using the current C++ Standard.
    The guidelines are designed to be modern, machine-enforceable wherever possible,
    and open to contributions and forking so that organizations can easily incorporate
    them into their own corporate coding guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.2: When and where was this work first announced?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It was announced by [Bjarne Stroustrup in his CppCon 2015 opening keynote, “Writing
    Good C++14”](https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote). See
    also the [accompanying isocpp.org blog post](https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines),
    and for the rationale of the type and memory safety guidelines see [Herb Sutter’s
    follow-up CppCon 2015 talk, “Writing Good C++14 … By Default”](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary).
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.3: Who are the authors and maintainers of these guidelines?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The initial primary authors and maintainers are Bjarne Stroustrup and Herb
    Sutter, and the guidelines so far were developed with contributions from experts
    at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time
    of their release, the guidelines are in a “0.6” state, and contributions are welcome.
    As Stroustrup said in his announcement: “We need help!”'
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.4: How can I contribute?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md).
    We appreciate volunteer help!
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.5: How can I become an editor/maintainer?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By contributing a lot first and having the consistent quality of your contributions
    recognized. See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md).
    We appreciate volunteer help!
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.6: Have these guidelines been approved by the ISO C++ standards committee?
    Do they represent the consensus of the committee?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. These guidelines are outside the standard. They are intended to serve the
    standard, and be maintained as current guidelines about how to use the current
    Standard C++ effectively. We aim to keep them in sync with the standard as that
    is evolved by the committee.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.7: If these guidelines are not approved by the committee, why are they
    under `github.com/isocpp`?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because `isocpp` is the Standard C++ Foundation; the committee’s repositories
    are under [github.com/*cplusplus*](https://github.com/cplusplus). Some neutral
    organization has to own the copyright and license to make it clear this is not
    being dominated by any one person or vendor. The natural entity is the Foundation,
    which exists to promote the use and up-to-date understanding of modern Standard
    C++ and the work of the committee. This follows the same pattern that isocpp.org
    did for the [C++ FAQ](https://isocpp.org/faq), which was initially the work of
    Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open
    project in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.8: Will there be a C++98 version of these Guidelines? A C++11 version?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. These guidelines are about how to best use modern standard C++ and write
    code assuming you have a modern conforming compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.9: Do these guidelines propose new language features?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. These guidelines are about how to best use modern Standard C++, and they
    limit themselves to recommending only those features.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.10: What version of Markdown do these guidelines use?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These coding standards are written using [CommonMark](https://commonmark.org),
    and `<a>` HTML anchors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are considering the following extensions from [GitHub Flavored Markdown
    (GFM)](https://help.github.com/articles/github-flavored-markdown/):'
  prefs: []
  type: TYPE_NORMAL
- en: fenced code blocks (consistently using indented vs. fenced is under discussion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tables (none yet but we’ll likely need them, and this is a GFM extension)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid other HTML tags and other extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We are not yet consistent with this style.'
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.50: What is the GSL (guidelines support library)?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GSL is the small set of types and aliases specified in these guidelines.
    As of this writing, their specification herein is too sparse; we plan to add a
    WG21-style interface specification to ensure that different implementations agree,
    and to propose as a contribution for possible standardization, subject as usual
    to whatever the committee decides to accept/improve/alter/reject.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.51: Is [github.com/Microsoft/GSL](https://github.com/Microsoft/GSL) the
    GSL?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. That is just a first implementation contributed by Microsoft. Other implementations
    by other vendors are encouraged, as are forks of and contributions to that implementation.
    As of this writing one week into the public project, at least one GPLv3 open-source
    implementation already exists. We plan to produce a WG21-style interface specification
    to ensure that different implementations agree.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are reluctant to bless one particular implementation because we do not want
    to make people think there is only one, and inadvertently stifle parallel implementations.
    And if these guidelines included an actual implementation, then whoever contributed
    it could be mistakenly seen as too influential. We prefer to follow the long-standing
    approach of the committee, namely to specify interfaces, not implementations.
    But at the same time we want at least one implementation available; we hope for
    many.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.53: Why weren’t the GSL types proposed through Boost?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we want to use them immediately, and because they are temporary in that
    we want to retire them as soon as types that fill the same needs exist in the
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++
    standards committee?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. The GSL exists only to supply a few types and aliases that are not currently
    in the standard library. If the committee decides on standardized versions (of
    these or other types that fill the same need) then they can be removed from the
    GSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.55: If you’re using the standard types where available, why is the GSL
    `span<char>` different from the `string_view` in the Library Fundamentals 1 Technical
    Specification and C++17 Working Paper? Why not just use the committee-approved
    `string_view`?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The consensus on the taxonomy of views for the C++ Standard Library was that
    “view” means “read-only”, and “span” means “read/write”. If you only need a read-only
    view of characters that does not need guaranteed bounds-checking and you have
    C++17, use C++17 `std::string_view`. Otherwise, if you need a read-write view
    that does not need guaranteed bounds-checking and you have C++20, use C++20 `std::span<char>`.
    Otherwise, use `gsl::span<char>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.56: Is `owner` the same as the proposed `observer_ptr`?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. `owner` owns, is an alias, and can be applied to any indirection type. The
    main intent of `observer_ptr` is to signify a *non*-owning pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.57: Is `stack_array` the same as the standard `array`?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. `stack_array` is guaranteed to be allocated on the stack. Although a `std::array`
    contains its storage directly inside itself, the `array` object can be put anywhere,
    including the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.58: Is `dyn_array` the same as `vector` or the proposed `dynarray`?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. `dyn_array` is a container, like `vector`, but it is not resizable; its
    size is fixed at runtime when it is constructed. It is a safe way to refer to
    a dynamically “heap”-allocated fixed-size array. Unlike `vector`, it is intended
    to replace array-`new[]`. Unlike the `dynarray` that has been proposed in the
    committee, this does not anticipate compiler/language magic to somehow allocate
    it on the stack when it is a member of an object that is allocated on the stack;
    it simply refers to a “dynamic” or heap-based array.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.59: Is `Expects` the same as `assert`?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. It is a placeholder for language support for contract preconditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'FAQ.60: Is `Ensures` the same as `assert`?'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No. It is a placeholder for language support for contract postconditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix A: Libraries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section lists recommended libraries, and explicitly recommends a few.
  prefs: []
  type: TYPE_NORMAL
- en: ??? Suitable for the general guide? I think not ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix B: Modernizing code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ideally, we follow all rules in all code. Realistically, we have to deal with
    a lot of old code:'
  prefs: []
  type: TYPE_NORMAL
- en: application code written before the guidelines were formulated or known
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: libraries written to older/different standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: code written under “unusual” constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: code that we just haven’t gotten around to modernizing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a million lines of new code, the idea of “just changing it all at
    once” is typically unrealistic. Thus, we need a way of gradually modernizing a
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading older code to modern style can be a daunting task. Often, the old
    code is both a mess (hard to understand) and working correctly (for the current
    range of uses). Typically, the original programmer is not around and the test
    cases incomplete. The fact that the code is a mess dramatically increases the
    effort needed to make any change and the risk of introducing errors. Often, messy
    old code runs unnecessarily slowly because it requires outdated compilers and
    cannot take advantage of modern hardware. In many cases, automated “modernizer”-style
    tool support would be required for major upgrade efforts.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of modernizing code is to simplify adding new functionality, to
    ease maintenance, and to increase performance (throughput or latency), and to
    better utilize modern hardware. Making code “look pretty” or “follow modern style”
    are not by themselves reasons for change. There are risks implied by every change
    and costs (including the cost of lost opportunities) implied by having an outdated
    code base. The cost reductions must outweigh the risks.
  prefs: []
  type: TYPE_NORMAL
- en: But how?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no one approach to modernizing code. How best to do it depends on
    the code, the pressure for updates, the backgrounds of the developers, and the
    available tool. Here are some (very general) ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: The ideal is “just upgrade everything.” That gives the most benefits for the
    shortest total time. In most circumstances, it is also impossible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could convert a code base module for module, but any rules that affects interfaces
    (especially ABIs), such as [use `span`](#ss-views), cannot be done on a per-module
    basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could convert code “bottom up” starting with the rules we estimate will give
    the greatest benefits and/or the least trouble in a given code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could start by focusing on the interfaces, e.g., make sure that no resources
    are lost and no pointer is misused. This would be a set of changes across the
    whole code base, but would most likely have huge benefits. Afterwards, code hidden
    behind those interfaces can be gradually modernized without affecting other code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever way you choose, please note that the most advantages come with the
    highest conformance to the guidelines. The guidelines are not a random set of
    unrelated rules where you can randomly pick and choose with an expectation of
    success.
  prefs: []
  type: TYPE_NORMAL
- en: We would dearly love to hear about experience and about tools used. Modernization
    can be much faster, simpler, and safer when supported with analysis tools and
    even code transformation tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix C: Discussion'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section contains follow-up material on rules and sets of rules. In particular,
    here we present further rationale, longer examples, and discussions of alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Define and initialize data members in the order of member declaration'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data members are always initialized in the order they are declared in the class
    definition, so write them in that order in the constructor initialization list.
    Writing them in a different order just makes the code confusing because it won’t
    run in the order you see, and that can make it hard to see order-dependent bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `email` will be constructed before `first` and `last` because
    it is declared first. That means its constructor will attempt to use `first` and
    `last` too soon – not just before they are set to the desired values, but before
    they are constructed at all.
  prefs: []
  type: TYPE_NORMAL
- en: If the class definition and the constructor body are in separate files, the
    long-distance influence that the order of data member declarations has over the
    constructor’s correctness will be even harder to spot.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[Cline99]](#Cline99) §22.03-11, [[Dewhurst03]](#Dewhurst03) §52-53, [[Koenig97]](#Koenig97)
    §4, [[Lakos96]](#Lakos96) §10.3.5, [[Meyers97]](#Meyers97) §13, [[Murray93]](#Murray93)
    §2.1.3, [[Sutter00]](#Sutter00) §47'
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Use of `=`, `{}`, and `()` as initializers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Use a factory function if you need “virtual behavior” during initialization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your design wants virtual dispatch into a derived class from a base class
    constructor or destructor for functions like `f` and `g`, you need other techniques,
    such as a post-constructor – a separate member function the caller must invoke
    to complete initialization, which can safely call `f` and `g` because in member
    functions virtual calls behave normally. Some techniques for this are shown in
    the References. Here’s a non-exhaustive list of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pass the buck:* Just document that user code must call the post-initialization
    function right after constructing an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Post-initialize lazily:* Do it during the first call of a member function.
    A Boolean flag in the base class tells whether or not post-construction has taken
    place yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use virtual base class semantics:* Language rules dictate that the constructor
    of the most-derived class decides which base constructor will be invoked; you
    can use that to your advantage. (See [[Taligent94]](#Taligent94).)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use a factory function:* This way, you can easily force a mandatory invocation
    of a post-constructor function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the last option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: 'This design requires the following discipline:'
  prefs: []
  type: TYPE_NORMAL
- en: Derived classes such as `D` must not expose a publicly callable constructor.
    Otherwise, `D`’s users could create `D` objects that don’t invoke `post_initialize`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocation is limited to `operator new`. `B` can, however, override `new` (see
    Items 45 and 46 in [SuttAlex05](#SuttAlex05)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D` must define a constructor with the same parameters that `B` selected. Defining
    several overloads of `create` can assuage this problem, however; and the overloads
    can even be templated on the argument types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the requirements above are met, the design guarantees that `post_initialize`
    has been called for any fully constructed `B`-derived object. `post_initialize`
    doesn’t need to be virtual; it can, however, invoke virtual functions freely.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, no post-construction technique is perfect. The worst techniques
    dodge the whole issue by simply asking the caller to invoke the post-constructor
    manually. Even the best require a different syntax for constructing objects (easy
    to check at compile time) and/or cooperation from derived class authors (impossible
    to check at compile time).
  prefs: []
  type: TYPE_NORMAL
- en: '**References**: [[Alexandrescu01]](#Alexandrescu01) §3, [[Boost]](#Boost),
    [[Dewhurst03]](#Dewhurst03) §75, [[Meyers97]](#Meyers97) §46, [[Stroustrup00]](#Stroustrup00)
    §15.4.3, [[Taligent94]](#Taligent94)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Make base class destructors public and virtual, or protected and
    non-virtual'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Should destruction behave virtually? That is, should destruction through a pointer
    to a `base` class be allowed? If yes, then `base`’s destructor must be public
    in order to be callable, and virtual, otherwise calling it results in undefined
    behavior. Otherwise, it should be protected so that only derived classes can invoke
    it in their own destructors, and non-virtual since it doesn’t need to behave virtually.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The common case for a base class is that it’s intended to have publicly derived
    classes, and so calling code is just about sure to use something like a `shared_ptr<base>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: 'In rarer cases, such as policy classes, the class is used as a base class for
    convenience, not for polymorphic behavior. It is recommended to make those destructors
    protected and non-virtual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This simple guideline illustrates a subtle issue and reflects modern uses of
    inheritance and object-oriented design principles.
  prefs: []
  type: TYPE_NORMAL
- en: For a base class `Base`, calling code might try to destroy derived objects through
    pointers to `Base`, such as when using a `unique_ptr<Base>`. If `Base`’s destructor
    is public and non-virtual (the default), it can be accidentally called on a pointer
    that actually points to a derived object, in which case the behavior of the attempted
    deletion is undefined. This state of affairs has led older coding standards to
    impose a blanket requirement that all base class destructors must be virtual.
    This is overkill (even if it is the common case); instead, the rule should be
    to make base class destructors virtual if and only if they are public.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a base class is to define an abstraction (see Items 35 through 37).
    Recall that for each member function participating in that abstraction, you need
    to decide:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether it should behave virtually or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether it should be publicly available to all callers using a pointer to `Base`
    or else be a hidden internal implementation detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As described in Item 39, for a normal member function, the choice is between
    allowing it to be called via a pointer to `Base` non-virtually (but possibly with
    virtual behavior if it invokes virtual functions, such as in the NVI or Template
    Method patterns), virtually, or not at all. The NVI pattern is a technique to
    avoid public virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Destruction can be viewed as just another operation, albeit with special semantics
    that make non-virtual calls dangerous or wrong. For a base class destructor, therefore,
    the choice is between allowing it to be called via a pointer to `Base` virtually
    or not at all; “non-virtually” is not an option. Hence, a base class destructor
    is virtual if it can be called (i.e., is public), and non-virtual otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the NVI pattern cannot be applied to the destructor because constructors
    and destructors cannot make deep virtual calls. (See Items 39 and 55.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Corollary: When writing a base class, always write a destructor explicitly,
    because the implicitly generated one is public and non-virtual. You can always
    `=default` the implementation if the default body is fine and you’re just writing
    the function to give it the proper visibility and virtuality.'
  prefs: []
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some component architectures (e.g., COM and CORBA) don’t use a standard deletion
    mechanism, and foster different protocols for object disposal. Follow the local
    patterns and idioms, and adapt this guideline as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider also this rare case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`B` is both a base class and a concrete class that can be instantiated by itself,
    and so the destructor must be public for `B` objects to be created and destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet `B` also has no virtual functions and is not meant to be used polymorphically,
    and so although the destructor is public it does not need to be virtual.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, even though the destructor has to be public, there can be great pressure
    to not make it virtual because as the first virtual function it would incur all
    the run-time type overhead when the added functionality should never be needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this rare case, you could make the destructor public and non-virtual but
    clearly document that further-derived objects must not be used polymorphically
    as `B`’s. This is what was done with `std::unary_function`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, however, avoid concrete base classes (see Item 35). For example,
    `unary_function` is a bundle-of-typedefs that was never intended to be instantiated
    standalone. It really makes no sense to give it a public destructor; a better
    design would be to follow this Item’s advice and give it a protected non-virtual
    destructor.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**: [[SuttAlex05]](#SuttAlex05) Item 50, [[Cargill92]](#Cargill92)
    pp. 77-79, 207, [[Cline99]](#Cline99) §21.06, 21.12-13, [[Henricson97]](#Henricson97)
    pp. 110-114, [[Koenig97]](#Koenig97) Chapters 4, 11, [[Meyers97]](#Meyers97) §14,
    [[Stroustrup00]](#Stroustrup00) §12.4.2, [[Sutter02]](#Sutter02) §27, [[Sutter04]](#Sutter04)
    §18'
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Usage of noexcept'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Destructors, deallocation, and swap must never fail'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never allow an error to be reported from a destructor, a resource deallocation
    function (e.g., `operator delete`), or a `swap` function using `throw`. It is
    nearly impossible to write useful code if these operations can fail, and even
    if something does go wrong it nearly never makes any sense to retry. Specifically,
    types whose destructors might throw an exception are flatly forbidden from use
    with the C++ Standard Library. Most destructors are now implicitly `noexcept`
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: '`Nefarious` objects are hard to use safely even as local variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, copying `s` could throw, and if that throws and if `n`’s destructor then
    also throws, the program will exit via `std::terminate` because two exceptions
    can’t be propagated simultaneously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Classes with `Nefarious` members or bases are also hard to use safely, because
    their destructors must invoke `Nefarious`’ destructor, and are similarly poisoned
    by its bad behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, if constructing `copy2` throws, we have the same problem because `i`’s
    destructor now also can throw, and if so we’ll invoke `std::terminate`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can’t reliably create global or static `Nefarious` objects either:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can’t reliably create arrays of `Nefarious`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The behavior of arrays is undefined in the presence of destructors that throw
    because there is no reasonable rollback behavior that could ever be devised. Just
    think: What code can the compiler generate for constructing an `arr` where, if
    the fourth object’s constructor throws, the code has to give up and in its cleanup
    mode tries to call the destructors of the already-constructed objects … and one
    or more of those destructors throws? There is no satisfactory answer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can’t use `Nefarious` objects in standard containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The standard library forbids all destructors used with it from throwing. You
    can’t store `Nefarious` objects in standard containers or use them with any other
    part of the standard library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'These are key functions that must not fail because they are necessary for the
    two key operations in transactional programming: to back out work if problems
    are encountered during processing, and to commit work if no problems occur. If
    there’s no way to safely back out using no-fail operations, then no-fail rollback
    is impossible to implement. If there’s no way to safely commit state changes using
    a no-fail operation (notably, but not limited to, `swap`), then no-fail commit
    is impossible to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following advice and requirements found in the C++ Standard:'
  prefs: []
  type: TYPE_NORMAL
- en: If a destructor called during stack unwinding exits with an exception, terminate
    is called (15.5.1). So destructors should generally catch exceptions and not let
    them propagate out of the destructor. –[[C++03]](#Cplusplus03) §15.2(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No destructor operation defined in the C++ Standard Library (including the destructor
    of any type that is used to instantiate a standard-library template) will throw
    an exception. –[[C++03]](#Cplusplus03) §17.4.4.8(3)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Deallocation functions, including specifically overloaded `operator delete`
    and `operator delete[]`, fall into the same category, because they too are used
    during cleanup in general, and during exception handling in particular, to back
    out of partial work that needs to be undone. Besides destructors and deallocation
    functions, common error-safety techniques rely also on `swap` operations never
    failing – in this case, not because they are used to implement a guaranteed rollback,
    but because they are used to implement a guaranteed commit. For example, here
    is an idiomatic implementation of `operator=` for a type `T` that performs copy
    construction followed by a call to a no-fail `swap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: (See also Item 56\. ???)
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, when releasing a resource, the scope for failure is definitely
    smaller. If using exceptions as the error reporting mechanism, make sure such
    functions handle all exceptions and other errors that their internal processing
    might generate. (For exceptions, simply wrap everything sensitive that your destructor
    does in a `try/catch(...)` block.) This is particularly important because a destructor
    might be called in a crisis situation, such as failure to allocate a system resource
    (e.g., memory, files, locks, ports, windows, or other system objects).
  prefs: []
  type: TYPE_NORMAL
- en: When using exceptions as your error handling mechanism, always document this
    behavior by declaring these functions `noexcept`. (See Item 75.)
  prefs: []
  type: TYPE_NORMAL
- en: '**References**: [[SuttAlex05]](#SuttAlex05) Item 51; [[C++03]](#Cplusplus03)
    §15.2(3), §17.4.4.8(3), [[Meyers96]](#Meyers96) §11, [[Stroustrup00]](#Stroustrup00)
    §14.4.7, §E.2-4, [[Sutter00]](#Sutter00) §8, §16, [[Sutter02]](#Sutter02) §18-19'
  prefs: []
  type: TYPE_NORMAL
- en: Define Copy, move, and destroy consistently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: ???
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you define a copy constructor, you must also define a copy assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you define a move constructor, you must also define a move assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: If you define a destructor, you should not use the compiler-generated copy or
    move operation; you probably need to define or suppress copy and/or move.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: If you define copying, and any base or member has a type that defines a move
    operation, you should also define a move operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: If you define any of the copy constructor, copy assignment operator, or destructor,
    you probably should define the others.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you need to define any of these five functions, it means you need it to
    do more than its default behavior – and the five are asymmetrically interrelated.
    Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you write/disable either of the copy constructor or the copy assignment
    operator, you probably need to do the same for the other: If one does “special”
    work, probably so should the other because the two functions should have similar
    effects. (See Item 53, which expands on this point in isolation.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you explicitly write the copying functions, you probably need to write the
    destructor: If the “special” work in the copy constructor is to allocate or duplicate
    some resource (e.g., memory, file, socket), you need to deallocate it in the destructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you explicitly write the destructor, you probably need to explicitly write
    or disable copying: If you have to write a non-trivial destructor, it’s often
    because you need to manually release a resource that the object held. If so, it
    is likely that those resources require careful duplication, and then you need
    to pay attention to the way objects are copied and assigned, or disable copying
    completely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many cases, holding properly encapsulated resources using RAII “owning” objects
    can eliminate the need to write these operations yourself. (See Item 13.)
  prefs: []
  type: TYPE_NORMAL
- en: Prefer compiler-generated (including `=default`) special members; only these
    can be classified as “trivial”, and at least one major standard library vendor
    heavily optimizes for classes having trivial special members. This is likely to
    become common practice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exceptions**: When any of the special functions are declared only to make
    them non-public or virtual, but without special semantics, it doesn’t imply that
    the others are needed. In rare cases, classes that have members of strange types
    (such as reference members) are an exception because they have peculiar copy semantics.
    In a class holding a reference, you likely need to write the copy constructor
    and the assignment operator, but the default destructor already does the right
    thing. (Note that using a reference member is almost always wrong.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**References**: [[SuttAlex05]](#SuttAlex05) Item 52; [[Cline99]](#Cline99)
    §30.01-14, [[Koenig97]](#Koenig97) §4, [[Stroustrup00]](#Stroustrup00) §5.5, §10.4,
    [[SuttHysl04b]](#SuttHysl04b)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource management rule summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Provide strong resource safety; that is, never leak anything that you think
    of as a resource](#cr-safety)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Never return or throw while holding a resource not owned by a handle](#cr-never)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A “raw” pointer or reference is never a resource handle](#cr-raw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Never let a pointer outlive the object it points to](#cr-outlive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use templates to express containers (and other resource handles)](#cr-templates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Return containers by value (relying on move or copy elision for efficiency)](#cr-value-return)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[If a class is a resource handle, it needs a constructor, a destructor, and
    copy and/or move operations](#cr-handle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[If a class is a container, give it an initializer-list constructor](#cr-list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Discussion: Provide strong resource safety; that is, never leak anything that
    you think of as a resource'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Prevent leaks. Leaks can lead to performance degradation, mysterious error,
    system crashes, and security violations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative formulation**: Have every resource represented as an object of
    some class managing its lifetime.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: This class is a resource handle. It manages the lifetime of the `T`s. To do
    so, `Vector` must define or delete [the copy, move, and destruction operations](#rc-five).
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The basic technique for preventing leaks is to have every resource owned by
    a resource handle with a suitable destructor. A checker can find “naked `new`s”.
    Given a list of C-style allocation functions (e.g., `fopen()`), a checker can
    also find uses that are not managed by a resource handle. In general, “naked pointers”
    can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources
    cannot be generated without human input (the definition of “a resource” is necessarily
    too general), but a tool can be “parameterized” with a resource list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Never return or throw while holding a resource not owned by a handle'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That would be a leak.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: 'If `i == 0` the file handle for `a file` is leaked. On the other hand, the
    `ifstream` for `another file` will correctly close its file (upon destruction).
    If you must use an explicit pointer, rather than a resource handle with specific
    semantics, use a `unique_ptr` or a `shared_ptr` with a custom deleter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: 'Better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A checker must consider all “naked pointers” suspicious. A checker probably
    must rely on a human-provided list of resources. For starters, we know about the
    standard-library containers, `string`, and smart pointers. The use of `span` and
    `string_view` should help a lot (they are not resource handles).
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: A “raw” pointer or reference is never a resource handle'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To be able to distinguish owners from views.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This is independent of how you “spell” pointer: `T*`, `T&`, `Ptr<T>` and `Range<T>`
    are not owners.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Never let a pointer outlive the object it points to'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined
    behavior and could lead to violations of the type system.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: The `string`s of `v` are destroyed upon exit from `bad()` and so is `v` itself.
    The returned pointer points to unallocated memory on the free store. This memory
    (pointed into by `p`) might have been reallocated by the time `*p` is executed.
    There might be no `string` to read and a write through `p` could easily corrupt
    objects of unrelated types.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most compilers already warn about simple cases and have the information to do
    more. Consider any pointer returned from a function suspect. Use containers, resource
    handles, and views (e.g., `span` known not to be resource handles) to lower the
    number of cases to be examined. For starters, consider every class with a destructor
    as resource handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: Use templates to express containers (and other resource handles)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To provide statically type-safe manipulation of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: 'Discussion: Return containers by value (relying on move or copy elision for
    efficiency)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To simplify code and eliminate a need for explicit memory management. To bring
    an object into a surrounding scope, thereby extending its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: '**See also**: [F.20, the general item about “out” output values](#rf-out)'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: Exception
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: See the Exceptions in [F.20](#rf-out).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Check for pointers and references returned from functions and see if they are
    assigned to resource handles (e.g., to a `unique_ptr`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: If a class is a resource handle, it needs a constructor, a destructor,
    and copy and/or move operations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To provide complete control of the lifetime of the resource. To provide a coherent
    set of operations on the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If all members are resource handles, rely on the compiler-generated operations
    where possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: Now `Named` has a default constructor, a destructor, and efficient copy and
    move operations, provided `T` has.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In general, a tool cannot know if a class is a resource handle. However, if
    a class has some of [the default operations](#ss-ctor), it should have all, and
    if a class has a member that is a resource handle, it should be considered as
    resource handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discussion: If a class is a container, give it an initializer-list constructor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reason
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is common to need an initial set of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: Enforcement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When is a class a container? ???
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix D: Supporting tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section contains a list of tools that directly support adoption of the
    C++ Core Guidelines. This list is not intended to be an exhaustive list of tools
    that are helpful in writing good C++ code. If a tool is designed specifically
    to support and links to the C++ Core Guidelines it is a candidate for inclusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools: [Clang-tidy](https://clang.llvm.org/extra/clang-tidy/checks/list.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clang-tidy has a set of rules that specifically enforce the C++ Core Guidelines.
    These rules are named in the pattern `cppcoreguidelines-*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools: [CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Microsoft compiler’s C++ code analysis contains a set of rules specifically
    aimed at enforcement of the C++ Core Guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Glossary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A relatively informal definition of terms used in the guidelines (based off
    the glossary in [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html))'
  prefs: []
  type: TYPE_NORMAL
- en: More information on many topics about C++ can be found on the [Standard C++
    Foundation](https://isocpp.org)’s site.
  prefs: []
  type: TYPE_NORMAL
- en: '*ABI*: Application Binary Interface, a specification for a specific hardware
    platform combined with the operating system. Contrast with API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*abstract class*: a class that cannot be directly used to create objects; often
    used to define an interface to derived classes. A class is made abstract by having
    a pure virtual function or only protected constructors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*abstraction*: a description of something that selectively and deliberately
    ignores (hides) details (e.g., implementation details); selective ignorance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*address*: a value that allows us to find an object in a computer’s memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*algorithm*: a procedure or formula for solving a problem; a finite series
    of computational steps to produce a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*alias*: an alternative way of referring to an object; often a name, pointer,
    or reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*API*: Application Programming Interface, a set of functions that form the
    communication between various software components. Contrast with ABI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*application*: a program or a collection of programs that is considered an
    entity by its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*approximation*: something (e.g., a value or a design) that is close to the
    perfect or ideal (value or design). Often an approximation is a result of trade-offs
    among ideals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*argument*: a value passed to a function or a template, in which it is accessed
    through a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*array*: a homogeneous sequence of elements, usually numbered, e.g., `[0:max)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*assertion*: a statement inserted into a program to state (assert) that something
    must always be true at this point in the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*base class*: a type that is intended to be derived from (e.g., has a non-`final`
    virtual function), and objects of the type are intended to be used only indirectly
    (e.g., by pointer). [In strict terms, “base class” could be defined as “something
    we derived from” but we are specifying in terms of the class designer’s intent.]
    Typically a base class has one or more virtual functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*bit*: the basic unit of information in a computer. A bit can have the value
    0 or the value 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*bug*: an error in a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*byte*: the basic unit of addressing in most computers. Typically, a byte holds
    8 bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*class*: a user-defined type that can contain data members, function members,
    and member types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*code*: a program or a part of a program; ambiguously used for both source
    code and object code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*compiler*: a program that turns source code into object code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*complexity*: a hard-to-precisely-define notion or measure of the difficulty
    of constructing a solution to a problem or of the solution itself. Sometimes complexity
    is used to (simply) mean an estimate of the number of operations needed to execute
    an algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*computation*: the execution of some code, usually taking some input and producing
    some output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*concept*: (1) a notion, and idea; (2) a set of requirements, usually for a
    template argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*concrete type*: a type that is not a base class, and objects of the type are
    intended to be used directly (not only by pointer/indirection), its size is known,
    it can typically be allocated anywhere the programmer wants (e.g., stack or statically).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*constant*: a value that cannot be changed (in a given scope); not mutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*constructor*: an operation that initializes (“constructs”) an object. Typically
    a constructor establishes an invariant and often acquires resources needed for
    an object to be used (which are then typically released by a destructor).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*container*: an object that holds elements (other objects).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*copy*: an operation that makes two objects have values that compare equal.
    See also move.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*correctness*: a program or a piece of a program is correct if it meets its
    specification. Unfortunately, a specification can be incomplete or inconsistent,
    or can fail to meet users’ reasonable expectations. Thus, to produce acceptable
    code, we sometimes have to do more than just follow the formal specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*cost*: the expense (e.g., in programmer time, run time, or space) of producing
    a program or of executing it. Ideally, cost should be a function of complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*customization point*: ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data*: values used in a computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*debugging*: the act of searching for and removing errors from a program; usually
    far less systematic than testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*declaration*: the specification of a name with its type in a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*definition*: a declaration of an entity that supplies all information necessary
    to complete a program using the entity. Simplified definition: a declaration that
    allocates memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*derived class*: a class derived from one or more base classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*design*: an overall description of how a piece of software should operate
    to meet its specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*destructor*: an operation that is implicitly invoked (called) when an object
    is destroyed (e.g., at the end of a scope). Often, it releases resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*encapsulation*: protecting something meant to be private (e.g., implementation
    details) from unauthorized access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*error*: a mismatch between reasonable expectations of program behavior (often
    expressed as a requirement or a users’ guide) and what a program actually does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*executable*: a program ready to be run (executed) on a computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*feature creep*: a tendency to add excess functionality to a program “just
    in case.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*file*: a container of permanent information in a computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*floating-point number*: a computer’s approximation of a real number, such
    as 7.93 and 10.78e-3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*function*: a named unit of code that can be invoked (called) from different
    parts of a program; a logical unit of computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*generic programming*: a style of programming focused on the design and efficient
    implementation of algorithms. A generic algorithm will work for all argument types
    that meet its requirements. In C++, generic programming typically uses templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*global variable*: technically, a named object in namespace scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*handle*: a class that allows access to another through a member pointer or
    reference. See also resource, copy, move.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*header*: a file containing declarations used to share interfaces between parts
    of a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*hiding*: the act of preventing a piece of information from being directly
    seen or accessed. For example, a name from a nested (inner) scope can prevent
    that same name from an outer (enclosing) scope from being directly used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ideal*: the perfect version of something we are striving for. Usually we have
    to make trade-offs and settle for an approximation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*implementation*: (1) the act of writing and testing code; (2) the code that
    implements a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*infinite loop*: a loop where the termination condition never becomes true.
    See iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*infinite recursion*: a recursion that doesn’t end until the machine runs out
    of memory to hold the calls. In reality, such recursion is never infinite but
    is terminated by some hardware error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*information hiding*: the act of separating interface and implementation, thus
    hiding implementation details not meant for the user’s attention and providing
    an abstraction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*initialize*: giving an object its first (initial) value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*input*: values used by a computation (e.g., function arguments and characters
    typed on a keyboard).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*integer*: a whole number, such as 42 and -99.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*interface*: a declaration or a set of declarations specifying how a piece
    of code (such as a function or a class) can be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*invariant*: something that must be always true at a given point (or points)
    of a program; typically used to describe the state (set of values) of an object
    or the state of a loop before entry into the repeated statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*iteration*: the act of repeatedly executing a piece of code; see recursion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*iterator*: an object that identifies an element of a sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ISO*: International Organization for Standardization. The C++ language is
    an ISO standard, ISO/IEC 14882\. More information at [iso.org](https://iso.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*library*: a collection of types, functions, classes, etc. implementing a set
    of facilities (abstractions) meant to be potentially used as part of more than
    one program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lifetime*: the time from the initialization of an object until it becomes
    unusable (goes out of scope, is deleted, or the program terminates).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*linker*: a program that combines object code files and libraries into an executable
    program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*literal*: a notation that directly specifies a value, such as 12 specifying
    the integer value “twelve.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*loop*: a piece of code executed repeatedly; in C++, typically a for-statement
    or a `while`-statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*move*: an operation that transfers a value from one object to another leaving
    behind a value representing “empty.” See also copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*move-only type*: a concrete type that is movable but not copyable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*mutable*: changeable; the opposite of immutable, constant, and invariable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*object*: (1) an initialized region of memory of a known type which holds a
    value of that type; (2) a region of memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*object code*: output from a compiler intended as input for a linker (for the
    linker to produce executable code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*object file*: a file containing object code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*object-oriented programming*: (OOP) a style of programming focused on the
    design and use of classes and class hierarchies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*operation*: something that can perform some action, such as a function and
    an operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*output*: values produced by a computation (e.g., a function result or lines
    of characters written on a screen).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*overflow*: producing a value that cannot be stored in its intended target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*overload*: defining two functions or operators with the same name but different
    argument (operand) types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*override*: defining a function in a derived class with the same name and argument
    types as a virtual function in the base class, thus making the function callable
    through the interface defined by the base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*owner*: an object responsible for releasing a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*paradigm*: a somewhat pretentious term for design or programming style; often
    used with the (erroneous) implication that there exists a paradigm that is superior
    to all others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*parameter*: a declaration of an explicit input to a function or a template.
    When called, a function can access the arguments passed through the names of its
    parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pointer*: (1) a value used to identify a typed object in memory; (2) a variable
    holding such a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*post-condition*: a condition that must hold upon exit from a piece of code,
    such as a function or a loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pre-condition*: a condition that must hold upon entry into a piece of code,
    such as a function or a loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*program*: code (possibly with associated data) that is sufficiently complete
    to be executed by a computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*programming*: the art of expressing solutions to problems as code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*programming language*: a language for expressing programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pseudo code*: a description of a computation written in an informal notation
    rather than a programming language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pure virtual function*: a virtual function that must be overridden in a derived
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RAII*: (“Resource Acquisition Is Initialization”) a basic technique for resource
    management based on scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*range*: a sequence of values that can be described by a start point and an
    end point. For example, `[0:5)` means the values 0, 1, 2, 3, and 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*recursion*: the act of a function calling itself; see also iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*reference*: (1) a value describing the location of a typed value in memory;
    (2) a variable holding such a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*regular expression*: a notation for patterns in character strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*regular*: a semiregular type that is equality-comparable (see `std::regular`
    concept). After a copy, the copied object compares equal to the original object.
    A regular type behaves similarly to built-in types like `int` and can be compared
    with `==`. In particular, an object of a regular type can be copied and the result
    of a copy is a separate object that compares equal to the original. See also *semiregular
    type*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*requirement*: (1) a description of the desired behavior of a program or part
    of a program; (2) a description of the assumptions a function or template makes
    of its arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*resource*: something that is acquired and must later be released, such as
    a file handle, a lock, or memory. See also handle, owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*rounding*: conversion of a value to the mathematically nearest value of a
    less precise type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RTTI*: Run-Time Type Information. ???'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*scope*: the region of program text (source code) in which a name can be referred
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*semiregular*: a concrete type that is copyable (including movable) and default-constructible
    (see `std::semiregular` concept). The result of a copy is an independent object
    with the same value as the original. A semiregular type behaves roughly like a
    built-in type like `int`, but possibly without a `==` operator. See also *regular
    type*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sequence*: elements that can be visited in a linear order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*software*: a collection of pieces of code and associated data; often used
    interchangeably with program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*source code*: code as produced by a programmer and (in principle) readable
    by other programmers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*source file*: a file containing source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*specification*: a description of what a piece of code should do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*standard*: an officially agreed upon definition of something, such as a programming
    language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*state*: a set of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*STL*: the containers, iterators, and algorithms part of the standard library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*string*: a sequence of characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*style*: a set of techniques for programming leading to a consistent use of
    language features; sometimes used in a very restricted sense to refer just to
    low-level rules for naming and appearance of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*subtype*: derived type; a type that has all the properties of a type and possibly
    more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*supertype*: base type; a type that has a subset of the properties of a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*system*: (1) a program or a set of programs for performing a task on a computer;
    (2) a shorthand for “operating system”, that is, the fundamental execution environment
    and tools for a computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TS*: [Technical Specification](https://www.iso.org/deliverables-all.html?type=ts),
    A Technical Specification addresses work still under technical development, or
    where it is believed that there will be a future, but not immediate, possibility
    of agreement on an International Standard. A Technical Specification is published
    for immediate use, but it also provides a means to obtain feedback. The aim is
    that it will eventually be transformed and republished as an International Standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*template*: a class or a function parameterized by one or more types or (compile-time)
    values; the basic C++ language construct supporting generic programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*testing*: a systematic search for errors in a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*trade-off*: the result of balancing several design and implementation criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*truncation*: loss of information in a conversion from a type into another
    that cannot exactly represent the value to be converted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*type*: something that defines a set of possible values and a set of operations
    for an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*uninitialized*: the (undefined) state of an object before it is initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*unit*: (1) a standard measure that gives meaning to a value (e.g., km for
    a distance); (2) a distinguished (e.g., named) part of a larger whole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*use case*: a specific (typically simple) use of a program meant to test its
    functionality and demonstrate its purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value*: a set of bits in memory interpreted according to a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value type*: a term some people use to mean a regular or semiregular type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*variable*: a named object of a given type; contains a value unless uninitialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*virtual function*: a member function that can be overridden in a derived class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*word*: a basic unit of memory in a computer, often the unit used to hold an
    integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To-do: Unclassified proto-rules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is our to-do list. Eventually, the entries will become rules or parts of
    rules. Alternatively, we will decide that no change is needed and delete the entry.
  prefs: []
  type: TYPE_NORMAL
- en: No long-distance friendship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should physical design (what’s in a file) and large-scale design (libraries,
    groups of libraries) be addressed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using directives in the global scope (except for std, and other “fundamental”
    namespaces (e.g. experimental))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How granular should namespaces be? All classes/functions designed to work together
    and released together (as defined in Sutter/Alexandrescu) or something narrower
    or wider?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should there be inline namespaces (à la `std::literals::*_literals`)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid implicit conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Const member functions should be thread safe … aka, but I don’t really change
    the variable, just assign it a value the first time it’s called … argh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always initialize variables, use initialization lists for data members.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anyone writing a public interface which takes or returns `void*` should have
    their toes set on fire. That one has been a personal favorite of mine for a number
    of years. :)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `const`-ness wherever possible: member functions, variables and (yippee)
    `const_iterators`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `auto`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(size)` vs. `{initializers}` vs. `{Extent{size}}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t overabstract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never pass a pointer down the call stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: falling through a function bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should there be guidelines to choose between polymorphisms? YES. classic (virtual
    functions, reference semantics) vs. Sean Parent style (value semantics, type-erased,
    kind of like `std::function`) vs. CRTP/static? YES Perhaps even vs. tag dispatch?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot
    of people ban them, even though I think it’s a big strength of C++ that they are
    ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD
    BE A GOOD EXAMPLE?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaking of lambdas, what would weigh in on the decision between lambdas and
    (local?) classes in algorithm calls and other callback scenarios?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And speaking of `std::bind`, Stephen T. Lavavej criticizes it so much I’m starting
    to wonder if it is indeed going to fade away in future. Should lambdas be recommended
    instead?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What to do with leaks out of temporaries? : `p = (s1 + s2).c_str();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pointer/iterator invalidation leading to dangling pointers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: LSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: private inheritance vs/and membership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: avoid static class members variables (race conditions, almost-global variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use RAII lock guards (`lock_guard`, `unique_lock`, `shared_lock`), never call
    `mutex.lock` and `mutex.unlock` directly (RAII)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer non-recursive locks (often used to work around bad reasoning, overhead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join your threads! (because of `std::terminate` in destructor if not joined
    or detached … is there a good reason to detach threads?) – ??? could support library
    provide a RAII wrapper for `std::thread`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If two or more mutexes must be acquired at the same time, use `std::lock` (or
    another deadlock avoidance algorithm?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a `condition_variable`, always protect the condition by a mutex (atomic
    bool whose value is set outside of the mutex is wrong!), and use the same mutex
    for the condition variable itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never use `atomic_compare_exchange_strong` with `std::atomic<user-defined-struct>`
    (differences in padding matter, while `compare_exchange_weak` in a loop converges
    to stable padding)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'individual `shared_future` objects are not thread-safe: two threads cannot
    wait on the same `shared_future` object (they can wait on copies of a `shared_future`
    that refer to the same shared state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'individual `shared_ptr` objects are not thread-safe: different threads can
    call non-`const` member functions on *different* `shared_ptr`s that refer to the
    same shared object, but one thread cannot call a non-`const` member function of
    a `shared_ptr` object while another thread accesses that same `shared_ptr` object
    (if you need that, consider `atomic_shared_ptr` instead)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rules for arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bibliography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Abrahams01]: D. Abrahams. [Exception-Safety in Generic Components](https://www.boost.org/community/exception_safety.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Alexandrescu01]: A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[C++03]: ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and
    ANSI C++ Standard including the contents of (C++98) plus errata corrections).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cargill92]: T. Cargill. C++ Programming Style (Addison-Wesley, 1992).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cline99]: M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley,
    1999).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dewhurst03]: S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Henricson97]: M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice
    Hall, 1997).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Koenig97]: A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lakos96]: J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers96]: S. Meyers. More Effective C++ (Addison-Wesley, 1996).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers97]: S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers01]: S. Meyers. Effective STL (Addison-Wesley, 2001).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers05]: S. Meyers. Effective C++ (3rd Edition) (Addison-Wesley, 2005).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Meyers15]: S. Meyers. Effective Modern C++ (O’Reilly, 2015).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Murray93]: R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup94]: B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley,
    1994).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup00]: B. Stroustrup. The C++ Programming Language (Special 3rdEdition)
    (Addison-Wesley, 2000).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup05]: B. Stroustrup. [A rationale for semantically enhanced library
    languages](https://www.stroustrup.com/SELLrationale.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup13]: B. Stroustrup. [The C++ Programming Language (4th Edition)](https://www.stroustrup.com/4th.html).
    Addison-Wesley 2013.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup14]: B. Stroustrup. [A Tour of C++](https://www.stroustrup.com/Tour.html).
    Addison-Wesley 2014.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stroustrup15]: B. Stroustrup, Herb Sutter, and G. Dos Reis: [A brief introduction
    to C++’s model for type- and resource-safety](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SuttHysl04b]: H. Sutter and J. Hyslop. [Collecting Shared Objects](https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839)
    (C/C++ Users Journal, 22(8), August 2004).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SuttAlex05]: H. Sutter and A. Alexandrescu. C++ Coding Standards. Addison-Wesley
    2005.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sutter00]: H. Sutter. Exceptional C++ (Addison-Wesley, 2000).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sutter02]: H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sutter04]: H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Taligent94]: Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
