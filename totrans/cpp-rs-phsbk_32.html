<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Overloading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Overloading</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/overloading.html">https://cel.cs.brown.edu/crp/idioms/overloading.html</a></blockquote>
                        
<p>C++ supports overloading of functions, so long as the invocations of the
functions can be distinguished by the number or types of their arguments.</p>
<p>Rust does not support this kind of function overloading. Instead, Rust has a few
different mechanisms (some of which C++ also has) for achieving the effects of
overloading in a way that interacts better with type inference. The mechanisms
usually involve making the commonalities between the overloaded functions
apparent in the code.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;

double twice(double x) {
  return x + x;
}

int twice(int x) {
  return x + x;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn twice(x: f64) -&gt; f64 {
    x + x
}

// error[E0428]: the name `twice` is defined multiple times
// fn twice(x: i32) -&gt; i32 {
//     x + x
// }
<span class="boring">}</span></code></pre></pre>
</div>
<p>In practice, an example like the above would also likely be implemented in a
more structured way even in C++, using templates.</p>
<p>When phrased this way, the example can be translated to Rust, with the notable
addition of <a href="./data_modeling/concepts.html">requiring a trait bound on the
type</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">template &lt;typename T&gt;
T twice(T x) {
  return x + x;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn twice&lt;T&gt;(x: T) -&gt; T::Output
where
    T: std::ops::Add&lt;T&gt;,
    T: Copy,
{
    x + x
}
<span class="boring">}</span></code></pre></pre>
</div>
<h2 id="overloaded-methods"><a class="header" href="#overloaded-methods">Overloaded methods</a></h2>
<p>In C++ it is possible to have methods with the same name but different
signatures on the same type. In Rust there can be at most one method with the
same name for each trait implementation and at most one inherent method with the
same name for a type.</p>
<p>In cases where there are multiple methods with the same names because the method
is defined for multiple traits, the desired method must be distinguished at the
call site by specifying the trait.</p>
<pre><pre class="playground"><code class="language-rust">trait TraitA {
    fn go(&amp;self) -&gt; String;
}

trait TraitB {
    fn go(&amp;self) -&gt; String;
}

struct MyStruct;

impl MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called inherent method".to_string()
    }
}

impl TraitA for MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called Trait A method".to_string()
    }
}

impl TraitB for MyStruct {
    fn go(&amp;self) -&gt; String {
        "Called Trait B method".to_string()
    }
}

fn main() {
    let my_struct = MyStruct;

    // Calling the inherent method
    println!("{}", my_struct.go());

    // Calling the method from TraitA
    println!("{}", TraitA::go(&amp;my_struct));

    // Calling the method from TraitB
    println!("{}", TraitB::go(&amp;my_struct));
}</code></pre></pre>
<p>One exception to this is when the methods are all from the same generic trait
with with different type parameters for the implementations. In that case, if
the signature is sufficient to determine which implementation to use, the trait
does not need to be specified to resolve the method. This is common when using
the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code> trait</a>.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl From&lt;i32&gt; for Widget {
    fn from(x: i32) -&gt; Widget {
        Widget
    }
}

impl From&lt;f32&gt; for Widget {
    fn from(x: f32) -&gt; Widget {
        Widget
    }
}

fn main() {
    // Calls &lt;Widget as From&lt;i32&gt;&gt;::from
    let w1 = Widget::from(5);
    // Calls &lt;Widget as From&lt;f32&gt;&gt;::from
    let w2 = Widget::from(1.0);
}</code></pre></pre>
<h2 id="overloaded-operators"><a class="header" href="#overloaded-operators">Overloaded operators</a></h2>
<p>In C++ most operators can either be overloaded either with a free-standing
function or by providing a method defining the operator on a class.</p>
<p>Rust provides operator via implementation of specific traits. Implementing a
method of the same name as required by the trait will not make a type usable
with the operator if the trait is not implemented.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Vec2 {
  double x;
  double y;

  Vec2 operator+(const Vec2 &amp;other) const {
    return Vec2{x + other.x, y + other.y};
  }
};

int main() {
  Vec2 a{1.0, 2.0};
  Vec2 b{3.0, 4.0};
  Vec2 c = a + b;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

impl std::ops::Add for &amp;Vec2 {
    type Output = Vec2;

    // Note that the type of self here is &amp;Vec2.
    fn add(self, other: Self) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = &amp;a + &amp;b;
}</code></pre></pre>
</div>
<p>Additionally, sometimes it is best to provide trait implementations for various
combinations of reference types, especially for types that implement the <a href="./constructors/copy_and_move_constructors.html"><code>Copy trait</code></a>, since they are
likely to want to be used either with or without taking a reference. For the
example above, that involve defining four implementations.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

impl std::ops::Add&lt;&amp;Vec2&gt; for &amp;Vec2 {
    type Output = Vec2;

    fn add(self, other: &amp;Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

// If Vec2 weren't so small, it might be desireable to re-use space in the below
// implementations, since they take ownership.

impl std::ops::Add&lt;Vec2&gt; for &amp;Vec2 {
    type Output = Vec2;

    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Add&lt;&amp;Vec2&gt; for Vec2 {
    type Output = Vec2;

    fn add(self, other: &amp;Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Add&lt;Vec2&gt; for Vec2 {
    type Output = Vec2;

    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = a + b;
}</code></pre></pre>
<p>The repetition can be addressed by defining a macro.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

macro_rules! impl_add_vec2 {
    ($lhs:ty, $rhs:ty) =&gt; {
        impl std::ops::Add&lt;$rhs&gt; for $lhs {
            type Output = Vec2;

            fn add(self, other: $rhs) -&gt; Vec2 {
                Vec2 {
                    x: self.x + other.x,
                    y: self.y + other.y,
                }
            }
        }
    };
}

impl_add_vec2!(&amp;Vec2, &amp;Vec2);
impl_add_vec2!(&amp;Vec2, Vec2);
impl_add_vec2!(Vec2, &amp;Vec2);
impl_add_vec2!(Vec2, Vec2);

fn main() {
    let a = Vec2 { x: 1.0, y: 2.0 };
    let b = Vec2 { x: 3.0, y: 4.0 };
    let c = a + b;
}</code></pre></pre>
<h2 id="default-arguments"><a class="header" href="#default-arguments">Default arguments</a></h2>
<p>Default arguments in C++ are sometimes implemented in terms of function
overloading.</p>
<p>Rust does not have default arguments. Instead, arguments with <code>Option</code> type can
be used to provide a similar effect.</p>
<div class="comparison">
<pre><code class="language-cpp">unsigned int shift(unsigned int x,
                   unsigned int shiftAmount) {
  return x &lt;&lt; shiftAmount;
}

unsigned int shift(unsigned int x) {
  return shift(x, 2);
}

int main() {
  unsigned int a = shift(7); // shifts by 2
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::ops::Shl;

fn shift(
    x: u32,
    shift_amount: Option&lt;u32&gt;,
) -&gt; u32 {
    let a = shift_amount.unwrap_or(2);
    x.shl(a)
}

fn main() {
    let res = shift(7, None); // shifts by 2
}</code></pre></pre>
</div>
<h2 id="unrelated-overloads"><a class="header" href="#unrelated-overloads">Unrelated overloads</a></h2>
<p>The lack of completely ad hoc overloading in Rust encourages the definition of
traits that capture essential commonalities between types, so that functions can
be implemented in terms of those interfaces and used generally. However, it also
sometime encourages the anti-pattern of defining of traits that only capture
incidental commonalities (such as having methods of the same name).</p>
<p>It is better programming practice in those cases to simply define separate
functions, rather than to shoehorn in a trait where no real commonality exists.</p>
<p>This is commonly seen in Rust in the naming conventions for constructor static
methods. Instead of them all being named <code>new</code> with different arguments, they
are <a href="https://rust-lang.github.io/api-guidelines/naming.html">usually given names of the form
<code>from_something</code></a>, where
the <code>something</code> varies based on from what the value is being constructed, or a
more specific name if appropriate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

impl Vec3 {
    fn from_x(x: f64) -&gt; Vec3 {
        Vec3 { x, y: 0.0, z: 0.0 }
    }

    fn from_y(y: f64) -&gt; Vec3 {
        Vec3 { x: 0.0, y, z: 0.0 }
    }

    fn diagonal(d: f64) -&gt; Vec3 {
        Vec3 { x: d, y: d, z: d }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This differs from the conversion methods supported by the <code>From</code> and <code>Into</code>
traits, which have the additional purpose of supporting trait bounds on generic
functions which should take any type convertible to a specific type.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;overloading&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;8cebf373-6026-43ed-9364-9fda8ca7fdcd&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;It compiles.&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does not compile because `Pigeon` cannot have both an inherent method called\n`height` and implement a trait with a method called `height`.\n&quot;,&quot;It does not compile because `Pigeon` cannot implement two traits that both have\na method called `height`.\n&quot;],&quot;prompt&quot;:&quot;Does this program compile? If not, why not?\n\n```rust\ntrait Jump {\n    // Height above ground in meters\n    fn height(&amp;self) -&gt; f64;\n}\n\ntrait Fly {\n    // Height above ground in meters\n    fn height(&amp;self) -&gt; f64;\n}\n\nstruct Pigeon {}\n\nimpl Pigeon {\n    // Head to tail in meters\n    fn height(&amp;self) -&gt; f64 {\n        0.3\n    }\n}\n\nimpl Jump for Pigeon {\n    fn height(&amp;self) -&gt; f64 {\n        0.0\n    }\n}\n\nimpl Fly for Pigeon {\n    fn height(&amp;self) -&gt; f64 {\n        5.0\n    }\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Overloading">Click here to leave us feedback about this page.</a>
                        
</body>
</html>