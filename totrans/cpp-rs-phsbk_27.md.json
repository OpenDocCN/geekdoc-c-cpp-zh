["```rs\n#include <stdexcept>\n\ndouble divide(double dividend, double divisor) {\n  if (divisor == 0.0) {\n    throw std::domain_error(\"zero divisor\");\n  }\n\n  return dividend / divisor;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <stdexcept>\n\nint produce_42() {\n  return 42;\n}\n\nint fail() {\n  throw std::runtime_error(\"oops\");\n}\n\nint useCallback(int (*func)(void)) {\n  return func();\n}\n\nint main() {\n  try {\n    int x = useCallback(produce_42);\n    int y = useCallback(fail);\n\n    // use x and y\n  } catch (std::runtime_error &e) {\n    // handle error\n  }\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <vector>\n#include <stdexcept>\n\nint main() {\n    std::vector<int> v;\n    // ... populate v ...\n    try {\n        auto x = v.at(0);\n        // use x\n    } catch (std::out_of_range &e) {\n        // handle error\n    }\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <expected>\n#include <string>\n\nint main() {\n  std::expected<int, std::string> res(42);\n  auto x(res.transform([](int n) { return n * 2; }));\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cstddef>\n#include <vector>\n\nint accessValue(std::vector<std::size_t> indices,\n                 std::vector<int> values,\n                 std::size_t i) {\n  // vector::at throws\n  size_t idx(indices.at(i));\n  // vector::at throws\n  return values.at(idx);\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <stdexcept>\n\nint main() {\n  throw std::runtime_error(\"oops\");\n} \n```", "```rs\nfn main() -> Result<(), &'static str> {\n    Err(\"oops\")\n}\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\nwarning: unused `Result` that must be used\n --> example.rs:3:5\n  |\n3 |     std::io::stdin().read_line(&mut buffer);\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: this `Result` may be an `Err` variant, which should be handled\n  = note: `#[warn(unused_must_use)]` on by default\nhelp: use `let _ = ...` to ignore the resulting value\n  |\n3 |     let _ = std::io::stdin().read_line(&mut buffer);\n  |     +++++++ \n```", "```rs\n#include <exception>\n\nstruct ErrorA : public std::exception {\n  const char *msg = \"ErrorA was produced\";\n  const char *what() const noexcept override {\n    return msg;\n  }\n};\n\nvoid mightThrowA() {}\n\nstruct ErrorB : public std::exception {\n  const char *msg = \"ErrorA was produced\";\n  const char *what() const noexcept override {\n    return msg;\n  }\n};\n\nvoid mightThrowB() {}\n\nvoid process() {\n  mightThrowA();\n  mightThrowB();\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <exception>\n\nstruct ErrorA : public std::exception {\n  const char *msg = \"ErrorA was produced\";\n  const char *what() const noexcept override {\n    return msg;\n  }\n};\n\nvoid mightThrowA() {}\n\nstruct ErrorB : public std::exception {\n  const char *msg = \"ErrorA was produced\";\n  const char *what() const noexcept override {\n    return msg;\n  }\n};\n\nvoid mightThrowB() {}\n\nvoid process() {\n  mightThrowA();\n  mightThrowB();\n} \n```", "```rs\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\n#[error(\"ErrorA was produced\")]\nstruct ErrorA;\n\nfn might_throw_A() -> Result<(), ErrorA> {\n    Ok(())\n}\n\n#[derive(Debug, Error)]\n#[error(\"ErrorB was produced\")]\nstruct ErrorB;\n\nfn might_throw_B() -> Result<(), ErrorB> {\n    Ok(())\n}\n\n#[derive(Debug, Error)]\nenum ErrorAOrB {\n    #[error(\"error from source A\")]\n    ErrorA(#[from] ErrorA),\n    #[error(\"error from source B\")]\n    ErrorB(#[from] ErrorB),\n}\n\nfn process() -> Result<(), ErrorAOrB> {\n    might_throw_A()?;\n    might_throw_B()?;\n    Ok(())\n}\n```", "```rs\n#include <exception>\n\nstruct ErrorA : public std::exception {\n  const char *msg = \"ErrorA was produced\";\n  const char *what() const noexcept override {\n    return msg;\n  }\n};\n\nvoid mightThrowA() {}\n\nstruct ErrorB : public std::exception {\n  const char *msg = \"ErrorA was produced\";\n  const char *what() const noexcept override {\n    return msg;\n  }\n};\n\nvoid mightThrowB() {}\n\nvoid process() {\n  mightThrowA();\n  mightThrowB();\n}\n\nint main() {\n  try {\n    process();\n  } catch (ErrorA &err) {\n    // handle ErrorA\n  } catch (ErrorB &err) {\n    // handle ErrorB\n  }\n} \n```", "```rs\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\n#[error(\"ErrorA was produced\")]\nstruct ErrorA;\n\nfn might_throw_A() -> Result<(), ErrorA> {\n    Ok(())\n}\n\n#[derive(Debug, Error)]\n#[error(\"ErrorB was produced\")]\nstruct ErrorB;\n\nfn might_throw_B() -> Result<(), ErrorB> {\n    Ok(())\n}\n\nfn process() -> anyhow::Result<()> {\n    might_throw_A()?;\n    might_throw_B()?;\n    Ok(())\n}\n\nfn main() {\n    if let Err(err) = process() {\n        if let Some(errA) =\n            err.downcast_ref::<ErrorA>()\n        {\n            // handle ErrorA\n        } else if let Some(errB) =\n            err.downcast_ref::<ErrorB>()\n        {\n            // handle ErrorB\n        }\n    }\n}\n```"]