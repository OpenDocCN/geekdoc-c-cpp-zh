["```cpp\n[](#cb1-1)struct AVLNode {\n[](#cb1-2)    uint32_t depth = 0;\n[](#cb1-3)    uint32_t cnt = 0;\n[](#cb1-4)    AVLNode *left = NULL;\n[](#cb1-5)    AVLNode *right = NULL;\n[](#cb1-6)    AVLNode *parent = NULL;\n[](#cb1-7)};\n[](#cb1-8)\n[](#cb1-9)static void avl_init(AVLNode *node) {\n[](#cb1-10)    node->depth = 1;\n[](#cb1-11)    node->cnt = 1;\n[](#cb1-12)    node->left = node->right = node->parent = NULL;\n[](#cb1-13)}\n```", "```cpp\n[](#cb2-1)static uint32_t avl_depth(AVLNode *node) {\n[](#cb2-2)    return node ? node->depth : 0;\n[](#cb2-3)}\n[](#cb2-4)\n[](#cb2-5)static uint32_t avl_cnt(AVLNode *node) {\n[](#cb2-6)    return node ? node->cnt : 0;\n[](#cb2-7)}\n[](#cb2-8)\n[](#cb2-9)static uint32_t max(uint32_t lhs, uint32_t rhs) {\n[](#cb2-10)    return lhs < rhs ? rhs : lhs;\n[](#cb2-11)}\n[](#cb2-12)\n[](#cb2-13)// maintaining the depth and cnt field\n[](#cb2-14)static void avl_update(AVLNode *node) {\n[](#cb2-15)    node->depth = 1 + max(avl_depth(node->left), avl_depth(node->right));\n[](#cb2-16)    node->cnt = 1 + avl_cnt(node->left) + avl_cnt(node->right);\n[](#cb2-17)}\n```", "```cpp\n[](#cb3-1)static AVLNode *rot_left(AVLNode *node) {\n[](#cb3-2)    AVLNode *new_node = node->right;\n[](#cb3-3)    if (new_node->left) {\n[](#cb3-4)        new_node->left->parent = node;\n[](#cb3-5)    }\n[](#cb3-6)    node->right = new_node->left;\n[](#cb3-7)    new_node->left = node;\n[](#cb3-8)    new_node->parent = node->parent;\n[](#cb3-9)    node->parent = new_node;\n[](#cb3-10)    avl_update(node);\n[](#cb3-11)    avl_update(new_node);\n[](#cb3-12)    return new_node;\n[](#cb3-13)}\n[](#cb3-14)\n[](#cb3-15)static AVLNode *rot_right(AVLNode *node) {\n[](#cb3-16)    // a mirror of the rot_left()\n[](#cb3-17)    // code omited...\n[](#cb3-18)}\n```", "```cpp\n b           d\n / \\         /\na   d  ==>  b\n   /       / \\\n  c       a   c\n```", "```cpp\n[](#cb5-1)// the left subtree is too deep\n[](#cb5-2)static AVLNode *avl_fix_left(AVLNode *root) {\n[](#cb5-3)    if (avl_depth(root->left->left) < avl_depth(root->left->right)) {\n[](#cb5-4)        root->left = rot_left(root->left);\n[](#cb5-5)    }\n[](#cb5-6)    return rot_right(root);\n[](#cb5-7)}\n[](#cb5-8)\n[](#cb5-9)// the right subtree is too deep\n[](#cb5-10)static AVLNode *avl_fix_right(AVLNode *root) {\n[](#cb5-11)    if (avl_depth(root->right->right) < avl_depth(root->right->left)) {\n[](#cb5-12)        root->right = rot_right(root->right);\n[](#cb5-13)    }\n[](#cb5-14)    return rot_left(root);\n[](#cb5-15)}\n```", "```cpp\n b           b           d\n / \\         / \\         / \\\na   c  ==>  a   d  ==>  b   c\n   /             \\     /\n  d               c   a\n```", "```cpp\n[](#cb7-1)// fix imbalanced nodes and maintain invariants until the root is reached\n[](#cb7-2)static AVLNode *avl_fix(AVLNode *node) {\n[](#cb7-3)    while (true) {\n[](#cb7-4)        avl_update(node);\n[](#cb7-5)        uint32_t l = avl_depth(node->left);\n[](#cb7-6)        uint32_t r = avl_depth(node->right);\n[](#cb7-7)        AVLNode **from = NULL;\n[](#cb7-8)        if (node->parent) {\n[](#cb7-9)            from = (node->parent->left == node)\n[](#cb7-10)                ? &node->parent->left : &node->parent->right;\n[](#cb7-11)        }\n[](#cb7-12)        if (l == r + 2) {\n[](#cb7-13)            node = avl_fix_left(node);\n[](#cb7-14)        } else if (l + 2 == r) {\n[](#cb7-15)            node = avl_fix_right(node);\n[](#cb7-16)        }\n[](#cb7-17)        if (!from) {\n[](#cb7-18)            return node;\n[](#cb7-19)        }\n[](#cb7-20)        *from = node;\n[](#cb7-21)        node = node->parent;\n[](#cb7-22)    }\n[](#cb7-23)}\n```", "```cpp\n[](#cb8-1)// detach a node and returns the new root of the tree\n[](#cb8-2)static AVLNode *avl_del(AVLNode *node) {\n[](#cb8-3)    if (node->right == NULL) {\n[](#cb8-4)        // no right subtree, replace the node with the left subtree\n[](#cb8-5)        // link the left subtree to the parent\n[](#cb8-6)        AVLNode *parent = node->parent;\n[](#cb8-7)        if (node->left) {\n[](#cb8-8)            node->left->parent = parent;\n[](#cb8-9)        }\n[](#cb8-10)        if (parent) {\n[](#cb8-11)            // attach the left subtree to the parent\n[](#cb8-12)            (parent->left == node ? parent->left : parent->right) = node->left;\n[](#cb8-13)            return avl_fix(parent);\n[](#cb8-14)        } else {\n[](#cb8-15)            // removing root?\n[](#cb8-16)            return node->left;\n[](#cb8-17)        }\n[](#cb8-18)    } else {\n[](#cb8-19)        // swap the node with its next sibling\n[](#cb8-20)        AVLNode *victim = node->right;\n[](#cb8-21)        while (victim->left) {\n[](#cb8-22)            victim = victim->left;\n[](#cb8-23)        }\n[](#cb8-24)        AVLNode *root = avl_del(victim);\n[](#cb8-25)\n[](#cb8-26)        *victim = *node;\n[](#cb8-27)        if (victim->left) {\n[](#cb8-28)            victim->left->parent = victim;\n[](#cb8-29)        }\n[](#cb8-30)        if (victim->right) {\n[](#cb8-31)            victim->right->parent = victim;\n[](#cb8-32)        }\n[](#cb8-33)        AVLNode *parent = node->parent;\n[](#cb8-34)        if (parent) {\n[](#cb8-35)            (parent->left == node ? parent->left : parent->right) = victim;\n[](#cb8-36)            return root;\n[](#cb8-37)        } else {\n[](#cb8-38)            // removing root?\n[](#cb8-39)            return victim;\n[](#cb8-40)        }\n[](#cb8-41)    }\n[](#cb8-42)}\n```", "```cpp\n[](#cb9-1)struct Data {\n[](#cb9-2)    AVLNode node;\n[](#cb9-3)    uint32_t val = 0;\n[](#cb9-4)};\n[](#cb9-5)\n[](#cb9-6)struct Container {\n[](#cb9-7)    AVLNode *root = NULL;\n[](#cb9-8)};\n```", "```cpp\n[](#cb10-1)static void add(Container &c, uint32_t val) {\n[](#cb10-2)    Data *data = new Data();\n[](#cb10-3)    avl_init(&data->node);\n[](#cb10-4)    data->val = val;\n[](#cb10-5)\n[](#cb10-6)    if (!c.root) {\n[](#cb10-7)        c.root = &data->node;\n[](#cb10-8)        return;\n[](#cb10-9)    }\n[](#cb10-10)\n[](#cb10-11)    AVLNode *cur = c.root;\n[](#cb10-12)    while (true) {\n[](#cb10-13)        AVLNode **from =\n[](#cb10-14)            (val < container_of(cur, Data, node)->val)\n[](#cb10-15)            ? &cur->left : &cur->right;\n[](#cb10-16)        if (!*from) {\n[](#cb10-17)            *from = &data->node;\n[](#cb10-18)            data->node.parent = cur;\n[](#cb10-19)            c.root = avl_fix(&data->node);\n[](#cb10-20)            break;\n[](#cb10-21)        }\n[](#cb10-22)        cur = *from;\n[](#cb10-23)    }\n[](#cb10-24)}\n```", "```cpp\n[](#cb11-1)static bool del(Container &c, uint32_t val) {\n[](#cb11-2)    AVLNode *cur = c.root;\n[](#cb11-3)    while (cur) {\n[](#cb11-4)        uint32_t node_val = container_of(cur, Data, node)->val;\n[](#cb11-5)        if (val == node_val) {\n[](#cb11-6)            break;\n[](#cb11-7)        }\n[](#cb11-8)        cur = val < node_val ? cur->left : cur->right;\n[](#cb11-9)    }\n[](#cb11-10)    if (!cur) {\n[](#cb11-11)        return false;\n[](#cb11-12)    }\n[](#cb11-13)\n[](#cb11-14)    c.root = avl_del(cur);\n[](#cb11-15)    delete container_of(cur, Data, node);\n[](#cb11-16)    return true;\n[](#cb11-17)}\n```", "```cpp\n[](#cb12-1)static void avl_verify(AVLNode *parent, AVLNode *node) {\n[](#cb12-2)    if (!node) {\n[](#cb12-3)        return;\n[](#cb12-4)    }\n[](#cb12-5)\n[](#cb12-6)    assert(node->parent == parent);\n[](#cb12-7)    avl_verify(node, node->left);\n[](#cb12-8)    avl_verify(node, node->right);\n[](#cb12-9)\n[](#cb12-10)    assert(node->cnt == 1 + avl_cnt(node->left) + avl_cnt(node->right));\n[](#cb12-11)\n[](#cb12-12)    uint32_t l = avl_depth(node->left);\n[](#cb12-13)    uint32_t r = avl_depth(node->right);\n[](#cb12-14)    assert(l == r || l + 1 == r || l == r + 1);\n[](#cb12-15)    assert(node->depth == 1 + max(l, r));\n[](#cb12-16)\n[](#cb12-17)    uint32_t val = container_of(node, Data, node)->val;\n[](#cb12-18)    if (node->left) {\n[](#cb12-19)        assert(node->left->parent == node);\n[](#cb12-20)        assert(container_of(node->left, Data, node)->val <= val);\n[](#cb12-21)    }\n[](#cb12-22)    if (node->right) {\n[](#cb12-23)        assert(node->right->parent == node);\n[](#cb12-24)        assert(container_of(node->right, Data, node)->val >= val);\n[](#cb12-25)    }\n[](#cb12-26)}\n```", "```cpp\n[](#cb13-1)static void extract(AVLNode *node, std::multiset<uint32_t> &extracted) {\n[](#cb13-2)    if (!node) {\n[](#cb13-3)        return;\n[](#cb13-4)    }\n[](#cb13-5)    extract(node->left, extracted);\n[](#cb13-6)    extracted.insert(container_of(node, Data, node)->val);\n[](#cb13-7)    extract(node->right, extracted);\n[](#cb13-8)}\n[](#cb13-9)\n[](#cb13-10)static void container_verify(\n[](#cb13-11)    Container &c, const std::multiset<uint32_t> &ref)\n[](#cb13-12){\n[](#cb13-13)    avl_verify(NULL, c.root);\n[](#cb13-14)    assert(avl_cnt(c.root) == ref.size());\n[](#cb13-15)    std::multiset<uint32_t> extracted;\n[](#cb13-16)    extract(c.root, extracted);\n[](#cb13-17)    assert(extracted == ref);\n[](#cb13-18)}\n```", "```cpp\n[](#cb14-1)static void dispose(Container &c) {\n[](#cb14-2)    while (c.root) {\n[](#cb14-3)        AVLNode *node = c.root;\n[](#cb14-4)        c.root = avl_del(c.root);\n[](#cb14-5)        delete container_of(node, Data, node);\n[](#cb14-6)    }\n[](#cb14-7)}\n```", "```cpp\n[](#cb15-1)    Container c;\n[](#cb15-2)\n[](#cb15-3)    // some quick tests\n[](#cb15-4)    container_verify(c, {});\n[](#cb15-5)    add(c, 123);\n[](#cb15-6)    container_verify(c, {123});\n[](#cb15-7)    assert(!del(c, 124));\n[](#cb15-8)    assert(del(c, 123));\n[](#cb15-9)    container_verify(c, {});\n[](#cb15-10)\n[](#cb15-11)    // sequential insertion\n[](#cb15-12)    std::multiset<uint32_t> ref;\n[](#cb15-13)    for (uint32_t i = 0; i < 1000; i += 3) {\n[](#cb15-14)        add(c, i);\n[](#cb15-15)        ref.insert(i);\n[](#cb15-16)        container_verify(c, ref);\n[](#cb15-17)    }\n```", "```cpp\n[](#cb16-1)    // random insertion\n[](#cb16-2)    for (uint32_t i = 0; i < 100; i++) {\n[](#cb16-3)        uint32_t val = (uint32_t)rand() % 1000;\n[](#cb16-4)        add(c, val);\n[](#cb16-5)        ref.insert(val);\n[](#cb16-6)        container_verify(c, ref);\n[](#cb16-7)    }\n[](#cb16-8)\n[](#cb16-9)    // random deletion\n[](#cb16-10)    for (uint32_t i = 0; i < 200; i++) {\n[](#cb16-11)        uint32_t val = (uint32_t)rand() % 1000;\n[](#cb16-12)        auto it = ref.find(val);\n[](#cb16-13)        if (it == ref.end()) {\n[](#cb16-14)            assert(!del(c, val));\n[](#cb16-15)        } else {\n[](#cb16-16)            assert(del(c, val));\n[](#cb16-17)            ref.erase(it);\n[](#cb16-18)        }\n[](#cb16-19)        container_verify(c, ref);\n[](#cb16-20)    }\n```", "```cpp\n[](#cb17-1)static void test_insert(uint32_t sz) {\n[](#cb17-2)    for (uint32_t val = 0; val < sz; ++val) {\n[](#cb17-3)        Container c;\n[](#cb17-4)        std::multiset<uint32_t> ref;\n[](#cb17-5)        for (uint32_t i = 0; i < sz; ++i) {\n[](#cb17-6)            if (i == val) {\n[](#cb17-7)                continue;\n[](#cb17-8)            }\n[](#cb17-9)            add(c, i);\n[](#cb17-10)            ref.insert(i);\n[](#cb17-11)        }\n[](#cb17-12)        container_verify(c, ref);\n[](#cb17-13)\n[](#cb17-14)        add(c, val);\n[](#cb17-15)        ref.insert(val);\n[](#cb17-16)        container_verify(c, ref);\n[](#cb17-17)        dispose(c);\n[](#cb17-18)    }\n[](#cb17-19)}\n[](#cb17-20)\n[](#cb17-21)static void test_remove(uint32_t sz) {\n[](#cb17-22)    for (uint32_t val = 0; val < sz; ++val) {\n[](#cb17-23)        Container c;\n[](#cb17-24)        std::multiset<uint32_t> ref;\n[](#cb17-25)        for (uint32_t i = 0; i < sz; ++i) {\n[](#cb17-26)            add(c, i);\n[](#cb17-27)            ref.insert(i);\n[](#cb17-28)        }\n[](#cb17-29)        container_verify(c, ref);\n[](#cb17-30)\n[](#cb17-31)        assert(del(c, val));\n[](#cb17-32)        ref.erase(val);\n[](#cb17-33)        container_verify(c, ref);\n[](#cb17-34)        dispose(c);\n[](#cb17-35)    }\n[](#cb17-36)}\n```", "```cpp\n[](#cb18-1)    // insertion/deletion at various positions\n[](#cb18-2)    for (uint32_t i = 0; i < 200; ++i) {\n[](#cb18-3)        test_insert(i);\n[](#cb18-4)        test_remove(i);\n[](#cb18-5)    }\n```"]