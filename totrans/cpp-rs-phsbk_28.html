<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Errors indicating bugs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Errors indicating bugs</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html">https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html</a></blockquote>
                        
<p>In C++, exceptions are sometimes used to indicate an error that is due to a
programming bug. In many situations no exception is produced, and instead the
invalid use of an API is simply undefined behavior.</p>
<p>In Rust, <code>panic!</code> is used for these kinds of errors, often via an
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code></a>
or
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>unwrap</code></a>
method on <code>Result</code> or <code>Option</code> or via <a href="#assertions">assertions like <code>assert!</code></a>.
While a panic in Rust may unwind the stack or abort a program, it is never
undefined behavior.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;vector&gt;

int main() {
  std::vector&lt;int&gt; v{1, 2, 3};
  // undefined behavior!
  int x(v[4]);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    let v = vec![1,2,3];
    // panics!
    let x = v[4];
}</code></pre></pre>
</div>
<h2 id="converting-result-or-option-to-panic"><a class="header" href="#converting-result-or-option-to-panic">Converting <code>Result</code> or <code>Option</code> to <code>panic!</code></a></h2>
<p>It is easier to convert from a <code>Result</code> or <code>Option</code> to a panic than to go the
other way around. Therefore, many libraries in Rust are written to return
<code>Result</code> or <code>Option</code> and allow the caller to determine whether a <code>None</code> result
indicates a bug by using <code>unwrap</code> or <code>expect</code> to extract the value, panicking if
there isn't one.</p>
<pre><pre class="playground"><code class="language-rust should_panic">/// Returns `None` if the number cannot be divided evenly.
fn divide_exact(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    let quotient = dividend / divisor;
    if quotient * divisor == dividend {
        Some(quotient)
    } else {
        None
    }
}

// Returns `None` if the number cannot be divided by 2
fn divide_by_two_exact(dividend: i32) -&gt; Option&lt;i32&gt; {
    // divide_exact returning None here isn't a bug
    divide_exact(dividend, 2)
}

fn main() {
    let res = divide_exact(10, 3); // Oops, a bug!
    let x = res.unwrap();
    // ...
}</code></pre></pre>
<p>When designing an API, if only one of a <code>Result</code>-based (or <code>Option</code>-based) or
panicking interface is going to be offered, it is generally better to offer the
<code>Result</code>-based interface. That way that the caller can choose to omit the
pre-condition checks and handle the error instead or to panic because
pre-conditions should have been met.</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>In Rust, panics are also generated by assertions. Unlike <code>assert</code> in C++, The
<a href="https://doc.rust-lang.org/std/macro.assert.html"><code>assert!</code></a> family of macros in
Rust cannot be disabled. They are therefore appropriate for asserting invariants
when creating safe wrappers for unsafe code, in addition to checking for logical
invariants.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;
#include &lt;cstddef&gt;

template &lt;typename T&gt;
class Widget {
  T *parts;
  std::size_t partCount;

public:
  // ... constructors ...

  /**
   * @pre n must be smaller than partCount
   */
  T getPart(std::size_t n) {
    // Unlike in Rust, this can be disabled,
    // e.g., with -DNDEBUG.
    assert(n &lt; partCount);
    return *(parts + n);
  }
};
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::convert::TryFrom;

pub struct Widget&lt;T&gt; {
    parts: *const T,
    part_count: usize,
}

impl&lt;T: Copy&gt; Widget&lt;T&gt; {
    // ... constructor methods ...

    /// Panics if n is greater than the number of
    /// parts.
    pub fn get_part(&amp;self, n: usize) -&gt; T {
        // SAFETY: Widget maintians invariant of
        // at least part_count parts, so if n is
        // less than the part count then we can
        // use it access a part.
        assert!(
            n &lt; self.part_count,
            "index {} exceeds part count {}",
            n,
            self.part_count
        );
        let idx = isize::try_from(n).expect(
            "can't convert index to offset"
        );
        unsafe { self.parts.offset(idx).read() }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The Rust <a href="https://doc.rust-lang.org/std/macro.debug_assert.html"><code>debug_assert!</code>
macro</a> is more like
<code>assert!</code> in C++, in that it can be turned off by a compilation configuration
option, and so is useful for encoding logical invariants that should be
checked during development and testing, but are too expensive to check
in production.</p>
<h3 id="other-assertion-macros"><a class="header" href="#other-assertion-macros">Other assertion macros</a></h3>
<p>Rust has several other convenience assertion macros. The macros
<a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a> and
<a href="https://doc.rust-lang.org/std/macro.assert_ne.html"><code>assert_ne!</code></a> will print
their arguments on assertion failure using the <code>Debug</code> trait implementation.</p>
<p>The <a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!</code></a> macro
is for asserting that when matching on an enum certain cases are expected to not
be possible. It is essentially <code>panic!</code> with a fixed error message, but better
communicates intent.</p>
<h3 id="static-assertions"><a class="header" href="#static-assertions">Static assertions</a></h3>
<p>C++ also has <code>static_assert</code>, which is guaranteed to be evaluated at compile
time, other than when used in templates. When used in templates, it is
guaranteed to be evaluated at compile time if the template is instantiated. In
Rust the same thing can achieved by calling <code>assert!</code> in a const block or some
other <a href="https://doc.rust-lang.org/reference/const_eval.html#const-context">constant
context</a>. The
convenience macros <code>assert_eq!</code> and <code>assert_ne!</code> cannot (yet) be used in const
contexts.</p>
<p>The following example fails to compile in both Rust and C++ with the message
from the static assertion.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cassert&gt;

int main() {
  static_assert(false, "static requirement");
}
</code></pre>
<pre><pre class="playground"><code class="language-rust ignore mdbook-runnable">fn main() {
    const {
        assert!(false, "static requirement");
    }
}</code></pre></pre>
</div>
<p>Like with C++ <code>static_assert</code>, a Rust assertion in a const block in a generic
definition is only evaluated when the generic arguments are known. Both the C++
and the Rust versions of the following example only fail to compile if the
<code>first</code> function is called on an array with a size less than 1.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;cstddef&gt;

template &lt;const std::size_t n&gt;
int &amp;first(std::array&lt;int, n&gt; arr) {
  static_assert(
      n &gt;= 1,
      "array needs to have at last size 1!");
  return arr[0];
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first&lt;const N: usize&gt;(arr: [i32; N]) -&gt; i32 {
    const {
        assert!(
            N &gt;= 1,
            "array needs to have at last size 1!"
        )
    }
    arr[0]
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In C++, <code>static_assert</code> can also be used at namespace scope. To achieve an
equivalent thing in Rust requires defining an unnamed constant.</p>
<div class="comparison">
<pre><code class="language-cpp">static_assert(true,  "top-level assert true");
static_assert(false,  "top-level assert false");

int main() {}
</code></pre>
<pre><pre class="playground"><code class="language-rust ignore mdbook-runnable">const _: () = assert!(true, "top-level assert true");
const _: () = assert!(false, "top-level assert false");

fn main() {}</code></pre></pre>
</div>
<h3 id="assertions-and-the-optimizer"><a class="header" href="#assertions-and-the-optimizer">Assertions and the optimizer</a></h3>
<p>Assertions do affect how the Rust compiler optimizes code (e.g., by enabling the
optimizer to eliminate subsequent redundant checks) but the specific effects are
not guaranteed.</p>
<h2 id="panics-in-embedded-systems"><a class="header" href="#panics-in-embedded-systems">Panics in embedded systems</a></h2>
<p>When programming in Rust for embedded systems using <code>#![no_std]</code>, there is no
default panic handler. Instead one must be specified using the
<code>#[panic_handler]</code> annotation.</p>
<p>The Embedded Rust Book <a href="https://docs.rust-embedded.org/book/start/panicking.html">chapter on handling
panics</a> has more
details on implementing panic handlers for in <code>no_std</code> programs.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;bugs&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Unlike `assert` in C++, the `assert!` macro in Rust cannot be disabled. For\nexpensive-to-check invariants that should be disabled in release builds, use\n`debug_assert!` instead.\n&quot;,&quot;id&quot;:&quot;42c3ea1a-4cf3-4e6c-869b-ae71dd0db493&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It can, because the assertions are guaranteed to be checked.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It cannot because the assertions might be disabled at runtime.\n&quot;],&quot;prompt&quot;:&quot;Can unafe Rust code rely on the `assert! macro to check invariants that, if\nviolated, would lead to undefined behavior?\n&quot;}},{&quot;context&quot;:&quot;Unlike `assert` in C++ which calls `std::abort()` when the assertion is false,\nin Rust, when the condition for an `assert!` is false, `panic!` is called. How\nthe program handles a panic depends on the panic strategy, the panic handler,\nwhether the panic was on the main thread, and whether `catch_unwind` was used.\nIn any case, the program will not resume from where the panic occurred.\n&quot;,&quot;id&quot;:&quot;91c357c8-786c-4f09-b164-3ffa7a68f180&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;False\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;True\n&quot;],&quot;prompt&quot;:&quot;True or false: a failed `assert!` will always halt the program.\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Errors indicating bugs">Click here to leave us feedback about this page.</a>
                        
</body>
</html>