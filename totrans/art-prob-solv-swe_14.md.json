["```cpp\n const bool skip_transaction = is_already_logged_transaction(thd);\n  if (gtid_next_list == nullptr) {\n    if (skip_transaction) {\n      skip_statement(thd);\n      return GTID_STATEMENT_SKIP;\n    }\n    return GTID_STATEMENT_EXECUTE;\n  } else { \n```", "```cpp\n/**\n  Check if current transaction should be skipped, that is, if GTID_NEXT\n  was already logged.\n  @param  thd    The calling thread.\n  @retval true   Transaction was already logged.\n  @retval false  Transaction must be executed.\n*/\nbool is_already_logged_transaction(const THD *thd); \n```", "```cpp\n/*\n  MTS load-balancing parameter.\n  Max length of one MTS Worker queue. The value also determines the size\n  of Relay_log_info::gaq (see @c slave_start_workers()).\n  It can be set to any value in [1, ULONG_MAX - 1] range.\n*/\nconst ulong mts_slave_worker_queue_len_max = 16384; \n```", "```cpp\n // possible WQ overfill\n  while (worker->running_status == Slave_worker::RUNNING && !thd->killed &&\n         (ret = worker->jobs.en_queue(job_item)) ==\n             Slave_jobs_queue::error_result) {\n    thd->ENTER_COND(&worker->jobs_cond, &worker->jobs_lock,\n                    &stage_replica_waiting_worker_queue, &old_stage);\n    worker->jobs.overfill = true;\n    worker->jobs.waited_overfill++;\n    rli->mts_wq_overfill_cnt++;\n    // wait if worker queue is full\n    mysql_cond_wait(&worker->jobs_cond, &worker->jobs_lock);\n    mysql_mutex_unlock(&worker->jobs_lock);\n    thd->EXIT_COND(&old_stage);\n    mysql_mutex_lock(&worker->jobs_lock);\n  } \n```", "```cpp\nbool Mts_submode_logical_clock::wait_for_last_committed_trx(\n    Relay_log_info *rli, longlong last_committed_arg) {\n  THD *thd = rli->info_thd;\n  ...\n  if ((!rli->info_thd->killed && !is_error) &&\n      !clock_leq(last_committed_arg, get_lwm_timestamp(rli, true))) {\n    PSI_stage_info old_stage;\n    struct timespec ts[2];\n    set_timespec_nsec(&ts[0], 0);\n    assert(rli->gaq->get_length() >= 2);  // there's someone to wait\n    thd->ENTER_COND(&rli->logical_clock_cond, &rli->mts_gaq_LOCK,\n                    &stage_worker_waiting_for_commit_parent, &old_stage);\n    do {\n      // wait if LWM is less than last committed\n      mysql_cond_wait(&rli->logical_clock_cond, &rli->mts_gaq_LOCK);\n    } while ((!rli->info_thd->killed && !is_error) &&\n             !clock_leq(last_committed_arg, estimate_lwm_timestamp()));\n    min_waited_timestamp.store(SEQ_UNINIT);  // reset waiting flag\n    mysql_mutex_unlock(&rli->mts_gaq_LOCK);\n    thd->EXIT_COND(&old_stage);\n    set_timespec_nsec(&ts[1], 0);\n    rli->mts_total_wait_overlap += diff_timespec(&ts[1], &ts[0]);\n  } else {\n    min_waited_timestamp.store(SEQ_UNINIT);\n    mysql_mutex_unlock(&rli->mts_gaq_LOCK);\n  }\n  return rli->info_thd->killed || is_error;\n} \n```", "```cpp\n/*\n  MTS load-ballancing parameter.\n  Max length of one MTS Worker queue. The value also determines the size\n  of Relay_log_info::gaq (see @c slave_start_workers()).\n  It can be set to any value in [1, ULONG_MAX - 1] range.\n*/\nconst ulong mts_slave_worker_queue_len_max = 16384 << 6; \n```", "```cpp\n/**\n  Remove a job item from the given workers job queue. It also updates related\n  status.\n  param[in] job_item The job item will be removed\n  param[in] worker   The worker which job_item belongs to.\n  param[in] rli      slave's relay log info object.\n */\nstatic void remove_item_from_jobs(slave_job_item *job_item,\n                                  Slave_worker *worker, Relay_log_info *rli) {\n  Log_event *ev = job_item->data;\n  mysql_mutex_lock(&worker->jobs_lock);\n  worker->jobs.de_queue(job_item);\n  /* possible overfill */\n  if (worker->jobs.get_length() == worker->jobs.capacity - 1 &&\n      worker->jobs.overfill == true) {\n    worker->jobs.overfill = false;\n    // todo: worker->hungry_cnt++;\n    mysql_cond_signal(&worker->jobs_cond);\n  }\n  mysql_mutex_unlock(&worker->jobs_lock);\n  /* statistics */\n  const auto jobs_length = worker->jobs.get_length();\n  /* todo: convert to rwlock/atomic write */\n  mysql_mutex_lock(&rli->pending_jobs_lock);\n  rli->pending_jobs--;\n  rli->mts_pending_jobs_size -= ev->common_header->data_written;\n  assert(rli->mts_pending_jobs_size < rli->mts_pending_jobs_size_max);\n  ... \n```", "```cpp\n/**\n   Coordinator enqueues a job item into a Worker private queue.\n   @param job_item  a pointer to struct carrying a reference to an event\n   @param worker    a pointer to the assigned Worker struct\n   @param rli       a pointer to Relay_log_info of Coordinator\n   @return false Success.\n           true  Thread killed or worker stopped while waiting for\n                 successful enqueue.\n*/\nbool append_item_to_jobs(slave_job_item *job_item, Slave_worker *worker,\n                         Relay_log_info *rli) {\n  THD *thd = rli->info_thd;\n  size_t ret = Slave_jobs_queue::error_result;\n  size_t ev_size = job_item->data->common_header->data_written;\n  ulonglong new_pend_size;\n  PSI_stage_info old_stage;\n  assert(thd == current_thd);\n  mysql_mutex_lock(&rli->pending_jobs_lock);\n  new_pend_size = rli->mts_pending_jobs_size + ev_size;\n  bool big_event = (ev_size > rli->mts_pending_jobs_size_max);\n  ... \n```"]