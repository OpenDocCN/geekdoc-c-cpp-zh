["```cpp\n> git clone https://github.com/arobenko/embxx_on_rpi.git\n> cd embxx_on_rpi\n```", "```cpp\n> mkdir build\n> cd build\n```", "```cpp\n> cmake ..\n```", "```cpp\n> make\n```", "```cpp\n> cmake -DCMAKE_BUILD_TYPE=Release ..\n```", "```cpp\n> cmake -DCROSS_COMPILE=/opt/arm-none-eabi-2013.05/bin/arm-none-eabi- ..\n```", "```cpp\n> VERBOSE=1 make\n```", "```cpp\n> git clone https://github.com/arobenko/embxx_on_rpi.git\n> mkdir -p <build_dir_somewhere>\n> cd <build_dir_somewhere>\n> cmake -DCMAKE_BUILD_TYPE=Release <path/to/embxx_on_rpi>\n> VERBOSE=1 make\n```", "```cpp\n> arm-none-eabi-objdump -D -S app_binary > app.list\n```", "```cpp\n00008198 <_mainCRTStartup>:\n```", "```cpp\n 8198:\te59f30f0 \tldr\tr3, [pc, #240]\t; 8290 <_mainCRTStartup+0xf8>\n    819c:\te3530000 \tcmp\tr3, #0\n    81a0:\t059f30e4 \tldreq\tr3, [pc, #228]\t; 828c <_mainCRTStartup+0xf4>\n    81a4:\te1a0d003 \tmov\tsp, r3\n```", "```cpp\n 81a8:\te10f2000 \tmrs\tr2, CPSR\n    81ac:\te312000f \ttst\tr2, #15\n    81b0:\t0a000015 \tbeq\t820c <_mainCRTStartup+0x74>\n    81b4:\te321f0d1 \tmsr\tCPSR_c, #209\t; 0xd1\n    81b8:\te1a0d003 \tmov\tsp, r3\n    81bc:\te24daa01 \tsub\tsl, sp, #4096\t; 0x1000\n    81c0:\te1a0300a \tmov\tr3, sl\n    81c4:\te321f0d7 \tmsr\tCPSR_c, #215\t; 0xd7\n    81c8:\te1a0d003 \tmov\tsp, r3\n    81cc:\te2433a01 \tsub\tr3, r3, #4096\t; 0x1000\n    81d0:\te321f0db \tmsr\tCPSR_c, #219\t; 0xdb\n    81d4:\te1a0d003 \tmov\tsp, r3\n    81d8:\te2433a01 \tsub\tr3, r3, #4096\t; 0x1000\n    81dc:\te321f0d2 \tmsr\tCPSR_c, #210\t; 0xd2\n    81e0:\te1a0d003 \tmov\tsp, r3\n    81e4:\te2433a02 \tsub\tr3, r3, #8192\t; 0x2000\n    81e8:\te321f0d3 \tmsr\tCPSR_c, #211\t; 0xd3\n    81ec:\te1a0d003 \tmov\tsp, r3\n    81f0:\te2433902 \tsub\tr3, r3, #32768\t; 0x8000\n    81f4:\te3c330ff \tbic\tr3, r3, #255\t; 0xff\n    81f8:\te3c33cff \tbic\tr3, r3, #65280\t; 0xff00\n    81fc:\te5033004 \tstr\tr3, [r3, #-4]\n    8200:\te9532000 \tldmdb\tr3, {sp}^\n    8204:\te38220c0 \torr\tr2, r2, #192\t; 0xc0\n    8208:\te121f002 \tmsr\tCPSR_c, r2\n    820c:\te243a801 \tsub\tsl, r3, #65536\t; 0x10000\n    8210:\te3b01000 \tmovs\tr1, #0\n    8214:\te1a0b001 \tmov\tfp, r1\n    8218:\te1a07001 \tmov\tr7, r1\n```", "```cpp\n 821c:\te59f0078 \tldr\tr0, [pc, #120]\t; 829c <_mainCRTStartup+0x104>\n    8220:\te59f2078 \tldr\tr2, [pc, #120]\t; 82a0 <_mainCRTStartup+0x108>\n    8224:\te0522000 \tsubs\tr2, r2, r0\n    8228:\teb00004a \tbl\t8358 <memset>\n\n   ... Then comes some code, purpose of which is not clear\n```", "```cpp\n 8278:\teb000014 \tbl\t82d0 <__libc_init_array>\n```", "```cpp\n 8284:\teb000010 \tbl\t82cc <main>\n```", "```cpp\n 8288:\teb000008 \tbl\t82b0 <exit>\n```", "```cpp\n 828c:\t00080000 \tandeq\tr0, r8, r0\n    8290:\t04008000 \tstreq\tr8, [r0], #-0\n\t...\n    829c:\t00008458 \tandeq\tr8, r0, r8, asr r4\n    82a0:\t00008474 \tandeq\tr8, r0, r4, ror r4\n```", "```cpp\n_entry:\n    ldr pc,reset_handler_ptr        ;@  Processor Reset handler\n    ldr pc,undefined_handler_ptr    ;@  Undefined instruction handler\n    ldr pc,swi_handler_ptr          ;@  Software interrupt\n    ldr pc,prefetch_handler_ptr     ;@  Prefetch/abort handler.\n    ldr pc,data_handler_ptr         ;@  Data abort handler/\n    ldr pc,unused_handler_ptr       ;@\n    ldr pc,irq_handler_ptr          ;@  IRQ handler\n    ldr pc,fiq_handler_ptr          ;@  Fast interrupt handler.\n\n    ;@ Set the branch addresses\n    reset_handler_ptr:      .word reset\n    undefined_handler_ptr:  .word hang\n    swi_handler_ptr:        .word hang\n    prefetch_handler_ptr:   .word hang\n    data_handler_ptr:       .word hang\n    unused_handler_ptr:     .word hang\n    irq_handler_ptr:        .word irq_handler\n    fiq_handler_ptr:        .word hang\n\nreset:\n    ;@ Disable interrupts\n    cpsid if\n\n    ;@ Copy interrupt vector to its place\n    ldr r0,=_entry\n    mov r1,#0x0000\n\n    ;@  Here we copy the branching instructions\n    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}\n    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}\n\n    ;@  Here we copy the branching addresses\n    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}\n    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}\n```", "```cpp\n_entry:\n    800c:\te59ff018 \tldr\tpc, [pc, #24]\t; 802c <reset_handler_ptr>\n    8010:\te59ff018 \tldr\tpc, [pc, #24]\t; 8030 <undefined_handler_ptr>\n    8014:\te59ff018 \tldr\tpc, [pc, #24]\t; 8034 <swi_handler_ptr>\n    8018:\te59ff018 \tldr\tpc, [pc, #24]\t; 8038 <prefetch_handler_ptr>\n    801c:\te59ff018 \tldr\tpc, [pc, #24]\t; 803c <data_handler_ptr>\n    8020:\te59ff018 \tldr\tpc, [pc, #24]\t; 8040 <unused_handler_ptr>\n    8024:\te59ff018 \tldr\tpc, [pc, #24]\t; 8044 <irq_handler_ptr>\n    8028:\te59ff018 \tldr\tpc, [pc, #24]\t; 8048 <fiq_handler_ptr>\n\n0000802c <reset_handler_ptr>:\n    802c:\t0000804c \tandeq\tr8, r0, ip, asr #32\n\n00008030 <undefined_handler_ptr>:\n    8030:\t000082b4 \t\t\t; <UNDEFINED> instruction: 0x000082b4\n\n00008034 <swi_handler_ptr>:\n    8034:\t000082b4 \t\t\t; <UNDEFINED> instruction: 0x000082b4\n\n00008038 <prefetch_handler_ptr>:\n    8038:\t000082b4 \t\t\t; <UNDEFINED> instruction: 0x000082b4\n\n0000803c <data_handler_ptr>:\n    803c:\t000082b4 \t\t\t; <UNDEFINED> instruction: 0x000082b4\n\n00008040 <unused_handler_ptr>:\n    8040:\t000082b4 \t\t\t; <UNDEFINED> instruction: 0x000082b4\n\n00008044 <irq_handler_ptr>:\n    8044:\t000082b8 \t\t\t; <UNDEFINED> instruction: 0x000082b8\n\n00008048 <fiq_handler_ptr>:\n    8048:\t000082b4 \t\t\t; <UNDEFINED> instruction: 0x000082b4\n```", "```cpp\n ;@ Copy interrupt vector to its place\n    ldr r0,=_entry\n    mov r1,#0x0000\n\n    ;@  Here we copy the branching instructions\n    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}\n    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}\n\n    ;@  Here we copy the branching addresses\n    ldmia r0!,{r2,r3,r4,r5,r6,r7,r8,r9}\n    stmia r1!,{r2,r3,r4,r5,r6,r7,r8,r9}\n```", "```cpp\nstd::vector<int> v;\nstatic const int MaxVecSize = 256;\nfor (int i = 0; i < MaxVecSize; ++i) {\n    v.push_back(i);\n}\n```", "```cpp\nunwind-arm.c:(.text+0x224): undefined reference to `__exidx_end'\nunwind-arm.c:(.text+0x228): undefined reference to `__exidx_start'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-abort.o): In function `abort':\nabort.c:(.text.abort+0x10): undefined reference to `_exit'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-sbrkr.o): In function `_sbrk_r':\nsbrkr.c:(.text._sbrk_r+0x18): undefined reference to `_sbrk'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-signalr.o): In function `_kill_r':\nsignalr.c:(.text._kill_r+0x1c): undefined reference to `_kill'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-signalr.o): In function `_getpid_r':\nsignalr.c:(.text._getpid_r+0x4): undefined reference to `_getpid'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-writer.o): In function `_write_r':\nwriter.c:(.text._write_r+0x20): undefined reference to `_write'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-closer.o): In function `_close_r':\ncloser.c:(.text._close_r+0x18): undefined reference to `_close'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-fstatr.o): In function `_fstat_r':\nfstatr.c:(.text._fstat_r+0x1c): undefined reference to `_fstat'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-isattyr.o): In function `_isatty_r':\nisattyr.c:(.text._isatty_r+0x18): undefined reference to `_isatty'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-lseekr.o): In function `_lseek_r':\nlseekr.c:(.text._lseek_r+0x20): undefined reference to `_lseek'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-readr.o): In function `_read_r':\nreadr.c:(.text._read_r+0x20): undefined reference to `_read'\ncollect2: error: ld returned 1 exit status\n```", "```cpp\n.ARM.exidx :\n{\n    __exidx_start = .;\n    *(.ARM.exidx* .gnu.linkonce.armexidx.*)\n    __exidx_end = .;\n} >RAM\n```", "```cpp\n#include <cstdlib>\n#include <new> \nvoid* operator new(size_t size) noexcept\n{\n    return malloc(size);\n}\n\nvoid operator delete(void *p) noexcept\n{\n    free(p);\n}\n\nvoid* operator new[](size_t size) noexcept\n{\n    return operator new(size); // Same as regular new\n}\n\nvoid operator delete[](void *p) noexcept\n{\n    operator delete(p); // Same as regular delete\n}\n\nvoid* operator new(size_t size, std::nothrow_t) noexcept\n{\n    return operator new(size); // Same as regular new\n}\n\nvoid operator delete(void *p,  std::nothrow_t) noexcept\n{\n    operator delete(p); // Same as regular delete\n}\n\nvoid* operator new[](size_t size, std::nothrow_t) noexcept\n{\n    return operator new(size); // Same as regular new\n}\n\nvoid operator delete[](void *p,  std::nothrow_t) noexcept\n{\n    operator delete(p); // Same as regular delete\n}\n```", "```cpp\nmain.cpp:34:42: error: exception handling disabled, use -fexceptions to enable\n     throw std::runtime_error(\"Some error\");\n```", "```cpp\nstd::vector<int> v;\nv.at(100) = 0;\n```", "```cpp\n00015f60 <main>:\n   15f60:\te92d4008 \tpush\t{r3, lr}\n   15f64:\te59f0000 \tldr\tr0, [pc]\t; 15f6c <main+0xc>\n   15f68:\teb0000a8 \tbl\t16210 <_ZSt20__throw_out_of_rangePKc>\n   15f6c:\t00013868 \tandeq\tr3, r1, r8, ror #16\n```", "```cpp\nmain.cpp.o: In function `main':\nmain.cpp:(.text.startup+0x8): undefined reference to `std::__throw_out_of_range(char const*)'\ncollect2: error: ld returned 1 exit status\n```", "```cpp\nnamespace std\n{\n\nvoid __throw_out_of_range(char const*)\n{\n    while (true) {}\n}\n\n}\n```", "```cpp\nstruct SomeClass\n{\n    virtual void someFunc();\n};\n```", "```cpp\nvoid SomeClass::someFunc()\n{\n}\n```", "```cpp\nSomeClass someClass;\nsomeClass.someFunc();\n```", "```cpp\n00008300 <_ZN9SomeClass8someFuncEv>:\n    8300:\te12fff1e \tbx\tlr\n```", "```cpp\nDisassembly of section .rodata:\n\n...\n00009c10 <_ZTV9SomeClass>:\n    9c10:\t00000000 \tandeq\tr0, r0, r0\n    9c14:\t00009c04 \tandeq\tr9, r0, r4, lsl #24\n    9c18:\t00008300 \tandeq\tr8, r0, r0, lsl #6\n    9c1c:\t00000000 \tandeq\tr0, r0, r0\n```", "```cpp\n00009c04 <_ZTI9SomeClass>:\n    9c04:\t00009c28 \tandeq\tr9, r0, r8, lsr #24\n    9c08:\t00009bf8 \tstrdeq\tr9, [r0], -r8\n    9c0c:\t00000000 \tandeq\tr0, r0, r0\n```", "```cpp\n00009bf8 <_ZTS9SomeClass>:\n    9bf8:\t6d6f5339 \tstclvs\t3, cr5, [pc, #-228]!\t; 9b1c <strcmp+0x180>\n    9bfc:\t616c4365 \tcmnvs\tip, r5, ror #6\n    9c00:\t00007373 \tandeq\tr7, r0, r3, ror r3\n```", "```cpp\n00009c20 <_ZTVN10__cxxabiv117__class_type_infoE>:\n    9c20:\t00000000 \tandeq\tr0, r0, r0\n    9c24:\t00009c50 \tandeq\tr9, r0, r0, asr ip\n    9c28:\t00009dc0 \tandeq\tr9, r0, r0, asr #27\n    9c2c:\t00009de4 \tandeq\tr9, r0, r4, ror #27\n    9c30:\t0000a114 \tandeq\tsl, r0, r4, lsl r1\n    9c34:\t0000a11c \tandeq\tsl, r0, ip, lsl r1\n    9c38:\t00009e40 \tandeq\tr9, r0, r0, asr #28\n    9c3c:\t00009d48 \tandeq\tr9, r0, r8, asr #26\n    9c40:\t00009e10 \tandeq\tr9, r0, r0, lsl lr\n    9c44:\t00009e94 \tmuleq\tr0, r4, lr\n    9c48:\t00009dac \tandeq\tr9, r0, ip, lsr #27\n    9c4c:\t00000000 \tandeq\tr0, r0, r0\n```", "```cpp\nDisassembly of section .rodata:\n\n00008320 <_ZTV9SomeClass>:\n\t...\n    8328:\t00008300 \tandeq\tr8, r0, r0, lsl #6\n    832c:\t00000000 \tandeq\tr0, r0, r0\n```", "```cpp\n#include <functional> namespace std\n{\nnamespace placeholders\n{\n\ndecltype(std::placeholders::_1) _1;\ndecltype(std::placeholders::_2) _2;\ndecltype(std::placeholders::_3) _3;\ndecltype(std::placeholders::_4) _4;\n\n}  // namespace placeholders\n}  // namespace std\n```", "```cpp\nclass SomeObj\n{\npublic:\n   static SomeObj& instanceGlobal();\n   static SomeObj& instanceLocal();\n\nprivate:\n    SomeObj(int v1, int v2);\n    int m_v1;\n    int m_v2;\n\n    static SomeObj globalObj;\n};\n\nSomeObj SomeObj::globalObj(1, 2);\n\nSomeObj& SomeObj::instanceGlobal()\n{\n    return globalObj;\n}\n\nSomeObj& SomeObj::instanceLocal()\n{\n    static SomeObj localObj(3, 4);\n    return localObj;\n}\n\nint main(int argc, const char** argv)\n{\n    static_cast<void>(argc);\n    static_cast<void>(argv);\n\n    auto& glob = SomeObj::instanceGlobal();\n    auto& local = SomeObj::instanceLocal();\n    static_cast<void>(glob);\n    static_cast<void>(local);\n\n    while (true) {};\n    return 0;\n}\n```", "```cpp\nmain.cpp:(.text.startup+0x1c): undefined reference to `__cxa_guard_acquire'\nmain.cpp:(.text.startup+0x3c): undefined reference to `__cxa_guard_release'\n```", "```cpp\n auto& local = SomeObj::instanceLocal();\n    static_cast<void>(local);\n```", "```cpp\n00008180 <__init_array_start>:\n    8180:\t00008154 \tandeq\tr8, r0, r4, asr r1\n```", "```cpp\n00008154 <_GLOBAL__sub_I__ZN7SomeObj9globalObjE>:\n    8154:\te59f0008 \tldr\tr0, [pc, #8]\t; 8164 <_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x10>\n    8158:\te3a01001 \tmov\tr1, #1\n    815c:\te3a02002 \tmov\tr2, #2\n    8160:\teaffffee \tb\t8120 <_ZN7SomeObjC1Eii>\n    8164:\t00008168 \tandeq\tr8, r0, r8, ror #2\n\n00008168 <_ZN7SomeObj9globalObjE>:\n\t...\n```", "```cpp\n .init.array :\n    {\n        __init_array_start = .;\n        *(.init_array)\n        *(.init_array.*)\n        __init_array_end = .;\n    } > RAM\n```", "```cpp\n ;@ Call constructors of all global objects\n    ldr r0, =__init_array_start\n    ldr r1, =__init_array_end\n\nglobals_init_loop:\n    cmp     r0,r1\n    it      lt\n    ldrlt   r2, [r0], #4\n    blxlt   r2\n    blt     globals_init_loop\n\n    ;@ Main function\n    bl main\n    b reset ;@ restart if main function returns\n```", "```cpp\n ;@ Call constructors of all global objects\n    bl\t__libc_init_array\n\n    ;@ Main function\n    bl main\n    b reset ;@ restart if main function returns\n```", "```cpp\n000080e4 <_ZN7SomeObj13instanceLocalEv>:\n    80e4:\te92d4010 \tpush\t{r4, lr}\n    80e8:\te59f4028 \tldr\tr4, [pc, #40]\t; 8118 <_ZN7SomeObj13instanceLocalEv+0x34>\n    80ec:\te5943008 \tldr\tr3, [r4, #8]\n    80f0:\te3130001 \ttst\tr3, #1\n    80f4:\t1a000005 \tbne\t8110 <_ZN7SomeObj13instanceLocalEv+0x2c>\n    80f8:\te284000c \tadd\tr0, r4, #12\n    80fc:\te3a01003 \tmov\tr1, #3\n    8100:\te3a02004 \tmov\tr2, #4\n    8104:\teb000005 \tbl\t8120 <_ZN7SomeObjC1Eii>\n    8108:\te3a03001 \tmov\tr3, #1\n    810c:\te5843008 \tstr\tr3, [r4, #8]\n    8110:\te59f0004 \tldr\tr0, [pc, #4]\t; 811c <_ZN7SomeObj13instanceLocalEv+0x38>\n    8114:\te8bd8010 \tpop\t{r4, pc}\n    8118:\t00008168 \tandeq\tr8, r0, r8, ror #2\n    811c:\t00008174 \tandeq\tr8, r0, r4, ror r1\n```", "```cpp\nclass SomeObj\n{\npublic:\n   ~SomeObj();\n    …\n}\n```", "```cpp\nSomeObj::~SomeObj() {}\n```", "```cpp\nCMakeFiles/03_test_statics.dir/SomeObj.cpp.o: In function `SomeObj::instanceLocal()':\nSomeObj.cpp:(.text+0x44): undefined reference to `__aeabi_atexit'\nSomeObj.cpp:(.text+0x58): undefined reference to `__dso_handle'\nCMakeFiles/03_test_statics.dir/SomeObj.cpp.o: In function `_GLOBAL__sub_I__ZN7SomeObj9globalObjE':\nSomeObj.cpp:(.text.startup+0x28): undefined reference to `__aeabi_atexit'\nSomeObj.cpp:(.text.startup+0x34): undefined reference to `__dso_handle'\n```", "```cpp\nextern \"C\" int __aeabi_atexit(\n    void *object,\n    void (*destructor)(void *),\n    void *dso_handle)\n{\n    static_cast<void>(object);\n    static_cast<void>(destructor);\n    static_cast<void>(dso_handle);\n    return 0;\n}\n\nvoid* __dso_handle = nullptr;\n```", "```cpp\n00008170 <_GLOBAL__sub_I__ZN7SomeObj9globalObjE>:\n    8170:\te92d4010 \tpush\t{r4, lr}\n    8174:\te59f4020 \tldr\tr4, [pc, #32]\t; 819c <_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x2c>\n    8178:\te3a01001 \tmov\tr1, #1\n    817c:\te1a00004 \tmov\tr0, r4\n    8180:\te3a02002 \tmov\tr2, #2\n    8184:\tebffffeb \tbl\t8138 <_ZN7SomeObjC1Eii>\n    8188:\te1a00004 \tmov\tr0, r4\n    818c:\te59f100c \tldr\tr1, [pc, #12]\t; 81a0 <_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x30>\n    8190:\te59f200c \tldr\tr2, [pc, #12]\t; 81a4 <_GLOBAL__sub_I__ZN7SomeObj9globalObjE+0x34>\n    8194:\te8bd4010 \tpop\t{r4, lr}\n    8198:\teaffffe9 \tb\t8144 <__aeabi_atexit>\n    819c:\t000081a8 \tandeq\tr8, r0, r8, lsr #3\n    81a0:\t00008140 \tandeq\tr8, r0, r0, asr #2\n    81a4:\t000081bc \t\t\t; <UNDEFINED> instruction: 0x000081bc\n\n00008140 <_ZN7SomeObjD1Ev>:\n    8140:\te12fff1e \tbx\tlr\n\n000081bc <__dso_handle>:\n    81bc:\t00000000 \tandeq\tr0, r0, r0\n```", "```cpp\nclass AbstractBase\n{\npublic:\n    virtual ~AbstractBase();\n    virtual void func() = 0;\n    virtual void nonOverridenFunc() final;\n};\n\nclass Derived : public AbstractBase\n{\npublic:\n    virtual ~Derived();\n    virtual void func() override;\n};\n\nAbstractBase::~AbstractBase()\n{\n}\n\nvoid AbstractBase::nonOverridenFunc()\n{\n}\n\nDerived::~Derived()\n{\n}\n\nvoid Derived::func()\n{\n}\n[source, c++]\n```", "```cpp\nDerived obj;\nAbstractBase* basePtr = &obj;\nbasePtr->func();\n```", "```cpp\nCMakeFiles/04_test_abstract_class.dir/AbstractBase.cpp.o: In function `AbstractBase::~AbstractBase()':\nAbstractBase.cpp:(.text+0x24): undefined reference to `operator delete(void*)'\nCMakeFiles/04_test_abstract_class.dir/AbstractBase.cpp.o:(.rodata+0x10): undefined reference to `__cxa_pure_virtual'\nCMakeFiles/04_test_abstract_class.dir/Derived.cpp.o: In function `Derived::~Derived()':\nDerived.cpp:(.text+0x3c): undefined reference to `operator delete(void*)'\n```", "```cpp\nextern \"C\" void __cxa_pure_virtual()\n{\n    while (true) {}\n}\n```", "```cpp\nvoid operator delete(void *)\n{\n}\n```", "```cpp\nDisassembly of section .rodata:\n\n000081a0 <_ZTV12AbstractBase>:\n\t...\n    81a8:\t000080d8 \tldrdeq\tr8, [r0], -r8\t; <UNPREDICTABLE>\n    81ac:\t000080ec \tandeq\tr8, r0, ip, ror #1\n    81b0:\t0000815c \tandeq\tr8, r0, ip, asr r1\n    81b4:\t000080e8 \tandeq\tr8, r0, r8, ror #1\n\n000081b8 <_ZTV7Derived>:\n\t...\n    81c0:\t00008110 \tandeq\tr8, r0, r0, lsl r1\n    81c4:\t00008130 \tandeq\tr8, r0, r0, lsr r1\n    81c8:\t0000810c \tandeq\tr8, r0, ip, lsl #2\n    81cc:\t000080e8 \tandeq\tr8, r0, r8, ror #1\n```", "```cpp\n000080e8 <_ZN12AbstractBase16nonOverridenFuncEv>:\n    80e8:\te12fff1e \tbx\tlr\n```", "```cpp\n0000810c <_ZN7Derived4funcEv>:\n    810c:\te12fff1e \tbx\tlr\n\n0000815c <__cxa_pure_virtual>:\n    815c:\teafffffe \tb\t815c <__cxa_pure_virtual>\n```", "```cpp\n000080d8 <_ZN12AbstractBaseD1Ev>:\n    80d8:\te59f3004 \tldr\tr3, [pc, #4]\t; 80e4 <_ZN12AbstractBaseD1Ev+0xc>\n    80dc:\te5803000 \tstr\tr3, [r0]\n    80e0:\te12fff1e \tbx\tlr\n    80e4:\t000081a8 \tandeq\tr8, r0, r8, lsr #3\n\n000080ec <_ZN12AbstractBaseD0Ev>:\n    80ec:\te59f3014 \tldr\tr3, [pc, #20]\t; 8108 <_ZN12AbstractBaseD0Ev+0x1c>\n    80f0:\te92d4010 \tpush\t{r4, lr}\n    80f4:\te1a04000 \tmov\tr4, r0\n    80f8:\te5803000 \tstr\tr3, [r0]\n    80fc:\teb000015 \tbl\t8158 <_ZdlPv>\n    8100:\te1a00004 \tmov\tr0, r4\n    8104:\te8bd8010 \tpop\t{r4, pc}\n    8108:\t000081a8 \tandeq\tr8, r0, r8, lsr #3\n\n00008110 <_ZN7DerivedD1Ev>:\n    8110:\te59f3014 \tldr\tr3, [pc, #20]\t; 812c <_ZN7DerivedD1Ev+0x1c>\n    8114:\te92d4010 \tpush\t{r4, lr}\n    8118:\te1a04000 \tmov\tr4, r0\n    811c:\te5803000 \tstr\tr3, [r0]\n    8120:\tebffffec \tbl\t80d8 <_ZN12AbstractBaseD1Ev>\n    8124:\te1a00004 \tmov\tr0, r4\n    8128:\te8bd8010 \tpop\t{r4, pc}\n    812c:\t000081c0 \tandeq\tr8, r0, r0, asr #3\n\n00008130 <_ZN7DerivedD0Ev>:\n    8130:\te59f301c \tldr\tr3, [pc, #28]\t; 8154 <_ZN7DerivedD0Ev+0x24>\n    8134:\te92d4010 \tpush\t{r4, lr}\n    8138:\te1a04000 \tmov\tr4, r0\n    813c:\te5803000 \tstr\tr3, [r0]\n    8140:\tebffffe4 \tbl\t80d8 <_ZN12AbstractBaseD1Ev>\n    8144:\te1a00004 \tmov\tr0, r4\n    8148:\teb000002 \tbl\t8158 <_ZdlPv>\n    814c:\te1a00004 \tmov\tr0, r4\n    8150:\te8bd8010 \tpop\t{r4, pc}\n    8154:\t000081c0 \tandeq\tr8, r0, r0, asr #3\n\n00008158 <_ZdlPv>:\n    8158:\te12fff1e \tbx\tlr\n```", "```cpp\nbasePtr->~AbstractBase();\ndelete basePtr;\n```", "```cpp\n 8190:\te59d3004 \tldr\tr3, [sp, #4]\n    8194:\te1a00004 \tmov\tr0, r4\n    8198:\te5933000 \tldr\tr3, [r3]\n    819c:\te12fff33 \tblx\tr3\n    81a0:\te59d3004 \tldr\tr3, [sp, #4]\n    81a4:\te1a00004 \tmov\tr0, r4\n    81a8:\te5933004 \tldr\tr3, [r3, #4]\n    81ac:\te12fff33 \tblx\tr3\n```", "```cpp\ntemplate <typename T>\nvoid func(T startValue)\n{\n    for (volatile T i = startValue; i < startValue * 2; i += 1) {}\n    for (volatile T i = startValue; i < startValue * 2; i += 2) {}\n    for (volatile T i = startValue; i < startValue * 2; i += 3) {}\n    for (volatile T i = startValue; i < startValue * 2; i += 4) {}\n    for (volatile T i = startValue; i < startValue * 2; i += 5) {}\n    for (volatile T i = startValue; i < startValue * 2; i += 6) {}\n}\n\nint main(int argc, const char** argv)\n{\n    static_cast<void>(argc);\n    static_cast<void>(argv);\n\n    int start1 = 100;\n    unsigned start2 = 200;\n\n    func(start1);\n    func(start2);\n\n    while (true) {};\n    return 0;\n}\n```", "```cpp\n00008504 <main>:\n    8504:\te92d4008 \tpush\t{r3, lr}\n    8508:\te3a00064 \tmov\tr0, #100\t; 0x64\n    850c:\tebfffefc \tbl\t8104 <_Z4funcIiEvT_>\n    8510:\te3a000c8 \tmov\tr0, #200\t; 0xc8\n    8514:\tebffff3a \tbl\t8204 <_Z4funcIjEvT_>\n    ...\n```", "```cpp\nvoid other()\n{\n    int start1 = 300;\n    unsigned start2 = 500;\n\n    func(start1);\n    func(start2);\n}\n```", "```cpp\n000080d8 <_Z5otherv>:\n    80d8:\te92d4008 \tpush\t{r3, lr}\n    80dc:\te3a00f4b \tmov\tr0, #300\t; 0x12c\n    80e0:\teb000007 \tbl\t8104 <_Z4funcIiEvT_>\n    80e4:\te3a00f7d \tmov\tr0, #500\t; 0x1f4\n    80e8:\teb000045 \tbl\t8204 <_Z4funcIjEvT_>\n    80ec:\te8bd8008 \tpop\t{r3, pc}\n```", "```cpp\ntemplate <typename T, std::size_t TDummy>\nstruct SomeTemplateClass\n{\n    static void func(T startValue)\n    {\n        for (volatile T i = startValue; i < startValue * 2; i += 1) {}\n        for (volatile T i = startValue; i < startValue * 2; i += 2) {}\n        for (volatile T i = startValue; i < startValue * 2; i += 3) {}\n        for (volatile T i = startValue; i < startValue * 2; i += 4) {}\n        for (volatile T i = startValue; i < startValue * 2; i += 5) {}\n        for (volatile T i = startValue; i < startValue * 2; i += 6) {}\n    }\n};\n```", "```cpp\nint main(int argc, const char** argv)\n{\n    ...\n    SomeTemplateClass<int, 5>::func(500);\n    SomeTemplateClass<int, 10>::func(500);\n\n    while (true) {};\n    return 0;\n}\n```", "```cpp\n00008504 <main>:\n    ...\n    8518:\te3a00f7d \tmov\tr0, #500\t; 0x1f4\n    851c:\tebffff78 \tbl\t8304 <_ZN17SomeTemplateClassIiLj5EE4funcEi>\n    8520:\te3a00f7d \tmov\tr0, #500\t; 0x1f4\n    8524:\tebffffb6 \tbl\t8404 <_ZN17SomeTemplateClassIiLj10EE4funcEi>\n    8528:\teafffffe \tb\t8528 <main+0x24>\n```", "```cpp\nstruct Tag1 {};\nstruct Tag2 {};\n\nclass Dispatcher\n{\npublic:\n\n    template <typename TTag>\n    static void func()\n    {\n        funcInternal(TTag());\n    }\n\nprivate:\n    static void funcInternal(Tag1 tag);\n    static void funcInternal(Tag2 tag);\n\n};\n```", "```cpp\nDispatcher::func<Tag1>();\nDispatcher::func<Tag2>();\n```", "```cpp\n000080fc <main>:\n    80fc:\te92d4008 \tpush\t{r3, lr}\n    8100:\te3a00000 \tmov\tr0, #0\n    8104:\tebfffff3 \tbl\t80d8 <_ZN10Dispatcher12funcInternalE4Tag1>\n    8108:\te3a00000 \tmov\tr0, #0\n    810c:\tebfffff2 \tbl\t80dc <_ZN10Dispatcher12funcInternalE4Tag2>\n    ...\n```", "```cpp\nclass Dispatcher\n{\npublic:\n\n    template <typename TTag>\n    static void otherFunc()\n    {\n        otherFuncInternal(TTag());\n    }\n\nprivate:\n\n    static void otherFuncInternal(Tag1 tag)\n    {\n        static_cast<void>(tag);\n        otherFuncTag1();\n    }\n\n    static void otherFuncInternal(Tag2 tag)\n    {\n        static_cast<void>(tag);\n        otherFuncTag2();\n    }\n\n    static void otherFuncTag1();\n    static void otherFuncTag2();\n};\n```", "```cpp\nDispatcher::otherFunc<Tag1>();\nDispatcher::otherFunc<Tag2>();\n```", "```cpp\n000080fc <main>:\n    ...\n    8110:\tebfffff2 \tbl\t80e0 <_ZN10Dispatcher13otherFuncTag1Ev>\n    8114:\tebfffff2 \tbl\t80e4 <_ZN10Dispatcher13otherFuncTag2Ev>\n```", "```cpp\n#include <cassert> …\nassert(some_condition);\n```", "```cpp\nvoid __assert_fail (const char *expr, const char *file, unsigned int line, const char *function) __attribute__ ((__noreturn__));\n```", "```cpp\nclass Assert\n{\npublic:\n    virtual void fail(\n        const char* expr,\n        const char* file,\n        unsigned int line,\n        const char* function) = 0;\n};\n```", "```cpp\n#include \"embxx/util/Assert.h\" \ntypedef ... Led;\nclass LedOnAssert : public embxx::util::Assert\n{\npublic:\n\n    LedOnAssert(Led& led)\n        : led_(led)\n    {\n    }\n\n    virtual void fail(\n        const char* expr,\n        const char* file,\n        unsigned int line,\n        const char* function)\n    {\n        led_.on();\n        while (true) {;}\n    }\n\nprivate:\n    Led& led_;\n};\n```", "```cpp\nclass AssertManager\n{\npublic:\n   static AssertManager& instance()\n    {\n        static AssertManager mgr;\n        return mgr;\n    }\n\n    Assert* reset(Assert* newAssert = nullptr)\n    {\n        auto prevAssert = assert_;\n        assert_ = newAssert;\n        return prevAssert;\n    }\n\n    Assert* getAssert()\n    {\n        return assert_;\n    }\n\n    bool hasAssertRegistered() const\n    {\n        return assert_ != nullptr;\n    }\n\n    void infiniteLoop()\n    {\n        while (true) {};\n    }\n\nprivate:\n    AssertManager() : assert_(nullptr) {}\n\n    Assert* assert_;\n};\n```", "```cpp\n#ifndef NDEBUG \n#define GASSERT(expr) \\\n    ((expr)                               \\\n      ? static_cast<void>(0)                     \\\n      : (embxx::util::AssertManager::instance().hasAssertRegistered() \\\n            ? embxx::util::AssertManager::instance().getAssert()->fail( \\\n                #expr, __FILE__, __LINE__, GASSERT_FUNCTION_STR) \\\n            : embxx::util::AssertManager::instance().infiniteLoop())) \n#else // #ifndef NDEBUG \n#define GASSERT(expr) static_cast<void>(0) \n#endif // #ifndef NDEBUG\n```", "```cpp\ntemplate < typename TAssert>\nclass EnableAssert\n{\n    static_assert(std::is_base_of<Assert, TAssert>::value,\n        \"TAssert class must be derived class of Assert\");\npublic:\n    typedef TAssert AssertType;\n\n    template<typename... Params>\n    EnableAssert(Params&&... args)\n        : assert_(std::forward<Params>(args)...),\n          prevAssert_(AssertManager::instance().reset(&assert_))\n    {\n    }\n\n    ~EnableAssert()\n    {\n        AssertManager::instance().reset(prevAssert_);\n    }\n\nprivate:\n    AssertType assert_;\n    Assert* prevAssert_;\n};\n```", "```cpp\nint main (int argc, const char* argv[])\n{\n    ...\n    Led led;\n    embxx::util::EnableAssert<LedOnAssert> assertion(led);\n\n    ... // Rest of the code\n}\n```", "```cpp\nint main (int argc, const char* argv[])\n{\n    ...\n    Led led;\n    embxx::util::EnableAssert<LedOnAssert> assertion(led);\n\n    ...\n    {\n        embxx::util::EnableAssert<OtherAssert> otherAssertion(.../* some params */);\n        ...\n    }  // restore previous registered behaviour – LedOnAssert.\n}\n```", "```cpp\nclass LowLevelPeripheral {\npublic:\n    template <typename TFunc>\n    void setEventCallback(TFunc&& func)\n    {\n        eventCallback_ = std::forward<TFunc>(func);\n    }\n\n    void eventHandler()\n    {\n        if (eventCallback_) {\n            eventCallback_(); // invoke registered callback object\n        }\n    }\nprivate:\n    std::function<void ()> eventCallback_;\n};\n\nclass SomeGenericControl\n{\npublic:\n    SomeGenericControl()\n    {\n        periph_.setEventCallback(\n            std::bind(&SomeGenericControl::eventCallbackHandler, this));\n    }\n\n    void eventCallbackHandler()\n    {\n        … // Handle the reported event.\n    }\n\nprivate:\n     LowLevelPeripheral periph_;\n};\n```", "```cpp\ntemplate <typename TSignature, std::size_t TSize = sizeof(void*) * 3>\nclass StaticFunction;\n```", "```cpp\ntypedef embxx::util::StaticFunction<void (int)> MyCallback;\ntypedef embxx::util::StaticFunction<\n    void (int, int), sizeof(void*) * 4> MyOtherCallback;\n```", "```cpp\ntemplate <std::size_t TSize, typename TRet, typename... TArgs>\nclass StaticFunction<TRet (TArgs...), TSize>\n{\npublic:\n    ...\n    TRet operator()(TArgs... args) const {...}\n    ...\nprivate:\n    typedef … StorageType; // Type of the storage area,\n                           // will be explained later.\n    StorageType handler_; // Storage area where the callback object\n                          // is stored\n    bool valid_; // flag indicating whether storage are contains\n                 // valid callback, initialised to false in\n                 // default constructor\n};\n```", "```cpp\nclass StaticFunction<TRet (TArgs...), TSize>\n{\n    ...\nprivate:\n\n    class Invoker\n    {\n    public:\n        virtual ~Invoker() {}\n\n        // virtual invocation function\n        virtual TRet exec(TArgs... args) const = 0;\n    };\n\n    template <typename TBound>\n    class InvokerBound : public Invoker\n    {\n    public:\n\n        template <typename TFunc>\n        InvokerBound(TFunc&& func)\n            : func_(std::forward<TFunc>(func))\n        {\n        }\n\n        virtual ~InvokerBound() {}\n\n        virtual TRet exec(TArgs... args) const\n        {\n            return func_(std::forward<TArgs>(args)...);\n        }\n\n    private:\n        TBound func_;\n    };\n\n    ...\n};\n```", "```cpp\nstatic const std::size_t StorageAreaSize = TSize + sizeof(Invoker);\ntypedef typename\n    std::aligned_storage<\n        StorageAreaSize,\n        std::alignment_of<Invoker>::value\n   >::type StorageType;\n```", "```cpp\ntemplate <std::size_t TSize, typename TRet, typename... TArgs>\nclass StaticFunction<TRet (TArgs...), TSize>\n{\npublic:\n    ...\n\n    template <typename TFunc>\n    StaticFunction(TFunc&& func)\n        : valid_(true)\n    {\n        assignHandler(std::forward<TFunc>(func));\n    }\n\n    StaticFunction& operator=(TFunc&& func)\n    {\n        destroyHandler();\n        assignHandler(std::forward<TFunc>(func));\n        valid_ = true;\n        return *this;\n    }\n\n    ...\n\nprivate:\n    template <typename TFunc>\n    void assignHandler(TFunc&& func)\n    {\n        typedef typename std::decay<TFunc>::type DecayedFuncType;\n        typedef InvokerBound<DecayedFuncType> InvokerBoundType;\n\n        static_assert(sizeof(InvokerBoundType) <= StorageAreaSize,\n            \"Increase the TSize template argument of the StaticFucntion\");\n\n        static_assert(alignof(Invoker) == alignof(InvokerBoundType),\n            \"Alignment requirement for Invoker object must be the same \"\n            \"as alignment requirement for InvokerBoundType type object\");\n\n        new (&handler_) InvokerBoundType(std::forward<TFunc>(func));\n    }\n\n    void destroyHandler()\n    {\n        if (valid_) {\n            auto invoker = reinterpret_cast<Invoker*>(&handler_);\n            invoker->~Invoker();\n        }\n    }\n};\n```", "```cpp\ntemplate <std::size_t TSize, typename TRet, typename... TArgs>\nclass StaticFunction<TRet (TArgs...), TSize>\n{\npublic:\n    ...\n    TRet operator()(TArgs... args) const\n    {\n        GASSERT(valid_);\n        auto invoker = reinterpret_cast<Invoker*>(&handler_);\n        return invoker->exec(std::forward<TArgs>(args)...);\n    }\n    ...\n};\n```", "```cpp\ntemplate <typename T, typename TIter>\nvoid writeBig(T value, TIter& iter);\n\ntemplate <typename T, typename TIter>\nT readBig(TIter& iter);\n\ntemplate <typename T, typename TIter>\nvoid writeLittle(T value, TIter& iter);\n\ntemplate <typename T, typename TIter>\nT readLittle(TIter& iter);\n```", "```cpp\nstd::uint8_t buf[128];\nauto iter = &buf[0];\n\nstd::uint16_t value1 = 0x0102;\nstd::uint32_t value2 = 0x03040506;\nstd::uint64_t value3 = 0x0708090a0b0c0d0e;\n\nembxx::io::writeBig(value1, iter);\nembxx::io::writeBig(value2, iter);\nembxx::io::writeBig(value3, iter);\n```", "```cpp\nstd::uint8_t buf[128];\nauto iter = &buf[0];\n\nauto value1 = embxx::io::readBig<std::uint16_t>(iter);\nauto value2 = embxx::io::readBig<std::uint32_t>(iter);\nauto value3 = embxx::io::readBig<std::uint64_t>(iter);\n```", "```cpp\nstd::vector<std::uint8_t> buf;\nauto iter = std::back_inserter(buf); // Will call push_back\n                                     // on assignment\n…\n// The writes below will use push_back for every byte.\nembxx::io::writeBig(value1, iter);\nembxx::io::writeBig(value2, iter);\nembxx::io::writeBig(value3, iter);\n```", "```cpp\ntemplate <std::size_t TSize, typename T, typename TIter>\nvoid writeBig(T value, TIter& iter);\n\ntemplate <typename T, std::size_t TSize, typename TIter>\nT readBig(TIter& iter);\n\ntemplate <std::size_t TSize, typename T, typename TIter>\nvoid writeLittle(T value, TIter& iter);\n\ntemplate <typename T, std::size_t TSize, typename TIter>\nT readLittle(TIter& iter);\n```", "```cpp\nauto value = embxx::io::readBig<std::uint32_t, 3>(iter);\nembxx::io::writeBig<3>(value, iter);\n```", "```cpp\n/// Same as writeBig<T, TIter>(value, iter);\ntemplate <typename T, typename TIter>\nvoid writeData(\n    T value,\n    TIter& iter,\n    const traits::endian::Big& endian);\n\n/// Same as writeBig<TSize, T, TIter>(value, iter)\ntemplate <std::size_t TSize, typename T, typename TIter>\nvoid writeData(\n    T value,\n    TIter& iter,\n    const traits::endian::Big& endian);\n\n/// Same as writeLittle<T, TIter>(value, iter)\ntemplate <typename T, typename TIter>\nvoid writeData(\n    T value,\n    TIter& iter,\n    const traits::endian::Little& endian);\n\n/// Same as writeLittle<TSize, T, TIter>(value, iter)\ntemplate <std::size_t TSize, typename T, typename TIter>\nvoid writeData(\n    T value,\n    TIter& iter,\n    const traits::endian::Little& endian);\n\n/// Same as readBig<T, TIter>(iter)\ntemplate <typename T, typename TIter>\nT readData(TIter& iter, const traits::endian::Big& endian);\n\n/// Same as readBig<TSize, T, TIter>(iter)\ntemplate <typename T, std::size_t TSize, typename TIter>\nT readData(TIter& iter, const traits::endian::Big& endian);\n\n/// Same as readLittle<T, TIter>(iter)\ntemplate <typename T, typename TIter>\nT readData(TIter& iter, const traits::endian::Little& endian);\n\n/// Same as readLittle<TSize, T, TIter>(iter)\ntemplate <typename T, std::size_t TSize, typename TIter>\nT readData(TIter& iter, const traits::endian::Little& endian);\n```", "```cpp\nnamespace traits\n{\n\nnamespace endian\n{\n\nstruct Big {};\n\nstruct Little {};\n\n}  // namespace endian\n\n}  // namespace traits\n```", "```cpp\ntemplate <typename TTraits>\nclass SomeClass\n{\npublic:\n    typedef typename TTraits::Endianness Endianness;\n\n    template <typename TIter>\n    void serialise(TIter& iter) const\n    {\n        embxx::io::writeData(data_, iter, Endianness());\n    }\n\nprivate:\n    std::uint32_t data_;\n};\n```", "```cpp\nstruct MyTraits\n{\n    typedef embxx::io::traits::endian::Big Endianness;\n};\n\nSomeClass<MyTraits> someClassObj;\n…\nsomeClassObj.serialise(iter); // Will serialise using big endian\n```", "```cpp\nchar buf[128] = {…};\nconst char* iter1 = &buf[0];\nchar* iter2 = &buf[0];\n\n// Instantiation 1\nauto value1 = embxx::io::readBig<std::uint16_t>(iter1);\n\n// Instantiation 2\nauto value2 = embxx::io::readBig<std::uint16_t>(iter2);\n```", "```cpp\ntemplate <typename T, std::size_t TSize>\nclass StaticQueue\n{\npublic:\n    ...\n    void popFront()\n    {\n        GASSERT(!empty());\n        ...\n    }\n};\n```", "```cpp\ntemplate <typename T, std::size_t TSize>\nclass StaticQueue\n{\npublic:\n    typedef T ValueType;\n    ...\nprivate:\n    typedef\n        typename std::aligned_storage<\n            sizeof(ValueType),\n            std::alignment_of<ValueType>::value\n        >::type StorageType;\n\n    typedef std::array<StorageType, TSize> ArrayType;\n\n    ArrayType array_;\n    ...\n};\n```", "```cpp\ntemplate <typename T, std::size_t TSize>\nclass StaticQueue\n{\npublic:\n    ...\n    typedef T ValueType;\n    ...\n\n    template <typename U>\n    void pushBack(U&& newElem)\n    {\n        auto* spacePtr = ...; // get pointer to the right place\n        new (spacePtr) ValueType(std::forward<U>(newElem));\n        ...\n    }\n};\n```", "```cpp\ntemplate <typename T, std::size_t TSize>\nclass StaticQueue\n{\npublic:\n    ...\n    typedef T ValueType;\n    ...\n   void popBack()\n    {\n        auto* spacePtr = ...; // get pointer to the right place\n        auto* elemPtr = reinterpret_cast<ValueType*>(spacePtr);\n        elemPtr->~T(); // call the destructor;\n        ...\n    }\n};\n```", "```cpp\ntemplate <typename T, std::size_t TSize>\nclass StaticQueue\n{\npublic:\n    class Iterator\n    {\n    public:\n        typedef std::random_access_iterator_tag iterator_category;\n        typedef T value_type;\n        typedef T* pointer;\n        typedef T& reference;\n        typedef typename std::iterator_traits<pointer>::difference_type difference_type;\n        ...\n    };\n\n    ...\n};\n```", "```cpp\ntemplate <typename T, std::size_t TSize>\nclass StaticQueue\n{\npublic:\n    ...\n\n    template <std::size_t TAnySize>\n    StaticQueue(const StaticQueue<T, TAnySize>& queue)\n        : Base(&array_[0], TSize)\n    {\n        ... // Copy all the elements from other queue\n    }\n\n    template <std::size_t TAnySize>\n    StaticQueue(StaticQueue<T, TAnySize>&& queue)\n        : Base(&array_[0], TSize)\n    {\n        ... // Move all the elements from other queue\n    }\n\n    template <std::size_t TAnySize>\n    StaticQueue& operator=(const StaticQueue<T, TAnySize>& queue)\n    {\n        ... // Copy all the elements from other queueu\n    }\n\n    template <std::size_t TAnySize>\n    StaticQueue& operator=(StaticQueue<T, TAnySize>&& queue)\n    {\n        ... // Move all the elements from other queue\n    }\n    ...\n};\n```", "```cpp\nnamespace details\n{\n\ntemplate <typename T>\nclass StaticQueueBase\n{\nprotected:\n    typedef T ValueType;\n    typedef\n        typename std::aligned_storage<\n            sizeof(ValueType),\n            std::alignment_of<ValueType>::value\n        >::type StorageType;\n    typedef StorageType* StorageTypePtr;\n\n    StaticQueueBase(StorageTypePtr data, std::size_t capacity)\n        : data_(data),\n          capacity_(capacity),\n          startIdx_(0),\n          count_(0)\n    {\n    }\n\n    template <typename U>\n    void pushBack(U&& value) {...}\n\n    ... // All other API functions\n\nprivate:\n    StorageTypePtr data_; // Pointer to storage area\n    std::size_t capacity_; // Capacity of the storage area\n    std::size_t startIdx_; // Index of the beginning of the queue\n    std::size_t count_; // Number of elements in the queue\n};\n\n} // namespace details\n\ntemplate <typename T, std::size_t TSize>\nclass StaticQueue : public details::StaticQueueBase<T>\n{\n    typedef details::StaticQueueBaseOptimised<T> Base;\n    typedef typename Base::StorageType StorageType;\n\npublic:\n   StaticQueue()\n        : Base(&array_[0], TSize)\n    {\n    }\n\n    template <typename U>\n    void pushBack(U&& value)\n    {\n        Base::pushBack(std::forward<U>(value));\n    }\n\n    ... // Wrap all other API functions\n\nprivate:\n    typedef std::array<StorageType, TSize> ArrayType;\n    ArrayType array_;\n};\n```", "```cpp\nbool g_buttonPressed = false;\n\nvoid gpioInterruptHandler()\n{\n    ...\n    if (/*button_gpio_recognised*/) {\n        g_buttonPressed = true;\n    }\n}\n\nint main(int argc, const char* argv[])\n{\n    ...\n    while (true) { // infinite event processing loop\n        enableInterrupts();\n        ...\n        if (g_buttonPressed) {\n            disableInterrupt(); // avoid races\n            g_buttonPressed = false;\n            enableInterrupts();\n            ... // Handle button press\n        }\n        ...\n        disableInterrupts();\n        if (/* no_more_events */) {\n            WFI(); // “Wait for interrupt” assembler instruction,\n                   // instruction will exit when there is pending\n                   // interrupt.\n        }\n    }\n}\n```", "```cpp\nenum EventId\n{\n    EventId_ClockTick,\n    EventId_ButtonPress,\n    ....\n}\n\nQueue<EventId> events;\n\nvoid gpioInterruptHandler()\n{\n    ...\n    if (/*button_gpio_recognised*/) {\n        events.push_back(EventId_ButtonPress);\n    }\n}\n\nint main(int argc, const char* argv[])\n{\n    ...\n    while (true) { // infinite event processing loop\n        enableInterrupts();\n        ...\n        switch (events.front()) {\n        case EventId_ClockTick:\n            ... // handle clock tick\n            break;\n\n        case EventId_ButtonPress:\n            ... // handle button press\n            break;\n            ...\n        }\n        ...\n        disableInterrupts();\n        events.pop_front(); // Remove processed event from queue\n       if (events.empty()) {\n            WFI(); // “Wait for interrupt” assembler instruction,\n                   // instruction will exit when there is pending interrupt.\n        }\n    }\n}\n```", "```cpp\ntypedef std::list<std::function<void ()> > Queue;\nQueue handlers;\n\ntemplate <typename TFunc>\nvoid addHandlerFromInterrupt(TFunc&& func)\n{\n    // No need to disable interrupts.\n    handlers.push_back(std::forward<TFunc>(func));\n}\n\ntemplate <typename TFunc>\nvoid addHandler(TFunc&& func)\n{\n   // Protect against races with interrupt handlers\n    disableInterrupts();\n    handlers.push_back(std::forward<TFunc>(func));\n    enableInterrupts();\n}\n\nvoid handleButtonPressStart()\n{\n    ...// Start handling of button press event\n    handleButtonPressBusyWait();\n}\n\nvoid handleButtonPressBusyWait()\n{\n    if (/* some_condition */) {\n        handleButtonPressFinish();\n        return;\n    }\n\n    // The condition is not true, need to wait,\n    // reschedule the execution of the same function.\n    addHandler(\n        []()\n        {\n             handleButtonPressBusyWait();\n        });\n}\n\nvoid handleButtonPressFinish()\n{\n    ...// Finalise handling of button press event.\n}\n\nvoid gpioInterruptHandler()\n{\n    ...\n    if (/*button_gpio_recognised*/) {\n        addHandlerFromInterrupt(\n            []()\n            {\n\t\t // Will be executed in non-interrupt event loop.\n                 handleButtonPressStart();\n            });\n    }\n}\n\nint main(int argc, const char* argv[])\n{\n    ...\n    while (true) { // infinite event processing loop\n        enableInterrupts();\n        ...\n        auto& firstHandler = handlers.front();\n        firstHandler(); // Execute scheduled callable object\n        ...\n        disableInterrupts();\n        handlers.pop_front(); // Remove executed callable object\n                              // (function) from queue of handlers.\n\n        if (handlers.empty()) {\n            WFI(); // “Wait for interrupt” assembler instruction,\n                   // instruction will exit when there is pending\n                   // interrupt.\n        }\n    }\n}\n```", "```cpp\ntypedef embxx::util::StaticFunction<void (), sizeof(void*) * 10>  Func;\ntypedef embxx::container::StaticQueue<Func, 1024> Queue;\n\nQueue handlers;\n…\nhandlers.push_back(std::bind(&func1, param1, param2)); // Will require size of only 3 values\n...\nhandlers.push_back(\n    std::bind(\n        &func2,\n        param1,\n        param2,\n        param3,\n        param4)); // Will require size of only 5 values\n\nhandlers.push_back(\n    std::bind(\n        &func3,\n        param1,\n        param2,\n        param3,\n        param4,\n        param5,\n        param6,\n        param7,\n        param8,\n        param9)); // Will consume the whole available space.\n```", "```cpp\nclass Task\n{\npublic:\n    virtual ~Task() {}\n\n    virtual std::size_t getSize() const\n    {\n        return 1U;\n    }\n\n    virtual void exec() {}\n};\n\ntemplate <typename TTask>\nclass TaskBound : public Task\n{\npublic:\n\n    // Size is minimal number of elements of size equal to sizeof(Task)\n    // that will be able to store this TaskBound object\n    static const std::size_t Size =\n        ((sizeof(TaskBound<typename std::decay<TTask>::type>) - 1) /\n                                                     sizeof(Task)) + 1;\n\n    explicit TaskBound(const TTask& task)\n      : task_(task)\n    {\n    }\n\n    explicit TaskBound(TTask&& task)\n      : task_(std::move(task))\n    {\n    }\n\n    virtual ~TaskBound() {}\n\n    virtual std::size_t getSize() const\n    {\n        return Size;\n    }\n\n    virtual void exec()\n    {\n        task_();\n    }\n\nprivate:\n    TTask task_;\n};\n```", "```cpp\ntypedef typename\n    std::aligned_storage<\n        sizeof(Task),\n        std::alignment_of<Task>::value\n   >::type ArrayElemType;\n\nstatic const std::size_t ArraySize = TSize / sizeof(Task);\ntypedef embxx::container::StaticQueue<ArrayElemType, ArraySize> Queue;\n```", "```cpp\ntemplate <typename TTask>\nbool addHandler(TTask&& task)\n{\n    typedef TaskBound<typename std::decay<TTask>::type> TaskBoundType;\n    static_assert(\n        std::alignment_of<Task>::value == std::alignment_of<TaskBoundType>::value,\n        \"Alignment of TaskBound must be same as alignment of Task\");\n\n    static const std::size_t requiredQueueSize = TaskBoundType::Size;\n\n    auto placePtr = getAllocPlace(requiredQueueSize);\n    if (placePtr == nullptr) {\n        return false;\n    }\n\n    new (placePtr) TaskBoundType(std::forward<TTask>(task));\n    return true;\n}\n```", "```cpp\nArrayElemType* getAllocPlace(std::size_t requiredQueueSize)\n{\n    auto invalidIter = queue_.invalidIter();\n    while (true)\n    {\n        if ((queue_.capacity() - queue_.size()) < requiredQueueSize) {\n            return nullptr;\n        }\n\n        auto curSize = queue_.size();\n        if (queue_.isLinearised()) {\n            auto dist =\n                static_cast<std::size_t>(\n                    std::distance(queue_.arrayTwo().second, invalidIter));\n            if ((0 < dist) && (dist < requiredQueueSize)) {\n                queue_.resize(curSize + 1);\n                auto placePtr = static_cast<void*>(&queue_.back());\n                new (placePtr) Task();\n                continue;\n            }\n        }\n\n        queue_.resize(curSize + requiredQueueSize);\n        return &queue_[curSize];\n    }\n}\n```", "```cpp\nwhile (true) {\n    ...\n    // Get an access pointer to next handler\n    auto taskPtr = reinterpret_cast<Task*>(&queue_.front());\n    auto sizeToRemove = taskPtr->getSize();\n\n    // Execute the handler while allowing interrutps\n    enableInterrupts();\n    taskPtr->exec();\n\n    // Remove the handler information from the queue\n    taskPtr->~Task();\n    disableInterrupts();\n    queue_.popFront(sizeToRemove);\n\n    ...\n}\n```", "```cpp\nstd::mutex lock_;\nstd::condition_variable_any cond_;\n...\n\nwhile (true) {\n    lock_.lock();\n\n    while (!queue_.isEmpty()) {\n        auto taskPtr = reinterpret_cast<Task*>(&queue_.front());\n        auto sizeToRemove = taskPtr->getSize();\n        lock_.unlock();\n\n        // Executed with interrupts enabled\n        taskPtr->exec();\n        taskPtr->~Task();\n\n        lock_.lock();\n        queue_.popFront(sizeToRemove);\n    }\n\n    // Still locked prior to wait\n    cond_.wait(lock_);\n    lock_.unlock();\n}\n```", "```cpp\ntemplate <typename TTask>\nbool addHandler(TTask&& task)\n{\n   std::lock_guard<decltype(lock_)> guard(lock_);\n   ... // adding handler functionality\n   cond_.notify_all(); // notify the condition variable\n}\n```", "```cpp\nThe class definition looks like this:\ntemplate <std::size_t TSize, typename Tlock, typename TCond>\nclass EventLoop\n{\n    ...\n};\n```", "```cpp\nclass PlatformLock\n{\npublic:\n    // Locks out interrupt \"thread\". The function is called\n    // in non-interrupt context\n    void lock() {...}\n\n    // Restore previous state changed by \"lock()\" function, i.e.\n    // allow interrupts if they were disabled by lock().\n    void unlock() {...}\n\n    // Same as lock(), but will be called when new handler is about to\n    // be added from interrupt handler. In normal case it should be an\n    // empty function, unless the interrupts are prioritised and there\n    // is a need to disable other interrupts from an interrupt handler\n    void lockInterruptCtx() {...}\n\n    // Same as unlock, but will be called in interrupt context. Should\n    // also be empty function when interrupts are not prioritised.\n    void unlockInterruptCtx() {...}\n};\n```", "```cpp\nclass PlatformCond\n{\npublic:\n    // Receives the reference to lockable object that is locked\n    // (has lock() and unlock() member functions) and\n    // responsible to release the lock if needed and wait for\n    // notifications from other thread(s). After the notification\n    // occurs it must re-acquire the lock prior to returning.\n    template <typename TLock>\n    void wait(TLock& lock) {...}\n\n    // This function is used to notify condition that wait should\n    // be terminated.\n    void notify() {...}\n};\n```", "```cpp\nclass InterruptLock\n{\npublic:\n    InterruptLock()\n        : flags_(0) {}\n\n    void lock()\n    {\n        __asm volatile(\"mrs %0, cpsr\" : \"=r\" (flags_)); // store flags\n        __asm volatile(\"cpsid i\"); // disable interrupts\n    }\n\n    void unlock()\n    {\n        if ((flags_ & IntMask) == 0) {\n            // Was previously enabled\n            __asm volatile(\"cpsie i\"); // enable interrupts\n        }\n    }\n\n    void lockInterruptCtx()\n    {\n        // Nothing to do\n    }\n\n    void unlockInterruptCtx()\n    {\n        // Nothing to do\n    }\n\nprivate:\n    volatile std::uint32_t flags_;\n    static const std::uint32_t IntMask = 1U << 7;\n};\n\nclass WaitCond\n{\npublic:\n    template <typename TLock>\n    void wait(TLock& lock)\n    {\n        // no need to unlock (re-enable interrupts)\n        static_cast<void>(lock);\n        __asm volatile(\"wfi\");\n    }\n\n    void notify()\n    {\n        // Nothing to do, pending interrupt will cause wfi\n        // to exit even with interrupts disabled\n    }\n};\n```", "```cpp\ntemplate <std::size_t TSize, typename Tlock, typename TCond>\nclass EventLoop\n{\npublic:\n    ...\n    /// @brief Post new handler for execution.\n    /// @details Acquires regular context lock. The task is added to\n    ///          the execution queue. If the execution queue is empty\n    ///          before the new handler is added, the condition\n    ///          variable is signalled by calling its notify() member\n    ///          function.\n    /// @param[in] task R-value reference to new handler functor.\n    /// @return true in case the handler was successfully posted,\n    ///         false if there is not enough space in the execution\n    ///         queue.\n    template <typename TTask>\n    bool post(TTask&& task);\n\n    /// @brief Post new handler for execution from interrupt context.\n    /// @details Acquires interrupt context lock. The task is added to\n    ///          the execution queue. If the execution queue is empty\n    ///          before the new handler is added, the condition variable\n    ///          is signalled by calling its notify() member function.\n    /// @param[in] task R-value reference to new handler functor.\n    /// @return true in case the handler was successfully posted, false\n    ///         if there is not enough space in the execution queue.\n    template <typename TTask>\n    bool postInterruptCtx(TTask&& task);\n\n    /// @brief Event loop execution function.\n    /// @details The function keeps executing posted handlers until\n    ///          none are left. When execution queue becomes empty the\n    ///          wait(...) member function of the condition variable\n    ///          gets called to execute blocking wait for new handlers.\n    ///          When new handler is added, the condition variable will\n    ///          be signalled and blocking wait is expected to be\n    ///          terminated to continue execution of the event loop.\n    ///          This function never exits unless stop() was called to\n    ///          terminate the execution. After stopping the main\n    ///          loop, use reset() member function to enable the loop\n    ///          to be executed again.\n    void run();\n\n    /// @brief Stop execution of the event loop.\n    /// @details The execution may not be stopped immediately. If there\n    ///          is an event handler being executed, the loop will be\n    ///          stopped after the execution of the handler is finished.\n    void stop();\n\n    /// @brief Reset the state of the event loop.\n    /// @details Clear the queue of registered event handlers and\n    ///          resets the \"stopped\" flag to allow new event loop\n    ///          execution.\n    void reset();\n}:\n```", "```cpp\ntemplate <std::size_t TSize, typename Tlock, typename TCond>\nclass EventLoop\n{\npublic:\n    ...\n    /// @brief Perform busy wait.\n    /// @details Executes busy wait while allowing other event handlers\n    ///          posted by interrupt handlers being processed.\n    /// @tparam TPred Predicate class type, must define\n    ///         @code bool operator()(); @endcode\n    ///         that return true in case busy wait must be terminated.\n    /// @tparam TFunc Functor class that will be executed when wait is\n    ///         complete. It must define\n    ///         @code void operator()(); @endcode\n    /// @param pred Any type of reference to predicate object\n    /// @param func Any type of reference to \"wait complete\" function.\n    /// @pre The event loop must have enough space to repost the call\n    ///      to busyWait(). Note that there is no wait to notify the\n    ///      caller if post operation fails. In debug compilation mode\n    ///      there will be an assertion failure in case call to post()\n    ///      returned false, in release compilation mode the failure\n    ///      will be silent.\n    template <typename TPred, typename TFunc>\n    void busyWait(TPred&& pred, TFunc&& func)\n    {\n        if (pred()) {\n            bool result = post(std::forward<TFunc>(func));\n            GASSERT(result);\n            static_cast<void>(result);\n            return;\n        }\n\n        bool result = post(\n            [this, pred, func]()\n            {\n                busyWait(std::move(pred), std::move(func));\n            });\n        GASSERT(result);\n        static_cast<void>(result);\n    }\n};\n```", "```cpp\nclass MyDevice\n{\npublic:\n    void startOp();\n    void startOpInterruptCtx();\n}\n```", "```cpp\nnamespace embxx\n{\n\nnamespace device\n{\n\nnamespace context\n{\n\n// Event loop context tag class.\nstruct EventLoop {};\n\n// Interrupt context tag class.\nstruct Interrupt {};\n\n} // namespace context\n\n} // namespace device\n\n} // namespace embxx\n```", "```cpp\nclass MyDevice\n{\npublic:\n    typedef embxx::device::context::EventLoop EventLoopCtx;\n    typedef embxx::device::context::Interrupt InterruptCtx;\n\n    void startOp(EventLoopCtx context)\n    {\n        static_cast<void>(context); // unused parameter\n        ... // Perform operation when called in event loop context\n    }\n\n    void startOp(InterruptCtx context)\n    {\n        static_cast<void>(context); // unused parameter\n        ... // Perform operation when called in interrupt context\n    }\n};\n```", "```cpp\nclass MyDriver\n{\npublic:\n    typedef embxx::device::context::EventLoop EventLoopCtx;\n    typedef embxx::device::context::Interrupt InterruptCtx;\n\n    // Invoked by some Component object in Event Loop Context\n    void asyncOp(...)\n    {\n        ...\n        device_.startOp(EventLoopCtx());\n        ...\n    }\n\nprivate:\n\n   // Some registered event callback handler,\n   // invoked in interrupt context\n   void interruptCallbackHandler()\n   {\n       ...\n       device_.startOp(InterruptCtx());\n   }\n};\n```", "```cpp\nclass MyDevice\n{\npublic:\n    typedef embxx::device::context::EventLoop EventLoopCtx;\n\n    void cancelOp(EventLoopCtx context)\n    {\n        static_cast<void>(context); // unused parameter\n        ... // Cancel recent operation\n    }\n};\n```", "```cpp\nclass SomeDevice\n{\npublic:\n\n    template <typename TContext>\n    void startOp(TContext context)\n    {\n        static_cast<void>(context); // unused parameter\n        startOpInternal();\n    }\n\nprivate:\n    void startOpInternal()\n    {\n        ...\n    }\n};\n```", "```cpp\nnamespace embxx\n{\n\nnamespace error\n{\n\nenum class ErrorCode\n{\n    Success, ///< Successful completion of operation.\n    Aborted, ///< The operation was cancelled/aborted.\n    BufferOverflow, /// The buffer is full with read termination condition being false\n    HwProtocolError, ///< Hardware peripheral reported protocol error.\n    Timeout, ///< The operation takes too much time.\n    NumOfStatuses ///< Number of available statuses. Must be last\n};\n\n}  // namespace error\n\n}  // namespace embxx\n```", "```cpp\nnamespace embxx\n{\n\nnamespace error\n{\n\ntemplate <typename TErrorCode = ErrorCode>\nclass ErrorStatusT\n{\npublic:\n    /// @brief Error code enum type\n    typedef TErrorCode ErrorCodeType;\n\n    /// @brief Default constructor.\n    /// @details The code value is 0, which is \"success\".\n    ErrorStatusT();\n\n    /// @brief Constructor\n    /// @details This constructor may be used for implicit\n    ///          construction of error status object out\n    ///          of error code value.\n    /// @param code Numeric error code value.\n    ErrorStatusT(ErrorCodeType code);\n\n    /// @brief Copy constructor is default\n    ErrorStatusT(const ErrorStatusT&) = default;\n\n    /// @brief Destructor is default\n    ~ErrorStatusT() = default;\n\n    /// @brief Copy assignment is default\n    ErrorStatusT& operator=(const ErrorStatusT&) = default;\n\n    /// @brief Retrieve error code value.\n    const ErrorCodeType code() const;\n\n    /// @brief boolean conversion operator.\n    /// @details Returns true if error code is not equal 0,\n    ///          i.e. any error will return true, success\n    ///          value will return false.\n    operator bool() const;\n\n    /// @brief Same as !(static_cast<bool>(*this)).\n    bool operator!() const;\n\nprivate:\n    ErrorCodeType code_;\n};\n\ntypedef ErrorStatusT<ErrorCode> ErrorStatus;\n\n}  // namespace error\n\n}  // namespace embxx\n```", "```cpp\nembxx::error::ErrorStatus es;\nGASSERT(!es); // No error\n...\nif (/* some condition */) {\n    es = embxx::error::ErrorCode::BufferOverflow;\n}\n...\nif (es) {\n    ... // Error occurred, access the arror code by calling es.code()\n}\n```", "```cpp\nvoid callback(const embxx::error::ErrorStatus& es, ... /* some other parameters */)\n{\n    if (es == embxx::error::ErrorCode::Aborted) {\n        return; // Nothing to do\n    }\n\n    if (es) {\n        ... // Error occurred\n        return;\n    }\n    ... // Success\n}\n```", "```cpp\ntemplate <typename TDevice, typename TEventLoop>\nclass MyDriver\n{\npublic:\n    // During the construction store references to Device\n    // and Event Loop objects.\n    MyDriver(TDevice& device, TEventLoop& el)\n      : device_(device),\n        el_(el)\n    {\n    }\n\n    ...\n\nprivate:\n\n    TDevice& device_;\n    TEventLoop& el_;\n};\n```", "```cpp\ntemplate <typename TDevice, typename TEventLoop>\nclass MyDriver\n{\npublic:\n    TEventLoop& getEventLoop()\n    {\n        return el_;\n    }\n\nprivate:\n    TEventLoop& el_;\n};\n\ntemplate <typename TDriver>\nclass MyComponent\n{\npublic:\n    MyComponent(TDriver& driver)\n      : driver_(driver)\n    {\n    }\n\n    void someFunc()\n    {\n        auto& el = driver_.getEventLoop();\n        el.post(...);\n    }\n\nprivate:\n    TDriver& driver_;\n};\n```", "```cpp\ntemplate <typename TDevice, typename TEventLoop>\nclass MyDriver\n{\npublic:\n    template <typename TFunc>\n    void asyncOp(TFunc&& callbackObj)\n    {\n        callback_ = std::forward<TFunc>(callbackObj);\n        ... // Start the operation\n    }\n\nprivate:\n    typedef std::function<void embxx::error::ErrorStatus&> CallbackType;\n\n    void opCompleteInterruptCallback(void embxx::error::ErrorStatus& es)\n    {\n        ... // Complete the operation\n        el_.postInterruptCtx(std::bind(std::move(callback_), es));\n    }\n\n    EventLoop& el_;\n    CallbackType callback_;\n};\n```", "```cpp\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TCallbackType>\nclass MyDriver\n{\nprivate:\n    ...\n    TCallbackType callback_;\n};\n```", "```cpp\nclass Function\n{\npublic:\n    enum class FuncSel {\n        Input,  // b000\n        Output, // b001\n        Alt5,   // b010\n        Alt4,   // b011\n        Alt0,   // b100\n        Alt1,   // b101\n        Alt2,   // b110\n        Alt3    // b111\n    };\n\n    typedef unsigned PinIdxType;\n\n    static const std::size_t NumOfLines = 54;\n\n    void configure(PinIdxType idx, FuncSel sel);\n};\n```", "```cpp\ntemplate <typename THandler = embxx::util::StaticFunction<void ()> >\nclass InterruptMgr\n{\npublic:\n    typedef THandler HandlerFunc;\n    enum IrqId {\n        IrqId_Timer,\n        IrqId_AuxInt,\n        IrqId_Gpio1,\n        IrqId_Gpio2,\n        IrqId_Gpio3,\n        IrqId_Gpio4,\n        IrqId_I2C,\n        IrqId_SPI,\n        IrqId_NumOfIds // Must be last\n    };\n\n    InterruptMgr();\n\n    template <typename TFunc>\n    void registerHandler(IrqId id, TFunc&& handler);\n\n    void enableInterrupt(IrqId id);\n\n    void disableInterrupt(IrqId id);\n\n    void handleInterrupt();\n\nprivate:\n    typedef std::uint32_t EntryType;\n\n    struct IrqInfo {\n        ... // Contains interrupt related information\n            // per single IrqId\n    };\n\n    typedef std::array<IrqInfo, IrqId_NumOfIds> IrqsArray;\n\n    IrqsArray irqs_;\n};\n```", "```cpp\nextern \"C\"\nvoid interruptHandler()\n{\n    System::instance().interruptMgr().handleInterrupt();\n}\n```", "```cpp\nnamespace device\n{\n\nnamespace interrupt\n{\n\ninline\nvoid enable()\n{\n    __asm volatile(\"cpsie i\");\n}\n\ninline\nvoid disable()\n{\n    __asm volatile(\"cpsid i\");\n}\n\n}  // namespace interrupt\n\n}  // namespace device\n```", "```cpp\nclass MyTimerDriver\n{\npublic:\n    typedef ... Handle;\n\n    Handle asyncWait(...);\n\n    void cancelWait(Handle handle);\n};\n```", "```cpp\nclass MyTimerDriver\n{\npublic:\n\n    typedef ... Handle;\n\n    class Timer\n    {\n    public:\n        Timer(MyTimerDriver& mgr, Handle handle)\n          : mgr_(mgr),\n            handle_(handle)\n        {\n        }\n\n        ~Timer()\n        {\n            ... // Invalidate the allocated handle\n        }\n\n        void asyncWait(...)\n        {\n            mgr_.asyncWait(handle_, ...)\n        }\n\n        void cancelWait()\n        {\n            mgr_.cancelWait(handle_);\n        }\n\n    private:\n\tMyTimerDriver& mgr_;\n        Handle handle_;\n    };\n\n    Timer allocTimer()\n    {\n        auto someHandle = ...;\n        return Timer(*this, someHandle)\n    }\n\nprivate:\n\n    friend class TimerMgr::Timer;\n\n    void asyncWait(Handle handle, ...);\n\n    void cancelWait(Handle handle);\n};\n```", "```cpp\nMyTimerDriver driver(...);\nauto timer = driver.allocTimer();\ntimer.asyncWait(...);\n...\ntimer.cancelWait();\n...\n```", "```cpp\nclass MyTimerDevice\n{\npublic:\n    typedef std::chrono::duration<unsigned, std::milli>\n                                                WaitTimeUnitDuration;\n\n    typedef embxx::device::context::EventLoop EventLoopCtx;\n\n    void startWait(WaitTimeUnitDuration::rep count, EventLoopCtx) {...}\n    ...\n};\n```", "```cpp\ntemplate <typename TDevice, ...>\nclass MyTimerDriver\n{\npublic:\n    typedef typename TDevice::WaitTimeUnitDuration WaitTimeUnitDuration\n    class Timer\n    {\n    public:\n        template <typename TRep, typename TPeriod, typename TFunc>\n        void asyncWait(\n            const std::chrono::duration<TRep, TPeriod>& waitTime,\n            TFunc&& func)\n        {\n            auto castedWaitDuration =\n                std::chrono::duration_cast<WaitTimeUnitDuration>(waitTime);\n            auto waitUnits = castedWaitDuration.count();\n            ... // Call the asyncWait() of the driver with waitUnits as\n                // first parameter.\n        }\n\n    };\n};\n```", "```cpp\ntimer.asyncWait(std::chrono::seconds(5), ...);\n```", "```cpp\ntimer.asyncWait(std::chrono::microseconds(5), ...);\n```", "```cpp\ntemplate <typename TDevice,\n          typename TEventLoop,\n          std::size_t TMaxTimers,\n          typename TTimeoutHandler = embxx::util::StaticFunction<void (const embxx::error::ErrorStatus&)> >\nclass TimerMgr\n{\npublic:\n    TimerMgr(TDevice& device, TEventLoop& el);\n      : device_(device),\n        el_(el)\n    {\n        ...\n    }\n\n    ...\n\nprivate:\n    struct TimerInfo {\n        TTimeoutHandler handler_; //\n        ...;                      // Some other internal data\n    }\n\n    // Internal data structures to track all the scheduled\n    // wait requests.\n    std::array<TimerInfo, TMaxTimers> infos_;\n\n    TDevice& device_;\n    TEventLoop& el_;\n    ...\n};\n```", "```cpp\ntemplate <...>\nclass TimerMgr\n{\npublic:\n    class Timer\n    {\n    public:\n        // Destructor, removes Timer record from internal\n        // data structures of TimerMgr\n        ~Timer() {...}\n\n        // Activates asyncrhonous wait\n        void asyncWait(...) {...}\n\n        // Cancels scheduled asynchronous wait\n        void cancel() {...}\n    };\n\n    // Allocate timer object\n    Timer allocTimer() {...}\n\nprivate:\n    // Allows usage of non-exposed private functions of\n    // TimerMgr\n    friend class TimerMgr::Timer;\n    ...\n};\n```", "```cpp\nnamespace\n{\n\nconst auto LedChangeStateTimeout = std::chrono::milliseconds(500);\n\ntemplate <typename TTimer>\nvoid ledOff(\n    TTimer& timer,\n    System::Led& led);\n\ntemplate <typename TTimer>\nvoid ledOn(\n    TTimer& timer,\n    System::Led& led)\n{\n    led.on();\n\n    timer.asyncWait(\n        LedChangeStateTimeout,\n        [&timer, &led](const embxx::error::ErrorStatus& status)\n        {\n            static_cast<void>(status);\n            ledOff(timer, led);\n        });\n}\n\ntemplate <typename TTimer>\nvoid ledOff(\n    TTimer& timer,\n    System::Led& led)\n{\n    led.off();\n\n    timer.asyncWait(\n        std::chrono::milliseconds(LedChangeStateTimeout),\n        [&timer, &led](const embxx::error::ErrorStatus& status)\n        {\n            static_cast<void>(status);\n            ledOn(timer, led);\n        });\n}\n\n}  // namespace\n\nint main() {\n    // Get reference to TimerMgr object\n    auto& system = System::instance();\n    auto& timerMgr = system.timerMgr();\n\n    // Allocate timer\n    auto timer = timerMgr.allocTimer();\n\n    // Start flashing with initial state to be OFF\n    device::interrupt::enable();\n    ledOff(timer, led);\n\n    // Run the event loop\n    auto& el = system.eventLoop();\n    el.run();\n\n    GASSERT(0); // Mustn't exit\n    return 0;\n}\n```", "```cpp\ntemplate <typename TDevice, typename TEventLoop, ...>\nclass TimerMgr\n{\npublic:\n    TimerMgr(TDevice& device, TEventLoop& el);\n    ...\n};\n```", "```cpp\n    typedef std::chrono::duration<...> WaitTimeUnitDuration;\n    ```", "```cpp\n    template <typename TFunc>\n    void setWaitCompleteCallback(TFunc&& func);\n    ```", "```cpp\n    void startWait(\n        WaitTimeUnitDuration::rep waitTime, // num of wait units\n        embxx::device::context::EventLoop context);\n    void startWait(\n        WaitTimeUnitDuration::rep waitTime, // num of wait units\n        embxx::device::context::Interrupt context);\n    ```", "```cpp\n    bool cancelWait(embxx::device::context::EventLoop context);\n    ```", "```cpp\n    bool suspendWait(embxx::device::context::EventLoop context);\n    ```", "```cpp\n    void resumeWait(embxx::device::context::EventLoop context);\n    ```", "```cpp\n    WaitTimeUnitDuration::rep getElapsed(embxx::device::context::EventLoop context) const;\n    ```", "```cpp\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-sbrkr.o): In function `_sbrk_r':\nsbrkr.c:(.text._sbrk_r+0x18): undefined reference to `_sbrk'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-writer.o): In function `_write_r':\nwriter.c:(.text._write_r+0x20): undefined reference to `_write'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-closer.o): In function `_close_r':\ncloser.c:(.text._close_r+0x18): undefined reference to `_close'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-fstatr.o): In function `_fstat_r':\nfstatr.c:(.text._fstat_r+0x1c): undefined reference to `_fstat'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-isattyr.o): In function `_isatty_r':\nisattyr.c:(.text._isatty_r+0x18): undefined reference to `_isatty'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-lseekr.o): In function `_lseek_r':\nlseekr.c:(.text._lseek_r+0x20): undefined reference to `_lseek'\n/usr/bin/../lib/gcc/arm-none-eabi/4.8.3/../../../../arm-none-eabi/lib/libc.a(lib_a-readr.o): In function `_read_r':\nreadr.c:(.text._read_r+0x20): undefined reference to `_read'\ncollect2: error: ld returned 1 exit status\n```", "```cpp\nextern \"C\" int _write(int file, char *ptr, int len)\n{\n    int count = len;\n    if (file == 1) { // stdout\n        while (count > 0) {\n            while (... /* poll the status bit */) {} // just wait\n            TX_REG = *ptr;\n            ++ptr;\n            --count;\n        }\n    }\n    return len;\n}\n```", "```cpp\nstd::int32_t i = ...; // some value\nprintf(\"Value = %d\\n\");\n```", "```cpp\nstd::int32_t i = ...; // some value\nstd::cout << \"Value = \" << i << std::endl;\n```", "```cpp\nclass CharacterDriver\n{\npublic:\n    typedef ... CharType;\n\n    template <typename TCallbackFunc>\n    void asyncWrite(\n        const CharType* buf,\n        std::size_t bufSize,\n        TCallbackFunc&& func);\n};\n```", "```cpp\ntypedef embxx::device::context::Interrupt InterruptContext;\n\nvoid canWriteCallback()\n{\n    // Executed in interrupt context, must be quick\n    while(device_.canWrite(InterruptContext())) {\n        if ((writeBufStart_ + writeBufSize_) <= currentWriteBufPtr_) {\n            break;\n        }\n\n        device_.write(*currentWriteBufPtr_, InterruptContext());\n        ++currentWriteBufPtr_;\n    }\n}\n```", "```cpp\nclass CharacterDriver\n{\npublic:\n    typedef ... CharType;\n\n    template <typename TCallbackFunc>\n    void asyncRead(\n        CharType* buf,\n        std::size_t bufSize,\n        TCallbackFunc&& func);\n};\n```", "```cpp\n void canReadCallback()\n    {\n        while(device_.canRead(InterruptContext())) {\n            if ((readBufStart_ + readBufSize_) <= currentReadBufPtr_) {\n                break;\n            }\n\n            auto ch = device_.read(InterruptContext());\n            *currentReadBufPtr_ = ch;\n            ++currentReadBufPtr_;\n        }\n    }\n```", "```cpp\nclass MyDevice\n{\npublic:\n    bool cancelRead(embxx::device::context::EventLoop) {...}\n    bool cancelRead(embxx::device::context::Interrupt) {...}\n};\n```", "```cpp\nclass MyDriver\n{\npublic:\n    template <typename TPred, typename TFunc>\n    void asyncReadUntil(\n        CharType* buf,\n        std::size_t size,\n        TPred&& pred,\n        TFunc&& func)\n    {\n        ...\n    }\n};\n```", "```cpp\ntypedef embxx::error::ErrorStatus EmbxxErrorStatus;\n\ndriver_.asyncReadUntil(\n    buf,\n    bufSize,\n    [](CharType ch) -> bool\n        {\n            return (ch == '\\r') || (ch == '\\n');\n        },\n    [](const EmbxxErrorStatus& es, std::size_t bytesTransferred)\n        {\n            ...\n        });\n```", "```cpp\nclass MyDevice\n{\npublic:\n    typedef std::uint8_t CharType;\n};\n```", "```cpp\ntemplate<typename TDevice, ...>\nclass MyDriver\n{\npublic:\n    typedef typename TDevice::CharType CharType;\n\n    void asyncRead(CharType* buf, std::size_t bufSize, ...) {}\n};\n```", "```cpp\nclass MyDevice\n{\npublic:\n    template <typename TFunc>\n    void setCanReadHandler(TFunc&& func)\n    {\n        canReadHandler_ = std::forward<TFunc>(func);\n    }\n\n    template <typename TFunc>\n    void setCanWriteHandler(TFunc&& func)\n    {\n        canWriteHandler_ = std::forward<TFunc>(func);\n    }\n\n    template <typename TFunc>\n    void setReadCompleteHandler(TFunc&& func)\n    {\n        readCompleteHandler_ = std::forward<TFunc>(func);\n    }\n\n    template <typename TFunc>\n    void setWriteCompleteHandler(TFunc&& func)\n    {\n        writeCompleteHandler_ = std::forward<TFunc>(func);\n    }\n\nprivate:\n    typedef ... OpAvailableHandler;\n    typedef ... OpCompleteHandler;\n\n    OpAvailableHandler canReadHandler_;\n    OpCompleteHandler readCompleteHandler_;\n\n    OpAvailableHandler canWriteHandler_;\n    OpCompleteHandler writeCompleteHandler_;\n\n};\n```", "```cpp\ntemplate <typename TCanReadHandler,\n          typename TCanWriteHandler,\n          typename TReadCompleteHandler,\n          typename TWriteCompleteHandler>\nclass MyDevice\n{\npublic:\n    ... // setters are as above\n\nprivate:\n\n    TCanReadHandler canReadHandler_;\n    TReadCompleteHandler readCompleteHandler_;\n\n    TCanWriteHandler canWriteHandler_;\n    TWriteCompleteHandler writeCompleteHandler_;\n};\n```", "```cpp\nclass MyDevice\n{\npublic:\n\n    typedef embxx::device::context::EventLoop EventLoopContext;\n    typedef embxx::device::context::Interrupt InterruptContext;\n\n    // Start read operation - enables interrupts\n    void startRead(std::size_t length, EventLoopContext context);\n\n    // Cancel read in event loop context\n    bool cancelRead(EventLoopContext context);\n\n    // Cancel read in interrupt context - used only if\n    // asyncReadUntil() function was used in Device\n    bool cancelRead(InterruptContext context);\n\n    // Start write operation - enables interrupts\n    void startWrite(std::size_t length, EventLoopContext context);\n\n    // Cancell write operation\n    bool cancelWrite(EventLoopContext context);\n\n    // Check whether there is a character available to be read.\n    bool canRead(InterruptContext context);\n\n    // Check whether there is space for one character to be written.\n    bool canWrite(InterruptContext context);\n\n    // Read the available character from Rx FIFO of the peripheral\n    CharType read(InterruptContext context);\n\n    // Write one more character to Tx FIFO of the peripheral\n    void write(CharType value, InterruptContext context);\n};\n```", "```cpp\nclass MyDevice\n{\npublic:\n    void configBaud(unsigned value) { ... }\n    ...\n};\n```", "```cpp\ntemplate <typename TDevice, typename TEventLoop>\nclass MyDriver\n{\npublic:\n    // Reuse definition of character type from the Device\n    typedef TDevice::CharType CharType;\n\n    // During the construction store references to Device\n    // and Event Loop objects.\n    MyDriver(TDevice& device, TEventLoop& el)\n      : device_(device),\n        el_(el)\n    {\n        // Register appropriate callbacks with device\n        device_.setCanReadHandler(\n            std::bind(\n                &MyDriver::canReadInterruptHandler, this));\n        device_.setReadCompleteHandler(\n            std::bind(\n                &MyDriver::readCompleteInterruptHandler,\n                this,\n                std::placeholders::_1));\n\n        device_.setCanWriteHandler(\n            std::bind(\n                &MyDriver::canWriteInterruptHandler, this));\n        device_.setWriteCompleteHandler(\n            std::bind(\n                &MyDriver::writeCompleteInterruptHandler,\n                this,\n                std::placeholders::_1));\n\n    }\n\n    ...\n\nprivate:\n\n    void canReadInterruptHandler() {...}\n    void readCompleteInterruptHandler(\n        const embxx::error::ErrorStatus& es) {...}\n\n    void canWriteInterruptHandler() {...}\n    void writeCompleteInterruptHandler(\n        const embxx::error::ErrorStatus& es) {...}\n\n    TDevice& device_;\n    TEventLoop& el_;\n};\n```", "```cpp\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TReadCompleteCallback,\n          typename TWriteCompleteCallback>\nclass MyDriver\n{\npublic:\n    ...\n\n    typedef embxx::device::context::EventLoop EventLoopContext;\n\n    template <typename TFunc>\n    void asyncRead(\n        CharType* buf,\n        std::size_t bufSize,\n        TFunc&& func)\n    {\n        readBufStart_ = buf;\n        currentReadBufPtr = buf;\n        readBufSize_ = bufSize;\n        readCompleteCallback_ = std::forward<TFunc>(func);\n        driver_.startRead(bufSize, EventLoopContext());\n    }\n\n    template <typename TFunc>\n    void asyncWrite(\n        const CharType* buf,\n        std::size_t bufSize,\n        TFunc&& func)\n    {\n        writeBufStart_ = buf;\n        currentWriteBufPtr = buf;\n        writeBufSize_ = bufSize;\n        writeCompleteCallback_ = std::forward<TFunc>(func);\n        driver_.startWrite(bufSize, EventLoopContext());\n    }\n\nprivate:\n    ...\n\n    // Read info\n    CharType* readBufStart_;\n    CharType* currentReadBufPtr_;\n    std::size_t readBufSize_;\n    TReadCompleteCallback readCompleteCallback_;\n\n    // Write info\n    const CharType* writeBufStart_;\n    const CharType* currentWriteBufPtr_;\n    std::size_t writeBufSize_;\n    TWriteCompleteCallback writeCompleteCallback_;\n};\n```", "```cpp\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TReadCompleteCallback,\n          typename TWriteCompleteCallback,\n          typename TReadUntilPred>\nclass MyDriver\n{\npublic:\n    ...\n\n    typedef embxx::device::context::EventLoop EventLoopContext;\n\n    template <typename TPred, typename TFunc>\n    void asyncReadUntil(\n        CharType* buf,\n        std::size_t bufSize,\n        TPred&& pred,\n        TFunc&& func)\n    {\n        readBufStart_ = buf;\n        currentReadBufPtr = buf;\n        readBufSize_ = bufSize;\n        readCompleteCallback_ = std::forward<TFunc>(func);\n        readUntilPred_ = std::forward<TPred>(pred)\n        driver_.startRead(bufSize, EventLoopContext());\n    }\n\nprivate:\n    ...\n\n    // Read info\n    CharType* readBufStart_;\n    CharType* currentReadBufPtr_;\n    std::size_t readBufSize_;\n    TReadCompleteCallback readCompleteCallback_;\n    TReadUntilPred readUntilPred_;\n\n    ...\n};\n```", "```cpp\nstruct MyOutputTraits\n{\n    // The \"read\" handler storage type.\n    typedef std::nullptr_t ReadHandler;\n\n    // The \"write\" handler storage type.\n    // The valid handler must have the following signature:\n    //  \"void handler(const embxx::error::ErrorStatus&, std::size_t);\"\n    typedef embxx::util::StaticFunction<\n        void(const embxx::error::ErrorStatus&, std::size_t)> WriteHandler;\n\n    // The \"read until\" predicate storage type\n    typedef std::nullptr_t ReadUntilPred;\n\n    // Read queue size\n    static const std::size_t ReadQueueSize = 0;\n\n    // Write queue size\n    static const std::size_t WriteQueueSize = 1;\n};\n```", "```cpp\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TTraits = MyOutputTraits>\nclass MyDriver :\n    public ReadSupportBase<\n                TDevice,\n                TEventLoop,\n                typename TTraits::ReadHandler,\n                typename TTraits::ReadUntilPred,\n                TTraits::ReadQueueSize>,\n    public WriteSupportBase<\n                TDevice,\n                TEventLoop,\n                typename TTraits::WriteHandler,\n                TTraits::WriteQueueSize>\n{\n    typedef ReadSupportBase<...> ReadBase;\n    typedef WriteSupportBase<...> WriteBase;\npublic:\n    template <typename TPred, typename TFunc>\n    void asyncRead(\n        CharType* buf,\n        std::size_t bufSize,\n        TFunc&& func)\n    {\n        ReadBase::asyncRead(buf, bufSize, std::forward<TFunc>(func);\n    }\n\n    template <typename TPred, typename TFunc>\n    void asyncWrite(\n        const CharType* buf,\n        std::size_t bufSize,\n        TFunc&& func)\n    {\n        WriteBase::asyncWrite(buf, bufSize, std::forward<TFunc>(func);\n    }\n};\n```", "```cpp\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TReadHandler,\n          typename TReadUntilPred,\n          std::size_t ReadQueueSize>;\nclass ReadSupportBase;\n\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TReadHandler,\n          typename TReadUntilPred>;\nclass ReadSupportBase<TDevice, TEventLoop, TReadHandler, TReadUntilPred, 1>\n{\npublic:\n    ReadSupportBase(TDevice& device, TEventLoop& el) {...}\n    ... // Implements the \"read\" related API\nprivate:\n    ... // Read related data members\n};\n\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TReadHandler,\n          typename TReadUntilPred>;\nclass ReadSupportBase<TDevice, TEventLoop, TReadHandler, TReadUntilPred, 0>\n{\npublic:\n    ReadSupportBase(TDevice& device, TEventLoop& el) {}\n    // No need for any \"read\" related API and data members\n};\n\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TWriteHandler,\n          std::size_t WriteQueueSize>;\nclass WriteSupportBase;\n\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TReadHandler>;\nclass WriteSupportBase<TDevice, TEventLoop, TWriteHandler, 1>\n{\npublic:\n    WriteSupportBase(TDevice& device, TEventLoop& el) {...}\n    ... // Implements the \"write\" related API\nprivate:\n    ... // Write related data members\n};\n\ntemplate <typename TDevice,\n          typename TEventLoop,\n          typename TWriteHandler>;\nclass WriteSupportBase<TDevice, TEventLoop, TWriteHandler, 0>\n{\npublic:\n    WriteSupportBase(TDevice& device, TEventLoop& el) {}\n    // No need for any \"write\" related API and data members\n};\n```", "```cpp\n    class MyDevice\n    {\n    public:\n        void startRead(std::size_t length, InterruptContext context);\n        void startWrite(std::size_t length, InterruptContext context);\n    };\n    ```", "```cpp\n    class MyDevice\n    {\n    public:\n        bool suspendRead(EventLoopContext context);\n        void resumeRead(EventLoopContext context)\n        bool suspendWrite(EventLoopContext context);\n        void resumeWrite(EventLoopContext context);\n    };\n    ```", "```cpp\nclass System\n{\npublic:\n    static const std::size_t EventLoopSpaceSize = 1024;\n    typedef embxx::util::EventLoop<\n        EventLoopSpaceSize,\n        device::InterruptLock,\n        device::WaitCond> EventLoop;\n\n    typedef device::InterruptMgr<> InterruptMgr;\n\n    typedef device::Uart1<InterruptMgr> Uart;\n\n    typedef embxx::driver::Character<Uart, EventLoop> UartSocket;\n\n    ...\n\nprivate:\n\n    ...\n    EventLoop el_;\n    Uart uart_;\n    UartSocket uartSocket_;\n};\n```", "```cpp\nstruct DefaultCharacterTraits\n{\n    typedef embxx::util::StaticFunction<\n        void(const embxx::error::ErrorStatus&, std::size_t)> ReadHandler;\n    typedef embxx::util::StaticFunction<\n        void(const embxx::error::ErrorStatus&, std::size_t)> WriteHandler;\n    typedef std::nullptr_t ReadUntilPred;\n    static const std::size_t ReadQueueSize = 1;\n    static const std::size_t WriteQueueSize = 1;\n};\n```", "```cpp\n// Forward declaration\nvoid writeChar(System::UartSocket& uartSocket, System::Uart::CharType& ch);\n\nvoid readChar(System::UartSocket& uartSocket, System::Uart::CharType& ch)\n{\n    uartSocket.asyncRead(&ch, 1,\n        [&uartSocket, &ch](const embxx::error::ErrorStatus& es, std::size_t bytesRead)\n        {\n            GASSERT(!es);\n            GASSERT(bytesRead == 1);\n            static_cast<void>(es);\n            static_cast<void>(bytesRead);\n            writeChar(uartSocket, ch);\n        });\n}\n\nvoid writeChar(System::UartSocket& uartSocket, System::Uart::CharType& ch)\n{\n    uartSocket.asyncWrite(&ch, 1,\n        [&uartSocket, &ch](const embxx::error::ErrorStatus& es, std::size_t bytesWritten)\n        {\n            GASSERT(!es);\n            GASSERT(bytesWritten == 1);\n            static_cast<void>(es);\n            static_cast<void>(bytesWritten);\n            readChar(uartSocket, ch);\n        });\n}\n\nint main() {\n    auto& system = System::instance();\n    auto& uart = system.uart();\n\n    // Configure serial interface\n    uart.configBaud(115200);\n    uart.setReadEnabled(true);\n    uart.setWriteEnabled(true);\n\n    // Start with asynchronous read\n    auto& uartSocket = system.uartSocket();\n    System::Uart::CharType ch = 0;\n    readChar(uartSocket, ch);\n\n    // Run the event loop\n    device::interrupt::enable();\n    auto& el = system.eventLoop();\n    el.run();\n\n    GASSERT(0); // Mustn't exit\n    return 0;\n```", "```cpp\ntemplate <typename TDriver>\nclass OutStreamBuf\n{\npublic:\n    OutStreamBuf(TDriver& driver)\n      : driver_(driver)\n    {\n    }\n\nprivate:\n   TDriver& driver_;\n   ...\n};\n```", "```cpp\ntemplate <typename TDriver,\n          std::size_t TBufSize>\nclass OutStreamBuf\n{\npublic:\n   typedef typename TDriver::CharType CharType;\n   typedef embxx::container::StaticQueue<CharType, BufSize> Buffer;\n\nprivate:\n   ...\n   Buffer buf_;\n};\n```", "```cpp\ntemplate <...>\nclass OutStreamBuf\n{\npublic:\n   // Add new character at the end of the buffer\n   std::size_t pushBack(CharType ch);\n\n   // Get number of written, not-flushed characters\n   std::size_t size();\n\n   // Flush number of characters\n   void flush(std::size_t count = size());\n   ...\n};\n```", "```cpp\nOutStreamBuf<...> outStreamBuf(...);\nstd::array<std::uint8_t, 128> data = {{.../* some data*/}};\n\nstd::copy(data.begin(), data.end(), std::back_inserter(outStreamBuf));\noutStreamBuf.flush();\n```", "```cpp\ntemplate <...>\nclass OutStreamBuf\n{\npublic:\n   // Wrap pushBack()\n   void push_back(CharType ch)\n   {\n       pushBack(ch);\n   }\n   ...\n};\n```", "```cpp\ntemplate <...>\nclass OutStreamBuf\n{\npublic:\n    typedef embxx::container::StaticQueue<CharType, BufSize> Buffer;\n    typedef typename Buffer::Iterator Iterator;\n    typedef typename Buffer::ConstIterator ConstIterator;\n    typedef typename Buffer::ValueType ValueType;\n    typedef typename Buffer::Reference Reference;\n    typedef typename Buffer::ConstReference ConstReference;\n\n    bool empty() const;\n    void clear();\n    void resize(std::size_t newSize);\n\n    Iterator begin();\n    Iterator end();\n\n    ConstIterator begin() const;\n    ConstIterator end() const;\n\n    ConstIterator cbegin() const;\n    ConstIterator cend() const;\n\n    Reference operator[](std::size_t idx);\n    ConstReference operator[](std::size_t idx) const;\n   ...\n};\n```", "```cpp\ntemplate <typename TDriver,\n          std::size_t TBufSize,\n          typename TWaitHandler =\n              embxx::util::StaticFunction<void (const embxx::error::ErrorStatus&)> >\nclass OutStreamBuf\n{\npublic:\n    std::size_t availableCapacity() const;\n\n    template <typename TFunc>\n    void asyncWaitAvailableCapacity(\n        std::size_t capacity,\n        TFunc&& func)\n    {\n        if (capacity <= availableCapacity()) {\n            ... // invoke callback via post() member function of Event Loop\n        }\n        waitAvailableCapacity_ = capacity;\n        waitHandler_ = std::forward<TFunc>(func);\n\n        // The Driver is writing some portion of flushed characters,\n        // evaluate the capacity again when Driver reports completion.\n    }\n\nprivate:\n    ...\n    std::size_t waitAvailableCapacity_;\n    WaitHandler waitHandler_;\n};\n```", "```cpp\ntemplate <typename TStreamBuf>\nclass OutStream\n{\npublic:\n    typedef typename TStreamBuf::CharType CharType;\n\n    explicit OutStream(TStreamBuf& buf)\n    : buf_(buf)\n    {\n    }\n\n    OutStream(OutStream&) = delete;\n    ~OutStream() = default;\n\n    void flush()\n    {\n        buf_.flush();\n    }\n\n    OutStream& operator<<(const CharType* str)\n    {\n        while (*str != '\\0') {\n            buf_.pushBack(*str);\n            ++str;\n        }\n        return *this;\n    }\n\n    OutStream& operator<<(char ch)\n    {\n        buf_.pushBack(ch);\n        return *this;\n    }\n\n    OutStream& operator<<(std::uint8_t value)\n    {\n        // Cast std::uint8_t to unsigned and print.\n        return (*this << static_cast<unsigned>(value));\n    }\n\n    OutStream& operator<<(std::int16_t value)\n    {\n        ... // Cast std::int16_t to int type and print.\n        return *this;\n    }\n\n    OutStream& operator<<(std::uint16_t value)\n    {\n        // Cast std::uint16_t to unsigned and print\n        return (*this << static_cast<std::uint32_t>(value));\n    }\n\n    OutStream& operator<<(std::int32_t value)\n    {\n        ... // Print signed value\n        return *this;\n    }\n\n    OutStream& operator<<(std::uint32_t value)\n    {\n        ... // Print unsigned value\n        return *this;\n    }\n\n    OutStream& operator<<(std::int64_t value)\n    {\n        ... // Print 64 bit signed value\n        return *this\n    }\n\n    OutStream& operator<<(std::uint64_t value)\n    {\n        ... // Print 64 bit signed value\n        return *this\n    }\n\nprivate:\n    TStreamBuf& buf_;\n};\n```", "```cpp\nenum Base\n{\n    bin, ///< Binary numeric base stream manipulator\n    oct, ///< Octal numeric base stream manipulator\n    dec, ///< Decimal numeric base stream manipulator\n    hex, ///< Hexadecimal numeric base stream manipulator\n    Base_NumOfBases ///< Must be last\n};\n\ntemplate <typename TStreamBuf>\nclass OutStream\n{\npublic:\n    explicit OutStream(TStreamBuf& buf)\n    : buf_(buf)\n      base_(dec)\n    {\n    }\n\n    OutStream& operator<<(Base value)\n    {\n        base_ = value;\n        return *this\n    }\n\nprivate:\n    TStreamBuf& buf_;\n    Base base_;\n};\n```", "```cpp\nOutStream<...> stream;\n\nstream << \"var1=\" << dec << var1 << \"; var2=\" << hex << var2 << '\\n';\nstream.flush();\n```", "```cpp\nclass WidthManip : public ValueManipBase<std::size_t>\n{\npublic:\n    WidthManip(std::size_t value) : value_(value) {}\n    std::size_t value() const { return value_;}\nprivate:\n    std::size_t value_;\n};\n\ninline\nWidthManip setw(std::size_t value)\n{\n    return WidthManip(value);\n}\n\ntemplate <typename T>\nclass FillManip\n{\npublic:\n    FillManip(T value) : value_(value) {}\n    T value() const { return value_;}\nprivate:\n    T value_;\n};\n\ntemplate <typename T>\ninline\nFillManip<T> setfill(T value)\n{\n    return FillManip<T>(value);\n}\n\ntemplate <typename TStreamBuf>\nclass OutStream\n{\npublic:\n    explicit OutStream(TStreamBuf& buf)\n    : buf_(buf)\n      base_(dec),\n      width_(0),\n      fill_(static_cast<CharType>(' ');\n    {\n    }\n\n    OutStream& operator<<(WidthManip manip)\n    {\n        width_ = manip.value();\n        return *this;\n    }\n\n    template <typename T>\n    OutStream& operator<<(details::FillManip<T> manip)\n    {\n        fill_ = static_cast<CharType>(manip.value());\n        return *this;\n    }\n\nprivate:\n    TStreamBuf& buf_;\n    Base base_;\n    std::size_t width_;\n    CharType fill_;\n};\n```", "```cpp\nOutStream<...> stream;\n\nstream << \"var1=\" << dec << setw(4) << var1 << \"; var2=\" << hex\n       << setfill('0') << var2 << '\\n';\nstream.flush();\n```", "```cpp\nenum Endl\n{\n    endl ///< End of line stream manipulator\n};\n\ntemplate <typename TStreamBuf>\nclass OutStream\n{\npublic:\n\n    OutStream& operator<<(Endl manip)\n    {\n        static_cast<void>(manip);\n        buf_.pushBack(static_cast<CharType>('\\n');\n        flush();\n        return *this;\n    }\n\nprivate:\n    ...\n};\n```", "```cpp\nOutStream<...> stream;\n\nstream << \"var1=\" << dec << setw(4) << var1 << \"; var2=\" << hex\n       << setfill('0') << var2 << endl;\n```", "```cpp\n#ifndef NDEBUG\n    stream << \"Some info massage\" << endl;\n#endif\n```", "```cpp\nnamespace log\n{\n\nenum Level\n{\n    Trace, ///< Use for tracing enter to and exit from functions.\n    Debug, ///< Use for debugging information.\n    Info, ///< Use for general informative output.\n    Warning, ///< Use for warning about potential dangers.\n    Error, ///< Use to report execution errors.\n    NumOfLogLevels ///< Number of log levels, must be last\n};\n\n}  // namespace log\n```", "```cpp\nconst auto MinLogLevel = log::Info;\n\n#define LOG(stream__, level__, output__) \\\n    do { \\\n        if (MinLevel <= (level__)) { \\\n            (stream__).stream() << output__; \\\n        } \\\n    } while (false)\n```", "```cpp\nLOG(stream, log::Debug, \"This message is not printed.\" << endl);\nLOG(stream, log::Info, \"This message IS printed.\" << endl);\nLOG(stream, log::Warning, \"This message IS printed also.\" << endl);\n```", "```cpp\nLOG(stream, log::Debug, \"This is DEBUG message.\");\nLOG(stream, log::Info, \"This is INFO message.\");\nLOG(stream, log::Warning, \"This is WARNING message.\");\n```", "```cpp\n[DEBUG]: This is DEBUG message.\n[INFO]: This is INFO message.\n[WARNING]: This is WARNING message.\n```", "```cpp\ntemplate <log::Level TLevel, typename TStream>\nclass StreamLogger\n{\npublic:\n\n    typedef TStream Stream;\n\n    static const log::Level MinLevel = TLevel;\n\n    explicit StreamLogger(Stream& outStream)\n      : outStream_(outStream)\n    {\n    }\n\n    Stream& stream()\n    {\n        return outStream_;\n    }\n\n    // Begin output. This function is called before requested\n    // output is redirected to stream. It does nothing.\n    void begin(log::Level level)\n    {\n        static_cast<void>(level);\n    }\n\n    // End output. This function is called after requested\n    // output is redirected to stream. It does nothing.\n    void end(log::Level level)\n    {\n        static_cast<void>(level);\n    }\n\nprivate:\n    Stream& outStream_;\n};\n```", "```cpp\n#define SLOG(log__, level__, output__) \\\n    do { \\\n        if ((log__).MinLevel <= (level__)) { \\\n            (log__).begin(level__); \\\n            (log__).stream() << output__; \\\n            (log__).end(level__); \\\n        } \\\n    } while (false)\n```", "```cpp\ntemplate <typename TNextLayer>\nclass StreamFlushSuffixer\n{\npublic:\n\n    // Constructor, forwards all the other parameters to the constructor\n    // of the next layer.\n    template<typename... TParams>\n    StreamFlushSuffixer(TParams&&... params)\n      : nextLavel_(std::forward<TParams>(params)...)\n    {\n    }\n\n    Stream& stream()\n    {\n        return nextLavel_.stream();\n    }\n\n    void begin(log::Level level)\n    {\n        nextLavel_.begin(level);\n    }\n\n    void end(log::Level level)\n    {\n        nextLavel_.end(level);\n        stream().flush();\n    }\n\nprivate:\n    TNextLavel nextLavel_;\n};\n```", "```cpp\ntypedef ... OutStream; // type of the output stream\ntypedef\n    StreamFlushSuffixer<\n        StreamLogger<\n            log::Debug,\n            OutStream\n        >\n    > Log;\n```", "```cpp\nOutStream stream(... /* construction params */);\nLog log(stream);\nSLOG(log, log::Debug, \"This is DEBUG message.\\n\");\n```", "```cpp\ntemplate <typename T, typename TNextLayer>\nclass StreamableValueSuffixer\n{\npublic:\n\n    template<typename... TParams>\n    explicit StreamableValueSuffixer(T&& value, TParams&&... params)\n      : value_(std::forward<T>(value)),\n        nextLevel_(std::forward<TParams>(params)...)\n    {\n    }\n\n    Stream& stream()\n    {\n        return nextLavel_.stream();\n    }\n\n    void begin(log::Level level)\n    {\n        nextLavel_.begin(level);\n    }\n\n    void end(log::Level level)\n    {\n        nextLavel_.end(level);\n        stream() << value_;\n    }\n\nprivate:\n    T value_;\n    TNextLavel nextLavel_;\n};\n```", "```cpp\ntypedef embxx::io::OutStream<...> OutStream;\ntypedef\n    StreamFlushSuffixer<\n        StreamableValueSuffixer<\n            char,\n            StreamLogger<\n                log::Debug,\n                OutStream\n            >\n        >\n    > Log;\n```", "```cpp\nOutStream stream(...);\nLog log('\\n', stream);\nSLOG(log, log::Debug, \"This is DEBUG message.\");\n```", "```cpp\ntemplate <typename TNextLayer>\nclass LevelStringPrefixer\n{\npublic:\n    template<typename... TParams>\n    LevelStringPrefixer(TParams&&... params);\n      : next_value(std::forward<TParams>(params)...)\n    {\n    }\n\n    Stream& stream()\n    {\n        return nextLavel_.stream();\n    }\n\n    void begin(Level level)\n    {\n        static const char* const Strings[NumOfLogLevels] = {\n            \"[TRACE] \",\n            \"[DEBUG] \",\n            \"[INFO] \",\n            \"[WARNING] \",\n            \"[ERROR] \"\n        };\n\n        if ((level < NumOfLogLevels) && (Strings[level] != nullptr)) {\n            stream() << Strings[level];\n        }\n\n        nextLavel_.begin(level);\n    }\n\n    void end(log::Level level)\n    {\n        nextLavel_.end(level);\n    }\n\nprivate:\n    TNextLavel nextLavel_;\n};\n```", "```cpp\ntypedef\n    StreamFlushSuffixer<\n        StreamableValueSuffixer<\n            char,\n            LevelStringPrefixer<\n                StreamLogger<\n                    log::Debug,\n                    OutStream\n                >\n            >\n        >\n    > Log;\n```", "```cpp\nnamespace log = embxx::util::log;\ntemplate <typename TLog, typename TTimer>\nvoid performLog(TLog& log, TTimer& timer, std::size_t& counter)\n{\n    ++counter;\n\n    SLOG(log, log::Info,\n        \"Logging output: counter = \" <<\n        embxx::io::dec << counter <<\n        \" (0x\" << embxx::io::hex << counter << \")\");\n\n    // Perform next logging after a timeout\n    static const auto LoggingWaitPeriod = std::chrono::seconds(1);\n    timer.asyncWait(\n        LoggingWaitPeriod,\n        [&](const embxx::error::ErrorStatus& es)\n        {\n            GASSERT(!es);\n            static_cast<void>(es);\n            performLog(log, timer, counter);\n        });\n}\n\nint main() {\n    auto& system = System::instance();\n    auto& log = system.log();\n\n    // Configure UART\n    auto& uart = system.uart();\n    uart.configBaud(115200);\n    uart.setWriteEnabled(true);\n\n    // Timer allocation\n    auto timer = system.timerMgr().allocTimer();\n    GASSERT(timer.isValid());\n\n    // Start logging\n    std::size_t counter = 0;\n    performLog(log, timer, counter);\n\n    // Run event loop\n    device::interrupt::enable();\n    auto& el = system.eventLoop();\n    el.run();\n\n    GASSERT(0); // Mustn't exit\n    return 0;\n}\n```", "```cpp\nclass System\n{\npublic:\n    static const std::size_t EventLoopSpaceSize = 1024;\n    typedef embxx::util::EventLoop<\n        EventLoopSpaceSize,\n        device::InterruptLock,\n        device::WaitCond> EventLoop;\n\n    // Devices\n    typedef device::Uart1<InterruptMgr> Uart;\n    ...\n\n    // Drivers\n    struct CharacterTraits\n    {\n        typedef std::nullptr_t ReadHandler;\n        typedef embxx::util::StaticFunction<\n            void(const embxx::error::ErrorStatus&, std::size_t)> WriteHandler;\n        typedef std::nullptr_t ReadUntilPred;\n        static const std::size_t ReadQueueSize = 0;\n        static const std::size_t WriteQueueSize = 1;\n    };\n    typedef embxx::driver::Character<\n        Uart, EventLoop, CharacterTraits> UartDriver;\n    ...\n\n    // Components\n    static const std::size_t OutStreamBufSize = 1024;\n    typedef embxx::io::OutStreamBuf<\n        UartDriver, OutStreamBufSize> OutStreamBuf;\n\n    typedef embxx::io::OutStream<OutStreamBuf> OutStream;\n    typedef embxx::util::log::StreamFlushSuffixer<\n            embxx::util::log::StreamableValueSuffixer<\n                const OutStream::CharType*,\n                embxx::util::log::LevelStringPrefixer<\n                    embxx::util::StreamLogger<\n                        embxx::util::log::Debug,\n                        OutStream\n                    >\n                >\n            >\n        > Log;\n\n    ...\nprivate:\n\n    EventLoop el_;\n\n    // Devices\n    Uart uart_;\n    ...\n\n    // Drivers\n    UartDriver uartDriver_;\n    ...\n\n    // Components\n    OutStreamBuf buf_;\n    OutStream stream_;\n    Log log_;\n    ...\n};\n```", "```cpp\n[INFO] Logging output: counter = 1 (0x1)\n[INFO] Logging output: counter = 2 (0x2)\n[INFO] Logging output: counter = 3 (0x3)\n...\n```", "```cpp\ntemplate <typename TDriver, std::size_t TBufSize>\nclass InStreamBuf\n{\npublic:\n    typedef typename TDriver::CharType CharType;\n    typedef embxx::container::StaticQueue<CharType, TBufSize> Buffer;\n\n    explicit\n    InStreamBuf(TDriver& driver)\n      : driver_(driver)\n    {\n    }\n\nprivate:\n    TDriver& driver_;\n    Buffer buf_;\n};\n```", "```cpp\ntemplate <typename TDriver, std::size_t TBufSize>\nclass InStreamBuf\n{\npublic:\n    // Start data accumulation in the internal buffer.\n    void start();\n\n    // Stop data accumulation in the internal buffer.\n    void stop();\n\n    // Inquire whether characters are being accumulated.\n    bool isRunning() const;\n};\n```", "```cpp\ntemplate <typename TDriver, std::size_t TBufSize, typename TWaitHandler>\nclass InStreamBuf\n{\npublic:\n\n    template <typename TFunc>\n    void asyncWaitDataAvailable(std::size_t reqSize, TFunc&& func)\n    {\n        callback_ = std::forward<TFunc>(func)\n        ...\n    }\n\nprivate:\n    TWaitHandler callback_;\n};\n```", "```cpp\ntemplate <typename TDriver, std::size_t TBufSize, typename TWaitHandler>\nclass InStreamBuf\n{\npublic:\n    typedef typename Buffer::ConstIterator ConstIterator;\n    typedef ConstIterator const_iterator;\n    typedef typename Buffer::ValueType ValueType;\n    typedef ValueType value_type;\n    typedef typename Buffer::ConstReference ConstReference;\n    typedef ConstReference const_reference;\n\n    // Get size of available for read data.\n    std::size_t size() const;\n\n    // Check whether number of available characters is 0.\n    bool empty() const;\n\n    //Get full capacity of the buffer.\n    constexpr std::size_t fullCapacity() const;\n\n    ConstIterator begin() const;\n    ConstIterator end() const;\n    ConstIterator cbegin() const;\n    ConstIterator cend() const;\n    ConstReference operator[](std::size_t idx) const;\n};\n```", "```cpp\ntemplate <typename TDriver, std::size_t TBufSize, typename TWaitHandler>\nclass InStreamBuf\n{\npublic:\n    // Consume part or the whole buffer of the available data for read.\n    void consume(std::size_t consumeSize = size());\n};\n```", "```cpp\ntemplate <typename TLed, typename TInBuf, typename TTimerMgr>\nclass Morse\n{\npublic:\n    typedef TLed Led;\n    typedef TInBuf InBuf;\n    typedef TTimerMgr TimerMgr;\n    typedef typename TimerMgr::Timer Timer;\n\n    Morse(Led& led, InBuf& buf, TimerMgr& timerMgr)\n      : led_(led),\n        buf_(buf),\n        timer_(timerMgr.allocTimer())\n    {\n        GASSERT(timer_.isValid());\n    }\n\n    ~Morse() = default;\n\nprivate:\n    Led& led_;\n    InBuf& buf_;\n    Timer timer_;\n};\n```", "```cpp\ntemplate <...>\nclass Morse\n{\npublic:\n    typedef typename InBuf::CharType CharType;\n    ...\nprivate:\n    typedef unsigned Duration;\n    static const Duration Dot = 200;\n    static const Duration Dash = Dot * 3;\n    static const Duration End = 0;\n    static const Duration Spacing = Dot;\n    static const Duration InterSpacing = Spacing * 2;\n\n    const Duration* getLettersSeq(CharType ch) const\n    {\n        static const Duration Seq_A[] = {Dot, Dash, End};\n        static const Duration Seq_B[] = {Dash, Dot, Dot, Dot, End};\n        ...\n        static const Duration Seq_Z[] = {Dash, Dash, Dot, Dot, End};\n\n        static const Duration Seq_0[] = {\n            Dash, Dash, Dash, Dash, Dash, End};\n        static const Duration Seq_1[] = {\n            Dot, Dash, Dash, Dash, Dash, End};\n        ...\n        static const Duration Seq_9[] = {\n            Dash, Dash, Dash, Dash, Dot, End};\n\n        static const Duration* Letters[] = {\n            Seq_A,\n            Seq_B,\n            ...\n            Seq_Z\n        };\n\n        static const Duration* Numbers[] = {\n            Seq_0,\n            ...\n            Seq_9\n        };\n\n        if ((static_cast<CharType>('A') <= ch) &&\n            (ch <= static_cast<CharType>('Z'))) {\n            return Letters[ch - 'A'];\n        }\n\n        if ((static_cast<CharType>('a') <= ch) &&\n            (ch <= static_cast<CharType>('z'))) {\n            return Letters[ch - 'a'];\n        }\n\n        if ((static_cast<CharType>('0') <= ch) &&\n            (ch <= static_cast<CharType>('9'))) {\n            return Numbers[ch - '0'];\n        }\n\n        return nullptr;\n    }\n};\n```", "```cpp\ntemplate <...>\nclass Morse\n{\npublic:\n\n    void start()\n    {\n        buf_.start();\n        nextLetter();\n    }\n\nprivate:\n    void nextLetter()\n    {\n        buf_.asyncWaitDataAvailable(\n            1U,\n            [this](const embxx::error::ErrorStatus& es)\n            {\n                if (es) {\n                    GASSERT(buf_.empty());\n                    nextLetter();\n                    return;\n                }\n\n                GASSERT(!buf_.empty());\n                auto ch = buf_[0];\n                buf_.consume(1U);\n\n                auto* seq = getLettersSeq(ch);\n                if (seq == nullptr) {\n                    nextLetter();\n                    return;\n                }\n\n                nextSyllable(seq);\n            });\n    }\n\n    void nextSyllable(const Duration* seq)\n    {\n        GASSERT(seq != nullptr);\n        GASSERT(*seq != End);\n\n        auto duration = *seq;\n        ++seq;\n\n        led_.on();\n        timer_.asyncWait(\n            std::chrono::milliseconds(duration),\n            [this, seq](const embxx::error::ErrorStatus& es)\n            {\n                static_cast<void>(es);\n                GASSERT(!es);\n\n                led_.off();\n\n                if (*seq != End) {\n                    timer_.asyncWait(\n                        std::chrono::milliseconds(Duration(Spacing)),\n                        [this, seq](const embxx::error::ErrorStatus& es)\n                        {\n                            static_cast<void>(es);\n                            GASSERT(!es);\n                            nextSyllable(seq);\n                        });\n                    return;\n                }\n\n                timer_.asyncWait(\n                    std::chrono::milliseconds(Duration(InterSpacing)),\n                    [this](const embxx::error::ErrorStatus& es)\n                    {\n                        static_cast<void>(es);\n                        GASSERT(!es);\n                        nextLetter();\n                    });\n            });\n    }\n\n};\n```", "```cpp\n    typedef unsigned PinIdType;\n    ```", "```cpp\n    template <typename TFunc>\n    void setHandler(TFunc&& func);\n    ```", "```cpp\n    void start(embxx::device::context::EventLoop context);\n    ```", "```cpp\n    bool cancel(embxx::device::context::EventLoop context);\n    ```", "```cpp\n    void setEnabled(\n        PinIdType pin,\n        bool enabled,\n        embxx::device::context::EventLoop context);\n    ```", "```cpp\n    bool suspend(embxx::device::context::EventLoop context);\n    ```", "```cpp\n    void resume(embxx::device::context::EventLoop context);\n    ```", "```cpp\ntemplate <typename TDevice, typename TEventLoop>\nclass MyGpioDriver\n{\npublic:\n    // During the construction store references to Device\n    // and Event Loop objects.\n    MyGpioDriver(TDevice& device, TEventLoop& el)\n      : device_(device),\n        el_(el)\n    {\n        // Register appropriate interrupt callbacks with device\n        device_.setHandler(...);\n    }\n\n    ...\n\nprivate:\n\n    TDevice& device_;\n    TEventLoop& el_;\n};\n```", "```cpp\ntemplate <typename TDevice, typename TEventLoop>\nclass MyGpioDriver\n{\npublic:\n    typedef typename TDevice::PinIdType PinIdType;\n\n    template <typename TFunc>\n    void asyncReadCont(PinIdType id, TFunc&& func) { ... }\n\n    bool cancelReadCont(PinIdType id) { ... }\n};\n```", "```cpp\ntemplate <typename TDevice,\n          typename TEventLoop,\n          std::size_t TNumOfLines,\n          typename THandler =\n              embxx::util::StaticFunction<void (const embxx::error::ErrorStatus&, bool)> >\nclass MyGpioDriver\n{\npublic:\n    template <typename TFunc>\n    void asyncReadCont(PinIdType id, TFunc&& func)\n    {\n        ...\n        auto* node = ...; // Locate or allocate appropriate node\n        node->id_ = id;\n        node->handler_ = std::forward<TFunc>(func);\n        ...\n    }\n\nprivate:\n    struct Node\n    {\n        Node() : id_(PinIdType()) {}\n\n        PinIdType id_;\n        THandler handler_;\n    };\n\n    typedef std::array<Node, TNumOfLines> Infos;\n\n    Infos infos_;\n    ...\n};\n```", "```cpp\ntemplate <typename TDriver,\n          bool TActiveState,\n          typename THandler = embxx::util::StaticFunction<void ()> >\nclass Button\n{\npublic:\n    typedef TDriver Driver;\n    typedef typename Driver::PinIdType PinIdType;\n\n    Button(Driver& driver, PinIdType pin);\n    ~Button();\n\n    bool isPressed() const;\n\n    template <typename TFunc>\n    void setPressedHandler(TFunc&& func);\n\n    template <typename TFunc>\n    void setReleasedHandler(TFunc&& func);\n};\n```", "```cpp\nint main() {\n    auto& system = System::instance();\n\n    // Configure uart\n    auto& uart = system.uart();\n    uart.configBaud(9600);\n    uart.setWriteEnabled(true);\n\n    // Allocate timer\n    auto& timerMgr = system.timerMgr();\n    auto timer = timerMgr.allocTimer();\n    GASSERT(timer.isValid());\n\n    // Set handlers for button press / release\n    auto& button = system.button();\n    button.setPressedHandler(\n        std::bind(\n            &buttonPressed,\n            std::ref(timer)));\n\n    button.setReleasedHandler(&buttonReleased);\n\n    // Run event loop with enabled interrupts\n    device::interrupt::enable();\n    auto& el = system.eventLoop();\n    el.run();\n\n    GASSERT(0); // Mustn't exit\n\treturn 0;\n}\n```", "```cpp\nvoid buttonPressed(System::TimerMgr::Timer& timer)\n{\n    static_cast<void>(timer);\n    auto& system = System::instance();\n    auto& el = system.eventLoop();\n    auto& led = system.led();\n    auto& log = system.log();\n\n    SLOG(log, embxx::util::log::Info, \"Button Pressed\");\n\n    timer.cancel();\n    auto result = el.post(\n        [&led]()\n        {\n            led.on();\n        });\n    GASSERT(result);\n    static_cast<void>(result);\n\n    static const auto WaitTime = std::chrono::seconds(1);\n    timer.asyncWait(\n        WaitTime,\n        [&led](const embxx::error::ErrorStatus& es)\n        {\n            if (es == embxx::error::ErrorCode::Aborted) {\n                return;\n            }\n            led.off();\n        });\n}\n```", "```cpp\nvoid buttonReleased()\n{\n    auto& system = System::instance();\n    auto& log = system.log();\n\n    SLOG(log, embxx::util::log::Info, \"Button Released\");\n}\n```", "```cpp\ntemplate <typename TDevice>\nclass IdAdaptor\n{\npublic:\n    // Type of the underlaying device.\n    typedef TDevice Device;\n\n    // Character type defined in the wrapped device\n    typedef typename TDevice::CharType CharType;\n\n    // Device identification type defined in the wrapped device class.\n    typedef typename TDevice::DeviceIdType DeviceIdType;\n\n    IdAdaptor(Device& device, DeviceIdType id)\n      : device_(device),\n        id_(id)\n    {\n    }\n\n    template <typename TFunc>\n    void setCanReadHandler(TFunc&& func)\n    {\n        device_.setCanReadHandler(id_, std::forward<TFunc>(func));\n    }\n\n    template <typename TFunc>\n    void setCanWriteHandler(TFunc&& func)\n    {\n        device_.setCanWriteHandler(id_, std::forward<TFunc>(func));\n    }\n\n    template <typename TFunc>\n    void setReadCompleteHandler(TFunc&& func)\n    {\n        device_.setReadCompleteHandler(id_, std::forward<TFunc>(func));\n    }\n\n    template <typename TFunc>\n    void setWriteCompleteHandler(TFunc&& func)\n    {\n        device_.setWriteCompleteHandler(id_, std::forward<TFunc>(func));\n    }\n\n    template <typename... TArgs>\n    void startRead(TArgs&&... args)\n    {\n        device_.startRead(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    bool cancelRead(TArgs&&... args)\n    {\n        return device_.cancelRead(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    void startWrite(TArgs&&... args)\n    {\n        device_.startWrite(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    bool cancelWrite(TArgs&&... args)\n    {\n        return device_.cancelWrite(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    bool suspend(TArgs&&... args)\n    {\n        return device_.suspend(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    void resume(TArgs&&... args)\n    {\n        device_.resume(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    bool canRead(TArgs&&... args)\n    {\n        return device_.canRead(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    bool canWrite(TArgs&&... args)\n    {\n        return device_.canWrite(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    CharType read(TArgs&&... args)\n    {\n        return device_.read(id_, std::forward<TArgs>(args)...);\n    }\n\n    template <typename... TArgs>\n    void write(TArgs&&... args)\n    {\n        device_.write(id_, std::forward<TArgs>(args)...);\n    }\n\nprivate:\n    Device& device_;\n    DeviceIdType id_;\n};\n```", "```cpp\ntemplate <typename TDevice,\n          std::size_t TSize,\n          typename TCanDoOpHandler = embxx::util::StaticFunction<void()>,\n          typename TOpCompleteHandler =\n              embxx::util::StaticFunction<void (const embxx::error::ErrorStatus&)> >\nclass DeviceOpQueue\n{\npublic:\n    DeviceOpQueue(TDevice& device);\n    ...\nprivate:\n    typedef embxx::container::StaticQueue<..., TSize> Queue;\n    Queue queue_;\n};\n```", "```cpp\ntemplate <typename TDevice>\nclass DeviceOpQueue<TDevice, 1>\n{\npublic:\n\n    typedef typename TDevice::PinIdType PinIdType;\n\n    template <typename... TArgs>\n    void startRead(TArgs&&... args)\n    {\n        device_.startRead(std::forward<TArgs>(args)...)\n    }\n\n    template <typename... TArgs>\n    bool cancelRead(PinIdType id, TArgs&&... args)\n    {\n        static_cast<void>(id); // No use for id in the Device itself\n        return device_.cancelRead(std::forward<TArgs>(args)...)\n    }\n\n    template <typename... TArgs>\n    bool suspend(PinIdType id, TArgs&&... args)\n    {\n        static_cast<void>(id); // No use for id in the Device itself\n        return device_.suspend(std::forward<TArgs>(args)...)\n    }\n\n    ...\n};\n```", "```cpp\nclass I2CDevice\n{\npublic:\n    // Single character type\n    typedef std::uint8_t CharType;\n\n    // ID type\n    typedef std::uint8_t DeviceIdType;\n\n    // Context types\n    typedef embxx::device::context::EventLoop EventLoopContext;\n    typedef embxx::device::context::Interrupt InterruptContext;\n\n    // Set various interrupt handlers\n    template <typename TFunc>\n    void setCanReadHandler(TFunc&& func);\n\n    template <typename TFunc>\n    void setCanWriteHandler(TFunc&& func);\n\n    template <typename TFunc>\n    void setReadCompleteHandler(TFunc&& func);\n\n    template <typename TFunc>\n    void setWriteCompleteHandler(TFunc&& func);\n\n    // Start read for both contexts.\n    void startRead(DeviceIdType address, std::size_t length, EventLoopContext);\n    void startRead(DeviceIdType address, std::size_t length, InterruptContext);\n\n    // Cancel read for both contexts.\n    bool cancelRead(EventLoopContext);\n    bool cancelRead(InterruptContext);\n\n    // Start write for both contexts.\n    void startWrite(DeviceIdType address, std::size_t length, EventLoopContext);\n    void startWrite(DeviceIdType address, std::size_t length, InterruptContext);\n        TContext context);\n\n    // Cancel write for both contexts.\n    bool cancelWrite(EventLoopContext);\n    bool cancelWrite(InterruptContext);\n\n    // Suspend/Resume\n    bool suspend(EventLoopContext);\n    void resume(EventLoopContext);\n\n    // Helper functions to manage read/write during the interrupt\n    bool canRead(InterruptContext);\n    bool canWrite(InterruptContext);\n    CharType read(InterruptContext);\n    void write(CharType value, InterruptContext);\n};\n```", "```cpp\nclass SpiDevice\n{\npublic:\n    // Single character type\n    typedef std::uint8_t CharType;\n\n    // ID type - chip select index\n    typedef unsigned DeviceIdType;\n\n    // Context types\n    typedef embxx::device::context::EventLoop EventLoopContext;\n    typedef embxx::device::context::Interrupt InterruptContext;\n\n    // Set various interrupt handlers\n    template <typename TFunc>\n    void setCanReadHandler(TFunc&& func);\n\n    template <typename TFunc>\n    void setCanWriteHandler(TFunc&& func);\n\n    template <typename TFunc>\n    void setReadCompleteHandler(TFunc&& func);\n\n    template <typename TFunc>\n    void setWriteCompleteHandler(TFunc&& func);\n\n    // Start read for both contexts.\n    void startRead(DeviceIdType chipSelect, std::size_t length, EventLoopContext);\n    void startRead(DeviceIdType chipSelect, std::size_t length, InterruptContext);\n\n    // Cancel read for both contexts.\n    bool cancelRead(EventLoopContext);\n    bool cancelRead(InterruptContext);\n\n    // Start write for both contexts.\n    void startWrite(DeviceIdType chipSelect, std::size_t length, EventLoopContext);\n    void startWrite(DeviceIdType chipSelect, std::size_t length, InterruptContext);\n        TContext context);\n\n    // Cancel write for both contexts.\n    bool cancelWrite(EventLoopContext);\n    bool cancelWrite(InterruptContext);\n\n    // Suspend/Resume\n    bool suspend(EventLoopContext);\n    void resume(EventLoopContext);\n\n    // Helper functions to manage read/write during the interrupt\n    bool canRead(InterruptContext);\n    bool canWrite(InterruptContext);\n    CharType read(InterruptContext);\n    void write(CharType value, InterruptContext);\n};\n```"]