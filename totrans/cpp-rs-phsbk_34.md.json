["```rs\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector<int> v{1, 2, 3};\n\n  // prints 1, 2, 3\n  for (auto &x : v) {\n    std::cout << x << std::endl;\n    x = x + 1;\n  }\n\n  // prints 2, 3, 4\n  for (const auto &x : v) {\n    std::cout << x << std::endl;\n  }\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <ranges>\n#include <vector>\n\nusing namespace std::views;\nusing namespace std::ranges::views;\n\nint main() {\n // clang-format off  // This example requires C++23\n  auto v =\n    iota(1)\n      | filter([](int n) { return n % 2 == 1; })\n      | transform([](int n) { return n + 3; })\n      | take(10)\n      | std::ranges::to<std::vector>();\n // clang-format on \n  // use v...\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <ranges>\n#include <iostream>\n\nusing namespace std::views;\nusing namespace std::ranges::views;\n\nint main() {\n // clang-format off    for (auto x :\n        iota(1)\n          | filter([](int n) { return n % 2 == 1; })\n          | transform([](int n) { return n + 3; })\n          | take(10)) {\n      std::cout<< x << std::endl;\n    }\n // clang-format on } \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <algorithm>\n#include <vector>\n\nint main() {\n  std::vector v{1, 2, 3, 4, 5, 6, 7, 8, 9};\n  auto begin = v.begin() + 2;\n  auto end = begin + 5;\n  bool b(std::any_of(begin, end, [](int n) {\n    return n % 2 == 0;\n  }));\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector v{9, 8, 7, 6, 5, 4, 3, 2, 1};\n\n  for (auto n : v) {\n    std::cout << n << \",\";\n  }\n  std::cout << std::endl;\n\n  std::sort(v.begin(), v.end());\n\n  for (auto n : v) {\n    std::cout << n << \",\";\n  }\n  std::cout << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector<int> v{1, 2, 3};\n\n  auto newEnd = remove(v.begin(), v.end(), 2);\n  v.erase(newEnd, v.end());\n\n  // Or since C++20\n  // std::erase(v, 2);\n\n  for (auto x : v) {\n    std::cout << x << std::endl;\n  }\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <memory>\n\ntemplate <typename V>\nclass Tree {\npublic:\n    V value;\n    std::unique_ptr<Tree<V>> left;\n    std::unique_ptr<Tree<V>> right;\n}; \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <memory> #include <vector>   template <typename V>\nclass Tree {\npublic:\n  class iterator {\n    std::vector<const Tree<V> *> rest;\n\n  public:\n    using difference_type = long;\n    using value_type = V;\n    using pointer = const V *;\n    using reference = const V &;\n    using iterator_category =\n        std::forward_iterator_tag;\n\n    iterator() {}\n    iterator(const Tree<V> *start) {\n      rest.push_back(start);\n    }\n\n    reference operator*() const {\n      return rest.back()->value;\n    }\n\n    iterator &operator++() {\n      const Tree<V> *t = rest.back();\n      rest.pop_back();\n      if (t->right) {\n        rest.push_back(t->right.get());\n      }\n      if (t->left) {\n        rest.push_back(t->left.get());\n      }\n      return *this;\n    }\n\n    iterator operator++(int) {\n      iterator retval = *this;\n      const Tree<V> *t = rest.back();\n      rest.pop_back();\n      if (t->right) {\n        rest.push_back(t->right.get());\n      }\n      if (t->left) {\n        rest.push_back(t->left.get());\n      }\n      return retval;\n    }\n\n    bool operator==(const iterator &other) const {\n      return rest == other.rest;\n    }\n\n    bool operator!=(const iterator &other) const {\n      return !(*this == other);\n    }\n  };\n  V value; std::unique_ptr<Tree<V>> left; std::unique_ptr<Tree<V>> right; }; \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <memory> #include <vector> \ntemplate <typename V>\nclass Tree {\npublic:\n class iterator { std::vector<const Tree<V> *> rest;   public: using difference_type = long; using value_type = V; using pointer = const V *; using reference = const V &; using iterator_category = std::forward_iterator_tag;   iterator() {} iterator(const Tree<V> *start) { rest.push_back(start); }   reference operator*() const { return rest.back()->value; }   iterator &operator++() { const Tree<V> *t = rest.back(); rest.pop_back(); if (t->right) { rest.push_back(t->right.get()); } if (t->left) { rest.push_back(t->left.get()); } return *this; }   iterator operator++(int) { iterator retval = *this; const Tree<V> *t = rest.back(); rest.pop_back(); if (t->right) { rest.push_back(t->right.get()); } if (t->left) { rest.push_back(t->left.get()); } return retval; }   bool operator==(const iterator &other) const { return rest == other.rest; }   bool operator!=(const iterator &other) const { return !(*this == other); } };    iterator begin() const {\n    return iterator(this);\n  }\n\n  iterator end() const {\n    return iterator();\n  }\n  V value; std::unique_ptr<Tree<V>> left; std::unique_ptr<Tree<V>> right; };\n\nint main() {\n  Tree<int> t{1,\n              std::make_unique<Tree<int>>(\n                  2, nullptr, nullptr),\n              std::make_unique<Tree<int>>(\n                  3,\n                  std::make_unique<Tree<int>>(\n                      4, nullptr, nullptr),\n                  nullptr)};\n\n  for (auto v : t) {\n    std::cout << v << std::endl;\n  }\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```"]