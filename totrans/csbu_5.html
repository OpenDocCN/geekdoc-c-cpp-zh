<html><head></head><body>
<main class="calibre3">
<div id="chapter05" class="author">
<header class="calibre6">
<h2 id="calibre_toc_7" class="calibre7"><span class="first-last">Chapter<span class="first-last"> </span></span><span class="first-last">6<span class="first-last">. </span></span>Virtual Memory</h2></header></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="virtual_memory_isnt"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_36"><span class="first-last">1<span class="first-last"> </span></span>What Virtual Memory <em class="calibre9">isn't</em></h2></header><p class="releaseinfo">Virtual memory is often naively discussed as a way to
    extended your RAM by using the hard drive as extra, slower, system
    memory.  That is, once your system runs out of memory, it flows
    over onto the hard drive which is used as "virtual" memory.</p><p class="releaseinfo">In modern operating systems, this is commonly referred to as
    <em class="calibre5">swap space</em>, because unused parts of memory as
    swapped out to disk to free up main memory (remember, programs can
    only execute from main memory).
    </p><p class="releaseinfo">Indeed, the ability to swap out memory to disk is an
    important capability, but as you will see it is not the purpose of
    virtual memory, but rather a very useful side effect!</p></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="virtual_memory_is"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_37"><span class="first-last">2<span class="first-last"> </span></span>What virtual memory <em class="calibre9">is</em></h2></header><p class="releaseinfo">Virtual memory is all about making use of <em class="calibre5">address
    space</em>.</p><p class="releaseinfo">The address space of a processor refers the range of
    possible addresses that it can use when loading and storing to
    memory.  The address space is limited by the width of the
    registers, since as we know to load an address we need to issue a
    <code class="computeroutput1">load</code> instruction with the address
    to load from stored in a register.  For example, registers that
    are 32 bits wide can hold addresses in a register range from
    <code class="computeroutput1">0x00000000</code> to
    <code class="computeroutput1">0xFFFFFFF</code>.
    2^<sup class="calibre22">32</sup> is equal to 4GB, so a 32 bit
    processor can load or store to up to 4GB of memory.</p><section id="virtual_memory_is_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">2<span class="first-last">.</span>1<span class="first-last"> </span></span>64 bit computing</h3></header><p class="releaseinfo">New processors are generally all 64-bit processors, which
        as the name suggests has registers 64 bits wide.  As an exercise,
        you should work out the address space available to these
        processors (hint: it is big!).</p><p class="releaseinfo">64-bit computing does have some trade-offs against using
        smaller bit-width processors.  Every program compiled in
        64-bit mode requires 8-byte pointers, which can increase code
        and data size, and hence impact both instruction and data
        cache performance.  However, 64-bit processors tend to have
        more registers, which means less need to save temporary
        variables to memory when the compiler is under register
        pressure.</p><section id="virtual_memory_is_s1_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>Canonical Addresses</h4></header><p class="releaseinfo">While 64-bit processors have 64-bit wide registers,
          systems generally do not implement all 64-bits for
          addressing — it is not actually possible to do
          <code class="computeroutput1">load</code> or
          <code class="computeroutput1">store</code> to all 16 exabytes of
          theoretical physical memory!</p><p class="releaseinfo">Thus most architectures define an
          <em class="calibre5">unimplemented</em> region of the address
          space which the processor will consider invalid for use.
          x86-64 and Itanium both define the most-significant valid
          bit of an address, which must then be sign-extended (see
          <a href="csbu-print_split_009.html#sign_extension" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>2<span class="sep">.</span>3<span class="sep">.</span>1<span class="sep">.</span>3<span class="sep">.</span>1, </span><span>Sign-extension</span></span></a>) to create a valid
          address.  The result of this is that the total address space
          is effectively divided into two parts, an upper and a lower
          portion, with the addresses in-between considered invalid.
          This is illustrated in <a href="#canonical_address" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>2<span class="sep">.</span>1<span class="sep">.</span>1<span class="sep">.</span>1, </span><span>Illustration of canonical addresses</span></span></a>.  Valid addresses are
          termed <em class="calibre5">canonical addresses</em> (invalid
          addresses being <em class="calibre5">non</em>-canonical).</p><div id="canonical_address" class="figure"><div class="author" summary="By defining a most-significant bit that must be sign-extended to create a full address, the address-space is effectively partitioned into upper and lower portions, with intermediate addresses considered invalid by the processor."><div class="media"><picture><img src="canonical.svg" alt="By defining a most-significant bit that must be sign-extended to create a full address, the address-space is effectively partitioned into upper and lower portions, with intermediate addresses considered invalid by the processor." class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>2<span>.</span>1<span>.</span>1<span>.</span>1<span> </span></span>Illustration of canonical addresses</div></header></div><p class="releaseinfo">The exact most-significant bit value for the processor
          can usually be found by querying the processor itself using
          its informational instructions.  Although the exact value is
          implementation dependent, a typical value would be 48;
          providing 2<sup class="calibre22">48</sup> = 256 TiB of usable
          address-space.
        </p><p class="releaseinfo">Reducing the possible address-space like this means that
          significant savings can be made with all parts of the
          addressing logic in the processor and related components, as
          they know they will not need to deal with full 64-bit
          addresses.  Since the implementation defines the upper-bits as
          being signed-extended, this prevents portable operating
          systems using these bits to store or flag additional
          information and ensuring compatibility if the implementation
          wishes to implement more address-space in the future.</p></section></section><section id="address_space"><header class="calibre8"><h3 class="calibre2"><span class="first-last">2<span class="first-last">.</span>2<span class="first-last"> </span></span>Using the address space</h3></header><p class="releaseinfo">As with most components of the operating system, virtual
        memory acts as an abstraction between the address space and the
        physical memory available in the system.  This means that when a
        program uses an address that address does not refer to the bits in
        an actual physical location in memory.</p><p class="releaseinfo">So to this end, we say that all addresses a program uses
        are <em class="calibre5">virtual</em>.  The operating system keeps
        track of virtual addresses and how they are allocated to
        <em class="calibre5">physical</em> addresses.  When a program does
        a load or store from an address, the processor and operating
        system work together to convert this virtual address to the
        actual address in the system memory chips.
      </p></section></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="virtual_memory_pages"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_38"><span class="first-last">3<span class="first-last"> </span></span>Pages</h2></header><p class="releaseinfo">The total address-space is divided into individual
      <em class="calibre5">pages</em>.  Pages can be many different sizes;
      generally they are around 4 KiB, but this is not a hard and fast
      rule and they can be much larger but generally not any smaller.
      The page is the smallest unit of memory that the operating
      system and hardware can deal with.</p><p class="releaseinfo">Additionally, each page has a number of attributes set by
      the operating system.  Generally, these include read, write and
      execute permissions for the current page.  For example, the
      operating system can generally mark the code pages of a process
      with an executable flag and the processor can choose to not
      execute any code from pages without this bit set.</p><div id="virtual_memory_pages_fig1" class="figure"><div class="author" summary="Pages"><div class="media"><picture><img src="page.svg" alt="Pages" class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>3<span>.</span>1<span> </span></span>Virtual memory pages</div></header></div><p class="releaseinfo">Programmers may at this point be thinking that they can
      easily allocate small amounts of memory, much smaller than 4
      KiB, using <code class="computeroutput1">malloc</code> or similar
      calls.  This <em class="calibre5">heap</em> memory is actually backed
      by page-size allocations, which the
      <code class="computeroutput1">malloc</code> implementation divides
      up and manages for you in an efficient manner.</p></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="physical_memory"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_39"><span class="first-last">4<span class="first-last"> </span></span>Physical Memory</h2></header><p class="releaseinfo">Just as the operating system divides the possible address
      space up into pages, it divides the available physical memory up
      into <em class="calibre5">frames</em>.  A frame is just the
      conventional name for a hunk of physical memory the same size as
      the system page size.</p><p class="releaseinfo">The operating system keeps a
      <em class="calibre5">frame-table</em> which is a list of all possible
      pages of physical memory and if they are free (available for
      allocation) or not.  When memory is allocated to a process, it
      is marked as used in the frame-table.  In this way, the
      operating-system keeps track of all memory allocations.</p><p class="releaseinfo">How does the operating system know what memory is available?
      This information about where memory is located, how much,
      attributes and so forth is passed to the operating system by the
      BIOS during initialisation.</p></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="page_tables"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_40"><span class="first-last">5<span class="first-last"> </span></span>Pages + Frames = Page Tables</h2></header><p class="releaseinfo">It is the job of the operating system is to keep track of
    which of virtual-page points to which physical frame.  This
    information is kept in a <em class="calibre5">page-table</em> which, in
    its simplest form, could simply be a table where each row contains
    its associated frame — this is termed a <em class="calibre5">linear
    page-table</em>.  If you were to use this simple system,
    with a 32 bit address-space and 4 KiB pages there would be 1048576
    possible pages to keep track of in the page table
    (2<sup class="calibre22">32</sup> ÷ 4096); hence the table
    would be 1048576 entries long to ensure we can always map a
    virtual page to a physical page.</p><p class="releaseinfo">Page tables can have many different structures and are
    highly optimised, as the process of finding a page in the page
    table can be a lengthy process.  We will examine page-tables in
    more depth later.</p><p class="releaseinfo">The page-table for a process is under the exclusive control
    of the operating system.  When a process requests memory, the
    operating system finds it a free page of physical memory and
    records the virtual-to-physical translation in the processes
    page-table.  Conversely, when the process gives up memory, the
    virtual-to-physical record is removed and the underlying frame
    becomes free for allocation to another process.</p></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="virtual_addresses"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_41"><span class="first-last">6<span class="first-last"> </span></span>Virtual Addresses</h2></header><p class="releaseinfo">When a program accesses memory, it does not know or care
    where the physical memory backing the address is stored.  It knows
    it is up to the operating system and hardware to work together to
    map locate the right physical address and thus provide access to
    the data it wants.  Thus we term the address a program is using to
    access memory a <em class="calibre5">virtual address</em>.  A virtual
    address consists of two parts; the page and an offset into that
    page.</p><section id="virtual_addresses_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">6<span class="first-last">.</span>1<span class="first-last"> </span></span>Page</h3></header><p class="releaseinfo">Since the entire possible address space is divided up into
      regular sized pages, every possible address resides within a
      page.  The page component of the virtual address acts as an
      index into the page table.  Since the page is the smallest unit
      of memory allocation within the system there is a trade-off
      between making pages very small, and thus having very many pages
      for the operating-system to manage, and making pages larger but
      potentially wasting memory</p></section><section id="virtual_addresses_s2"><header class="calibre8"><h3 class="calibre2"><span class="first-last">6<span class="first-last">.</span>2<span class="first-last"> </span></span>Offset</h3></header><p class="releaseinfo">The last bits of the virtual address are called the
      <em class="calibre5">offset</em> which is the location difference
      between the byte address you want and the start of the page.
      You require enough bits in the offset to be able to get to any
      byte in the page.  For a 4K page you require (4K == (4 * 1024)
      == 4096 == 2<sup class="calibre22">12</sup> ==) 12 bits of offset.
      Remember that the smallest amount of memory that the operating
      system or hardware deals with is a page, so each of these 4096
      bytes reside within a single page and are dealt with as
      "one".</p></section><section id="virtual_address_translation"><header class="calibre8"><h3 class="calibre2"><span class="first-last">6<span class="first-last">.</span>3<span class="first-last"> </span></span>Virtual Address Translation</h3></header><p class="releaseinfo">Virtual address translation refers to the process of
      finding out which physical page maps to which virtual
      page.</p><p class="releaseinfo">When translating a virtual-address to a physical-address
        we only deal with the <em class="calibre5">page number </em>.  The
        essence of the procedure is to take the page number of the
        given address and look it up in the
        <em class="calibre5">page-table</em> to find a pointer to a
        physical address, to which the offset from the virtual address
        is added, giving the actual location in system memory.</p><p class="releaseinfo">Since the page-tables are under the control of the
        operating system, if the virtual-address doesn't exist in the
        page-table then the operating-system knows the process is
        trying to access memory that has not been allocated to it and
        the access will not be allowed.</p><div id="virtual_address_translation_fig1" class="figure"><div class="author" summary="Converting a virtual address to a physical address"><div class="media"><picture><img src="virtaddress.svg" alt="Converting a virtual address to a physical address" class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>6<span>.</span>3<span>.</span>1<span> </span></span>Virtual Address Translation</div></header></div><p class="releaseinfo">We can follow this through for our previous example of a
      simple <em class="calibre5">linear</em> page-table.  We calculated
      that a 32-bit address-space would require a table of 1048576
      entries when using 4KiB pages.  Thus to map a theoretical
      address of 0x80001234, the first step would be to remove the
      offset bits.  In this case, with 4KiB pages, we know we have
      12-bits (2<sup class="calibre22">12</sup> == 4096) of offset.  So
      we would right-shift out 12-bits of the virtual address, leaving
      us with 0x80001.  Thus (in decimal) the value in row 524289 of
      the linear page table would be the physical frame corresponding
      to this page.</p><p class="releaseinfo">You might see a problem with a linear page-table: since
      every page must be accounted for, whether in use or not, a
      physically linear page-table is completely impractical with a
      64-bit address space.  Consider a 64-bit address space divided
      into 64 KiB pages creates
      2<sup class="calibre22">64</sup>/2<sup class="calibre22">16</sup> =
      2<sup class="calibre22">52</sup> pages to be managed; assuming
      each page requires an 8-byte pointer to a physical location a
      total of
      2<sup class="calibre22">52</sup>*2<sup class="calibre22">3</sup> =
      2<sup class="calibre22">55</sup> or 32 PiB of contiguous memory
      would be required just for the page table!  There are ways to
      split addressing up that avoid this which we will discuss
      later.</p></section></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="virtual_address_and_page_tables"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_42"><span class="first-last">7<span class="first-last"> </span></span>Consequences of virtual addresses, pages and page tables</h2></header><p class="releaseinfo">Virtual addressing, pages and page-tables are the basis of
    every modern operating system.  It under-pins most of the things
    we use our systems for.</p><section id="virtual_address_and_page_tables_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">7<span class="first-last">.</span>1<span class="first-last"> </span></span>Individual address spaces</h3></header><p class="releaseinfo">By giving each process its own page table, every process
        can pretend that it has access to the entire address space
        available from the processor.  It doesn't matter that two
        processes might use the same address, since different
        page-tables for each process will map it to a different frame
        of physical memory.  Every modern operating system provides
        each process with its own address space like this.</p><p class="releaseinfo">Over time, physical memory becomes
        <em class="calibre5">fragmented</em>, meaning that there are
        "holes" of free space in the physical memory.  Having to work
        around these holes would be at best annoying and would become
        a serious limit to programmers.  For example, if you
        <code class="computeroutput1">malloc</code> 8 KiB of memory;
        requiring the backing of two 4 KiB frames, it would be a huge
        unconvinced if those frames had to be contiguous (i.e.,
        physically next to each other).  Using virtual-addresses it
        does not matter; as far as the process is concerned it has 8
        KiB of contiguous memory, even if those pages are backed by
        frames very far apart.  By assigning a virtual address space
        to each process the programmer can leave working around
        fragmentation up to the operating system.</p></section><section id="protection"><header class="calibre8"><h3 class="calibre2"><span class="first-last">7<span class="first-last">.</span>2<span class="first-last"> </span></span>Protection</h3></header><p class="releaseinfo">We previously mentioned that the virtual mode of the 386
        processor is called protected mode, and this name arises from
        the protection that virtual memory can offer to processes
        running on it.</p><p class="releaseinfo">In a system without virtual memory, every process has
        complete access to all of system memory.  This means that
        there is nothing stopping one process from overwriting another
        processes memory, causing it to crash (or perhaps worse,
        return incorrect values, especially if that program is
        managing your bank account!)</p><p class="releaseinfo">This level of protection is provided because the operating
        system is now the layer of abstraction between the process and
        memory access.  If a process gives a virtual address that is
        not covered by its page-table, then the operating system knows
        that that process is doing something wrong and can inform the
        process it has stepped out of its bounds.</p><p class="releaseinfo">Since each page has extra attributes, a page can be set
      read only, write only or have any number of other interesting
      properties.  When the process tries to access the page, the
      operating system can check if it has sufficient permissions and
      stop it if it does not (writing to a read only page, for
      example).</p><p class="releaseinfo">Systems that use virtual memory are inherently more stable
      because, assuming the perfect operating system, a process can
      only crash itself and not the entire system (of course, humans
      write operating systems and we inevitably overlook bugs that can
      still cause entire systems to crash).</p></section><section id="virtual_address_and_page_tables_s3"><header class="calibre8"><h3 class="calibre2"><span class="first-last">7<span class="first-last">.</span>3<span class="first-last"> </span></span>Swap</h3></header><p class="releaseinfo">We can also now see how the swap memory is implemented.
        If instead of pointing to an area of system memory the page
        pointer can be changed to point to a location on a
        disk.</p><p class="releaseinfo">When this page is referenced, the operating system needs
        to move it from the disk back into system memory (remember,
        program code can only execute from system memory).  If system
        memory is full, then <em class="calibre5">another</em> page needs to
        be kicked out of system memory and put into the swap disk before
        the required page can be put in memory.  If another process
        wants that page that was just kicked out back again, the process
        repeats.</p><p class="releaseinfo">This can be a major issue for swap memory.  Loading from
        the hard disk is very slow (compared to operations done in
        memory) and most people will be familiar with sitting in front of
        the computer whilst the hard disk churns and churns whilst the
        system remains unresponsive.</p><section id="virtual_address_and_page_tables_s3_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">7<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last"> </span></span>mmap</h4></header><p class="releaseinfo">A different but related process is the memory map, or
          <code class="computeroutput1">mmap</code> (from the system call
          name).  If instead of the page table pointing to physical
          memory or swap the page table points to a file, on disk, we
          say the file is
          <code class="computeroutput1">mmap</code>ed.</p><p class="releaseinfo">Normally, you need to
          <code class="computeroutput1">open</code> a file on disk to
          obtain a file descriptor, and then
          <code class="computeroutput1">read</code> and
          <code class="computeroutput1">write</code> it in a sequential
          form.  When a file is mmaped it can be accessed just like
          system RAM.
        </p></section></section><section id="virtual_address_and_page_tables_s4"><header class="calibre8"><h3 class="calibre2"><span class="first-last">7<span class="first-last">.</span>4<span class="first-last"> </span></span>Sharing memory</h3></header><p class="releaseinfo">Usually, each process gets its own page table, so any
      address it uses is mapped to a unique frame in physical memory.
      But what if the operating system points two page table-entries
      to the same frame?  This means that this frame will be shared;
      and any changes that one process makes will be visible to the
      other.</p><p class="releaseinfo">You can see now how threads are implemented.  In <a href="csbu-print_split_024.html#linux_clone" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>4<span class="sep">.</span>3<span class="sep">.</span>1, </span><span>
            <code class="computeroutput1">clone</code>
          </span></span></a> we said that the Linux
      <code class="computeroutput1">clone()</code> function could share as
      much or as little of a new process with the old process as it
      required.  If a process calls
      <code class="computeroutput1">clone()</code> to create a new
      process, but requests that the two processes share the same page
      table, then you effectively have a <em class="calibre5">thread</em>
      as both processes see the same underlying physical
      memory.</p><p class="releaseinfo">You can also see now how copy on write is done.  If you
      set the permissions of a page to be read-only, when a process
      tries to write to the page the operating system will be
      notified.  If it knows that this page is a copy-on-write page,
      then it needs to make a new copy of the page in system memory
      and point the page in the page table to this new page.  This can
      then have its attributes updated to have write permissions and
      the process has its own unique copy of the page.</p></section><section id="virtual_address_and_page_tables_s5"><header class="calibre8"><h3 class="calibre2"><span class="first-last">7<span class="first-last">.</span>5<span class="first-last"> </span></span>Disk Cache</h3></header><p class="releaseinfo">In a modern system, it is often the case that rather than
      having too little memory and having to swap memory out, there is
      more memory available than the system is currently using.</p><p class="releaseinfo">The memory hierarchy tells us that disk access is much
      slower than memory access, so it makes sense to move as much
      data from disk into system memory if possible.</p><p class="releaseinfo">Linux, and many other systems, will copy data from files
      on disk into memory when they are used.  Even if a program only
      initially requests a small part of the file, it is highly likely
      that as it continues processing it will want to access the rest
      of file.  When the operating system has to read or write to a
      file, it first checks if the file is in its memory
      cache.</p><p class="releaseinfo">These pages should be the first to be removed as memory
      pressure in the system increases.</p><section id="virtual_address_and_page_tables_s5_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">7<span class="first-last">.</span>5<span class="first-last">.</span>1<span class="first-last"> </span></span>Page Cache</h4></header><p class="releaseinfo">A term you might hear when discussing the kernel is the
	<em class="calibre5">page cache</em>.</p><p class="releaseinfo">The <em class="calibre5">page cache</em> refers to a list of
      pages the kernel keeps that refer to files on disk.  From above,
      swap page, mmaped pages and disk cache pages all fall into this
      category.  The kernel keeps this list because it needs to be
      able to look them up quickly in response to read and write
      requests XXX: this bit doesn't file?</p></section></section></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="virtual_memory_hardware"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_43"><span class="first-last">8<span class="first-last"> </span></span>Hardware Support</h2></header><p class="releaseinfo">So far, we have only mentioned that hardware works with the
    operating system to implement virtual memory.  However we have
    glossed over the details of exactly how this happens.</p><p class="releaseinfo">Virtual memory is necessarily quite dependent on the
    hardware architecture, and each architecture has its own
    subtleties.  However, there are are a few universal elements to
    virtual memory in hardware.</p><section id="virtual_memory_hardware_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">8<span class="first-last">.</span>1<span class="first-last"> </span></span>Physical v Virtual Mode</h3></header><p class="releaseinfo">All processors have some concept of either operating in
      <em class="calibre5">physical</em> or <em class="calibre5">virtual</em>
      mode.  In physical mode, the hardware expects that any address
      will refer to an address in actual system memory.  In virtual
      mode, the hardware knows that addresses will need to be
      translated to find their physical address.</p><p class="releaseinfo">In many processors, this two modes are simply referred to
      as physical and virtual mode.  Itanium is one such example.  The
      most common processor, the x86, has a lot of baggage from days
      before virtual memory and so the two modes are referred to as
      <em class="calibre5">real</em> and <em class="calibre5">protected</em>
      mode.  The first processor to implement protected mode was the
      386, and even the most modern processors in the x86 family line
      can still do real mode, though it is not used.  In real mode the
      processor implements a form of memory organisation called
      segmentation.</p><section id="issues_with_segmentation"><header class="calibre8"><h4 class="calibre21"><span class="first-last">8<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>Issues with segmentation</h4></header><p class="releaseinfo">Segmentation is really only interesting as a historical
	note, since virtual memory has made it less relevant.
	Segmentation has a number of drawbacks, not the least of which
	it is very confusing for inexperienced programmers, which
	virtual memory systems were largely invented to get around.
	</p><p class="releaseinfo">In segmentation there are a number of registers which
	hold an address that is the start of a segment.  The only way
	to get to an address in memory is to specify it as an offset
	from one of these segment registers.  The size of the segment
	(and hence the maximum offset you can specify) is determined
	by the number of bits available to offset from segment base
	register.  In the x86, the maximum offset is 16 bits, or only
	64K<span id="issues_with_segmentation_para2_footnote1-fnote">Imagine that the maximum offset was 32
	bits; in this case the entire address space could be accessed
	as an offset from a segment at
	<code class="computeroutput1">0x00000000</code> and you would
	essentially have a flat layout -- but it still isn't as good as
	virtual memory as you will see.  In fact, the only reason it
	is 16 bits is because the original Intel processors were
	limited to this, and the chips maintain backwards
	compatibility.</span> .  This causes all sorts of
	havoc if one wants to use an address that is more than 64K
	away, which as memory grew into the megabytes (and now
	gigabytes) became more than a slight inconvenience to a complete
	failure.
	</p><div id="issues_with_segmentation_fig1" class="figure"><div class="author" summary="A segmentation problem. You only have three segment registers, and can only offset a short distance from each segment. How do you get to another address? You need to manually reorganise the segment registers, which quickly becomes a bottleneck."><div class="media"><picture><img src="segmentation.svg" alt="A segmentation problem. You only have three segment registers, and can only offset a short distance from each segment. How do you get to another address? You need to manually reorganise the segment registers, which quickly becomes a bottleneck." class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>8<span>.</span>1<span>.</span>1<span>.</span>1<span> </span></span>Segmentation</div></header></div><p class="releaseinfo">In the above figure, there are three segment registers
	which are all pointing to segments.  The maximum offset
	(constrained by the number of bits available) is shown by
	shading.  If the program wants an address outside this range,
	the segment registers must be reconfigured.  This quickly
	becomes a major annoyance.  Virtual memory, on the other hand,
	allows the program to specify any address and the operating
	system and hardware do the hard work of translating to a
	physical address.</p></section></section><section id="the_tlb"><header class="calibre8"><h3 class="calibre2"><span class="first-last">8<span class="first-last">.</span>2<span class="first-last"> </span></span>The TLB</h3></header><p class="releaseinfo">The <em class="calibre5">Translation Lookaside Buffer</em> (or
      TLB for short) is the main component of the processor
      responsible for virtual-memory.  It is a cache of virtual-page
      to physical-frame translations inside the processor.  The
      operating system and hardware work together to manage the TLB as
      the system runs.</p><section id="page_faults"><header class="calibre8"><h4 class="calibre21"><span class="first-last">8<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last"> </span></span>Page Faults</h4></header><p class="releaseinfo">When a virtual address is requested of the hardware
	  — say via a <code class="computeroutput1">load</code>
	  instruction requesting to get some data — the
	  processor looks for the virtual-address to physical-address
	  translation in its TLB.  If it has a valid translation it
	  can then combine this with the offset portion to go straight
	  to the physical address and complete the load.</p><p class="releaseinfo">However, if the processor can <em class="calibre5">not</em>
	find a translation in the TLB, the processor must raise a
	<em class="calibre5">page fault</em>.  This is similar to an
	interrupt (as discussed before) which the operating system
	must handle.</p><p class="releaseinfo">When the operating system gets a page fault, it needs to
	go through its page-table to find the correct translation and
	insert it into the TLB.</p><p class="releaseinfo"> In the case that the operating system can not find a
	translation in the page table, or alternatively if the
	operating system checks the permissions of the page in
	question and the process is not authorised to access it, the
	operating system must kill the process.  If you have ever seen
	a segmentation fault (or a segfault) this is the operating
	system killing a process that has overstepped its
	bounds.</p><p class="releaseinfo">Should the translation be found, and the TLB currently
	be full, then one translation needs to be removed before
	another can be inserted.  It does not make sense to remove a
	translation that is likely to be used in the future, as you
	will incur the cost of finding the entry in the page-tables
	all over again.  TLBs usually use something like a
	<em class="calibre5">Least Recently Used</em> or LRU algorithm,
	where the oldest translation that has not been used is ejected
	in favour of the new one.</p><p class="releaseinfo">The access can then be tried again, and, all going well,
	should be found in the TLB and translated correctly.</p><section id="page_faults_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">8<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>Finding the page table</h5></header><p class="releaseinfo">When we say that the operating system finds the
	  translation in the page table, it is logical to ask how the
	  operating system finds the memory that has the page
	  table.</p><p class="releaseinfo">The base of the page table will be kept in a register
	  associated with each process.  This is usually called the
	  page-table base-register or similar.  By taking the address
	  in this register and adding the page number to it, the
	  correct entry can be located.</p></section></section><section id="the_tlb_s2"><header class="calibre8"><h4 class="calibre21"><span class="first-last">8<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last"> </span></span>Other page related faults</h4></header><p class="releaseinfo">There are two other important faults that the TLB can
	generally generate which help to mange accessed and dirty
	pages.  Each page generally contains an attribute in the form
	of a single bit which flags if the page has been accessed or
	is dirty.</p><p class="releaseinfo">An accessed page is simply any page that has been
	accessed.  When a page translation is initially loaded into
	the TLB the page can be marked as having been accessed (else
	why were you loading it in?<span id="the_tlb_s2_para2_footnote1-fnote">Actually, if you
	were loading it in without a pending access this would be
	called <em class="calibre5">speculation</em>, which is where you do
	something with the expectation that it will pay off.  For
	example, if code was reading along memory linearly putting the
	next page translation in the TLB might save time and give a
	performance improvement.</span>)</p><p class="releaseinfo">The operating system can periodically go through
	<em class="calibre5">all</em> the pages and clear the accessed bit
	to get an idea of what pages are currently in use.  When
	system memory becomes full and it comes time for the operating
	system to choose pages to be swapped out to disk, obviously
	those pages whose accessed bit has not been reset are the best
	candidates for removal, because they have not been used the
	longest.</p><p class="releaseinfo">A dirty page is one that has data written to it, and so
	does not match any data already on disk.  For example, if a
	page is loaded in from swap and then written to by a process,
	before it can be moved out of swap it needs to have its on
	disk copy updated.  A page that is clean has had no changes,
	so we do not need the overhead of copying the page back to
	disk.</p><p class="releaseinfo">Both are similar in that they help the operating system
	to manage pages.  The general concept is that a page has two
	extra bits; the dirty bit and the accessed bit.  When the page
	is put into the TLB, these bits are set to indicate that the
	CPU should raise a fault .</p><p class="releaseinfo">When a process tries to reference memory, the hardware
	does the usual translation process.  However, it also does an
	extra check to see if the accessed flag is
	<em class="calibre5">not</em> set.  If so, it raises a fault to the
	operating system, which should set the bit and allow the
	process to continue.  Similarly if the hardware detects that
	it is writing to a page that does not have the dirty bit set,
	it will raise a fault for the operating system to mark the
	page as dirty.</p></section></section><section id="virtual_memory_hardware_s3"><header class="calibre8"><h3 class="calibre2"><span class="first-last">8<span class="first-last">.</span>3<span class="first-last"> </span></span>TLB Management</h3></header><p class="releaseinfo">We can say that the TLB used by the hardware but managed
      by software.  It is up to the operating system to load the TLB
      with correct entries and remove old entries.</p><section id="flushing_tlb"><header class="calibre8"><h4 class="calibre21"><span class="first-last">8<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last"> </span></span>Flushing the TLB</h4></header><p class="releaseinfo">The process of removing entries from the TLB is called
      <em class="calibre5">flushing</em>.  Updating the TLB is a crucial
      part of maintaining separate address spaces for processes; since
      each process can be using the same virtual address not updating
      the TLB would mean a process might end up overwriting another
      processes memory (conversely, in the case of
      <em class="calibre5">threads</em> sharing the address-space is what
      you want, thus the TLB is <em class="calibre5">not</em> flushed when
      switching between threads in the same process). </p><p class="releaseinfo">On some processors, every time there is a context switch
      the entire TLB is flushed.  This can be quite expensive, since
      this means the new process will have to go through the whole
      process of taking a page fault, finding the page in the page
      tables and inserting the translation.</p><p class="releaseinfo">Other processors implement an extra <em class="calibre5">address
      space ID</em> (ASID) which is added to each TLB
      translation to make it unique.  This means each address space
      (usually each process, but remember threads want to share the
      same address space) gets its own ID which is stored along with
      any translations in the TLB.  Thus on a context switch the TLB
      does <em class="calibre5">not</em> need to be flushed, since the next
      process will have a different address space ID and even if it
      asks for the same virtual address, the address space ID will
      differ and so the translation to physical page will be
      different.  This scheme reduces flushing and increases overall
      system performance, but requires more TLB hardware to hold the
      ASID bits.</p><p class="releaseinfo">Generally, this is implemented by having an additional
        register as part of the process state that includes the ASID.
        When performing a virtual-to-physical translation, the TLB
        consults this register and will only match those entries that
        have the same ASID as the currently running process.  Of
        course the width of this register determines the number of
        ASID's available and thus has performance implications.  For
        an example of ASID's in a processor architecture see <a href="csbu-print_split_039.html#itanium_address_spaces" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>1, </span><span>Address spaces</span></span></a>.</p></section><section id="virtual_memory_hardware_s3_s2"><header class="calibre8"><h4 class="calibre21"><span class="first-last">8<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last"> </span></span>Hardware v Software loaded TLB</h4></header><p class="releaseinfo">While the control of what ends up in the TLB is the
          domain of the operating system; it is not the whole story.
          The process described in <a href="#page_faults" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>8<span class="sep">.</span>2<span class="sep">.</span>1, </span><span>Page Faults</span></span></a>
          describes a page-fault being raised to the operating system,
          which traverses the page-table to find the
          virtual-to-physical translation and installs it in the TLB.
          This would be termed a <em class="calibre5">software-loaded
          TLB</em> — but there is another alternative; the
          <em class="calibre5">hardware-loaded TLB</em>.</p><p class="releaseinfo">In a hardware loaded TLB, the processor architecture
          defines a particular layout of page-table information (<a href="csbu-print_split_034.html#page_tables" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>5, </span><span>Pages + Frames = Page Tables</span></span></a> which must be followed for virtual
          address translation to proceed.  In response to access to a
          virtual-address that is not present in the TLB, the processor
          will automatically walk the page-tables to load the correct
          translation entry.  Only if the translation entry does not exist
          will the processor raise an exception to be handled by the
          operating system.
        </p><p class="releaseinfo">Implementing the page-table traversal in specialised
          hardware gives speed advantages when finding translations,
          but removes flexibility from operating-systems implementors
          who might like to implement alternative schemes for
          page-tables.</p><p class="releaseinfo">All architectures can be broadly categorised into these
          two methodologies.  Later, we will examine some common
          architectures and their virtual-memory support.</p></section></section></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="virtual_memory_linux"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_44"><span class="first-last">9<span class="first-last"> </span></span>Linux Specifics</h2></header><p class="releaseinfo">Although the basic concepts of virtual memory remain
    constant, the specifics of implementations are highly dependent
    on the operating system and hardware.</p><section id="virtual_memory_linux_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">9<span class="first-last">.</span>1<span class="first-last"> </span></span>Address Space Layout</h3></header><p class="releaseinfo">Linux divides the available address space up into a shared
      kernel component and private user space addresses.  This means
      that addresses in the kernel port of the address space map to
      the same physical memory for each process, whilst user-space
      addresses are private to the process.  On Linux, the shared
      kernel space is at the very top of the available address space.
      On the most common processor, the 32 bit x86, this split happens
      at the 3GB point.  As 32 bits can map a maximum of 4GB, this
      leaves the top 1GB for the shared kernel region<span id="virtual_memory_linux_s1_para1_footnote1-fnote">This is unfortunately an over-simplification, because many
      machines wanted to support more than 4GB per process.
      <em class="calibre5">High memory</em> support allows processors to
      get access to a full 4GB via special
      extensions.</span>.</p><div id="virtual_memory_linux_s1_fig1" class="figure"><div class="author" summary="The Linux address space layout. Note that pages in the user-space address space are private, whilst the kernel pages are shared."><div class="media"><picture><img src="linux-layout.svg" alt="The Linux address space layout. Note that pages in the user-space address space are private, whilst the kernel pages are shared." class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>9<span>.</span>1<span>.</span>1<span> </span></span>Linux address space layout</div></header></div></section><section id="three_level_page_table"><header class="calibre8"><h3 class="calibre2"><span class="first-last">9<span class="first-last">.</span>2<span class="first-last"> </span></span>Three Level Page Table</h3></header><p class="releaseinfo">There are many different ways for an operating system to
      organise the page tables but Linux chooses to use a
      <em class="calibre5">hierarchical</em> system.</p><p class="releaseinfo">As the page tables use a hierarchy that is three levels
      deep, the Linux scheme is most commonly referred to as the
      <em class="calibre5">three level page table</em>.  The three level
      page table has proven to be robust choice, although it is not
      without its criticism.  The details of the virtual memory
      implementation of each processor vary Whitley meaning that the
      generic page table Linux chooses must be portable and relatively
      generic.</p><p class="releaseinfo">The concept of the three level page table is not
      difficult.  We already know that a virtual address consists of a
      page number and an offset in the physical memory page.  In a
      three level page table, the virtual address is further split up
      into a number <em class="calibre5">levels</em>.</p><p class="releaseinfo">Each level is a page table of its own right; i.e. it maps
      a page number of a physical page.  In a single level page table
      the "level 1" entry would directly map to the physical frame.
      In the multilevel version each of the upper levels gives the
      address of the physical memory frame holding the next lower
      levels page table.</p><div id="three_level_page_table_fig1" class="figure"><div class="author" summary="A three level page table"><div class="media"><picture><img src="threelevel.svg" alt="A three level page table" class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>9<span>.</span>2<span>.</span>1<span> </span></span>Linux Three Level Page Table</div></header></div><p class="releaseinfo">So a sample reference involves going to the top level page
      table, finding the physical frame that the next level address is
      on, reading that levels table and finding the physical frame
      that the next levels page table lives on, and so on.</p><p class="releaseinfo">At first, this model seems to be needlessly complex.  The
      main reason this model is implemented is for size
      considerations.  Imagine the theoretical situation of a process
      with only one single page mapped right near the end of its
      virtual address space.  We said before that the page table entry
      is found as an offset from the page table base register, so the
      page table needs to be a contiguous array in memory.  So the
      single page near the end of the address space requires the
      entire array, which might take up considerable space (many, many
      physical pages of memory).</p><p class="releaseinfo">In a three level system, the first level is only one
      physical frame of memory.  This maps to a second level, which is
      again only a single frame of memory, and again with the third.
      Consequently, the three level system reduces the number of pages
      required to only a fraction of those required for the single
      level system.</p><p class="releaseinfo">There are obvious disadvantages to the system.  Looking up
      a single address takes more references, which can be expensive.
      Linux understands that this system may not be appropriate on
      many different types of processor, so each architecture can
      <em class="calibre5">collapse</em> the page table to have less levels
      easily (for example, the most common architecture, the x86, only
      uses a two level system in its implementation).</p></section></section></div></main>

<main class="calibre3">
<div id="chapter05" class="author">
<section id="hardware_support_for_virtual_memory"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_45"><span class="first-last">10<span class="first-last"> </span></span>Hardware support for virtual memory</h2></header><p class="releaseinfo">As covered in <a href="csbu-print_split_037.html#the_tlb" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>8<span class="sep">.</span>2, </span><span>The TLB</span></span></a>, the processor
    hardware provides a lookup-table that links virtual addresses to
    physical addresses.  Each processor architecture defines different
    ways to manage the TLB with various advantages and
    disadvantages.</p><p class="releaseinfo">The part of the processor that deals with virtual memory is
      generally referred to as the <em class="calibre5">Memory Management
        Unit</em> or MMU<span id="mmu"/>
    </p><section id="hardware_support_for_virtual_memory_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">10<span class="first-last">.</span>1<span class="first-last"> </span></span>x86-64</h3></header><p class="releaseinfo">XXX</p></section><section id="hardware_support_for_virtual_memory_s2"><header class="calibre8"><h3 class="calibre2"><span class="first-last">10<span class="first-last">.</span>2<span class="first-last"> </span></span>Itanium</h3></header><p class="releaseinfo">The Itanium MMU provides many interesting features for the
      operating system to work with virtual memory.</p><section id="itanium_address_spaces"><header class="calibre8"><h4 class="calibre21"><span class="first-last">10<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last"> </span></span>Address spaces</h4></header><p class="releaseinfo"><a href="csbu-print_split_037.html#flushing_tlb" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>8<span class="sep">.</span>3<span class="sep">.</span>1, </span><span>Flushing the TLB</span></span></a> introduced the
          concept of the <em class="calibre5">address-space ID</em> to
          reduce the overheads of flushing the TLB when context
          switching.  However, programmers often use
          <em class="calibre5">threads</em> to allow execution contexts to
          share an address space.  Each thread has the same ASID and
          hence shares TLB entries, leading to increased performance.
          However, a single ASID prevents the TLB from enforcing
          protection; sharing becomes an "all or nothing" approach.
          To share even a few bytes, threads must forgo all protection
          from each other (see also <a href="csbu-print_split_036.html#protection" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>7<span class="sep">.</span>2, </span><span>Protection</span></span></a>).</p><div id="ia64_regions_keys" class="figure"><div class="author" summary="Itanium regions and protection keys. In this example the processes alias region 1. Each process has a private mapping and they share a key for another."><div class="media"><picture><img src="ia64-regions-keys.svg" alt="Itanium regions and protection keys. In this example the processes alias region 1. Each process has a private mapping and they share a key for another." class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>10<span>.</span>2<span>.</span>1<span>.</span>1<span> </span></span>Illustration Itanium regions and protection keys</div></header></div><p class="releaseinfo">The Itanium MMU considers these problems and provides
          the ability to share an address space (and hence translation
          entries) at a much lower granularity whilst still
          maintaining protection within the hardware.  The Itanium
          divides the 64-bit address space up into 8
          <em class="calibre5">regions</em>, as illustrated in <a href="#ia64_regions_keys" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>1<span class="sep">.</span>1, </span><span>Illustration Itanium regions and protection keys</span></span></a>.  Each process has eight
          24-bit <em class="calibre5">region registers</em> as part of its
          state, which each hold a <em class="calibre5">region ID</em>
          (RID) for each of the eight regions of the process address
          space.  TLB translations are tagged with the RID and thus
          will only match if the process also holds this RID, as
          illustrated in <a href="#ia64_tlb_translation" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>1<span class="sep">.</span>2, </span><span>Illustration of Itanium TLB translation</span></span></a>.</p><div id="ia64_tlb_translation" class="figure"><div class="author" summary="Illustration of the Itanium translation process (Mosberger)."><div class="media"><picture><img src="ia64-tlb-translation.svg" alt="Illustration of the Itanium translation process (Mosberger)." class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>10<span>.</span>2<span>.</span>1<span>.</span>2<span> </span></span>Illustration of Itanium TLB translation</div></header></div><p class="releaseinfo">Further to this, the top three bits (the region bits)
          are not considered in virtual address translation.
          Therefore, if two processes share a RID (i.e., hold the same
          value in one of their region registers) then they have an
          aliased view of that region.  For example, if process-A
          holds RID <code class="computeroutput1">0x100</code> in
          region-register 3 and process-B holds the same RID
          <code class="computeroutput1">0x100</code> in region-register 5
          then process-A, region 3 is aliased to process-B, region 5.
          This limited sharing means both processes receive the
          benefits of shared TLB entries without having to grant
          access to their entire address space.</p><section id="itanium_address_spaces_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">10<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>Protection Keys</h5></header><p class="releaseinfo">To allow for even finer grained sharing, each TLB entry
        on the Itanium is also tagged with a <em class="calibre5">protection
        key</em>.  Each process has an additional number of
        <em class="calibre5">protection key registers</em> under
        operating-system control.</p><p class="releaseinfo">When a series of pages is to be shared (e.g., code for a
        shared system library), each page is tagged with a unique key
        and the OS grants any processes allowed to access the pages
        that key.  When a page is referenced the TLB will check the
        key associated with the translation entry against the keys the
        process holds in its protection key registers, allowing the
        access if the key is present or otherwise raising a
        <em class="calibre5">protection</em> fault to the operating system.</p><p class="releaseinfo">The key can also enforce permissions; for example, one
         process may have a key which grants write permissions and
         another may have a read-only key.  This allows for sharing of
         translation entries in a much wider range of situations with
         granularity right down to a single-page level, leading to
         large potential improvements in TLB performance.</p></section></section><section id="hardware_support_for_virtual_memory_s2_s2"><header class="calibre8"><h4 class="calibre21"><span class="first-last">10<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last"> </span></span>Itanium Hardware Page-Table Walker</h4></header><p class="releaseinfo">
        Switching context to the OS when resolving a TLB miss adds
        significant overhead to the fault processing path.  To combat
        this, Itanium allows the option of using built-in hardware to
        read the page-table and automatically load virtual-to-physical
        translations into the TLB.  The hardware page-table walker
        (HPW) avoids the expensive transition to the OS, but requires
        translations to be in a fixed format suitable for the hardware
        to understand.</p><p class="releaseinfo">The Itanium HPW is referred to in Intel's documentation
          as the <em class="calibre5">virtually hashed page-table
          walker</em> or VHPT walker, for reasons which should
          become clear.  Itanium gives developers the option of two
          mutually exclusive HPW implementations; one based on a
          virtual linear page-table and the other based on a hash
          table.</p><p class="releaseinfo">It should be noted it is possible to operate with no
        hardware page-table walker; in this case each TLB miss is
        resolved by the OS and the processor becomes a software-loaded
        architecture.  However, the performance impact of disabling
        the HPW is so considerable it is very unlikely any benefit
        could be gained from doing so</p><section id="virtual_linear_pagetable"><header class="calibre8"><h5 class="calibre24"><span class="first-last">10<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last"> </span></span>Virtual Linear Page-Table</h5></header><p class="releaseinfo">The virtual linear page-table implementation is
          referred to in documentation as the <em class="calibre5">short format
          virtually hashed page-table</em> (SF-VHPT).  It is the
          default HPW model used by Linux on Itanium.</p><p class="releaseinfo">The usual solution is a multi-level or hierarchical
            page-table, where the bits comprising the virtual page
            number are used as an index into intermediate levels of
            the page-table (see <a href="csbu-print_split_038.html#three_level_page_table" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>9<span class="sep">.</span>2, </span><span>Three Level Page Table</span></span></a>).  Empty regions
            of the virtual address space simply do not exist in the
            hierarchical page-table.  Compared to a linear page-table,
            for the (realistic) case of a tightly-clustered and
            sparsely-filled address space, relatively little space is
            wasted in overheads.  The major disadvantage is the
            multiple memory references required for lookup.</p><div id="hierarchical-pt" class="figure"><div class="author" summary="The hierarchical page-table"><div class="media"><picture><img src="hierarchical-pt.svg" alt="The hierarchical page-table" class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>10<span>.</span>2<span>.</span>2<span>.</span>1<span>.</span>1<span> </span></span>Illustration of a hierarchical page-table</div></header></div><p class="releaseinfo">With a 64-bit address space, even a 512~GiB linear
            table identified in <a href="csbu-print_split_035.html#virtual_address_translation" class="xref pcalibre"><span><span>Section<span class="sep"> </span></span><span>6<span class="sep">.</span>3, </span><span>Virtual Address Translation</span></span></a> takes only
            0.003% of the 16-exabytes available.  Thus a
            <em class="calibre5">virtual linear page-table</em> (VLPT) can
            be created in a contiguous area of
            <em class="calibre5">virtual</em> address space.</p><p class="releaseinfo">Just as for a physically linear page-table, on a TLB
            miss the hardware uses the virtual page number to offset
            from the page-table base.  If this entry is valid, the
            translation is read and inserted directly into the TLB.
            However, with a VLPT the address of the translation entry
            is itself a virtual address and thus there is the
            possibility that the virtual page which it resides in is
            not present in the TLB.  In this case a <em class="calibre5">nested
            fault</em> is raised to the operating system.  The
            software must then correct this fault by mapping the page
            holding the translation entry into the VLPT.</p><div id="ia64_short_format" class="figure"><div class="author" summary="Operation of the Itanium short-format VHPT"><div class="media"><picture><img src="ia64-short-format.svg" alt="Operation of the Itanium short-format VHPT" class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>10<span>.</span>2<span>.</span>2<span>.</span>1<span>.</span>2<span> </span></span>Itanium short-format VHPT implementation</div></header></div><p class="releaseinfo">This process can be made quite straight forward if the
            operating system keeps a hierarchical page-table.  The
            leaf page of a hierarchical page-table holds translation
            entries for a virtually contiguous region of addresses and
            can thus be mapped by the TLB to create the VLPT as
            described in <a href="#ia64_short_format" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>2<span class="sep">.</span>1<span class="sep">.</span>2, </span><span>Itanium short-format VHPT implementation</span></span></a>.</p><div id="ia64_ptes" class="figure"><div class="author" summary="Itanium PTE entry formats"><div class="media"><picture><img src="ia64-ptes.svg" alt="Itanium PTE entry formats" class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>10<span>.</span>2<span>.</span>2<span>.</span>1<span>.</span>3<span> </span></span>Itanium PTE entry formats</div></header></div><p class="releaseinfo">The major advantage of a VLPT occurs when an
            application makes repeated or contiguous accesses to
            memory.  Consider that for a walk of virtually contiguous
            memory, the first fault will map a page full of
            translation entries into the virtual linear page-table.  A
            subsequent access to the next virtual page will require
            the next translation entry to be loaded into the TLB,
            which is now available in the VLPT and thus loaded very
            quickly and without invoking the operating system.
            Overall, this will be an advantage if the cost of the
            initial nested fault is amortised over subsequent HPW
            hits.</p><p class="releaseinfo">The major drawback is that the VLPT now requires TLB
            entries which causes an increase on TLB pressure.  Since
            each address space requires its own page table the
            overheads become greater as the system becomes more
            active.  However, any increase in TLB capacity misses
            should be more than regained in lower refill costs from
            the efficient hardware walker.  Note that a pathological
            case could skip over
            <code class="computeroutput1">page_size</code> ÷
            <code class="computeroutput1">translation_size</code> entries,
            causing repeated nested faults, but this is a very
            unlikely access pattern.</p><p class="releaseinfo">The hardware walker expects translation entries in a
            specific format as illustrated on the left of <a href="#ia64_ptes" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>2<span class="sep">.</span>1<span class="sep">.</span>3, </span><span>Itanium PTE entry formats</span></span></a>.  The VLPT requires
            translations in the so-called 8-byte <em class="calibre5">short
            format</em>.  If the operating system is to use its
            page-table as backing for the VLPT (as in <a href="#ia64_short_format" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>2<span class="sep">.</span>1<span class="sep">.</span>2, </span><span>Itanium short-format VHPT implementation</span></span></a>) it must use this
            translation format.  The architecture describes a limited
            number of bits in this format as ignored and thus
            available for use by software, but significant
            modification is not possible.</p><p class="releaseinfo">A linear page-table is premised on the idea of a fixed
            page size.  Multiple page-size support is problematic
            since it means the translation for a given virtual page is
            no longer at a constant offset.  To combat this, each of
            the 8-regions of the address space (<a href="#ia64_regions_keys" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>1<span class="sep">.</span>1, </span><span>Illustration Itanium regions and protection keys</span></span></a>) has a separate VLPT
            which only maps addresses for that region.  A default
            page-size can be given for each region (indeed, with Linux
            HugeTLB, discussed below, one region is dedicated to
            larger pages).  However, page sizes can not be mixed
            within a region.</p></section><section id="hardware_support_for_virtual_memory_s2_s2_s2"><header class="calibre8"><h5 class="calibre24"><span class="first-last">10<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last"> </span></span>Virtual Hash Table</h5></header><p class="releaseinfo">Using TLB entries in an effort to reduce TLB refill
            costs, as done with the SF-VHPT, may or may not be an
            effective trade-off.  Itanium also implements a
            <em class="calibre5">hashed page-table</em> with the potential
            to lower TLB overheads.  In this scheme, the processor
            <em class="calibre5">hashes</em> a virtual address to find an
            offset into a contiguous table.</p><p class="releaseinfo">The previously described physically linear page-table
            can be considered a hash page-table with a
            <em class="calibre5">perfect</em> hash function which will
            never produce a collision.  However, as explained, this
            requires an impractical trade-off of huge areas of
            contiguous physical memory.  However, constraining the
            memory requirements of the page table raises the
            possibility of collisions when two virtual addresses hash
            to the same offset.  Colliding translations require a
            <em class="calibre5">chain</em> pointer to build a linked-list
            of alternative possible entries.  To distinguish which
            entry in the linked-list is the correct one requires a
            <em class="calibre5">tag</em> derived from the incoming virtual
            address.</p><p class="releaseinfo">The extra information required for each translation
            entry gives rise to the moniker
            <em class="calibre5">long-format</em>~VHPT (LF-VHPT).
            Translation entries grow to 32-bytes as illustrated on the
            right hand side of <a href="#ia64_ptes" class="xref pcalibre"><span><span>Figure<span class="sep"> </span></span><span>10<span class="sep">.</span>2<span class="sep">.</span>2<span class="sep">.</span>1<span class="sep">.</span>3, </span><span>Itanium PTE entry formats</span></span></a>.</p><p class="releaseinfo">The main advantage of this approach is the global hash
            table can be pinned with a single TLB entry.  Since all
            processes share the table it should scale better than the
            SF-VHPT, where each process requires increasing numbers of
            TLB entries for VLPT pages.  However, the larger entries
            are less cache friendly; consider we can fit four 8-byte
            short-format entries for every 32-byte long-format entry.
            The very large caches on the Itanium processor may help
            mitigate this impact, however.</p><p class="releaseinfo">One advantage of the SF-VHPT is that the operating
            system can keep translations in a hierarchical page-table
            and, as long as the hardware translation format is
            maintained, can map leaf pages directly to the VLPT.  With
            the LF-VHPT the OS must either use the hash table as the
            primary source of translation entries or otherwise keep
            the hash table as a cache of its own translation
            information.  Keeping the LF-VHPT hash table as a cache is
            somewhat sub-optimal because of increased overheads on time
            critical fault paths, however advantages are gained from
            the table requiring only a single TLB entry.</p></section></section></section></section></div><div id="chapter06" class="author"><header class="calibre6"><div class="calibre10" id="calibre_pb_46"/>
</header></div></main></body></html>