- en: The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/Chapter2.html](https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/Chapter2.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Chapter 2: Mysterious MySQL Problems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL, the most popular open-source database software with a history spanning
    several decades, is renowned for its simplicity and user-friendly nature, making
    it a cornerstone choice among internet companies. Despite its widespread adoption,
    MySQL faces a variety of challenges.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces nine puzzling MySQL problems or phenomena that serve
    as examples and lay the groundwork for deeper exploration in subsequent topics.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 SysBench Read-Write Test Demonstrates Super-Linear Throughput Growth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the MySQL 8.0.27 release version, for example, in a 4-way NUMA environment
    on x86 architecture, using SysBench to remotely test MySQL’s read-write capabilities.
    The MySQL transaction isolation level is set to Read Committed. MySQL instances
    1 and 2 are deployed on the same machine, with a testing duration of 60 seconds.
    The results of separate SysBench tests for MySQL instance 1 and instance 2 are
    shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829081346732](../Images/4b0375da1bd67aa5ba01e20bbf59ae04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Throughput of MySQL running separately.
  prefs: []
  type: TYPE_NORMAL
- en: The throughput of each instance is modest, with figures of 172,781 QPS and 155,387
    QPS respectively. When combined, the two instances achieve a total throughput
    of 328,168 QPS. When using SysBench to simultaneously test the read and write
    capabilities of these two instances, the obtained throughputs are 271,232 QPS
    and 275,197 QPS respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829204745429](../Images/1a8e24e554d620728c802e02cdbc9cfa.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Throughput of MySQL running together.
  prefs: []
  type: TYPE_NORMAL
- en: The combined throughput of the two MySQL instances is 546,429 QPS. This data
    demonstrates that when these two MySQL instances share the same machine, the combined
    throughput is significantly higher than the sum of their individual throughputs
    when run separately. For detailed statistical comparisons, please refer to the
    following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829081541149](../Images/247c0a2d6a11182b31da63d83b2a657b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Total throughput of running separately vs. running together.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of mathematical logic, if the total throughput when running two instances
    together is roughly equal to the sum of the throughputs when running them separately,
    it represents a linear relationship. If the combined throughput exceeds this sum,
    it suggests a super-linear relationship.
  prefs: []
  type: TYPE_NORMAL
- en: What drives super-linear relationships? Does MySQL exhibit super-linear behavior?
    Understanding this requires a deep dive into computer fundamentals and advanced
    MySQL concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Unexpected Decline in TPC-C Throughput After Applying PGO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Profile-guided optimization (PGO) is a well-established technique for improving
    compile-time optimization decisions. Profile information is collected through
    instrumentation or sampling of the executable, and this data is used to optimize
    the executables it was gathered from [45]. Despite its effectiveness, PGO has
    not been widely adopted by software projects due to its cumbersome dual-compilation
    model. Nevertheless, PGO remains a highly valuable optimization technique to consider
    for improving MySQL performance, as it theoretically has the potential to significantly
    improve MySQL’s efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram illustrates the application of PGO to higher versions
    of MySQL 8.0.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ae99fcd5e823f541d7fefb98808bda0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4\. Using PGO in higher versions of MySQL 8.0: a step-by-step guide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the diagram, the Profile-Guided Optimization (PGO) mechanism involves
    several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, compile a specific version of MySQL with the compilation option *“-DFPROFILE_GENERATE=ON”*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start this MySQL version and capture training data by running performance tests
    such as TPC-C, which helps collect performance metrics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completing the training phase, perform a second compilation with the option
    *“-DFPROFILE_USE=ON”*. During this compilation, the compiler automatically utilizes
    the gathered statistical data to optimize conditional branches and related aspects,
    significantly improving the performance of the resulting MySQL executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following figure illustrates the relationship between throughput and concurrency
    before and after applying PGO to MySQL 8.0.27.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829081620633](../Images/b6b04f80128c2493951ed2b7e22a25e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Performance comparison tests before and after using PGO in MySQL
    8.0.27.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the figure, it’s evident that PGO leads to notable improvements in
    MySQL throughput at lower concurrency levels. However, beyond 150 concurrency,
    both the overall throughput and peak performance show a decline.
  prefs: []
  type: TYPE_NORMAL
- en: Does PGO primarily benefit low-concurrency scenarios, or are there additional
    factors limiting its effectiveness? This question delves into queueing theory
    and system architecture. Further exploration of practical computer fundamentals
    will provide deeper insights into this matter.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Adverse Effects of Thread Pool on MySQL After Scalability Enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After applying various scalability patches to MySQL 8.0.27, it’s crucial to
    evaluate whether the Percona thread pool still effectively addresses scalability
    problems. The following figure depicts the results of TPC-C testing on a standalone
    MySQL instance using BenchmarkSQL. The deep blue line indicates the configuration
    with the Percona thread pool enabled (thread pool size = 128), while the deep
    red line represents the configuration with the thread pool disabled. The test
    covered concurrency levels ranging from 50 to 2000, utilizing a database with
    1000 warehouses.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829081719592](../Images/19020790b6e4bb0ba79c70e5806c1b1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Enabling the Percona thread pool resulted in a significant reduction
    in throughput compared to when it was disabled.
  prefs: []
  type: TYPE_NORMAL
- en: From the figure, it is clear that enabling the Percona thread pool clearly led
    to a significant decrease in throughput compared to having it disabled. Notably,
    even without the thread pool enabled, MySQL 8.0 showed a marked improvement in
    scalability compared to MySQL 5.7\. This suggests that the additional benefit
    of using the Percona thread pool for improving TPC-C testing was limited. Moreover,
    the Percona thread pool mechanism itself introduces overhead, which is reflected
    in the figure’s results.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to acknowledge that the Percona thread pool remains valuable
    in scenarios involving frequent connection creation and severe contention. However,
    the key question remains: what exactly contributed to such significant improvements
    in MySQL scalability? Future chapters will explore these mysteries further.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 In MySQL 8.0, TPC-C Throughput Drops Too Quickly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standards for long-term TPC-C testing are as follows: the TPC-C benchmark
    requires that the database run for at least eight hours with jitters less than
    2% in two hours [14].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on MySQL 8.0.27, long-term TPC-C testing was conducted using the BenchmarkSQL
    tool. Below are the BenchmarkSQL testing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the above, it can be seen that there are 1000 warehouses, with a concurrency
    of 200, and terminalWarehouseFixed is set to false. This setting enables each
    transaction to use a different warehouse ID every time, thereby accessing data
    across all warehouses.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure illustrates the throughput over time during long-term testing.
    The TPC-C throughput shows a decline rate that significantly surpasses expectations,
    nearing a 50% decrease.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-degrade](../Images/fb8512e9e16a446b64ce536566d96926.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Performance degradation exposed during BenchmarkSQL testing of
    MySQL 8.0.27.
  prefs: []
  type: TYPE_NORMAL
- en: This problem was identified during testing using BenchmarkSQL and may not necessarily
    occur with other TPC-C testing tools. As of the current version, MySQL 8.0.40,
    the problem of rapid throughput decline has not been fully solved. Subsequent
    chapters will delve into detailed explanations of the underlying causes of this
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Repeatable Read Surprisingly Outperforms Read Committed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transaction isolation is fundamental to database processing, represented by
    the ‘I’ in the ACID acronym. The isolation level determines the balance between
    performance and the reliability, consistency, and predictability of results when
    multiple transactions concurrently make changes and queries. Commonly used isolation
    levels are Read Committed, Repeatable Read, and Serializable. By default, InnoDB
    uses Repeatable Read.
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB employs distinct locking strategies for each isolation level, impacting
    query locking behavior under concurrent conditions. Depending on the isolation
    level, queries may need to wait for locks currently held by other sessions before
    execution begins [13]. There’s a common perception that stricter isolation levels
    can degrade performance. How does MySQL perform in practical scenarios?
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests were conducted across Serializable, Repeatable Read (RR), and Read Committed
    (RC) isolation levels using two benchmark types: SysBench uniform and pareto tests.
    The SysBench uniform test simulates low-conflict scenarios, while the SysBench
    pareto test models high-conflict situations. Due to excessive deadlock logs generated
    during the SysBench pareto test, which significantly interfered with performance
    analysis, these logs were suppressed by modifying the source code to ensure fair
    testing conditions. Moreover, the MySQL testing program utilized a modified version
    for accuracy, rather than the original version.'
  prefs: []
  type: TYPE_NORMAL
- en: The figure below presents results from the SysBench uniform test, where concurrency
    increases from 50 to 800 in doubling increments. Given the few conflicts in this
    test type, there is little variation in throughput among the three transaction
    isolation levels at low concurrency levels. However, beyond 400 concurrency, the
    throughput of the Serializable isolation level exhibits a notable decline.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829151823981](../Images/9cc90a9a314099d2959fdca30879ba7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. SysBench read-write performance comparison with low conflicts under
    different isolation levels.
  prefs: []
  type: TYPE_NORMAL
- en: Below 400 concurrency, the differences are minor because of fewer conflicts
    in the uniform test. With fewer conflicts, the impact of lock strategies under
    different transaction isolation levels is reduced. However, Read Committed is
    mainly constrained by frequent acquisition of MVCC ReadView, resulting in performance
    inferior to Repeatable Read.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the SysBench test under pareto distribution conditions, specific
    comparative test results can be seen in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829081950365](../Images/863a6a952f8f78d9ba4db908e60ab73c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. SysBench read-write performance comparison with high conflicts
    under different isolation levels.
  prefs: []
  type: TYPE_NORMAL
- en: The figure clearly illustrates that in scenarios with significant conflicts,
    performance differences due to lock strategies under different transaction isolation
    levels are pronounced. As anticipated, higher transaction isolation levels generally
    exhibit lower throughput, particularly under severe conflict conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In scenarios with few conflicts, performance is primarily constrained by the
    overhead of acquiring ReadView in MVCC. This is because, under the Read Committed
    isolation level, MySQL must copy the entire active transaction list each time
    it reads from the global active transaction list, whereas under Repeatable Read,
    it only needs to obtain a copy of the active transaction list at the start of
    the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, in low-conflict tests like SysBench uniform, the overhead of MVCC
    ReadView is the predominant bottleneck, outweighing lock overhead. Consequently,
    Repeatable Read performs better than Read Committed. Conversely, in high-conflict
    tests like SysBench pareto, lock overhead becomes the primary bottleneck, resulting
    in Read Committed outperforming Repeatable Read.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Group Replication Throughput Lower Than Semisynchronous Replication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During Group Replication operation, a certification database is maintained.
    Regular cleanup of outdated certification information is crucial to manage memory
    usage efficiently. However, this cleanup process involves acquiring a global latch,
    temporarily pausing MySQL primary execution until the certification information
    is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, traditional semisynchronous replication requires the MySQL secondary
    to process a substantial amount of relay log event information. Only after these
    relay log events are written to disk can the secondary send acknowledgment (ack)
    information back to the MySQL primary. This process includes network interactions,
    handling numerous relay log events, and disk flushes, resulting in relatively
    longer response times for semisynchronous replication.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, with semisynchronous replication, the MySQL primary must wait for acknowledgment
    from the MySQL secondary after relay log events are written to disk before it
    can proceed. In contrast, Group Replication continues processing once consensus
    is achieved at the Paxos layer, without waiting for log writes at that layer.
    Theoretically, Group Replication can achieve higher throughput.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario of a two-node cluster, TPC-C throughput comparisons based on
    concurrency were conducted between Group Replication and semisynchronous replication.
    Please refer to the following figure for details.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829082024079](../Images/9351e17f8c92f4f061ee17c5acaeecd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10\. Performance comparison between Group Replication and semisynchronous
    replication.
  prefs: []
  type: TYPE_NORMAL
- en: The figure indicates that under low concurrency, semisynchronous replication
    outperforms Group Replication, whereas Group Replication shows superior performance
    under high concurrency. Semisynchronous replication reaches its peak performance
    at 100 concurrency, whereas Group Replication peaks at 250 concurrency but offers
    lower peak performance than semisynchronous replication. These test results are
    unexpected. What could be the problem?
  prefs: []
  type: TYPE_NORMAL
- en: The root problem lies in the certification database mechanism used by Group
    Replication, which is absent in semisynchronous replication. This mechanism involves
    substantial memory allocation and deallocation, significantly limiting throughput
    improvement. Despite not requiring Paxos log persistence, this bottleneck negates
    the advantages of Group Replication. It is clear that the implementation of the
    certification database mechanism poses the primary performance challenge for Group
    Replication.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Modified Group Replication Outperforms Semisynchronous Replication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Group Replication has been extensively enhanced while addressing scalability
    problems in MySQL 8.0.32\. To validate these improvements, simultaneous testing
    of semisynchronous replication and Group Replication with Paxos log persistence
    was conducted. The deployment setup included two-node configurations for both
    semisynchronous and Group Replication, hosted on the same machine with independent
    NVMe SSDs and NUMA binding to isolate each node. Specifically, the MySQL primary
    utilized NUMA nodes 0 to 2, while the MySQL secondary utilized NUMA node 3\. All
    settings, except those directly related to semisynchronous or Group Replication
    configurations, remained identical.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the throughput comparison of semisynchronous replication
    and Group Replication with Paxos log persistence under different concurrency levels.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829082055680](../Images/425d17eb1164f66705bb88ac813356d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-11\. Performance comparison between Group Replication with Paxos log
    persistence and semisynchronous replication.
  prefs: []
  type: TYPE_NORMAL
- en: Both employ persistence mechanisms, with Group Replication utilizing Paxos log
    persistence and semisynchronous replication utilizing relay log persistence. Due
    to these distinct mechanisms, Group Replication with Paxos log persistence demonstrates
    significantly superior performance compared to semisynchronous replication.
  prefs: []
  type: TYPE_NORMAL
- en: Meta Company has implemented a MySQL high availability solution based on Raft.
    According to tests conducted by Meta Company developers, the performance of the
    Raft-based improved version is comparable to that of semisynchronous replication.
    For specific details, refer to the figure below [42].
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/237394cba6704ecede134066d538b56d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-12\. Throughput comparison borrowed from Meta paper.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, Group Replication can leverage a batching-based disk persistence
    mechanism, eliminating the need to process binlog events during disk writes, thereby
    achieving higher expected throughput. Future chapters will delve into detailed
    discussions on modifying Group Replication and examining specific factors contributing
    to the scalability challenges of native semisynchronous replication.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 SysBench Shows No Effect, TPC-C Performs Well
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The specifics of the lock-sys optimization in MySQL 8.0 are detailed below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This represents a scalability improvement in MySQL 8.0 by addressing the global
    latch bottleneck and optimizing lock scheduling in InnoDB. To validate the effectiveness
    of this lock-sys optimization, refer to the specific test results illustrated
    in the figure below using SysBench read-write tests.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829082201268](../Images/705d7cb4c07b467983305f07877a5508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-13\. Comparison of SysBench read-write tests before and after lock-sys
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: It’s surprising that after implementing the lock-sys optimization, the throughput
    decreased, which was unexpected. To mitigate interference from NUMA compatibility
    problems in MySQL code, the MySQL running instance was bound to NUMA node 0 (similar
    to an SMP environment). The test results are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829082231096](../Images/8fdedabe9286e8570b48c7ff839fbb24.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-14\. Comparison of SysBench read-write tests before and after lock-sys
    optimization under SMP.
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows that the difference before and after optimization is minimal,
    almost negligible. This suggests that during the testing process, the effectiveness
    of the lock-sys optimization is overshadowed by other factors, resulting in distorted
    test results. However, binding to NUMA node 0 reduced interference from other
    bottlenecks, narrowing the performance gap. It also indicates that the lock-sys
    optimization has limited impact on SysBench standard read-write tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using BenchmarkSQL for TPC-C testing, the results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829082255780](../Images/0dcf63ede0309279dce727da79852a49.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-15\. Comparison of BenchmarkSQL tests before and after lock-sys optimization.
  prefs: []
  type: TYPE_NORMAL
- en: The figure demonstrates a noticeable improvement from the lock-sys optimization.
    However, it raises questions as to why SysBench testing shows no effect while
    BenchmarkSQL testing does. Understanding the differences between these two tools
    and important considerations during testing will be thoroughly discussed in upcoming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Is Disabling NUMA Really Beneficial for MySQL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The impact of disabling NUMA on the MySQL primary was initially tested. The
    deployment setup was as follows: BenchmarkSQL high-pressure stress tests were
    conducted on two x86 machines with identical hardware configurations. One machine
    had NUMA disabled in the BIOS, while the other had NUMA enabled. The comparison
    of TPC-C throughput versus concurrency is illustrated in the figure below.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829082344150](../Images/9504f742addd5d137a4c93010b1c9795.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-16\. Significantly improved TPC-C throughput by disabling NUMA in the
    BIOS.
  prefs: []
  type: TYPE_NORMAL
- en: The figure demonstrates that disabling NUMA on x86 machines significantly improves
    TPC-C throughput. This improvement stems from the favorable memory allocation
    mechanism after disabling NUMA in the BIOS, particularly beneficial for applications
    like MySQL primary servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, does disabling NUMA also benefit MySQL secondary replay? Using the same
    machines mentioned earlier for testing, the setup details are as follows: in the
    environment where NUMA is disabled in the BIOS, NUMA binding cannot be utilized,
    allowing all memory to be utilized. Conversely, in the environment where NUMA
    is enabled in the BIOS, MySQL secondaries are bound to NUMA node 0\. The following
    figure illustrates the balanced replay speeds tested in these different environments.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image-20240829082406694](../Images/86aa08156ec12b7b94a09fa1d35169a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-17\. Comparison of balanced replay speed before and after disabling
    NUMA in the BIOS.
  prefs: []
  type: TYPE_NORMAL
- en: The figure reveals that disabling NUMA at the BIOS level results in a balanced
    replay speed of only around 570,000 tpmC, primarily due to the unsolved NUMA unfriendliness
    problems with MySQL secondaries. In contrast, enabling NUMA and binding MySQL
    secondaries to a single NUMA node can achieve a balanced replay speed exceeding
    810,000 tpmC. This test highlights the disadvantage of disabling NUMA at the BIOS
    level for MySQL secondary replay efficiency. Effective MySQL secondary replay
    with NUMA disabled necessitates addressing these NUMA unfriendliness problems,
    as failure to do so significantly reduces efficiency. The upcoming Chapter 10
    on improving MySQL secondary replay will provide a detailed examination of these
    NUMA unfriendliness problems.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter delves into classic and intricate MySQL problems, which pose significant
    challenges for analysis. The resolution of these problems begins with a detailed
    logical analysis, as outlined in the following chapter. Addressing and solving
    these problems necessitates a profound understanding of computer fundamentals
    and MySQL internals. Computer fundamentals encompass a broad range of topics including
    computer architecture, data structures, algorithms, operating systems, computer
    networks, compilers, queueing theory, and distributed systems theory, among others.
    These topics will be thoroughly explored in Chapter 4\. Chapter 5 will focus specifically
    on MySQL internals.
  prefs: []
  type: TYPE_NORMAL
- en: '[Next](/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/Part2.html)'
  prefs: []
  type: TYPE_NORMAL
