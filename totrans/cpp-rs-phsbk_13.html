<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Inheritance and implementation reuse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Inheritance and implementation reuse</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/data_modeling/inheritance_and_reuse.html">https://cel.cs.brown.edu/crp/idioms/data_modeling/inheritance_and_reuse.html</a></blockquote>
                        
<p>Rust does not have inheritance and so the primary means of reuse of
implementations in Rust are composition, aggregation, and
<a href="./templates.html">generics</a>.</p>
<p>However, Rust traits do have support for default methods which resemble one
simple case of using inheritance for reuse of implementations. For example, in
the following example two virtual methods are used to support a method whose
implementation is provided by the abstract class.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

class Device {
public:
    virtual void powerOn() = 0;
    virtual void powerOff() = 0;

    virtual void resetDevice() {
        std::cout &lt;&lt; "Resetting device..." &lt;&lt; std::endl;
        powerOff();
        powerOn();
    }

    virtual ~Device() {}
};

class Printer : public Device {
    bool powered = false;
public:
    void powerOn() override {
        this.powered = true;
        std::cout &lt;&lt; "Printer is powered on." &lt;&lt; std::endl;
    }

    void powerOff() override {
        this.powered = false;
        std::cout &lt;&lt; "Printer is powered off." &lt;&lt; std::endl;
    }
};

int main() {
    Printer myPrinter;
    myPrinter.resetDevice();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">trait Device {
    fn power_on(&amp;mut self);
    fn power_off(&amp;mut self);

    fn reset_device(&amp;mut self) {
        println!("Resetting device...");
        self.power_off();
        self.power_on();
    }
}

struct Printer {
    powered: bool,
}

impl Printer {
    fn new() -&gt; Printer {
        Printer { powered: false }
    }
}

impl Device for Printer {
    fn power_on(&amp;mut self) {
        self.powered = true;
        println!("Printer is powered on");
    }

    fn power_off(&amp;mut self) {
        self.powered = false;
        println!("Printer is powered off");
    }
}

fn main() {
    let mut p = Printer::new();
    p.reset_device();
}</code></pre></pre>
</div>
<p>In practice, the <code>resetDevice()</code> method in the <code>Device</code> class might be made
non-virtual in C++ if it is not expected that it will be overridden. In order to
make it align with the Rust example, we have made it virtual here, since Rust
traits can be used either for <a href="./abstract_classes.html">dynamic
dispatch</a> or <a href="./concepts.html">static
dispatch</a> (with <a href="./abstract_classes.html#vtables-and-rust-trait-object-types">no vtable overhead in the
static dispatch
case</a>).</p>
<p>Rust traits differ from abstract classes in few more ways. For example,
Rust traits cannot define data members and cannot define private or protected
methods. This limits the effectiveness of using traits to implement the template
method pattern.</p>
<p>Rust traits also cannot be privately implemented. Anywhere that both a trait
and a type that implements that trait are visible, the methods of the trait are
visible as methods on the type.</p>
<p>Traits can, however, inherit from each other, including multiple inheritance. As
in modern C++, inheritance hierarchies in Rust tend to be shallow. In situations
with complex multiple inheritance, however, the diamond problem cannot arise in
Rust because traits cannot override other traits implementations. Therefore, all
paths to a common parent trait resolve to the same implementation.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;inheritance_and_reuse&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Unlike with a C++ parent class, the default method is not part of `BareLogger`,\neven when accessed statically via the trait.\n&quot;,&quot;id&quot;:&quot;2bc058d0-99e4-44e0-9abe-5497b713731e&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;a message\nan error\nanother message\nanother error\n&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;trait Logger {\n    fn log(&amp;self, message: &amp;str);\n\n    fn error(&amp;self, message: &amp;str) {\n        self.log(&amp;format!(\&quot;ERROR: {}\&quot;, message));\n    }\n}\n\nstruct BareLogger;\n\nimpl Logger for BareLogger {\n    fn log(&amp;self, message: &amp;str) {\n        println!(\&quot;{}\&quot;, message);\n    }\n\n    fn error(&amp;self, message: &amp;str) {\n        // Omits the ERROR: prefix\n        println!(\&quot;{}\&quot;, message)\n    }\n}\n\nfn main() {\n    let logger = BareLogger;\n    logger.log(\&quot;a message\&quot;);\n    logger.error(\&quot;an error\&quot;);\n    &lt;BareLogger as Logger&gt;::log(&amp;logger, \&quot;another message\&quot;);\n    &lt;BareLogger as Logger&gt;::error(&amp;logger, \&quot;another error\&quot;);\n}\n&quot;}},{&quot;context&quot;:&quot;A trait only defines an interface, with the ability to define default methods as\na convenience for when some methods on the trait can be defined in terms of\nothers.\n&quot;,&quot;id&quot;:&quot;78c03495-5d3d-4faf-8375-b9f338a377ff&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;It does not compile because in Rust traits cannot have fields.\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;It does compile.\n&quot;,&quot;It does not compile, because `health` isn't initialized when `Enemy` implements\n`Damageable`.\n&quot;,&quot;It does not compile, because `e.health` isn't initialized before using `e` in\n`main`.\n&quot;],&quot;prompt&quot;:&quot;Does the following program compile? If not, why not?\n\n```rust\ntrait Damageable {\n    health: u32;\n\n    fn take_damage(&amp;mut self, damage: u32) {\n        self.health = self.health.saturating_sub(damage);\n    }\n}\n\nstruct Enemy;\n\nimpl Damageable for Enemy {}\n\nfn main() {\n    let e = Enemy;\n    e.take_damage(10);\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Inheritance and implementation reuse">Click here to leave us feedback about this page.</a>
                        
</body>
</html>