["```cpp\n[](#cb1-1)enum {\n[](#cb1-2)    STATE_REQ = 0,\n[](#cb1-3)    STATE_RES = 1,\n[](#cb1-4)    STATE_END = 2,  // mark the connection for deletion\n[](#cb1-5)};\n[](#cb1-6)\n[](#cb1-7)struct Conn {\n[](#cb1-8)    int fd = -1;\n[](#cb1-9)    uint32_t state = 0;     // either STATE_REQ or STATE_RES\n[](#cb1-10)    // buffer for reading\n[](#cb1-11)    size_t rbuf_size = 0;\n[](#cb1-12)    uint8_t rbuf[4 + k_max_msg];\n[](#cb1-13)    // buffer for writing\n[](#cb1-14)    size_t wbuf_size = 0;\n[](#cb1-15)    size_t wbuf_sent = 0;\n[](#cb1-16)    uint8_t wbuf[4 + k_max_msg];\n[](#cb1-17)};\n```", "```cpp\n[](#cb2-1)int main() {\n[](#cb2-2)    int fd = socket(AF_INET, SOCK_STREAM, 0);\n[](#cb2-3)    if (fd < 0) {\n[](#cb2-4)        die(\"socket()\");\n[](#cb2-5)    }\n[](#cb2-6)\n[](#cb2-7)    // bind, listen and etc\n[](#cb2-8)    // code omitted...\n[](#cb2-9)\n[](#cb2-10)    // a map of all client connections, keyed by fd\n[](#cb2-11)    std::vector<Conn *> fd2conn;\n[](#cb2-12)\n[](#cb2-13)    // set the listen fd to nonblocking mode\n[](#cb2-14)    fd_set_nb(fd);\n[](#cb2-15)\n[](#cb2-16)    // the event loop\n[](#cb2-17)    std::vector<struct pollfd> poll_args;\n[](#cb2-18)    while (true) {\n[](#cb2-19)        // prepare the arguments of the poll()\n[](#cb2-20)        poll_args.clear();\n[](#cb2-21)        // for convenience, the listening fd is put in the first position\n[](#cb2-22)        struct pollfd pfd = {fd, POLLIN, 0};\n[](#cb2-23)        poll_args.push_back(pfd);\n[](#cb2-24)        // connection fds\n[](#cb2-25)        for (Conn *conn : fd2conn) {\n[](#cb2-26)            if (!conn) {\n[](#cb2-27)                continue;\n[](#cb2-28)            }\n[](#cb2-29)            struct pollfd pfd = {};\n[](#cb2-30)            pfd.fd = conn->fd;\n[](#cb2-31)            pfd.events = (conn->state == STATE_REQ) ? POLLIN : POLLOUT;\n[](#cb2-32)            pfd.events = pfd.events | POLLERR;\n[](#cb2-33)            poll_args.push_back(pfd);\n[](#cb2-34)        }\n[](#cb2-35)\n[](#cb2-36)        // poll for active fds\n[](#cb2-37)        // the timeout argument doesn't matter here\n[](#cb2-38)        int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), 1000);\n[](#cb2-39)        if (rv < 0) {\n[](#cb2-40)            die(\"poll\");\n[](#cb2-41)        }\n[](#cb2-42)\n[](#cb2-43)        // process active connections\n[](#cb2-44)        for (size_t i = 1; i < poll_args.size(); ++i) {\n[](#cb2-45)            if (poll_args[i].revents) {\n[](#cb2-46)                Conn *conn = fd2conn[poll_args[i].fd];\n[](#cb2-47)                connection_io(conn);\n[](#cb2-48)                if (conn->state == STATE_END) {\n[](#cb2-49)                    // client closed normally, or something bad happened.\n[](#cb2-50)                    // destroy this connection\n[](#cb2-51)                    fd2conn[conn->fd] = NULL;\n[](#cb2-52)                    (void)close(conn->fd);\n[](#cb2-53)                    free(conn);\n[](#cb2-54)                }\n[](#cb2-55)            }\n[](#cb2-56)        }\n[](#cb2-57)\n[](#cb2-58)        // try to accept a new connection if the listening fd is active\n[](#cb2-59)        if (poll_args[0].revents) {\n[](#cb2-60)            (void)accept_new_conn(fd2conn, fd);\n[](#cb2-61)        }\n[](#cb2-62)    }\n[](#cb2-63)\n[](#cb2-64)    return 0;\n[](#cb2-65)}\n```", "```cpp\n[](#cb3-1)static void conn_put(std::vector<Conn *> &fd2conn, struct Conn *conn) {\n[](#cb3-2)    if (fd2conn.size() <= (size_t)conn->fd) {\n[](#cb3-3)        fd2conn.resize(conn->fd + 1);\n[](#cb3-4)    }\n[](#cb3-5)    fd2conn[conn->fd] = conn;\n[](#cb3-6)}\n[](#cb3-7)\n[](#cb3-8)static int32_t accept_new_conn(std::vector<Conn *> &fd2conn, int fd) {\n[](#cb3-9)    // accept\n[](#cb3-10)    struct sockaddr_in client_addr = {};\n[](#cb3-11)    socklen_t socklen = sizeof(client_addr);\n[](#cb3-12)    int connfd = accept(fd, (struct sockaddr *)&client_addr, &socklen);\n[](#cb3-13)    if (connfd < 0) {\n[](#cb3-14)        msg(\"accept() error\");\n[](#cb3-15)        return -1;  // error\n[](#cb3-16)    }\n[](#cb3-17)\n[](#cb3-18)    // set the new connection fd to nonblocking mode\n[](#cb3-19)    fd_set_nb(connfd);\n[](#cb3-20)    // creating the struct Conn\n[](#cb3-21)    struct Conn *conn = (struct Conn *)malloc(sizeof(struct Conn));\n[](#cb3-22)    if (!conn) {\n[](#cb3-23)        close(connfd);\n[](#cb3-24)        return -1;\n[](#cb3-25)    }\n[](#cb3-26)    conn->fd = connfd;\n[](#cb3-27)    conn->state = STATE_REQ;\n[](#cb3-28)    conn->rbuf_size = 0;\n[](#cb3-29)    conn->wbuf_size = 0;\n[](#cb3-30)    conn->wbuf_sent = 0;\n[](#cb3-31)    conn_put(fd2conn, conn);\n[](#cb3-32)    return 0;\n[](#cb3-33)}\n```", "```cpp\n[](#cb4-1)static void connection_io(Conn *conn) {\n[](#cb4-2)    if (conn->state == STATE_REQ) {\n[](#cb4-3)        state_req(conn);\n[](#cb4-4)    } else if (conn->state == STATE_RES) {\n[](#cb4-5)        state_res(conn);\n[](#cb4-6)    } else {\n[](#cb4-7)        assert(0);  // not expected\n[](#cb4-8)    }\n[](#cb4-9)}\n```", "```cpp\n[](#cb5-1)static void state_req(Conn *conn) {\n[](#cb5-2)    while (try_fill_buffer(conn)) {}\n[](#cb5-3)}\n[](#cb5-4)\n[](#cb5-5)static bool try_fill_buffer(Conn *conn) {\n[](#cb5-6)    // try to fill the buffer\n[](#cb5-7)    assert(conn->rbuf_size < sizeof(conn->rbuf));\n[](#cb5-8)    ssize_t rv = 0;\n[](#cb5-9)    do {\n[](#cb5-10)        size_t cap = sizeof(conn->rbuf) - conn->rbuf_size;\n[](#cb5-11)        rv = read(conn->fd, &conn->rbuf[conn->rbuf_size], cap);\n[](#cb5-12)    } while (rv < 0 && errno == EINTR);\n[](#cb5-13)    if (rv < 0 && errno == EAGAIN) {\n[](#cb5-14)        // got EAGAIN, stop.\n[](#cb5-15)        return false;\n[](#cb5-16)    }\n[](#cb5-17)    if (rv < 0) {\n[](#cb5-18)        msg(\"read() error\");\n[](#cb5-19)        conn->state = STATE_END;\n[](#cb5-20)        return false;\n[](#cb5-21)    }\n[](#cb5-22)    if (rv == 0) {\n[](#cb5-23)        if (conn->rbuf_size > 0) {\n[](#cb5-24)            msg(\"unexpected EOF\");\n[](#cb5-25)        } else {\n[](#cb5-26)            msg(\"EOF\");\n[](#cb5-27)        }\n[](#cb5-28)        conn->state = STATE_END;\n[](#cb5-29)        return false;\n[](#cb5-30)    }\n[](#cb5-31)\n[](#cb5-32)    conn->rbuf_size += (size_t)rv;\n[](#cb5-33)    assert(conn->rbuf_size <= sizeof(conn->rbuf) - conn->rbuf_size);\n[](#cb5-34)\n[](#cb5-35)    // Try to process requests one by one.\n[](#cb5-36)    // Why is there a loop? Please read the explanation of \"pipelining\".\n[](#cb5-37)    while (try_one_request(conn)) {}\n[](#cb5-38)    return (conn->state == STATE_REQ);\n[](#cb5-39)}\n```", "```cpp\n[](#cb6-1)def do_something_to_client(fd):\n[](#cb6-2)    if should_read_from(fd):\n[](#cb6-3)        data = read_until_EAGAIN(fd)\n[](#cb6-4)        process_incoming_data(data)\n[](#cb6-5)    # code omitted...\n```", "```cpp\n[](#cb7-1)static bool try_one_request(Conn *conn) {\n[](#cb7-2)    // try to parse a request from the buffer\n[](#cb7-3)    if (conn->rbuf_size < 4) {\n[](#cb7-4)        // not enough data in the buffer. Will retry in the next iteration\n[](#cb7-5)        return false;\n[](#cb7-6)    }\n[](#cb7-7)    uint32_t len = 0;\n[](#cb7-8)    memcpy(&len, &conn->rbuf[0], 4);\n[](#cb7-9)    if (len > k_max_msg) {\n[](#cb7-10)        msg(\"too long\");\n[](#cb7-11)        conn->state = STATE_END;\n[](#cb7-12)        return false;\n[](#cb7-13)    }\n[](#cb7-14)    if (4 + len > conn->rbuf_size) {\n[](#cb7-15)        // not enough data in the buffer. Will retry in the next iteration\n[](#cb7-16)        return false;\n[](#cb7-17)    }\n[](#cb7-18)\n[](#cb7-19)    // got one request, do something with it\n[](#cb7-20)    printf(\"client says: %.*s\\n\", len, &conn->rbuf[4]);\n[](#cb7-21)\n[](#cb7-22)    // generating echoing response\n[](#cb7-23)    memcpy(&conn->wbuf[0], &len, 4);\n[](#cb7-24)    memcpy(&conn->wbuf[4], &conn->rbuf[4], len);\n[](#cb7-25)    conn->wbuf_size = 4 + len;\n[](#cb7-26)\n[](#cb7-27)    // remove the request from the buffer.\n[](#cb7-28)    // note: frequent memmove is inefficient.\n[](#cb7-29)    // note: need better handling for production code.\n[](#cb7-30)    size_t remain = conn->rbuf_size - 4 - len;\n[](#cb7-31)    if (remain) {\n[](#cb7-32)        memmove(conn->rbuf, &conn->rbuf[4 + len], remain);\n[](#cb7-33)    }\n[](#cb7-34)    conn->rbuf_size = remain;\n[](#cb7-35)\n[](#cb7-36)    // change state\n[](#cb7-37)    conn->state = STATE_RES;\n[](#cb7-38)    state_res(conn);\n[](#cb7-39)\n[](#cb7-40)    // continue the outer loop if the request was fully processed\n[](#cb7-41)    return (conn->state == STATE_REQ);\n[](#cb7-42)}\n```", "```cpp\n[](#cb8-1)static void state_res(Conn *conn) {\n[](#cb8-2)    while (try_flush_buffer(conn)) {}\n[](#cb8-3)}\n[](#cb8-4)\n[](#cb8-5)static bool try_flush_buffer(Conn *conn) {\n[](#cb8-6)    ssize_t rv = 0;\n[](#cb8-7)    do {\n[](#cb8-8)        size_t remain = conn->wbuf_size - conn->wbuf_sent;\n[](#cb8-9)        rv = write(conn->fd, &conn->wbuf[conn->wbuf_sent], remain);\n[](#cb8-10)    if (rv < 0 && errno == EAGAIN) {\n[](#cb8-11)        // got EAGAIN, stop.\n[](#cb8-12)        return false;\n[](#cb8-13)    }\n[](#cb8-14)    if (rv < 0) {\n[](#cb8-15)        msg(\"write() error\");\n[](#cb8-16)        conn->state = STATE_END;\n[](#cb8-17)        return false;\n[](#cb8-18)    }\n[](#cb8-19)    conn->wbuf_sent += (size_t)rv;\n[](#cb8-20)    assert(conn->wbuf_sent <= conn->wbuf_size);\n[](#cb8-21)    if (conn->wbuf_sent == conn->wbuf_size) {\n[](#cb8-22)        // response was fully sent, change state back\n[](#cb8-23)        conn->state = STATE_REQ;\n[](#cb8-24)        conn->wbuf_sent = 0;\n[](#cb8-25)        conn->wbuf_size = 0;\n[](#cb8-26)        return false;\n[](#cb8-27)    }\n[](#cb8-28)    // still got some data in wbuf, could try to write again\n[](#cb8-29)    return true;\n[](#cb8-30)}\n```", "```cpp\n[](#cb9-1)// the `query` function was simply splited into `send_req` and `read_res`.\n[](#cb9-2)static int32_t send_req(int fd, const char *text);\n[](#cb9-3)static int32_t read_res(int fd);\n[](#cb9-4)\n[](#cb9-5)int main() {\n[](#cb9-6)    int fd = socket(AF_INET, SOCK_STREAM, 0);\n[](#cb9-7)    if (fd < 0) {\n[](#cb9-8)        die(\"socket()\");\n[](#cb9-9)    }\n[](#cb9-10)\n[](#cb9-11)    // code omitted...\n[](#cb9-12)\n[](#cb9-13)    // multiple pipelined requests\n[](#cb9-14)    const char *query_list[3] = {\"hello1\", \"hello2\", \"hello3\"};\n[](#cb9-15)    for (size_t i = 0; i < 3; ++i) {\n[](#cb9-16)        int32_t err = send_req(fd, query_list[i]);\n[](#cb9-17)        if (err) {\n[](#cb9-18)            goto L_DONE;\n[](#cb9-19)        }\n[](#cb9-20)    }\n[](#cb9-21)    for (size_t i = 0; i < 3; ++i) {\n[](#cb9-22)        int32_t err = read_res(fd);\n[](#cb9-23)        if (err) {\n[](#cb9-24)            goto L_DONE;\n[](#cb9-25)        }\n[](#cb9-26)    }\n[](#cb9-27)\n[](#cb9-28)L_DONE:\n[](#cb9-29)    close(fd);\n[](#cb9-30)    return 0;\n[](#cb9-31)}\n```"]