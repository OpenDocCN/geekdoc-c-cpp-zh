["```cpp\ncommit 6be2fa0bdbbadc52cc8478b52b69db02b0eaff40\nAuthor: Paweł Olchawa <pawel.olchawa@oracle.com>\nDate:   Wed Feb 14 09:33:42 2018 +0100\n\n    WL#10310 Redo log optimization: dedicated threads and concurrent log buffer.\n\n    0. Log buffer became a ring buffer, data inside is no longer shifted.\n    1. User threads are able to write concurrently to log buffer. \n    2. Relaxed order of dirty pages in flush lists - no need to synchronize\n       the order in which dirty pages are added to flush lists.\n    3. Concurrent MTR commits can interleave on different stages of commits.\n    4. Introduced dedicated log threads which keep writing log buffer: \n        * log_writer: writes log buffer to system buffers,\n        * log_flusher: flushes system buffers to disk.\n       As soon as they finished writing (flushing) and there is new data to \n       write (flush), they start next write (flush).\n    5. User threads no longer write / flush log buffer to disk, they only\n       wait by spinning or on event for notification. They do not have to \n       compete for the responsibility of writing / flushing.\n    6. Introduced a ring buffer of events (one per log-block) which are used\n       by user threads to wait for written/flushed redo log to avoid:\n        * contention on single event\n        * false wake-ups of all waiting threads whenever some write/flush\n          has finished (we can wake-up only those waiting in related blocks)\n    7. Introduced dedicated notifier threads not to delay next writes/fsyncs:\n        * log_write_notifier: notifies user threads about written redo,\n        * log_flush_notifier: notifies user threads about flushed redo.\n    8. Master thread no longer has to flush log buffer.\n    ...\n    30. Mysql test runner received a new feature (thanks to Marcin):\n        --exec_in_background.\n    Review: RB#15134\n    Reviewers:\n        - Marcin Babij <marcin.babij@oracle.com>,\n        - Debarun Banerjee <debarun.banerjee@oracle.com>.\n    Performance tests:\n        - Dimitri Kravtchuk <dimitri.kravtchuk@oracle.com>,\n        - Daniel Blanchard <daniel.blanchard@oracle.com>,\n        - Amrendra Kumar <amrendra.x.kumar@oracle.com>.\n    QA and MTR tests:\n        - Vinay Fisrekar <vinay.fisrekar@oracle.com>. \n```", "```cpp\n/** Prepare to write the mini-transaction log to the redo log buffer.\n@return number of bytes to write in finish_write() */\nulint mtr_t::Command::prepare_write() {\n  switch (m_impl->m_log_mode) {\n    case MTR_LOG_SHORT_INSERTS:\n      ut_d(ut_error);\n      /* fall through (write no redo log) */\n      [[fallthrough]];\n    case MTR_LOG_NO_REDO:\n    case MTR_LOG_NONE:\n      ut_ad(m_impl->m_log.size() == 0);\n      return 0;\n    case MTR_LOG_ALL:\n      break;\n    default:\n      ut_d(ut_error);\n      ut_o(return 0);\n  }\n  ... \n```", "```cpp\ncommit 1d259b87a63defa814e19a7534380cb43ee23c48\nAuthor: Jakub Łopuszański <jakub.lopuszanski@oracle.com>\nDate:   Wed Feb 5 14:12:22 2020 +0100\n\n    WL#10314 - InnoDB: Lock-sys optimization: sharded lock_sys mutex\n\n    The Lock-sys orchestrates access to tables and rows. Each table, and each row,\n    can be thought of as a resource, and a transaction may request access right for\n    a resource. As two transactions operating on a single resource can lead to\n    problems if the two operations conflict with each other, Lock-sys remembers\n    lists of already GRANTED lock requests and checks new requests for conflicts in\n    which case they have to start WAITING for their turn.\n\n    Lock-sys stores both GRANTED and WAITING lock requests in lists known as queues.\n    To allow concurrent operations on these queues, we need a mechanism to latch\n    these queues in safe and quick fashion.\n\n    In the past a single latch protected access to all of these queues.\n    This scaled poorly, and the managment of queues become a bottleneck.\n    In this WL, we introduce a more granular approach to latching.\n\n    Reviewed-by: Pawel Olchawa <pawel.olchawa@oracle.com>\n    Reviewed-by: Debarun Banerjee <debarun.banerjee@oracle.com>\n      RB:23836 \n```", "```cpp\ncommit e66d48b0c73d5fec278f81784bd5697502990263\nAuthor: Paweł Olchawa <pawel.olchawa@oracle.com>\nDate:   Mon Mar 1 15:52:30 2021 +0100\n\n    BUG#27933068 USE DIFFERENT MUTEX TO PROTECT TRX_SYS->SERIALISATION_LIST\n\n    This is an optimization patch, which reduces contention on the trx_sys_t::mutex\n    by introducing a new mutex - the trx_sys_t::serialisation_mutex.\n\n    The new mutex protects the trx_sys_t::serialisation_list and replaces the\n    trx_sys_t::mutex when trx->no is being assigned.\n\n    This is a modified version of the contribution patch which was created by Zhai Weixiang.\n    Modifications:\n    1. Periodical write of max_trx_id to the transaction system header page is modified.\n    2. The trx_get_serial_no() is called when we do not hold trx_sys_t::mutex.\n    3. Members in trx_sys_t are rearranged, so they are grouped by mutex that protects them.\n    4. The new mutex received its own latch_id.\n    5. InnoDB relies on rw_trx_max_id instead of max_trx_id in few places.\n    6. The min_active_id is updated only when it really changes.\n\n    RB: 19712\n    Reviewed-by: Debarun Banerjee debarun.banerjee@oracle.com \n```", "```cpp\ncommit bc95476c0156070fd5cedcfd354fa68ce3c95bdb\nAuthor: Paweł Olchawa <pawel.olchawa@oracle.com>\nDate:   Tue May 25 18:12:20 2021 +0200\n\n    BUG#32832196 SINGLE RW_TRX_SET LEADS TO CONTENTION ON TRX_SYS MUTEX\n\n    1. Introduced shards, each with rw_trx_set and dedicated mutex.\n    2. Extracted modifications to rw_trx_set outside its original critical sections\n       (removal had to be extracted outside trx_erase_lists).\n    3. Eliminated allocation on heap inside TrxUndoRsegs.\n    4. [BUG-FIX] The trx->state and trx->start_time became converted to std::atomic<>\n       fields to avoid risk of torn reads on egzotic platforms.\n    5. Added assertions which ensure that thread operating on transaction has rights\n       to do so (to show there is no possible race condition).\n\n    RB: 26314\n    Reviewed-by: Jakub Łopuszański jakub.lopuszanski@oracle.com \n```", "```cpp\nThis WL improves the implementation of CATS to the point where the FCFS will be redundant (as often slower, and easy to \"emulate\" by setting equal schedule weights in CATS), so it removes FCFS from the code, further simplifying the lock_sys's logic. \n```", "```cpp\nvoid Deadlock_notifier::notify(const ut::vector<const trx_t *> &trxs_on_cycle,\n                               const trx_t *victim_trx) {\n  ut_ad(locksys::owns_exclusive_global_latch());\n  start_print();\n  const auto n = trxs_on_cycle.size();\n  for (size_t i = 0; i < n; ++i) {\n    const trx_t *trx = trxs_on_cycle[i];\n    const trx_t *blocked_trx = trxs_on_cycle[0 < i ? i - 1 : n - 1];\n    const lock_t *blocking_lock =\n        lock_has_to_wait_in_queue(blocked_trx->lock.wait_lock, trx);\n    ut_a(blocking_lock);\n    print_title(i, \"TRANSACTION\");\n    print(trx, 3000);\n    print_title(i, \"HOLDS THE LOCK(S)\");\n    print(blocking_lock);\n    print_title(i, \"WAITING FOR THIS LOCK TO BE GRANTED\");\n    print(trx->lock.wait_lock);\n  }\n  const auto victim_it =\n      std::find(trxs_on_cycle.begin(), trxs_on_cycle.end(), victim_trx);\n  ut_ad(victim_it != trxs_on_cycle.end());\n  const auto victim_pos = std::distance(trxs_on_cycle.begin(), victim_it);\n  ut::ostringstream buff;\n  buff << \"*** WE ROLL BACK TRANSACTION (\" << (victim_pos + 1) << \")\\n\";\n  print(buff.str().c_str());\n  DBUG_PRINT(\"ib_lock\", (\"deadlock detected\"));\n  ...\n  lock_deadlock_found = true;\n} \n```", "```cpp\ncommit b9be77784bf690173522d8db015acf0e72f28f84\nAuthor: Steinar H. Gunderson <steinar.gunderson@oracle.com>\nDate:   Wed May 6 16:32:13 2020 +0200\n\n    WL #14070: Hypergraph partitioning algorithm\n\n    Implement DPhyp for hypergraph partitioning, a central component of the join\n    optimizer. The algorithm enumerates all possible connected sub-hypergraphs\n    of the larger join graph, in a bottom-up fashion. (That is, for a given graph G\n    with a subgraphs A and B than can further be partitioned respectively into A1/A2\n    and B1/B2, A1 and A2 will both be seen before A, which will in turn be seen\n    before S. However, there is no guarantee that B1 or B2 is seen before A.)\n\n    The algorithm is described in the paper \"Dynamic Programming Strikes Back\" by\n    Neumann and Moerkotte. There is a somewhat extended version of the paper\n    (that also contains a few corrections) in Moerkotte's treatise \"Building Query  Compilers\". Some critical details are still missing, which we've had to fill in\n    ourselves. We don't currently implement the extension to generalized\n    hypergraphs, but it should be fairly straightforward to do later.\n\n    Since our graphs can never have more than 61 tables, node sets and edge lists\n    are implemented using 64-bit bit sets. This allows for a compact representation\n    and very fast set manipulation; the algorithm does a fair amount of\n    intersections and unions. If we should need extensions to larger graphs later\n    (this will require additional heuristics for reducing the search space), we can\n    use dynamic bit sets, although at a performance cost.\n\n    This is implemented entirely independently of the server; there are no MySQL\n    dependencies, short of some shared header files for bit manipulations. It is\n    tested using unit tests and microbenchmarks.\n\n    Change-Id: I7912c09ab69a17e607ee3b8fb2af2bd7602e54ec \n```"]