<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>RTTI and dynamic_cast</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>RTTI and dynamic_cast</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/rtti.html">https://cel.cs.brown.edu/crp/idioms/rtti.html</a></blockquote>
                        
<p>Rust does not have built-in support for generalized RTTI, nor does Rust have a direct analog to
<code>dynamic_cast</code>.</p>
<p>The only language primitive provided by Rust in this vein is <a href="https://doc.rust-lang.org/std/any/struct.TypeId.html"><code>TypeId</code></a>,
which is a globally unique identifier for a type. Rust's standard library builds on <code>TypeId</code> to provide an <a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>Any</code>
trait</a> that supports similar
uses to <code>std::any</code> in C++. However, <code>Any</code> does not enable testing for
implementation of, or converting to, another trait. It only enables testing for
and converting to a specific type.</p>
<p>Every type with a <code>'static</code> lifetime bound (i.e., that does not contain
references with a non-static lifetime) implements <code>Any</code> via a blanket implementation in
the standard library.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;any&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void print_if_string(const std::any &amp;x) {
  try {
    const std::string &amp;s =
        any_cast&lt;std::string const &amp;&gt;(x);
    std::cout &lt;&lt; s &lt;&lt; std::endl;
  } catch (std::bad_any_cast &amp;e) {
    std::cout &lt;&lt; "Not a string!" &lt;&lt; std::endl;
  }
}

int main() {
  print_if_string(std::string("hello world"));
  print_if_string(5);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">use std::any::Any;

fn print_if_string(x: &amp;dyn Any) {
    match x.downcast_ref::&lt;String&gt;() {
        Some(s) =&gt; println!("{}", s),
        None    =&gt; println!("Not a string!")
    }
}

fn main() {
    print_if_string(&amp;String::from("hello world"));
    print_if_string(&amp;5);
}</code></pre></pre>
</div>
<h2 id="event-handling"><a class="header" href="#event-handling">Event handling</a></h2>
<p>One practical use of RTTI and <code>dynamic_cast</code> in C++ is for event handling in
situations where both the subsystem generating events and the events themselves
need to be decoupled from the handling logic. This is usually because the events
are generated by a framework, such as a GUI or game framework, while the
response to the events is application-specific.</p>
<div class="comparison">
<pre><code class="language-cpp">struct Event {
  virtual ~Event() = default;
};

struct ClickEvent : public Event {
  int x;
  int y;
};

struct ResizeEvent : public Event {
  int old_height;
  int old_width;
  int new_height;
  int new_width;
};

void handle_event(Event *e) {
  if (auto click_event =
          dynamic_cast&lt;ClickEvent *&gt;(e)) {
    // ...
  } else if (auto resize_event =
                 dynamic_cast&lt;ResizeEvent *&gt;(e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
}

// register event handler in main
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Event {
    ClickEvent {
        x: i32,
        y: i32,
    },
    ResizeEvent {
        old_height: i32,
        old_width: i32,
        new_height: i32,
        new_width: i32,
    },
}

fn handle_event(e: Event) {
    match e {
        Event::ClickEvent { x, y } =&gt; {
            // ...
        }
        Event::ResizeEvent {
            old_height,
            old_width,
            new_height,
            new_width,
        } =&gt; {
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>Even when the a client of the library is needs to be able to define custom
events, it is usually possible to make use of an event enum. This is the
approach taken by the <a href="https://docs.rs/winit/latest/winit/event/enum.Event.html">winit
crate</a>, which does
cross-platform window and event loop management.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">struct Event {
</span><span class="boring">  virtual ~Event() = default;
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ClickEvent : public Event {
</span><span class="boring">  int x;
</span><span class="boring">  int y;
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct ResizeEvent : public Event {
</span><span class="boring">  int old_height;
</span><span class="boring">  int old_width;
</span><span class="boring">  int new_height;
</span><span class="boring">  int new_width;
</span><span class="boring">};
</span><span class="boring">
</span>struct DoSomething : public Event {
  double how_much;
}

struct DoSomethingElse : public Event {
  double how_many;
}

void handle_event(Event *e) {
<span class="boring">  if (auto click_event =
</span><span class="boring">          dynamic_cast&lt;ClickEvent *&gt;(e)) {
</span><span class="boring">    // ...
</span><span class="boring">  } else if (auto resize_event =
</span><span class="boring">                 dynamic_cast&lt;ResizeEvent *&gt;(e)) {
</span><span class="boring">    // ...
</span>  // ...
  } else if (auto user_event =
                 dynamic_cast&lt;DoSomething *&gt;(e)) {
    // ...
  } else if (auto user_event =
                 dynamic_cast&lt;DoSomethingElse *&gt;(
                     e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Event&lt;T&gt; {
<span class="boring">    ClickEvent {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    },
</span><span class="boring">    ResizeEvent {
</span><span class="boring">        old_height: i32,
</span><span class="boring">        old_width: i32,
</span><span class="boring">        new_height: i32,
</span><span class="boring">        new_width: i32,
</span><span class="boring">    },
</span>    // ...
    UserEvent(T),
}

enum UserEvent {
    DoSomething { how_much: f64 },
    DoSomethingElse { how_many: i32 },
}

fn handle_event(e: Event&lt;UserEvent&gt;) {
    match e {
<span class="boring">        Event::ClickEvent { x, y } =&gt; {
</span><span class="boring">            // ...
</span><span class="boring">        }
</span><span class="boring">        Event::ResizeEvent {
</span><span class="boring">            old_height,
</span><span class="boring">            old_width,
</span><span class="boring">            new_height,
</span><span class="boring">            new_width,
</span><span class="boring">        } =&gt; {
</span><span class="boring">            // ...
</span><span class="boring">        }
</span>        // ...
        Event::UserEvent(
            UserEvent::DoSomething { how_much },
        ) =&gt; {
            // ...
        }
        Event::UserEvent(
            UserEvent::DoSomethingElse {
                how_many,
            },
        ) =&gt; {
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>When representing events as an enum truly isn't feasible, sometimes double
dispatch <!-- TODO: link to visitor --> can be used instead. Otherwise it may be
necessary to use the <code>Any</code> trait or to define an <code>Event</code> trait that exposes a
type identifier that an be used for safe downcasting (via <code>Any</code>) or unsafe
downcasting behind a safe interface.<sup class="footnote-reference" id="fr-safe-event-handler-1"><a href="#footnote-safe-event-handler">1</a></sup></p>
<h2 id="library-support-for-reflection-via-macros"><a class="header" href="#library-support-for-reflection-via-macros">Library support for reflection via macros</a></h2>
<p>Some of the use cases of RTTI can be achieved in Rust by using one of the third-party
reflection libraries. These libraries implement reflection by providing macros
for deriving traits to support common reflection operations. Rust reflection libraries include
<a href="https://docs.rs/bevy_reflect/latest/bevy_reflect/">bevy_reflect</a>, <a href="https://facet.rs/">facet</a>, and
<a href="https://docs.rs/mirror-mirror/latest/mirror_mirror/">mirror-mirror</a>.</p>
<p>The derive-macro approach to reflection essentially makes it opt-in, so that software that
does not use reflection does not have to pay a price for it (performance costs or binary size). However,
due to Rust's <a href="https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules">orphan rule</a>,
this approach makes it more difficult to integrate third-party types that lack the derived trait.</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-safe-event-handler">
<p>Such an interface usually involves providing individual
event handling functions for specific types, rather than a single large
event handling function, so that the underlying implementation can managing
the enforcement of the invariants required to make the casting safe. <a href="#fr-safe-event-handler-1">↩</a></p>
</li>
</ol>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=RTTI and dynamic_cast">Click here to leave us feedback about this page.</a>
                        
</body>
</html>