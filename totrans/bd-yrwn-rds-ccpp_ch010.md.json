["```cpp\n[](#cb1-1)enum {\n[](#cb1-2)    SER_NIL = 0,\n[](#cb1-3)    SER_ERR = 1,\n[](#cb1-4)    SER_STR = 2,\n[](#cb1-5)    SER_INT = 3,\n[](#cb1-6)    SER_ARR = 4,\n[](#cb1-7)};\n```", "```cpp\n[](#cb2-1)static bool try_one_request(Conn *conn) {\n[](#cb2-2)    // code omitted...\n[](#cb2-3)\n[](#cb2-4)    // parse the request\n[](#cb2-5)    std::vector<std::string> cmd;\n[](#cb2-6)    if (0 != parse_req(&conn->rbuf[4], len, cmd)) {\n[](#cb2-7)        msg(\"bad req\");\n[](#cb2-8)        conn->state = STATE_END;\n[](#cb2-9)        return false;\n[](#cb2-10)    }\n[](#cb2-11)\n[](#cb2-12)    // got one request, generate the response.\n[](#cb2-13)    std::string  out;\n[](#cb2-14)    do_request(cmd, out);\n[](#cb2-15)\n[](#cb2-16)    // pack the response into the buffer\n[](#cb2-17)    if (4 + out.size() > k_max_msg) {\n[](#cb2-18)        out.clear();\n[](#cb2-19)        out_err(out, ERR_2BIG, \"response is too big\");\n[](#cb2-20)    }\n[](#cb2-21)    uint32_t wlen = (uint32_t)out.size();\n[](#cb2-22)    memcpy(&conn->wbuf[0], &wlen, 4);\n[](#cb2-23)    memcpy(&conn->wbuf[4], out.data(), out.size());\n[](#cb2-24)    conn->wbuf_size = 4 + wlen;\n[](#cb2-25)\n[](#cb2-26)    // code omitted...\n[](#cb2-27)}\n```", "```cpp\n[](#cb3-1)static void do_request(std::vector<std::string> &cmd, std::string &out) {\n[](#cb3-2)    if (cmd.size() == 1 && cmd_is(cmd[0], \"keys\")) {\n[](#cb3-3)        do_keys(cmd, out);\n[](#cb3-4)    } else if (cmd.size() == 2 && cmd_is(cmd[0], \"get\")) {\n[](#cb3-5)        do_get(cmd, out);\n[](#cb3-6)    } else if (cmd.size() == 3 && cmd_is(cmd[0], \"set\")) {\n[](#cb3-7)        do_set(cmd, out);\n[](#cb3-8)    } else if (cmd.size() == 2 && cmd_is(cmd[0], \"del\")) {\n[](#cb3-9)        do_del(cmd, out);\n[](#cb3-10)    } else {\n[](#cb3-11)        // cmd is not recognized\n[](#cb3-12)        out_err(out, ERR_UNKNOWN, \"Unknown cmd\");\n[](#cb3-13)    }\n[](#cb3-14)}\n```", "```cpp\n[](#cb4-1)static void out_nil(std::string &out) {\n[](#cb4-2)    out.push_back(SER_NIL);\n[](#cb4-3)}\n[](#cb4-4)\n[](#cb4-5)static void out_str(std::string &out, const std::string &val) {\n[](#cb4-6)    out.push_back(SER_STR);\n[](#cb4-7)    uint32_t len = (uint32_t)val.size();\n[](#cb4-8)    out.append((char *)&len, 4);\n[](#cb4-9)    out.append(val);\n[](#cb4-10)}\n[](#cb4-11)\n[](#cb4-12)static void out_int(std::string &out, int64_t val) {\n[](#cb4-13)    out.push_back(SER_INT);\n[](#cb4-14)    out.append((char *)&val, 8);\n[](#cb4-15)}\n[](#cb4-16)\n[](#cb4-17)static void out_err(std::string &out, int32_t code, const std::string &msg) {\n[](#cb4-18)    out.push_back(SER_ERR);\n[](#cb4-19)    out.append((char *)&code, 4);\n[](#cb4-20)    uint32_t len = (uint32_t)msg.size();\n[](#cb4-21)    out.append((char *)&len, 4);\n[](#cb4-22)    out.append(msg);\n[](#cb4-23)}\n[](#cb4-24)\n[](#cb4-25)static void out_arr(std::string &out, uint32_t n) {\n[](#cb4-26)    out.push_back(SER_ARR);\n[](#cb4-27)    out.append((char *)&n, 4);\n[](#cb4-28)}\n```", "```cpp\n[](#cb5-1)static void h_scan(HTab *tab, void (*f)(HNode *, void *), void *arg) {\n[](#cb5-2)    if (tab->size == 0) {\n[](#cb5-3)        return;\n[](#cb5-4)    }\n[](#cb5-5)    for (size_t i = 0; i < tab->mask + 1; ++i) {\n[](#cb5-6)        HNode *node = tab->tab[i];\n[](#cb5-7)        while (node) {\n[](#cb5-8)            f(node, arg);\n[](#cb5-9)            node = node->next;\n[](#cb5-10)        }\n[](#cb5-11)    }\n[](#cb5-12)}\n[](#cb5-13)\n[](#cb5-14)static void cb_scan(HNode *node, void *arg) {\n[](#cb5-15)    std::string &out = *(std::string *)arg;\n[](#cb5-16)    out_str(out, container_of(node, Entry, node)->key);\n[](#cb5-17)}\n[](#cb5-18)\n[](#cb5-19)static void do_keys(std::vector<std::string> &cmd, std::string &out) {\n[](#cb5-20)    (void)cmd;\n[](#cb5-21)    out_arr(out, (uint32_t)hm_size(&g_data.db));\n[](#cb5-22)    h_scan(&g_data.db.ht1, &cb_scan, &out);\n[](#cb5-23)    h_scan(&g_data.db.ht2, &cb_scan, &out);\n[](#cb5-24)}\n```", "```cpp\n[](#cb6-1)static void do_del(std::vector<std::string> &cmd, std::string &out) {\n[](#cb6-2)    Entry key;\n[](#cb6-3)    key.key.swap(cmd[1]);\n[](#cb6-4)    key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());\n[](#cb6-5)\n[](#cb6-6)    HNode *node = hm_pop(&g_data.db, &key.node, &entry_eq);\n[](#cb6-7)    if (node) {\n[](#cb6-8)        delete container_of(node, Entry, node);\n[](#cb6-9)    }\n[](#cb6-10)    return out_int(out, node ? 1 : 0);\n[](#cb6-11)}\n```", "```cpp\n[](#cb7-1)static int32_t on_response(const uint8_t *data, size_t size) {\n[](#cb7-2)    if (size < 1) {\n[](#cb7-3)        msg(\"bad response\");\n[](#cb7-4)        return -1;\n[](#cb7-5)    }\n[](#cb7-6)    switch (data[0]) {\n[](#cb7-7)    case SER_NIL:\n[](#cb7-8)        printf(\"(nil)\\n\");\n[](#cb7-9)        return 1;\n[](#cb7-10)    case SER_ERR:\n[](#cb7-11)        if (size < 1 + 8) {\n[](#cb7-12)            msg(\"bad response\");\n[](#cb7-13)            return -1;\n[](#cb7-14)        }\n[](#cb7-15)        {\n[](#cb7-16)            int32_t code = 0;\n[](#cb7-17)            uint32_t len = 0;\n[](#cb7-18)            memcpy(&code, &data[1], 4);\n[](#cb7-19)            memcpy(&len, &data[1 + 4], 4);\n[](#cb7-20)            if (size < 1 + 8 + len) {\n[](#cb7-21)                msg(\"bad response\");\n[](#cb7-22)                return -1;\n[](#cb7-23)            }\n[](#cb7-24)            printf(\"(err) %d  %.*s\\n\", code, len, &data[1 + 8]);\n[](#cb7-25)            return 1 + 8 + len;\n[](#cb7-26)        }\n[](#cb7-27)    case SER_STR:\n[](#cb7-28)        // code omited...\n[](#cb7-29)    case SER_INT:\n[](#cb7-30)        // code omited...\n[](#cb7-31)    case SER_ARR:\n[](#cb7-32)        if (size < 1 + 4) {\n[](#cb7-33)            msg(\"bad response\");\n[](#cb7-34)            return -1;\n[](#cb7-35)        }\n[](#cb7-36)        {\n[](#cb7-37)            uint32_t len = 0;\n[](#cb7-38)            memcpy(&len, &data[1], 4);\n[](#cb7-39)            printf(\"(arr) len=%u\\n\", len);\n[](#cb7-40)            size_t arr_bytes = 1 + 4;\n[](#cb7-41)            for (uint32_t i = 0; i < len; ++i) {\n[](#cb7-42)                int32_t rv = on_response(&data[arr_bytes], size - arr_bytes);\n[](#cb7-43)                if (rv < 0) {\n[](#cb7-44)                    return rv;\n[](#cb7-45)                }\n[](#cb7-46)                arr_bytes += (size_t)rv;\n[](#cb7-47)            }\n[](#cb7-48)            printf(\"(arr) end\\n\");\n[](#cb7-49)            return (int32_t)arr_bytes;\n[](#cb7-50)        }\n[](#cb7-51)    default:\n[](#cb7-52)        msg(\"bad response\");\n[](#cb7-53)        return -1;\n[](#cb7-54)    }\n[](#cb7-55)}\n```", "```cpp\n[](#cb8-1)$ ./client asdf\n[](#cb8-2)(err) 1 Unknown cmd\n[](#cb8-3)$ ./client get asdf\n[](#cb8-4)(nil)\n[](#cb8-5)$ ./client set k v\n[](#cb8-6)(nil)\n[](#cb8-7)$ ./client get k\n[](#cb8-8)(str) v\n[](#cb8-9)$ ./client keys\n[](#cb8-10)(arr) len=1\n[](#cb8-11)(str) k\n[](#cb8-12)(arr) end\n[](#cb8-13)$ ./client del k\n[](#cb8-14)(int) 1\n[](#cb8-15)$ ./client del k\n[](#cb8-16)(int) 0\n[](#cb8-17)$ ./client keys\n[](#cb8-18)(arr) len=0\n[](#cb8-19)(arr) end\n```"]