["```rs\n#include <exception>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n// Declare types that visitor can visit\nclass Lit;\nclass Plus;\nclass Var;\nclass Let;\n\n// Define abstract class for visitor\nstruct Visitor {\n  virtual void visit(Lit &e) = 0;\n  virtual void visit(Plus &e) = 0;\n  virtual void visit(Var &e) = 0;\n  virtual void visit(Let &e) = 0;\n  virtual ~Visitor() = default;\n\nprotected:\n  Visitor() = default;\n};\n\n// Define abstract class for expressions\nstruct Exp {\n  virtual void accept(Visitor &v) = 0;\n  virtual ~Exp() = default;\n};\n\n// Implement each expression variant\nstruct Lit : public Exp {\n  int value;\n\n  Lit(int value) : value(value) {}\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\nstruct Plus : public Exp {\n  std::unique_ptr<Exp> lhs;\n  std::unique_ptr<Exp> rhs;\n\n  Plus(std::unique_ptr<Exp> lhs,\n       std::unique_ptr<Exp> rhs)\n      : lhs(std::move(lhs)), rhs(std::move(rhs)) {\n  }\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\nstruct Var : public Exp {\n  std::string name;\n\n  Var(std::string name) : name(name) {}\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\nstruct Let : public Exp {\n  std::string name;\n  std::unique_ptr<Exp> exp;\n  std::unique_ptr<Exp> body;\n\n  Let(std::string name, std::unique_ptr<Exp> exp,\n      std::unique_ptr<Exp> body)\n      : name(std::move(name)),\n        exp(std::move(exp)),\n        body(std::move(body)) {}\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\n// Define Visitor for evaluating expressions\n\n// Exception for representing expression\n// evaluation errors\nstruct UnknownVar : std::exception {\n  std::string name;\n\n  UnknownVar(std::string name) : name(name) {}\n\n  const char *what() const noexcept override {\n    return \"Unknown variable\";\n  }\n};\n\n// Define type for evaluation environment\nusing Env = std::unordered_map<std::string, int>;\n\n// Define evaluator\nstruct EvalVisitor : public Visitor {\n  // Return value. Results propagate up the stack.\n  int value = 0;\n\n  // Evaluation environment. Changes propagate\n  // down the stack\n  Env env;\n\n  // Define behavior for each case of the\n  // expression.\n  void visit(Lit &e) override { value = e.value; }\n  void visit(Plus &e) override {\n    e.lhs->accept(*this);\n    auto lhs = value;\n    e.rhs->accept(*this);\n    auto rhs = value;\n    value = lhs + rhs;\n  }\n  void visit(Var &e) override {\n    try {\n      value = env.at(e.name);\n    } catch (std::out_of_range &ex) {\n      throw UnknownVar(e.name);\n    }\n  }\n  void visit(Let &e) override {\n    e.exp->accept(*this);\n    auto orig_env = env;\n    env[e.name] = value;\n    e.body->accept(*this);\n    env = orig_env;\n  }\n};\n\nint main() {\n  // Construct an expression\n  auto x = Plus(std::make_unique<Let>(\n                    std::string(\"x\"),\n                    std::make_unique<Lit>(3),\n                    std::make_unique<Var>(\n                        std::string(\"x\"))),\n                std::make_unique<Lit>(2));\n\n  // Construct the evaluator\n  EvalVisitor visitor;\n\n  // Run the evaluator\n  x.accept(visitor);\n\n  // Print the output\n  std::cout << visitor.value << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <exception>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n// Declare types that visitor can visit\nclass Lit;\nclass Plus;\nclass Var;\nclass Let;\n\n// Define abstract class for visitor\nstruct Visitor {\n  virtual void visit(Lit &e) = 0;\n  virtual void visit(Plus &e) = 0;\n  virtual void visit(Var &e) = 0;\n  virtual void visit(Let &e) = 0;\n  virtual ~Visitor() = default;\n\nprotected:\n  Visitor() = default;\n};\n\n// Define abstract class for expressions\nstruct Exp {\n  virtual void accept(Visitor &v) = 0;\n  virtual ~Exp() = default;\n};\n\n// Implement each expression variant\nstruct Lit : public Exp {\n  int value;\n\n  Lit(int value) : value(value) {}\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\nstruct Plus : public Exp {\n  std::unique_ptr<Exp> lhs;\n  std::unique_ptr<Exp> rhs;\n\n  Plus(std::unique_ptr<Exp> lhs,\n       std::unique_ptr<Exp> rhs)\n      : lhs(std::move(lhs)), rhs(std::move(rhs)) {\n  }\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\nstruct Var : public Exp {\n  std::string name;\n\n  Var(std::string name) : name(name) {}\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\nstruct Let : public Exp {\n  std::string name;\n  std::unique_ptr<Exp> exp;\n  std::unique_ptr<Exp> body;\n\n  Let(std::string name, std::unique_ptr<Exp> exp,\n      std::unique_ptr<Exp> body)\n      : name(std::move(name)),\n        exp(std::move(exp)),\n        body(std::move(body)) {}\n\n  void accept(Visitor &v) override {\n    v.visit(*this);\n  }\n};\n\n// Define Visitor for evaluating expressions\n\n// Exception for representing expression\n// evaluation errors\nstruct UnknownVar : std::exception {\n  std::string name;\n\n  UnknownVar(std::string name) : name(name) {}\n\n  const char *what() const noexcept override {\n    return \"Unknown variable\";\n  }\n};\n\n// Define type for evaluation environment\nusing Env = std::unordered_map<std::string, int>;\n\n// Define evaluator\nstruct EvalVisitor : public Visitor {\n  // Return value. Results propagate up the stack.\n  int value = 0;\n\n  // Evaluation environment. Changes propagate\n  // down the stack\n  Env env;\n\n  // Define behavior for each case of the\n  // expression.\n  void visit(Lit &e) override { value = e.value; }\n  void visit(Plus &e) override {\n    e.lhs->accept(*this);\n    auto lhs = value;\n    e.rhs->accept(*this);\n    auto rhs = value;\n    value = lhs + rhs;\n  }\n  void visit(Var &e) override {\n    try {\n      value = env.at(e.name);\n    } catch (std::out_of_range &ex) {\n      throw UnknownVar(e.name);\n    }\n  }\n  void visit(Let &e) override {\n    e.exp->accept(*this);\n    auto orig_env = env;\n    env[e.name] = value;\n    e.body->accept(*this);\n    env = orig_env;\n  }\n};\n\nint main() {\n  // Construct an expression\n  auto x = Plus(std::make_unique<Let>(\n                    std::string(\"x\"),\n                    std::make_unique<Lit>(3),\n                    std::make_unique<Var>(\n                        std::string(\"x\"))),\n                std::make_unique<Lit>(2));\n\n  // Construct the evaluator\n  EvalVisitor visitor;\n\n  // Run the evaluator\n  x.accept(visitor);\n\n  // Print the output\n  std::cout << visitor.value << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```"]