["```cpp\n[](#cb1-1)struct Work {\n[](#cb1-2)    void (*f)(void *) = NULL;\n[](#cb1-3)    void *arg = NULL;\n[](#cb1-4)};\n[](#cb1-5)\n[](#cb1-6)struct TheadPool {\n[](#cb1-7)    std::vector<pthread_t> threads;\n[](#cb1-8)    std::deque<Work> queue;\n[](#cb1-9)    pthread_mutex_t mu;\n[](#cb1-10)    pthread_cond_t not_empty;\n[](#cb1-11)};\n```", "```cpp\n[](#cb2-1)void thread_pool_init(TheadPool *tp, size_t num_threads) {\n[](#cb2-2)    assert(num_threads > 0);\n[](#cb2-3)\n[](#cb2-4)    int rv = pthread_mutex_init(&tp->mu, NULL);\n[](#cb2-5)    assert(rv == 0);\n[](#cb2-6)    rv = pthread_cond_init(&tp->not_empty, NULL);\n[](#cb2-7)    assert(rv == 0);\n[](#cb2-8)\n[](#cb2-9)    tp->threads.resize(num_threads);\n[](#cb2-10)    for (size_t i = 0; i < num_threads; ++i) {\n[](#cb2-11)        int rv = pthread_create(&tp->threads[i], NULL, &worker, tp);\n[](#cb2-12)        assert(rv == 0);\n[](#cb2-13)    }\n[](#cb2-14)}\n```", "```cpp\n[](#cb3-1)static void *worker(void *arg) {\n[](#cb3-2)    TheadPool *tp = (TheadPool *)arg;\n[](#cb3-3)    while (true) {\n[](#cb3-4)        pthread_mutex_lock(&tp->mu);\n[](#cb3-5)        // wait for the condition: a non-empty queue\n[](#cb3-6)        while (tp->queue.empty()) {\n[](#cb3-7)            pthread_cond_wait(&tp->not_empty, &tp->mu);\n[](#cb3-8)        }\n[](#cb3-9)\n[](#cb3-10)        // got the job\n[](#cb3-11)        Work w = tp->queue.front();\n[](#cb3-12)        tp->queue.pop_front();\n[](#cb3-13)        pthread_mutex_unlock(&tp->mu);\n[](#cb3-14)\n[](#cb3-15)        // do the work\n[](#cb3-16)        w.f(w.arg);\n[](#cb3-17)    }\n[](#cb3-18)    return NULL;\n[](#cb3-19)}\n```", "```cpp\n[](#cb4-1)void thread_pool_queue(TheadPool *tp, void (*f)(void *), void *arg) {\n[](#cb4-2)    Work w;\n[](#cb4-3)    w.f = f;\n[](#cb4-4)    w.arg = arg;\n[](#cb4-5)\n[](#cb4-6)    pthread_mutex_lock(&tp->mu);\n[](#cb4-7)    tp->queue.push_back(w);\n[](#cb4-8)    pthread_cond_signal(&tp->not_empty);\n[](#cb4-9)    pthread_mutex_unlock(&tp->mu);\n[](#cb4-10)}\n```", "```cpp\n[](#cb5-1)// global variables\n[](#cb5-2)static struct {\n[](#cb5-3)    HMap db;\n[](#cb5-4)    // a map of all client connections, keyed by fd\n[](#cb5-5)    std::vector<Conn *> fd2conn;\n[](#cb5-6)    // timers for idle connections\n[](#cb5-7)    DList idle_list;\n[](#cb5-8)    // timers for TTLs\n[](#cb5-9)    std::vector<HeapItem> heap;\n[](#cb5-10)    // the thread pool\n[](#cb5-11)    TheadPool tp;\n[](#cb5-12)} g_data;\n```", "```cpp\n[](#cb6-1)    // some initializations\n[](#cb6-2)    dlist_init(&g_data.idle_list);\n[](#cb6-3)    thread_pool_init(&g_data.tp, 4);\n```", "```cpp\n[](#cb7-1)// deallocate the key immediately\n[](#cb7-2)static void entry_destroy(Entry *ent) {\n[](#cb7-3)    switch (ent->type) {\n[](#cb7-4)    case T_ZSET:\n[](#cb7-5)        zset_dispose(ent->zset);\n[](#cb7-6)        delete ent->zset;\n[](#cb7-7)        break;\n[](#cb7-8)    }\n[](#cb7-9)    delete ent;\n[](#cb7-10)}\n[](#cb7-11)\n[](#cb7-12)static void entry_del_async(void *arg) {\n[](#cb7-13)    entry_destroy((Entry *)arg);\n[](#cb7-14)}\n[](#cb7-15)\n[](#cb7-16)// dispose the entry after it got detached from the key space\n[](#cb7-17)static void entry_del(Entry *ent) {\n[](#cb7-18)    entry_set_ttl(ent, -1);\n[](#cb7-19)\n[](#cb7-20)    const size_t k_large_container_size = 10000;\n[](#cb7-21)    bool too_big = false;\n[](#cb7-22)    switch (ent->type) {\n[](#cb7-23)    case T_ZSET:\n[](#cb7-24)        too_big = hm_size(&ent->zset->hmap) > k_large_container_size;\n[](#cb7-25)        break;\n[](#cb7-26)    }\n[](#cb7-27)\n[](#cb7-28)    if (too_big) {\n[](#cb7-29)        thread_pool_queue(&g_data.tp, &entry_del_async, ent);\n[](#cb7-30)    } else {\n[](#cb7-31)        entry_destroy(ent);\n[](#cb7-32)    }\n[](#cb7-33)}\n```"]