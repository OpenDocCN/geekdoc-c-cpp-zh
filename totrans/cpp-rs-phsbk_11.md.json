["```rs\n#include <cstdint>\n\nenum Pin : uint8_t {\n  Pin1 = 0x01,\n  Pin2 = 0x02,\n  Pin3 = 0x04\n};\n\nenum Mode : uint8_t {\n  Output = 0x03,\n  Pullup = 0x04,\n  Analog = 0x27\n  // ...\n};\n\nvoid low_level_set_pin(uint8_t pin, uint8_t mode);\n\nvoid set_pin_mode(Pin pin, Mode mode) {\n  low_level_set_pin(pin, mode);\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cstdint>   enum Pin : uint8_t {\n Pin1 = 0x01, Pin2 = 0x02, Pin3 = 0x04 };   struct InvalidPin {\n    uint8_t pin;\n};\n\nPin to_pin(uint8_t pin) {\n  // The values are not contiguous, so we can't\n  // just check the bounds and then cast.\n  switch (pin) {\n  case 0x1: { return Pin1; }\n  case 0x2: { return Pin2; }\n  case 0x4: { return Pin3; }\n  }\n  throw InvalidPin{pin};\n}\n\nint main() {\n  try {\n    Pin p(to_pin(2));\n  } catch (InvalidPin &e) {\n    return 0;\n  }\n\n  // use pin p\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cstdint>\n\n// Actual enum\nenum PinImpl : uint8_t {\n  Pin1 = 0x01,\n  Pin2 = 0x02,\n  Pin3 = 0x04\n};\n\nclass LastPin{};\n\n// Wrapper type\nstruct Pin {\n  PinImpl pin;\n\n  // Conversion constructor so that PinImpl can be\n  // used as a Pin.\n  Pin(PinImpl p) : pin(p) {}\n\n  // Conversion method so wrapper type can be\n  // used with switch statement.\n  operator PinImpl() {\n    return this->pin;\n  }\n\n  Pin next() const {\n    switch (pin) {\n    case Pin1:\n      return Pin(Pin2);\n    case Pin2:\n      return Pin(Pin3);\n    default:\n      throw LastPin{};\n    }\n  }\n}; \n```", "```rs\n\n```", "```rs\n\n```"]