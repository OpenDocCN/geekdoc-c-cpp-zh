["```cpp\n[](#cb1-1)int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), 1000);\n```", "```cpp\n[](#cb2-1)struct DList {\n[](#cb2-2)    DList *prev = NULL;\n[](#cb2-3)    DList *next = NULL;\n[](#cb2-4)};\n[](#cb2-5)\n[](#cb2-6)inline void dlist_init(DList *node) {\n[](#cb2-7)    node->prev = node->next = node;\n[](#cb2-8)}\n[](#cb2-9)\n[](#cb2-10)inline bool dlist_empty(DList *node) {\n[](#cb2-11)    return node->next == node;\n[](#cb2-12)}\n[](#cb2-13)\n[](#cb2-14)inline void dlist_detach(DList *node) {\n[](#cb2-15)    DList *prev = node->prev;\n[](#cb2-16)    DList *next = node->next;\n[](#cb2-17)    prev->next = next;\n[](#cb2-18)    next->prev = prev;\n[](#cb2-19)}\n[](#cb2-20)\n[](#cb2-21)inline void dlist_insert_before(DList *target, DList *rookie) {\n[](#cb2-22)    DList *prev = target->prev;\n[](#cb2-23)    prev->next = rookie;\n[](#cb2-24)    rookie->prev = prev;\n[](#cb2-25)    rookie->next = target;\n[](#cb2-26)    target->prev = rookie;\n[](#cb2-27)}\n```", "```cpp\n[](#cb3-1)static uint64_t get_monotonic_usec() {\n[](#cb3-2)    timespec tv = {0, 0};\n[](#cb3-3)    clock_gettime(CLOCK_MONOTONIC, &tv);\n[](#cb3-4)    return uint64_t(tv.tv_sec) * 1000000 + tv.tv_nsec / 1000;\n[](#cb3-5)}\n```", "```cpp\n[](#cb4-1)// global variables\n[](#cb4-2)static struct {\n[](#cb4-3)    HMap db;\n[](#cb4-4)    // a map of all client connections, keyed by fd\n[](#cb4-5)    std::vector<Conn *> fd2conn;\n[](#cb4-6)    // timers for idle connections\n[](#cb4-7)    DList idle_list;\n[](#cb4-8)} g_data;\n```", "```cpp\n[](#cb5-1)struct Conn {\n[](#cb5-2)    int fd = -1;\n[](#cb5-3)    uint32_t state = 0;     // either STATE_REQ or STATE_RES\n[](#cb5-4)    // buffer for reading\n[](#cb5-5)    size_t rbuf_size = 0;\n[](#cb5-6)    uint8_t rbuf[4 + k_max_msg];\n[](#cb5-7)    // buffer for writing\n[](#cb5-8)    size_t wbuf_size = 0;\n[](#cb5-9)    size_t wbuf_sent = 0;\n[](#cb5-10)    uint8_t wbuf[4 + k_max_msg];\n[](#cb5-11)    uint64_t idle_start = 0;\n[](#cb5-12)    // timer\n[](#cb5-13)    DList idle_list;\n[](#cb5-14)};\n```", "```cpp\n[](#cb6-1)int main() {\n[](#cb6-2)    // some initializations\n[](#cb6-3)    dlist_init(&g_data.idle_list);\n[](#cb6-4)\n[](#cb6-5)    int fd = socket(AF_INET, SOCK_STREAM, 0);\n[](#cb6-6)    // bind, listen & other miscs\n[](#cb6-7)    // code omitted...\n[](#cb6-8)\n[](#cb6-9)    // the event loop\n[](#cb6-10)    std::vector<struct pollfd> poll_args;\n[](#cb6-11)    while (true) {\n[](#cb6-12)        // prepare the arguments of the poll()\n[](#cb6-13)        // code omitted...\n[](#cb6-14)\n[](#cb6-15)        // poll for active fds\n[](#cb6-16)        int timeout_ms = (int)next_timer_ms();\n[](#cb6-17)        int rv = poll(poll_args.data(), (nfds_t)poll_args.size(), timeout_ms);\n[](#cb6-18)        if (rv < 0) {\n[](#cb6-19)            die(\"poll\");\n[](#cb6-20)        }\n[](#cb6-21)\n[](#cb6-22)        // process active connections\n[](#cb6-23)        for (size_t i = 1; i < poll_args.size(); ++i) {\n[](#cb6-24)            if (poll_args[i].revents) {\n[](#cb6-25)                Conn *conn = g_data.fd2conn[poll_args[i].fd];\n[](#cb6-26)                connection_io(conn);\n[](#cb6-27)                if (conn->state == STATE_END) {\n[](#cb6-28)                    // client closed normally, or something bad happened.\n[](#cb6-29)                    // destroy this connection\n[](#cb6-30)                    conn_done(conn);\n[](#cb6-31)                }\n[](#cb6-32)            }\n[](#cb6-33)        }\n[](#cb6-34)\n[](#cb6-35)        // handle timers\n[](#cb6-36)        process_timers();\n[](#cb6-37)\n[](#cb6-38)        // try to accept a new connection if the listening fd is active\n[](#cb6-39)        if (poll_args[0].revents) {\n[](#cb6-40)            (void)accept_new_conn(fd);\n[](#cb6-41)        }\n[](#cb6-42)    }\n[](#cb6-43)\n[](#cb6-44)    return 0;\n[](#cb6-45)}\n```", "```cpp\n[](#cb7-1)const uint64_t k_idle_timeout_ms = 5 * 1000;\n[](#cb7-2)\n[](#cb7-3)static uint32_t next_timer_ms() {\n[](#cb7-4)    if (dlist_empty(&g_data.idle_list)) {\n[](#cb7-5)        return 10000;   // no timer, the value doesn't matter\n[](#cb7-6)    }\n[](#cb7-7)\n[](#cb7-8)    uint64_t now_us = get_monotonic_usec();\n[](#cb7-9)    Conn *next = container_of(g_data.idle_list.next, Conn, idle_list);\n[](#cb7-10)    uint64_t next_us = next->idle_start + k_idle_timeout_ms * 1000;\n[](#cb7-11)    if (next_us <= now_us) {\n[](#cb7-12)        // missed?\n[](#cb7-13)        return 0;\n[](#cb7-14)    }\n[](#cb7-15)\n[](#cb7-16)    return (uint32_t)((next_us - now_us) / 1000);\n[](#cb7-17)}\n```", "```cpp\n[](#cb8-1)static void process_timers() {\n[](#cb8-2)    uint64_t now_us = get_monotonic_usec();\n[](#cb8-3)    while (!dlist_empty(&g_data.idle_list)) {\n[](#cb8-4)        Conn *next = container_of(g_data.idle_list.next, Conn, idle_list);\n[](#cb8-5)        uint64_t next_us = next->idle_start + k_idle_timeout_ms * 1000;\n[](#cb8-6)        if (next_us >= now_us + 1000) {\n[](#cb8-7)            // not ready, the extra 1000us is for the ms resolution of poll()\n[](#cb8-8)            break;\n[](#cb8-9)        }\n[](#cb8-10)\n[](#cb8-11)        printf(\"removing idle connection: %d\\n\", next->fd);\n[](#cb8-12)        conn_done(next);\n[](#cb8-13)    }\n[](#cb8-14)}\n```", "```cpp\n[](#cb9-1)static void connection_io(Conn *conn) {\n[](#cb9-2)    // waked up by poll, update the idle timer\n[](#cb9-3)    // by moving conn to the end of the list.\n[](#cb9-4)    conn->idle_start = get_monotonic_usec();\n[](#cb9-5)    dlist_detach(&conn->idle_list);\n[](#cb9-6)    dlist_insert_before(&g_data.idle_list, &conn->idle_list);\n[](#cb9-7)\n[](#cb9-8)    // do the work\n[](#cb9-9)    if (conn->state == STATE_REQ) {\n[](#cb9-10)        state_req(conn);\n[](#cb9-11)    } else if (conn->state == STATE_RES) {\n[](#cb9-12)        state_res(conn);\n[](#cb9-13)    } else {\n[](#cb9-14)        assert(0);  // not expected\n[](#cb9-15)    }\n[](#cb9-16)}\n```", "```cpp\n[](#cb10-1)static int32_t accept_new_conn(int fd) {\n[](#cb10-2)    // code omitted...\n[](#cb10-3)\n[](#cb10-4)    // creating the struct Conn\n[](#cb10-5)    struct Conn *conn = (struct Conn *)malloc(sizeof(struct Conn));\n[](#cb10-6)    if (!conn) {\n[](#cb10-7)        close(connfd);\n[](#cb10-8)        return -1;\n[](#cb10-9)    }\n[](#cb10-10)    conn->fd = connfd;\n[](#cb10-11)    conn->state = STATE_REQ;\n[](#cb10-12)    conn->rbuf_size = 0;\n[](#cb10-13)    conn->wbuf_size = 0;\n[](#cb10-14)    conn->wbuf_sent = 0;\n[](#cb10-15)    conn->idle_start = get_monotonic_usec();\n[](#cb10-16)    dlist_insert_before(&g_data.idle_list, &conn->idle_list);\n[](#cb10-17)    conn_put(g_data.fd2conn, conn);\n[](#cb10-18)    return 0;\n[](#cb10-19)}\n```", "```cpp\n[](#cb11-1)static void conn_done(Conn *conn) {\n[](#cb11-2)    g_data.fd2conn[conn->fd] = NULL;\n[](#cb11-3)    (void)close(conn->fd);\n[](#cb11-4)    dlist_detach(&conn->idle_list);\n[](#cb11-5)    free(conn);\n[](#cb11-6)}\n```", "```cpp\n[](#cb12-1)$ ./server\n[](#cb12-2)removing idle connection: 4\n```", "```cpp\n[](#cb13-1)$ socat tcp:127.0.0.1:1234 -\n```"]