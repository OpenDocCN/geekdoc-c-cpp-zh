["```cpp\nwarehouses=1000\nloadWorkers=100\nterminals=200\nwarehouses-begin=1\nwarehouses-end=1000\n//To run specified transactions per terminal- runMins must equal zero\nrunTxnsPerTerminal=0\n//To run for specified minutes- runTxnsPerTerminal must equal zero\nrunMins=480\n//Number of total transactions per minute\nlimitTxnsPerMin=0\n//Set to true to run in 4.x compatible mode. Set to false to use the\n//entire configured database evenly.\nterminalWarehouseFixed=false\n//The following five values must add up to 100\n//The default percentages of 45, 43, 4, 4 & 4 match the TPC-C spec\nnewOrderWeight=45\npaymentWeight=43\norderStatusWeight=4\ndeliveryWeight=4\nstockLevelWeight=4 \n```", "```cpp\ncommit 1d259b87a63defa814e19a7534380cb43ee23c48\nAuthor: Jakub Łopuszański <jakub.lopuszanski@oracle.com>\nDate:   Wed Feb 5 14:12:22 2020 +0100\n    WL#10314 - InnoDB: Lock-sys optimization: sharded lock_sys mutex\n\n    The Lock-sys orchestrates access to tables and rows. Each table, and each row,\n    can be thought of as a resource, and a transaction may request access right for\n    a resource. As two transactions operating on a single resource can lead to \n    problems if the two operations conflict with each other, Lock-sys remembers\n    lists of already GRANTED lock requests and checks new requests for conflicts in\n    which case they have to start WAITING for their turn.\n\n    Lock-sys stores both GRANTED and WAITING lock requests in lists known as queues.\n    To allow concurrent operations on these queues, we need a mechanism to latch\n    these queues in safe and quick fashion.\n\n    In the past a single latch protected access to all of these queues. \n    This scaled poorly, and the management of queues become a bottleneck.\n\n    In this WL, we introduce a more granular approach to latching. \n```"]