["```rs\n#include <stdexcept>\n#include <vector>\n\ntemplate <typename Label>\nclass DirectedGraph {\n  std::vector<std::vector<size_t>> adjacencies;\n  std::vector<Label> nodeLabels;\n\npublic:\n  size_t addNode(Label label) {\n    adjacencies.push_back(std::vector<size_t>());\n    nodeLabels.push_back(std::move(label));\n    return numNodes() - 1;\n  }\n\n  void addEdge(size_t from, size_t to) {\n    size_t numNodes = this->numNodes();\n    if (from >= numNodes || to >= numNodes) {\n      throw std::invalid_argument(\n          \"Node index out of range\");\n    }\n    adjacencies[from].push_back(to);\n  }\n\n  size_t numNodes() const {\n    return adjacencies.size();\n  }\n}; \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <optional>\n#include <stdexcept> #include <vector> \ntemplate <typename Label>\nclass DirectedGraph {\n std::vector<std::vector<size_t>> adjacencies; std::vector<Label> nodeLabels;   public:\n size_t addNode(Label label) { adjacencies.push_back(std::vector<size_t>()); nodeLabels.push_back(std::move(label)); return numNodes() - 1; }   void addEdge(size_t from, size_t to) { size_t numNodes = this->numNodes(); if (from >= numNodes || to >= numNodes) { throw std::invalid_argument( \"Node index out of range\"); } adjacencies[from].push_back(to); }   size_t numNodes() const { return adjacencies.size(); }    std::optional<size_t> smallestNode() {\n    if (nodeLabels.empty()) {\n      return std::nullopt;\n    }\n    Label &least = nodeLabels[0];\n    size_t index = 0;\n\n    for (int i = 1; i < nodeLabels.size(); i++) {\n      if (least > nodeLabels[i]) {\n        least = nodeLabels[i];\n        index = i;\n      }\n    }\n    return std::optional(index);\n  }\n}; \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\nuse itertools::*;\n\npub struct DirectedGraph<Label> {\n adjacencies: Vec<Vec<usize>>, node_labels: Vec<Label>, }   impl<Label> DirectedGraph<Label> {\n pub fn new() -> Self { DirectedGraph { adjacencies: Vec::new(), node_labels: Vec::new(), } }   pub fn add_node( &mut self, label: Label, ) -> usize { self.adjacencies.push(Vec::new()); self.node_labels.push(label); self.num_nodes() - 1 }   pub fn num_nodes(&self) -> usize { self.node_labels.len() }   pub fn add_edge( &mut self, from: usize, to: usize, ) -> Result<(), &str> { if from > self.num_nodes() || to > self.num_nodes() { Err(\"Node not in graph.\") } else { self.adjacencies[from].push(to); Ok(()) } }      pub fn smallest_node(&self) -> Option<usize>\n    where\n        Label: Ord,\n    {\n        self.node_labels.iter().position_min()\n    }\n}\n```", "```rs\n#include <array>\n#include <cstddef>\n\ntemplate <size_t N>\nstd::array<int, N>\nmakeSequentialArray(int start) {\n  std::array<int, N> arr;\n  for (size_t i = 0; i < N; i++) {\n    arr[i] = start + i;\n  }\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <stdexcept>\n#include <vector>\n\ntemplate <typename Label>\nclass DirectedGraph {\n  std::vector<std::vector<size_t>> adjacencies;\n  // The mistake is here: size_t should be Label\n  std::vector<size_t> nodeLabels;\n\npublic:\n  Label getNode(size_t nodeId) {\n    return nodeLabels[nodeId];\n  }\n\n  size_t addNode(Label label) {\n    adjacencies.push_back(std::vector<size_t>());\n    nodeLabels.push_back(std::move(label));\n    return numNodes() - 1;\n  }\n\n  size_t numNodes() const {\n    return adjacencies.size();\n  }\n};\n\n#define BOOST_TEST_MODULE DirectedGraphTests\n#include <boost/test/included/unit_test.hpp>\n\nBOOST_AUTO_TEST_CASE(test_add_node_int) {\n  DirectedGraph<int> g;\n  auto n1 = g.addNode(1);\n  BOOST_CHECK_EQUAL(1, g.getNode(n1));\n}\n\nBOOST_AUTO_TEST_CASE(test_add_node_float) {\n  DirectedGraph<float> g;\n  float label = 1.0f;\n  auto n1 = g.addNode(label);\n  BOOST_CHECK_CLOSE(label, g.getNode(n1), 0.0001);\n} \n```", "```rs\npub struct DirectedGraph<Label> {\n    adjacencies: Vec<Vec<usize>>,\n    // The mistake is here: size_t should be Label\n    node_labels: Vec<usize>,\n}\n\nimpl<Label> DirectedGraph<Label> {\n    pub fn new() -> Self {\n        DirectedGraph {\n            adjacencies: Vec::new(),\n            node_labels: Vec::new(),\n        }\n    }\n\n    pub fn get_node(\n        &self,\n        node_id: usize,\n    ) -> Option<&Label> {\n        self.node_labels.get(node_id)\n    }\n\n    pub fn add_node(\n        &mut self,\n        label: Label,\n    ) -> usize {\n        self.adjacencies.push(Vec::new());\n        self.node_labels.push(label);\n        self.num_nodes() - 1\n    }\n\n    pub fn num_nodes(&self) -> usize {\n        self.node_labels.len()\n    }\n}\n```", "```rs\nRunning 2 test cases...\n\n*** No errors detected \n```", "```rs\nerror[E0308]: mismatched types\n    --> example.rs:26:31\n     |\n6    | impl<Label> DirectedGraph<Label> {\n     |      ----- found this type parameter\n...\n26   |         self.node_labels.push(label);\n     |                          ---- ^^^^^ expected `usize`, found type parameter `Label`\n     |                          |\n     |                          arguments to this method are incorrect\n     |\n     = note:        expected type `usize`\n             found type parameter `Label` \n```"]