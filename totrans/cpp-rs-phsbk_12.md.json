["```rs\nenum Tag { Rectangle, Triangle };\n\nstruct Shape {\n  Tag tag;\n  union {\n    struct {\n      double width;\n      double height;\n    } rectangle;\n    struct {\n      double base;\n      double height;\n    } triangle;\n  };\n\n  double area() {\n    switch (this->tag) {\n    case Rectangle: {\n      return this->rectangle.width *\n             this->rectangle.height;\n    }\n    case Triangle: {\n      return 0.5 * this->triangle.base *\n             this->triangle.height;\n    }\n    }\n  }\n}; \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>   enum Tag { Rectangle, Triangle, Circle };   struct Shape {\n Tag tag; union { struct { double width; double height; } rectangle; struct { double base; double height; } triangle; struct { double radius; } circle; };    void print_shape() {\n    switch (this->tag) {\n    case Rectangle: {\n      std::cout << \"Rectangle\" << std::endl;\n      break;\n    }\n    default: {\n      std::cout << \"Some other shape\"\n                << std::endl;\n      break;\n    }\n    }\n  }\n}; \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <ranges>\n#include <vector>\n\n// Uses the same Shape definition.\nenum Tag { Rectangle, Triangle };\n\nstruct Shape {\n  Tag tag;\n  union {\n    struct {\n      double width;\n      double height;\n    } rectangle;\n    struct {\n      double base;\n      double height;\n    } triangle;\n  };\n};\n\nstd::vector<Shape> get_shapes() {\n  return std::vector<Shape>{\n      Shape{Triangle, {.triangle = {1.0, 1.0}}},\n      Shape{Triangle, {.triangle = {1.0, 1.0}}},\n      Shape{Rectangle, {.rectangle = {1.0, 1.0}}},\n  };\n}\n\nstd::vector<Shape> get_shapes();\n\nint main() {\n  std::vector<Shape> shapes = get_shapes();\n\n  auto is_triangle = [](Shape shape) {\n    return shape.tag == Triangle;\n  };\n\n  // Create an iterator that only sees the\n  // triangles. (std::views::filter is from C++20,\n  // but the same effect can be acheived with a\n  // custom iterator.)\n  auto triangles =\n      shapes | std::views::filter(is_triangle);\n\n  double total_base = 0.0;\n  for (auto &triangle : triangles) {\n    // Skip checking the tag because we know we\n    // have only triangles.\n    total_base += triangle.triangle.base;\n  }\n\n  return 0;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <variant>\n\nstruct Rectangle {\n  double width;\n  double height;\n};\n\nstruct Triangle {\n  double base;\n  double height;\n};\n\nusing Shape = std::variant<Rectangle, Triangle>;\n\ndouble area(const Shape &shape) {\n  return std::visit(\n      [](auto &&arg) -> double {\n        using T = std::decay_t<decltype(arg)>;\n        if constexpr (std::is_same_v<T, Rectangle>) {\n          return arg.width * arg.height;\n        } else if constexpr (std::is_same_v<T, Triangle>) {\n          return 0.5 * arg.base * arg.height;\n        }\n      },\n      shape);\n} \n```", "```rs\n#include <variant>\n\nstruct Rectangle {\n  double width;\n  double height;\n};\n\nstruct Triangle {\n  double base;\n  double height;\n};\n\nusing Shape = std::variant<Rectangle, Triangle>;\n\ndouble area(const Shape &shape) {\n  return std::visit(\n      [](auto &&arg) -> double {\n        using T = std::decay_t<decltype(arg)>;\n        if constexpr (std::is_same_v<T, Rectangle>) {\n          return arg.width * arg.height;\n        }\n      },\n      shape);\n} \n```", "```rs\nenum Shape {\n    Rectangle { width: f64, height: f64 },\n    Triangle { base: f64, height: f64 },\n}\n\nimpl Shape {\n    fn area(&self) -> f64 {\n        match self {\n            Shape::Rectangle {\n                width,\n                height,\n            } => width * height,\n        }\n    }\n}\n```", "```rs\nexample.cc: In instantiation of ‘area(const Shape&)::<lambda(auto:27&&)> [with auto:27 = const Triangle&]’:\n/usr/include/c++/14.2.1/bits/invoke.h:61:36:   required from ‘constexpr _Res std::__invoke_impl(__invoke_other, _Fn&&, _Args&& ...) [with _Res = double; _Fn = area(const Shape&)::<lambda(auto:27&&)>; _Args = {const Triangle&}]’\n   61 |     { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }\n      |              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/14.2.1/bits/invoke.h:96:40:   required from ‘constexpr typename std::__invoke_result<_Functor, _ArgTypes>::type std::__invoke(_Callable&&, _Args&& ...) [with _Callable = area(const Shape&)::<lambda(auto:27&&)>; _Args = {const Triangle&}; typename __invoke_result<_Functor, _ArgTypes>::type = double]’\n   96 |       return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),\n      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   97 |                                         std::forward<_Args>(__args)...);\n      |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/14.2.1/variant:1060:24:   required from ‘static constexpr decltype(auto) std::__detail::__variant::__gen_vtable_impl<std::__detail::__variant::_Multi_array<_Result_type (*)(_Visitor, _Variants ...)>, std::integer_sequence<long unsigned int, __indices ...> >::__visit_invoke(_Visitor&&, _Variants ...) [with _Result_type = std::__detail::__variant::__deduce_visit_result<double>; _Visitor = area(const Shape&)::<lambda(auto:27&&)>&&; _Variants = {const std::variant<Rectangle, Triangle>&}; long unsigned int ...__indices = {1}]’\n 1060 |           return std::__invoke(std::forward<_Visitor>(__visitor),\n      |                  ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n 1061 |               __element_by_index_or_cookie<__indices>(\n      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n 1062 |                 std::forward<_Variants>(__vars))...);\n      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/14.2.1/variant:1820:5:   required from ‘constexpr decltype(auto) std::__do_visit(_Visitor&&, _Variants&& ...) [with _Result_type = __detail::__variant::__deduce_visit_result<double>; _Visitor = area(const Shape&)::<lambda(auto:27&&)>; _Variants = {const variant<Rectangle, Triangle>&}]’\n 1820 |                   _GLIBCXX_VISIT_CASE(1)\n      |                   ^~~~~~~~~~~~~~~~~~~\n/usr/include/c++/14.2.1/variant:1882:34:   required from ‘constexpr std::__detail::__variant::__visit_result_t<_Visitor, _Variants ...> std::visit(_Visitor&&, _Variants&& ...) [with _Visitor = area(const Shape&)::<lambda(auto:27&&)>; _Variants = {const variant<Rectangle, Triangle>&}; __detail::__variant::__visit_result_t<_Visitor, _Variants ...> = double]’\n 1882 |             return std::__do_visit<_Tag>(\n      |                    ~~~~~~~~~~~~~~~~~~~~~^\n 1883 |               std::forward<_Visitor>(__visitor),\n      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n 1884 |               static_cast<_Vp>(__variants)...);\n      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nexample.cc:17:20:   required from here\n   17 |   return std::visit(\n      |          ~~~~~~~~~~^\n   18 |       [](auto &&arg) -> double {\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~\n   19 |         using T = std::decay_t<decltype(arg)>;\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   20 |         if constexpr (std::is_same_v<T, Rectangle>) {\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   21 |           return arg.width * arg.height;\n      |           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   22 |         }\n      |         ~\n   23 |       },\n      |       ~~\n   24 |       shape);\n      |       ~~~~~~\nexample.cc:23:7: error: no return statement in ‘constexpr’ function returning non-void\n   23 |       },\n      |       ^\nexample.cc: In lambda function:\nexample.cc:23:7: warning: control reaches end of non-void function [-Wreturn-type] \n```", "```rs\nerror[E0004]: non-exhaustive patterns: `&Shape::Triangle { .. }` not covered\n --> example.rs:8:15\n  |\n8 |         match self {\n  |               ^^^^ pattern `&Shape::Triangle { .. }` not covered\n  |\nnote: `Shape` defined here\n --> example.rs:1:6\n  |\n1 | enum Shape {\n  |      ^^^^^\n2 |     Rectangle { width: f64, height: f64 },\n3 |     Triangle { base: f64, height: f64 },\n  |     -------- not covered\n  = note: the matched value is of type `&Shape`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n  |\n12~             } => width * height,\n13~             &Shape::Triangle { .. } => todo!(),\n  | \n```", "```rs\n\n```", "```rs\n\n```"]