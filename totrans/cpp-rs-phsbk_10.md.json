["```rs\n#include <iostream>\n\nstruct Triangle {\n  double base;\n  double height;\n\n  Triangle(double base, double height)\n      : base(base), height(height) {}\n\n  // NOT virtual: it will be used with static\n  // dispatch\n  double area() const {\n    return 0.5 * base * height;\n  }\n};\n\n// Generic function using interface\ntemplate <class T>\ndouble twiceArea(const T &shape) {\n  return shape.area() * 2;\n}\n\nint main() {\n  Triangle triangle{1.0, 1.0};\n\n  std::cout << twiceArea(triangle) << std::endl;\n  return 0;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <concepts>\n\ntemplate <typename T>\nconcept shape = requires(const T &t) {\n  { t.area() } -> std::same_as<double>;\n};\n\ntemplate <shape T>\ndouble twiceArea(const T &shape) {\n  return shape.area() * 2.0;\n} \n```", "```rs\n#include <concepts>\n#include <iostream>\n\nstruct Shape {\n  Shape() {}\n  virtual ~Shape() {}\n  virtual double area() const = 0;\n};\n\ntemplate <typename T>\nconcept shape = std::derived_from<T, Shape>;\n\nstruct Triangle : public Shape {\n  double base;\n  double height;\n\n  Triangle(double base, double height)\n      : base(base), height(height) {}\n\n  // still will be used with static dispatch\n  double area() const override {\n    return 0.5 * base * height;\n  }\n};\n\ntemplate <shape T>\ndouble twiceArea(const T &shape) {\n  return shape.area() * 2;\n}\n\nint main() {\n  Triangle triangle{1.0, 1.0};\n\n  std::cout << twiceArea(triangle) << std::endl;\n  return 0;\n} \n```", "```rs\n#include <concepts>\n\nstruct Shape {\n  Shape() {}\n  virtual ~Shape() {}\n  virtual double area() = 0;\n};\n\ntemplate <typename T>\nconcept shape = std::derived_from<T, Shape>;\n\ntemplate <shape T>\ndouble twiceArea(const T &shape) {\n  // note the call to a method not defined in Shape\n  return shape.volume() * 2;\n} \n```", "```rs\ntrait Shape {\n    fn area(&self) -> f64;\n}\n\nfn twice_area<T: Shape>(shape: &T) -> f64 {\n    // note the call to a method not defined in Shape\n    2.0 * shape.volume()\n}\n```", "```rs\nerror[E0599]: no method named `volume` found for reference `&T` in the current scope\n --> example.rs:7:17\n  |\n7 |     2.0 * shape.volume()\n  |                 ^^^^^^ method not found in `&T` \n```", "```rs\ntemplate <shape T>\ndouble twiceArea(const T &shape) {\n  return 2.0 * shape.area();\n} \n```", "```rs\nfn twice_area<T: Shape>(shape: &T) -> f64 {\n    2.0 * shape.area()\n}\n```", "```rs\ntemplate <typename T>\n  requires shape<T>\ndouble twiceArea(const T &shape) {\n  return 2.0 * shape.area();\n} \n```", "```rs\nfn twice_area<T>(shape: &T) -> f64\nwhere\n    T: Shape,\n{\n    2.0 * shape.area()\n}\n```", "```rs\ndouble twiceArea(const shape auto &shape) {\n  return 2.0 * shape.area();\n} \n```", "```rs\nfn twice_area(shape: &impl Shape) -> f64 {\n    2.0 * shape.area()\n}\n```", "```rs\n#include <memory>   struct Shape {\n Shape() {} virtual ~Shape() {} virtual double area() = 0; };   template<typename S>\nvoid store(S s, std::unique_ptr<Shape> data) {\n    // Will pointers or references in `s` become dangling while `data`\n    // is still in use?\n\t*data = s;\n} \n```", "```rs\ntrait Shape {}   fn store<S: Shape>(x: S, data: &mut Box<dyn Shape>) {\n    *data = Box::new(x);\n}\n```", "```rs\nerror[E0310]: the parameter type `S` may not live long enough\n --> example.rs:7:5\n  |\n7 |     *data = Box::new(x);\n  |     ^^^^^\n  |     |\n  |     the parameter type `S` must be valid for the static lifetime...\n  |     ...so that the type `S` will meet its required lifetime bounds\n  | \n```", "```rs\ntrait Shape {}   struct Triangle {\n base: f64, height: f64, }   impl Shape for Triangle {}   // The type parameter S is assigned no lifetime bound.\nfn store<'a, S: Shape>(\n    x: S,\n    // The reference is assigned a fresh lifetime by rule\n    // [lifetime-elision.function.implicit-lifetime-parameters].\n    //\n    // The trait object is assigned 'static by rule\n    // [lifetime-elision.trait-object.default] and\n    // [lifetime-elision.trait-object.innermost-type].\n    data: &'a mut Box<dyn Shape + 'static>,\n) {\n    *data = Box::new(x);\n}\n\n// An example of how the implementation of store could be misused with\n// the given type.\nfn main() {\n    let triangle = Triangle {\n        base: 1.0,\n        height: 2.0,\n    };\n    let mut b: Box<dyn Shape> = Box::new(triangle);\n    {\n        let short_lived_triangle = Triangle {\n            base: 5.0,\n            height: 10.0,\n        };\n        store(short_lived_triangle, &mut b);\n    }\n    // Here b contains a dangling reference.\n}\n```", "```rs\n\n```", "```rs\n\n```"]