["```cpp\n[](#cb1-1)struct ZSet {\n[](#cb1-2)    AVLNode *tree = NULL;\n[](#cb1-3)    HMap hmap;\n[](#cb1-4)};\n[](#cb1-5)\n[](#cb1-6)struct ZNode {\n[](#cb1-7)    AVLNode tree;\n[](#cb1-8)    HNode hmap;\n[](#cb1-9)    double score = 0;\n[](#cb1-10)    size_t len = 0;\n[](#cb1-11)    char name[0];\n[](#cb1-12)};\n[](#cb1-13)\n[](#cb1-14)static ZNode *znode_new(const char *name, size_t len, double score) {\n[](#cb1-15)    ZNode *node = (ZNode *)malloc(sizeof(ZNode) + len);\n[](#cb1-16)    assert(node);   // not a good idea in real projects\n[](#cb1-17)    avl_init(&node->tree);\n[](#cb1-18)    node->hmap.next = NULL;\n[](#cb1-19)    node->hmap.hcode = str_hash((uint8_t *)name, len);\n[](#cb1-20)    node->score = score;\n[](#cb1-21)    node->len = len;\n[](#cb1-22)    memcpy(&node->name[0], name, len);\n[](#cb1-23)    return node;\n[](#cb1-24)}\n```", "```cpp\n[](#cb2-1)// insert into the AVL tree\n[](#cb2-2)static void tree_add(ZSet *zset, ZNode *node) {\n[](#cb2-3)    if (!zset->tree) {\n[](#cb2-4)        zset->tree = &node->tree;\n[](#cb2-5)        return;\n[](#cb2-6)    }\n[](#cb2-7)\n[](#cb2-8)    AVLNode *cur = zset->tree;\n[](#cb2-9)    while (true) {\n[](#cb2-10)        AVLNode **from = zless(&node->tree, cur) ? &cur->left : &cur->right;\n[](#cb2-11)        if (!*from) {\n[](#cb2-12)            *from = &node->tree;\n[](#cb2-13)            node->tree.parent = cur;\n[](#cb2-14)            zset->tree = avl_fix(&node->tree);\n[](#cb2-15)            break;\n[](#cb2-16)        }\n[](#cb2-17)        cur = *from;\n[](#cb2-18)    }\n[](#cb2-19)}\n```", "```cpp\n[](#cb3-1)// compare by the (score, name) tuple\n[](#cb3-2)static bool zless(\n[](#cb3-3)    AVLNode *lhs, double score, const char *name, size_t len)\n[](#cb3-4){\n[](#cb3-5)    ZNode *zl = container_of(lhs, ZNode, tree);\n[](#cb3-6)    if (zl->score != score) {\n[](#cb3-7)        return zl->score < score;\n[](#cb3-8)    }\n[](#cb3-9)    int rv = memcmp(zl->name, name, min(zl->len, len));\n[](#cb3-10)    if (rv != 0) {\n[](#cb3-11)        return rv < 0;\n[](#cb3-12)    }\n[](#cb3-13)    return zl->len < len;\n[](#cb3-14)}\n[](#cb3-15)\n[](#cb3-16)static bool zless(AVLNode *lhs, AVLNode *rhs) {\n[](#cb3-17)    ZNode *zr = container_of(rhs, ZNode, tree);\n[](#cb3-18)    return zless(lhs, zr->score, zr->name, zr->len);\n[](#cb3-19)}\n```", "```cpp\n[](#cb4-1)// update the score of an existing node (AVL tree reinsertion)\n[](#cb4-2)static void zset_update(ZSet *zset, ZNode *node, double score) {\n[](#cb4-3)    if (node->score == score) {\n[](#cb4-4)        return;\n[](#cb4-5)    }\n[](#cb4-6)    zset->tree = avl_del(&node->tree);\n[](#cb4-7)    node->score = score;\n[](#cb4-8)    avl_init(&node->tree);\n[](#cb4-9)    tree_add(zset, node);\n[](#cb4-10)}\n[](#cb4-11)\n[](#cb4-12)// add a new (score, name) tuple, or update the score of the existing tuple\n[](#cb4-13)bool zset_add(ZSet *zset, const char *name, size_t len, double score) {\n[](#cb4-14)    ZNode *node = zset_lookup(zset, name, len);\n[](#cb4-15)    if (node) {\n[](#cb4-16)        zset_update(zset, node, score);\n[](#cb4-17)        return false;\n[](#cb4-18)    } else {\n[](#cb4-19)        node = znode_new(name, len, score);\n[](#cb4-20)        hm_insert(&zset->hmap, &node->hmap);\n[](#cb4-21)        tree_add(zset, node);\n[](#cb4-22)        return true;\n[](#cb4-23)    }\n[](#cb4-24)}\n[](#cb4-25)\n[](#cb4-26)// lookup by name\n[](#cb4-27)ZNode *zset_lookup(ZSet *zset, const char *name, size_t len) {\n[](#cb4-28)    // just a hashtable look up\n[](#cb4-29)    // code omitted...\n[](#cb4-30)}\n```", "```cpp\n[](#cb5-1)// find the (score, name) tuple that is greater or equal to the argument,\n[](#cb5-2)// then offset relative to it.\n[](#cb5-3)ZNode *zset_query(\n[](#cb5-4)    ZSet *zset, double score, const char *name, size_t len, int64_t offset)\n[](#cb5-5){\n[](#cb5-6)    AVLNode *found = NULL;\n[](#cb5-7)    AVLNode *cur = zset->tree;\n[](#cb5-8)    while (cur) {\n[](#cb5-9)        if (zless(cur, score, name, len)) {\n[](#cb5-10)            cur = cur->right;\n[](#cb5-11)        } else {\n[](#cb5-12)            found = cur;    // candidate\n[](#cb5-13)            cur = cur->left;\n[](#cb5-14)        }\n[](#cb5-15)    }\n[](#cb5-16)\n[](#cb5-17)    if (found) {\n[](#cb5-18)        found = avl_offset(found, offset);\n[](#cb5-19)    }\n[](#cb5-20)    return found ? container_of(found, ZNode, tree) : NULL;\n[](#cb5-21)}\n```", "```cpp\n[](#cb6-1)struct AVLNode {\n[](#cb6-2)    uint32_t depth = 0;\n[](#cb6-3)    uint32_t cnt = 0;\n[](#cb6-4)    AVLNode *left = NULL;\n[](#cb6-5)    AVLNode *right = NULL;\n[](#cb6-6)    AVLNode *parent = NULL;\n[](#cb6-7)};\n```", "```cpp\n[](#cb7-1)// offset into the succeeding or preceding node.\n[](#cb7-2)// note: the worst-case is O(log(n)) regardless of how long the offset is.\n[](#cb7-3)AVLNode *avl_offset(AVLNode *node, int64_t offset) {\n[](#cb7-4)    int64_t pos = 0;    // relative to the starting node\n[](#cb7-5)    while (offset != pos) {\n[](#cb7-6)        if (pos < offset && pos + avl_cnt(node->right) >= offset) {\n[](#cb7-7)            // the target is inside the right subtree\n[](#cb7-8)            node = node->right;\n[](#cb7-9)            pos += avl_cnt(node->left) + 1;\n[](#cb7-10)        } else if (pos > offset && pos - avl_cnt(node->left) <= offset) {\n[](#cb7-11)            // the target is inside the left subtree\n[](#cb7-12)            node = node->left;\n[](#cb7-13)            pos -= avl_cnt(node->right) + 1;\n[](#cb7-14)        } else {\n[](#cb7-15)            // go to the parent\n[](#cb7-16)            AVLNode *parent = node->parent;\n[](#cb7-17)            if (!parent) {\n[](#cb7-18)                return NULL;\n[](#cb7-19)            }\n[](#cb7-20)            if (parent->right == node) {\n[](#cb7-21)                pos -= avl_cnt(node->left) + 1;\n[](#cb7-22)            } else {\n[](#cb7-23)                pos += avl_cnt(node->right) + 1;\n[](#cb7-24)            }\n[](#cb7-25)            node = parent;\n[](#cb7-26)        }\n[](#cb7-27)    }\n[](#cb7-28)    return node;\n[](#cb7-29)}\n```", "```cpp\n[](#cb8-1)static void test_case(uint32_t sz) {\n[](#cb8-2)    Container c;\n[](#cb8-3)    for (uint32_t i = 0; i < sz; ++i) {\n[](#cb8-4)        add(c, i);\n[](#cb8-5)    }\n[](#cb8-6)\n[](#cb8-7)    AVLNode *min = c.root;\n[](#cb8-8)    while (min->left) {\n[](#cb8-9)        min = min->left;\n[](#cb8-10)    }\n[](#cb8-11)    for (uint32_t i = 0; i < sz; ++i) {\n[](#cb8-12)        AVLNode *node = avl_offset(min, (int64_t)i);\n[](#cb8-13)        assert(container_of(node, Data, node)->val == i);\n[](#cb8-14)\n[](#cb8-15)        for (uint32_t j = 0; j < sz; ++j) {\n[](#cb8-16)            int64_t offset = (int64_t)j - (int64_t)i;\n[](#cb8-17)            AVLNode *n2 = avl_offset(node, offset);\n[](#cb8-18)            assert(container_of(n2, Data, node)->val == j);\n[](#cb8-19)        }\n[](#cb8-20)        assert(!avl_offset(node, -(int64_t)i - 1));\n[](#cb8-21)        assert(!avl_offset(node, sz - i));\n[](#cb8-22)    }\n[](#cb8-23)\n[](#cb8-24)    dispose(c.root);\n[](#cb8-25)}\n```", "```cpp\n[](#cb9-1)enum {\n[](#cb9-2)    T_STR = 0,\n[](#cb9-3)    T_ZSET = 1,\n[](#cb9-4)};\n[](#cb9-5)\n[](#cb9-6)// the structure for the key\n[](#cb9-7)struct Entry {\n[](#cb9-8)    struct HNode node;\n[](#cb9-9)    std::string  key;\n[](#cb9-10)    std::string  val;\n[](#cb9-11)    uint32_t type = 0;\n[](#cb9-12)    ZSet *zset = NULL;\n[](#cb9-13)};\n```", "```cpp\n[](#cb10-1)CASES = r'''\n[](#cb10-2)$ ./client zscore asdf n1\n[](#cb10-3)(nil)\n[](#cb10-4)$ ./client zquery xxx 1 asdf 1 10\n[](#cb10-5)(arr) len=0\n[](#cb10-6)(arr) end\n[](#cb10-7)# more cases...\n[](#cb10-8)'''\n[](#cb10-9)\n[](#cb10-10)import shlex\n[](#cb10-11)import subprocess\n[](#cb10-12)\n[](#cb10-13)cmds = []\n[](#cb10-14)outputs = []\n[](#cb10-15)lines = CASES.splitlines()\n[](#cb10-16)for x in lines:\n[](#cb10-17)    x = x.strip()\n[](#cb10-18)    if not x:\n[](#cb10-19)        continue\n[](#cb10-20)    if x.startswith('$ '):\n[](#cb10-21)        cmds.append(x[2:])\n[](#cb10-22)        outputs.append('')\n[](#cb10-23)    else:\n[](#cb10-24)        outputs[-1] = outputs[-1] + x + '\\n'\n[](#cb10-25)\n[](#cb10-26)assert len(cmds) == len(outputs)\n[](#cb10-27)for cmd, expect in zip(cmds, outputs):\n[](#cb10-28)    out = subprocess.check_output(shlex.split(cmd)).decode('utf-8')\n[](#cb10-29)    assert out == expect, f'cmd:{cmd} out:{out}'\n```"]