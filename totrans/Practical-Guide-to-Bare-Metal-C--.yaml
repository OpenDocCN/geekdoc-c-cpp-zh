- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2025-12-10 18:30:43'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2025-12-10 18:30:43
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: Practical Guide to Bare Metal C++
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用指南：裸机C++
- en: 来源：[https://arobenko.github.io/bare_metal_cpp/#_data_serialisation](https://arobenko.github.io/bare_metal_cpp/#_data_serialisation)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://arobenko.github.io/bare_metal_cpp/#_data_serialisation](https://arobenko.github.io/bare_metal_cpp/#_data_serialisation)
- en: Overview
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Once in a while I encounter a question whether C++ is suitable for embedded
    development and bare metal development in particular. There are multiple articles
    of how C++ is superior to C, that everything you can do in C you can do in C++
    with a lot of extras, and that it should be used even with bare metal development.
    However, I haven’t found many practical guides or tutorials of how to use C++
    superiority and boost development process compared to conventional approach of
    using “C” programming language. With this book I hope to explain and show examples
    of how to implement **soft** real time systems without prioritising interrupts
    and without any need for complex real time task scheduling. Hopefully it will
    help someone to get started with using C++ in embedded bare metal development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我会遇到这样的问题：C++是否适合嵌入式开发，尤其是裸机开发。有多篇文章认为C++优于C，你可以在C++中做的一切都可以在C中做，并且还有许多额外的功能，甚至应该用于裸机开发。然而，我没有找到很多关于如何使用C++的优势和提升开发过程与传统的使用“C”编程语言方法的实际指南或教程。通过这本书，我希望解释并展示如何实现**软实时系统**，而不需要优先考虑中断，也不需要任何复杂的实时任务调度。希望它能帮助某人开始使用C++进行嵌入式裸机开发。
- en: This work is licensed under a [Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](http://creativecommons.org/licenses/by-nc-sa/4.0/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本作品受[Commons Attribution-NonCommercial-ShareAlike 4.0国际许可协议](http://creativecommons.org/licenses/by-nc-sa/4.0/)的许可。
- en: '![cc by nd](img/fb70fd05f48d6bf68393251b58afb451.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![cc by nd](img/fb70fd05f48d6bf68393251b58afb451.png)'
- en: Audience
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受众
- en: The primary intended audience of this document is professional C++ developers
    who want to understand bare metal development a little bit better, get to know
    how to use their favourite programming language in an embedded environment, and
    probably bring their C++ skills to an “expert” level. Why **professional**? Because
    bare metal platform has lots of limitations. In most cases no exceptions and no
    runtime type information (RTTI) support will be available. In many cases the dynamic
    memory allocation will also be excluded. In order to be able to use C++ effectively
    you will have to have deep knowledge of existing C++ idioms, constructs and STL
    contents. You must know how your favourite data structures are implemented and
    whether it is possible to reuse them in your environment. If it is not possible
    to use the STL (or any other library) code “as is”, you will have to implement
    a reduced version of it, and it is better to know how the library developers implemented
    the feature and how to make it work with the constrains of your environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档的主要目标受众是希望更好地理解裸机开发的专业C++开发者，了解如何在嵌入式环境中使用他们喜欢的编程语言，并可能将他们的C++技能提升到“专家”水平。为什么是**专业**开发者？因为裸机平台有很多限制。在大多数情况下，将没有异常和运行时类型信息（RTTI）的支持。在许多情况下，动态内存分配也将被排除。为了能够有效地使用C++，你必须对现有的C++惯用用法、构造和STL内容有深入的了解。你必须知道你喜欢的数据结构是如何实现的，以及是否可以在你的环境中重用它们。如果无法直接使用STL（或任何其他库）代码，你必须实现它的简化版本，并且最好知道库开发者是如何实现该功能的，以及如何使其适应你环境的限制。
- en: The professional embedded developers with intermediate knowledge of C++ may
    also find this document useful. They will probably benefit from lots of C++ insights
    and will have several “eureka” moments with “I didn’t know I could do that!!!”
    kind of thoughts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有中级C++知识的专业嵌入式开发者，这份文档也可能很有用。他们可能会从许多C++洞察中受益，并会有几次“我没想到我能做到这一点！”这样的顿悟时刻。
- en: If your C++ knowledge doesn’t go much beyond polymorphism and virtual functions,
    if template meta-programming doesn’t mean anything to you, probably you are not
    ready to use C++ in the embedded environment and this document will probably be
    too complex to understand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的C++知识仅限于多态和虚函数，如果模板元编程对你来说毫无意义，那么你可能还没有准备好在嵌入式环境中使用C++，这份文档可能也会过于复杂而难以理解。
- en: I’d like to emphasise the fact that this is NOT a C++ tutorial. There are lots
    of resources on the web that teach conventional C++ with OS services, exceptions
    and RTTI. My personal opinion is that you have to master C++ in regular environment
    before using it effectively in the bare metal world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调的是，这**不是一个 C++ 教程**。网上有很多资源教授传统的 C++，包括操作系统服务、异常和 RTTI。我个人的观点是，在使用裸机世界之前，你必须掌握在常规环境下的
    C++。
- en: C++ Popularity
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++ 的流行度
- en: C++ is quite popular in the embedded world of Linux-based embedded systems.
    However, it is not that popular in bare metal development. Why? Probably because
    of its complexity. Knowing C++ syntax is not enough. To use it effectively the
    developer must know what Standard Template Library (STL) provides, what can and
    what cannot be used when developing for specific platform. STL mastery is also
    not enough, the developer should have some level of proficiency in template meta-programming.
    Although there is an opinion that templates are dangerous because of executable
    code bloating, I think that templates are developer’s friends, but the one must
    know the dangers and know how to use templates effectively. But again, it requires
    time and effort to get to know how to do it right.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 在基于 Linux 的嵌入式系统中相当流行。然而，在裸机开发中并不那么流行。为什么？可能是因为它的复杂性。仅仅了解 C++ 语法是不够的。为了有效地使用它，开发者必须知道标准模板库（STL）提供了什么，在为特定平台开发时什么可以使用，什么不可以使用。对
    STL 的精通也不够，开发者应该对模板元编程有一定的熟练程度。尽管有人认为模板因为可执行代码膨胀而危险，但我认为模板是开发者的朋友，但必须知道这些危险并知道如何有效地使用模板。但再次强调，要正确地做到这一点，需要时间和努力。
- en: 'Another reason why C++ is not used in bare metal development is that software
    in significant number (if not majority) of projects gets written by hardware developers,
    at least in its first stages just to make sure the hardware works as expected.
    The “C” programming language is a natural choice for them. And of course majority
    of hardware developers lack proficiency in software development. They may have
    some difficulties writing code of good quality in “C”, not to mention “C++”. After
    software reaches certain level of complexity it is handed over to software engineers
    who are not allowed to re-implement it from scratch. They are told something like:
    “This code almost works, just fix a couple of bugs, implement this short set of
    features and we’re good to go. Throwing away the existing code is a waste, we
    do not have time to re-implement it.”'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因，为什么 C++ 不用于裸机开发，是因为在许多项目（如果不是大多数项目）中，软件是由硬件开发者编写的，至少在最初阶段是为了确保硬件按预期工作。对于他们来说，“C”编程语言是一个自然的选择。当然，大多数硬件开发者缺乏软件开发的专业知识。他们可能难以编写高质量的“C”代码，更不用说“C++”了。当软件达到一定复杂度时，它会被转交给不允许从头开始重新实现的软件工程师。他们被告知：“这段代码几乎可以工作，只需修复几个错误，实现这个简短的功能集，我们就可以继续了。丢弃现有的代码是浪费，我们没有时间重新实现它。”
- en: The last reason, I think, is psychological one. People prefer to be wrong in
    a group than right by themselves. When majority of bare metal products being developed
    using “C”, it feels risky and unnatural to choose “C++”, even though the latter
    is better choice from the technological perspective.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个原因，我认为，是一个心理原因。人们宁愿在群体中犯错，也不愿自己正确。当大多数基于 Linux 的嵌入式系统产品正在使用“C”进行开发时，选择“C++”会感觉风险和自然，尽管从技术角度来看后者是一个更好的选择。
- en: Benefits of C++
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++ 的好处
- en: The primary reason to prefer C++ over C is **code reuse**. Thanks to templates,
    it is much easier to implement generic piece of code that can be reused between
    projects in C++ than in C. When implementing everything from scratch, then probably
    using C++ instead of C won’t give any significant advantage in terms of development
    effort, maybe even extend it. However, once generic components have been developed,
    the whole development process for next projects will be much easier and faster,
    thanks to reuse of the former.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 C++ 而不是 C 的主要原因是**代码重用**。多亏了模板，在 C++ 中实现通用的代码块，使其能够在项目之间重用，比在 C 中要容易得多。当从头开始实现所有内容时，使用
    C++ 而不是 C 在开发工作量方面可能不会带来任何显著的优势，甚至可能增加工作量。然而，一旦开发出了通用组件，下一个项目的整个开发过程将会因为重用之前的组件而变得更加容易和快速。
- en: Contents of This Book
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本书内容
- en: This document introduces several concepts that can be used in bare-metal development
    as well as shows how they can be implemented using features of latest (at the
    time of writing) C++11 standard.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档介绍了可以在裸机开发中使用的几个概念，并展示了如何使用当时最新（撰写时）的 C++11 标准实现它们。
- en: The code of generic components is implemented as part of “Embedded C++ Library”
    project called “embxx” and can be found at [https://github.com/arobenko/embxx](https://github.com/arobenko/embxx).
    It has GPLv3 licence.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通用组件的代码作为“嵌入式 C++ 库”项目“embxx”的一部分实现，可以在[https://github.com/arobenko/embxx](https://github.com/arobenko/embxx)找到。它拥有
    GPLv3 许可证。
- en: There is also a project that implements multiple simple bare metal applications
    using [embxx](https://github.com/arobenko/embxx) which can run on RaspberryPi
    platform. The source code can be found at [https://github.com/arobenko/embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi).
    It also has GPLv3 licence.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个项目实现了多个简单的裸机应用程序，使用 [embxx](https://github.com/arobenko/embxx) 可以在 RaspberryPi
    平台上运行。源代码可以在 [https://github.com/arobenko/embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)
    找到。它也拥有 GPLv3 许可证。
- en: 'Both projects require gcc version 4.7 or higher, because of C++11 support requirement.
    They also use [CMake](http://www.cmake.org) as their build system. The code has
    been tested with following free toolchains:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个项目都需要 gcc 版本 4.7 或更高版本，因为需要 C++11 支持。它们还使用 [CMake](http://www.cmake.org) 作为它们的构建系统。代码已经与以下免费工具链进行了测试：
- en: '[GNU Tools for ARM Embedded Processors](https://launchpad.net/gcc-arm-embedded)
    on Launchpad'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Launchpad 上的 [GNU Tools for ARM Embedded Processors](https://launchpad.net/gcc-arm-embedded)
- en: '[Sourcery CodeBench Lite Edition](http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sourcery CodeBench Lite Edition](http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/)'
- en: The whole document is ARM platform centric. At this moment I do not try to cover
    anything else.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文档以 ARM 平台为中心。目前我并不尝试涵盖其他内容。
- en: 'To compile Raspberry Pi example applications in Linux environment use the following
    steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 环境中编译 Raspberry Pi 示例应用程序，请按照以下步骤操作：
- en: Checkout [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检出 [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) 项目
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create separate build directory and cd to it
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单独的构建目录并切换到该目录
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Generate makefiles
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成 makefiles
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that last parameter to cmake is relative or absolute path to the root of
    the source tree. Also note that [embxx](https://github.com/arobenko/embxx) library
    will be checked out as external git submodule during this process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，cmake 的最后一个参数是源树根的相对或绝对路径。另外注意，[embxx](https://github.com/arobenko/embxx)
    库将在此过程中作为外部 git 子模块检出。
- en: Build the applications
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Take the generated image from `<build_dir>/image/<app_name>/kernel.img`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `<build_dir>/image/<app_name>/kernel.img` 中获取生成的镜像
- en: 'The CMake provides the following build types, which I believe are self-explanatory:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供以下构建类型，我认为它们是自解释的：
- en: None (default)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: None（默认）
- en: Debug
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debug
- en: Release
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Release
- en: MinSizeRel
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MinSizeRel
- en: RelWithDebInfo
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RelWithDebInfo
- en: 'To specify the required build type use `-DCMAKE_BUILD_TYPE=<value>` option
    of cmake utility:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定所需的构建类型，请使用 cmake 实用工具的 `-DCMAKE_BUILD_TYPE=<value>` 选项：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If no build type is specified, the default one is **None**, which is similar
    to **Debug**, but without `-g` compilation option, i.e. no optimisations and no
    debugging information is generated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定构建类型，默认类型是**None**，这与**Debug**类似，但没有 `-g` 编译选项，即不进行优化也不生成调试信息。
- en: 'It is possible to specify the cross-compilation toolchain prefix. By default
    `arm-none-eabi-` is expected, i.e. `arm-none-eabi-gcc`, `arm-none-eabi-g++` and
    `arm-none-eabi-as` are used to compile the sources. If these utilities cannot
    be found in environment search paths, then you should specify the prefix passing
    `-DCROSS_COMPILE=<prefix>` option to cmake:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定交叉编译工具链的前缀。默认期望 `arm-none-eabi-`，即 `arm-none-eabi-gcc`、`arm-none-eabi-g++`
    和 `arm-none-eabi-as` 用于编译源代码。如果这些实用工具在环境搜索路径中找不到，那么您应该通过传递 `-DCROSS_COMPILE=<prefix>`
    选项到 cmake 来指定前缀：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To see the commands used to compile the sources, prefix `make` with `VERBOSE=1`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看编译源代码使用的命令，请在 `make` 前面加上 `VERBOSE=1`：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The [embxx](https://github.com/arobenko/embxx) library has doxygen generated
    documentation. It can be found at [release artifacts](https://github.com/arobenko/embxx/releases).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx](https://github.com/arobenko/embxx) 库有 doxygen 生成的文档。可以在 [发布工件](https://github.com/arobenko/embxx/releases)
    中找到。'
- en: Contribution
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贡献
- en: If you have any suggestions, requests, bug fixes, spelling mistakes fixes, or
    maybe you feel that some things are not explained properly, please feel free to
    e-mail me to **arobenko@gmail.com**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何建议、请求、错误修复、拼写错误修复，或者您觉得某些事情没有解释清楚，请随时通过电子邮件联系我 **arobenko@gmail.com**。
- en: Reading Offline
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离线读取
- en: The source code of this book is hosted on [github](https://github.com/arobenko/bare_metal_cpp_src)
    and both PDF and HTML versions of this book can be downloaded from the [release_artifacts](https://github.com/arobenko/bare_metal_cpp_src/releases).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码托管在 [github](https://github.com/arobenko/bare_metal_cpp_src) 上，本书的PDF和HTML版本可以从
    [release_artifacts](https://github.com/arobenko/bare_metal_cpp_src/releases) 下载。
- en: Know Your Compiler Output
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解您的编译器输出
- en: To successfully use C++ language and its libraries in bare metal development
    it is important to know what binary code compiler generates from the C++ source
    code. This section will lead you through the process of building simple testing
    applications and analysis of their binary code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在裸机开发中成功使用C++语言及其库，了解编译器从C++源代码生成的二进制代码非常重要。本节将引导您通过构建简单测试应用程序并分析它们的二进制代码的过程。
- en: Test Applications
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: 'The [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project contains
    several simple test application, which are intended to be used for binary code
    analysis only and not to be executed on the target platform. This applications
    reside in [src/test_cpp](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp)
    directory. In order to properly analyse the code that compiler produces for production
    environment, let’s compile all the applications in Release mode:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) 项目包含几个简单的测试应用程序，这些应用程序仅用于二进制代码分析，不应在目标平台上执行。这些应用程序位于
    [src/test_cpp](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp)
    目录中。为了正确分析编译器为生产环境生成的代码，让我们以发布模式编译所有应用程序：'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The listing file of every application will be `<build_dir_somewhere>/src/test_cpp/<app_name>/kernel.list`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序的列表文件将是 `<build_dir_somewhere>/src/test_cpp/<app_name>/kernel.list`。
- en: Get Simple Application Compiled
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单应用程序编译
- en: Let’s try to compile simple application of infinite loop, called [test_cpp_simple](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编译一个无限循环的简单应用程序，称为 [test_cpp_simple](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple)。
- en: A linker script is required to get all the generated objects successfully linked.
    It states what code/data sections need to be loaded at what addresses as well
    as defines several symbols that may be required by the sources. [Here](http://www.delorie.com/gnu/docs/binutils/ld_6.html)
    is a good manual of linker script syntax and [here](https://github.com/arobenko/embxx_on_rpi/blob/master/src/raspberrypi.ld)
    is the linker script I use to get applications linked for Raspberry Pi platform.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功地将所有生成的对象链接起来，需要一个链接脚本。它说明了哪些代码/数据段需要在什么地址加载，以及定义了可能由源代码需要的几个符号。[这里](http://www.delorie.com/gnu/docs/binutils/ld_6.html)是一个关于链接脚本语法的良好手册，[这里](https://github.com/arobenko/embxx_on_rpi/blob/master/src/raspberrypi.ld)是我用来为Raspberry
    Pi平台链接应用程序的链接脚本。
- en: Depending on your compiler, the link may fail because some symbols are missing.
    For example `__exidx_start` and `__exidx_end` are needed when the application
    is compiled with exceptions support, or `__bss_start__` and `__bss_end__` may
    be required by standard library if it contains the code for zeroing `.bss` section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的编译器，链接可能会失败，因为某些符号缺失。例如，当应用程序使用异常支持编译时，需要 `__exidx_start` 和 `__exidx_end`，或者如果标准库包含清零
    `.bss` 段的代码，可能需要 `__bss_start__` 和 `__bss_end__`。
- en: 'Every application must have a startup code usually written in Assembler. This
    startup code must perform the following steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都必须有一个启动代码，通常用汇编语言编写。这个启动代码必须执行以下步骤：
- en: Write the interrupt vector table at appropriate location (usually at address
    0x0000).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的位置（通常在地址0x0000）写入中断向量表。
- en: Set the stack pointers for every runtime mode.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个运行时模式设置栈指针。
- en: Zero the .bss section
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清零 .bss 段
- en: Call constructors of global (static) objects (applicable only to C++)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用全局（静态）对象的构造函数（仅适用于C++）
- en: Call the main function.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用主函数。
- en: It may happen that compiler generates some startup code for you, especially
    if you haven’t excluded standard library (stdlib) from compilation. To check whether
    this is the case, we need to analyse assembler listing of the successfully compiled
    and linked image binary. All the generated files for a test application will reside
    in `<build_dir>/src/test_cpp/<app_name>`. The assembler listing file will have
    `kernel.list` name.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生编译器为您生成一些启动代码的情况，尤其是如果您没有从编译中排除标准库（stdlib）。为了检查这是否是这种情况，我们需要分析成功编译和链接的图像二进制文件的汇编列表。测试应用程序的所有生成文件都将位于`<build_dir>/src/test_cpp/<app_name>`。汇编列表文件将具有`kernel.list`名称。
- en: '**Side note**: the assembler listing can be generated using the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**旁注**：可以使用以下命令生成汇编列表：'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Open the listing file and look for function with **CRT** string in it. **CRT**
    stands for “C Run-Time”. When using [this](https://launchpad.net/gcc-arm-embedded)
    compiler, the function that compiler has generated, is called `_mainCRTStartup`.
    Let’s take closer look what this function does.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 打开列表文件，查找包含**CRT**字符串的函数。**CRT**代表“C运行时”。当使用[这个](https://launchpad.net/gcc-arm-embedded)编译器时，编译器生成的函数被称为`_mainCRTStartup`。让我们更仔细地看看这个函数做了什么。
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Load the address of the end of the RAM and assign its value to stack pointer
    (sp).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 加载RAM末端的地址并将其值赋给堆栈指针（sp）。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Set the value of sp for various modes, the sizes of the stacks are determined
    by the compiler itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为各种模式设置sp的值，堆栈的大小由编译器本身确定。
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Load the addresses of `__bss_start__` and `__bss_end__` symbols and zero all
    the area in between.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 加载`__bss_start__`和`__bss_end__`符号的地址，并将它们之间的所有区域清零。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Call the `__libc_init_array` function provided by standard library which will
    initialise all the global objects. It will treat the area between `__init_array_start`
    and `__init_array_end` as list of pointers to initialisation functions and call
    them one by one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 调用标准库提供的`__libc_init_array`函数，该函数将初始化所有全局对象。它将`__init_array_start`和`__init_array_end`之间的区域视为指向初始化函数的指针列表，并逐个调用它们。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Call the main function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 调用主函数。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If `main` function returns for some reason, call the exit function, which probably
    must be implemented as infinite loop or jumping back to the beginning of the startup
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因`main`函数返回，则调用退出函数，该函数可能必须实现为无限循环或跳回启动代码的开始处。
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here comes local data
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是局部数据
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only missing stage in the startup process is updating the interrupt vector
    table. After the latter is updated properly, it is possible to call the provided
    `_mainCRTStartup` function. However, if your compiler doesn’t provide such function
    you have no other choice but to write the whole startup code yourself. [Here](https://github.com/arobenko/embxx_on_rpi/blob/master/src/asm/startup.s)
    is an example of such code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程中唯一缺失的阶段是更新中断向量表。在正确更新了后者之后，就可以调用提供的服务程序`_mainCRTStartup`函数。然而，如果您的编译器没有提供此类函数，您别无选择，只能自己编写整个启动代码。[这里](https://github.com/arobenko/embxx_on_rpi/blob/master/src/asm/startup.s)是此类代码的一个示例。
- en: Please note, that `.bss` section by definition contains uninitialised data that
    must be zeroed at startup. Even if you don’t have uninitialised variables in your
    code, zeroing `.bss` is a must have operation. This is because compiler might
    put variables that are explicitly initialised to 0 into the `.bss` for performance
    reasons and count on this section being zeroed at startup.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据定义，`.bss`段包含未初始化的数据，必须在启动时将其清零。即使您的代码中没有未初始化的变量，清零`.bss`也是必须的操作。这是因为编译器可能会出于性能原因将显式初始化为0的变量放入`.bss`，并假定在启动时此部分将被清零。
- en: Also note, that pointers to initialisation functions of global variables reside
    in `.init.array` section. To initialise your global objects you just iterate over
    all entries in this section and call them one by one.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外请注意，全局变量初始化函数的指针位于`.init.array`段中。要初始化您的全局对象，您只需遍历此段中的所有条目并逐个调用它们。
- en: 'To implement the missing stage for use the following assembler instructions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现缺失的阶段，请使用以下汇编指令：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Please note that at interrupt vector table that resides at address 0x0000 contains
    branch instructions to the appropriate handlers, not just addresses of the handlers.
    Let’s take a closer look how these branching instructions look in our assembler
    listing file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，位于地址0x0000的中断向量表包含指向适当处理器的分支指令，而不仅仅是处理器的地址。让我们更仔细地看看这些分支指令在我们的汇编列表文件中的样子：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The branching instructions load address of the interrupt function to “pc” register.
    However, the address of the function is stored somewhere and compiler generates
    access to this storage using relative offset to current “pc” register. This is
    the reason why we have to copy not just the branching instructions, but also the
    storage area where addresses of interrupt routines are stored:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 分支指令将中断函数的地址加载到“pc”寄存器。然而，函数的地址存储在某个地方，编译器生成对该存储的访问使用相对于当前“pc”寄存器的相对偏移。这就是为什么我们必须复制不仅仅是分支指令，还要复制存储中断例程地址的区域：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Dynamic Memory Allocation
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: 'Let’s try to compile simple application that uses dynamic memory allocation.
    The [test_cpp_vector](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector)
    application contains the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编译一个使用动态内存分配的简单应用程序。[test_cpp_vector](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector)
    应用程序包含以下代码：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It may happen that linking operation will fail with multiple referenced symbols
    being undefined:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现链接操作失败的情况，因为多个引用符号未定义：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The symbols `__exidx_start` and `__exidx_end` are required to indicate start
    and end of `.ARM.exidx` section. It is used for exception handling. They must
    be defined in the linker script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `__exidx_start` 和 `__exidx_end` 用于指示 `.ARM.exidx` 部分的开始和结束。它用于异常处理。它们必须在链接脚本中定义：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The dynamic memory allocation will require implementation of `_sbrk` function
    which will be used to allocate chunks of memory for the C/C++ heap management.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配将需要实现 `_sbrk` 函数，该函数将用于为 C/C++ 堆管理分配内存块。
- en: All other symbols will be required to properly support exceptions which are
    used by C++ heap management system. [Here](https://sourceware.org/newlib/libc.html#Syscalls)
    is a good resource, that lists all the system calls, the developer may need to
    implement, to get the application compiled.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他符号都需要正确支持由 C++ 堆管理系统使用的异常。[这里](https://sourceware.org/newlib/libc.html#Syscalls)
    是一个很好的资源，列出了开发者可能需要实现的所有系统调用，以使应用程序编译成功。
- en: Now, after successful compilation, take a good look at the size of the images
    of two sample applications we compiled. The paths are `<build_dir>/src/test_cpp/test_cpp_simple/kernel.img`
    and `<build_dir>/src/test_cpp/test_cpp_vector/kernel.img`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在成功编译后，仔细查看我们编译的两个示例应用程序的映像大小。路径是 `<build_dir>/src/test_cpp/test_cpp_simple/kernel.img`
    和 `<build_dir>/src/test_cpp/test_cpp_vector/kernel.img`。
- en: '**Side note**: The image can be generated out of elf binary using the following
    instruction: > arm-none-eabi-objcopy <elf_executable> -O binary <binary_image_path>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**旁注**：可以使用以下指令从 elf 二进制文件生成映像：> arm-none-eabi-objcopy <elf_executable> -O
    binary <binary_image_path>'
- en: 'You may notice that size of [test_cpp_vector](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector)
    image is greater by approximately 100K than [test_cpp_simple](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple).
    It is due to C++ heap management and exceptions handling. Let’s try to see what
    happens to the size of the application if "C++" heap is replaced with “C” one
    without exceptions. You will have to override all the global C++ operators responsible
    for memory allocation/deallocation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，[test_cpp_vector](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector)
    图像的大小比 [test_cpp_simple](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple)
    大约多 100K。这是由于 C++ 堆管理和异常处理引起的。让我们尝试看看如果将“C++”堆替换为不带异常的“C”堆，应用程序的大小会发生什么变化。你将不得不覆盖所有负责内存分配/释放的全局
    C++ 操作符：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Please compile the [test_cpp_vector](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector)
    application again, create its image and take a look at its size. It will be much
    closer to the size of the [test_cpp_simple](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple)
    image. In fact, you may not even need majority of the system call functions you
    have implemented before. Try to remove them one by one and see whether linker
    still reports “undefined reference” to these symbols.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请重新编译 [test_cpp_vector](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_vector)
    应用程序，创建其映像，并查看其大小。它将更接近 [test_cpp_simple](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_simple)
    映像的大小。实际上，你可能甚至不需要之前实现的大多数系统调用函数。尝试逐个删除它们，看看链接器是否仍然报告对这些符号的“未定义引用”。
- en: '**CONCLUSION**: Usage of C++ heap brings a significant code size overhead.
    It is a good practice to override implementation of `new` and `delete` operators
    with usage of `malloc` and `free` when using C++ in bare metal development. Note
    that in this case, if memory allocation fails [nullptr](http://en.cppreference.com/w/cpp/types/nullptr_t)
    will be returned instead of throwing [std::bad_alloc](http://en.cppreference.com/w/cpp/memory/new/bad_alloc)
    exception, so beware of third party C++ libraries that count on exception been
    thrown and do not check the returned value form [operator new](http://en.cppreference.com/w/cpp/memory/new/operator_new).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：使用C++堆会带来显著的代码大小开销。在裸机开发中使用C++时，覆盖`new`和`delete`操作符的实现，使用`malloc`和`free`是一个好的做法。请注意，在这种情况下，如果内存分配失败，将返回[nullptr](http://en.cppreference.com/w/cpp/types/nullptr_t)而不是抛出[std::bad_alloc](http://en.cppreference.com/w/cpp/memory/new/bad_alloc)异常，因此要小心第三方C++库，这些库依赖于抛出异常，并且没有检查从[operator
    new](http://en.cppreference.com/w/cpp/memory/new/operator_new)返回的值。'
- en: Excluding Usage of Dynamic Memory
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 排除动态内存的使用
- en: The dynamic memory allocation is a core part of conventional C++. However, in
    some bare-metal products the usage of dynamic memory may be problematic and/or
    forbidden. The only way (I know of) to make to compilation fail, if dynamic memory
    is used, is to exclude standard library altogether. With `gcc` compiler it is
    achieved by using `-nostdlib` compilation option.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配是传统C++的核心部分。然而，在某些裸机产品中，使用动态内存可能存在问题和/或被禁止。如果使用动态内存，唯一（我知道的）使编译失败的方法是完全排除标准库。使用`gcc`编译器，可以通过使用`-nostdlib`编译选项来实现。
- en: Excluding standard library from the compilation will remove the whole C++ run-time
    environment, which includes dynamic memory (heap) management and exception handling.
    The implication of using this compilation option will be described later in [Removing
    Standard Library and C++ Runtime](#compiler_output-nostdlib).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从编译中排除标准库将移除整个C++运行时环境，这包括动态内存（堆）管理和异常处理。使用此编译选项的含义将在[移除标准库和C++运行时](#compiler_output-nostdlib)部分进行描述。
- en: Exceptions
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常
- en: Exception handling is also a core feature of the conventional C++. However,
    this feature is considered to be too dangerous, because of unpredictable code
    execution time and too expensive (in terms of code size) for bare metal platforms.
    The usage of single throw statement in the source code will result in more than
    120KB of extra binary code in the final binary image. Just try it yourself with
    your compiler and see the difference in size of the produced binary images.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理也是传统C++的核心特性之一。然而，由于代码执行时间不可预测以及对于裸机平台来说过于昂贵（从代码大小来看），这个特性被认为是非常危险的。在源代码中使用单个抛出语句会导致最终二进制映像中额外超过120KB的二进制代码。你可以自己尝试使用你的编译器，看看生成的二进制映像大小有何不同。
- en: It is possible to forbid usage of throw statements by providing certain options
    to the compiler. For GNU compiler (`gcc`) please use `-fno-exceptions` in conjunction
    with `-fno-unwind-tables` options. According to [this page](https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html)
    of `gcc` manual, all the throw statements are supposed to be replaced with call
    to `abort()`. Unfortunately this information seems to be outdated. The behaviour
    I see with my latest (at the moment of writing) `gcc` version 4.8 is a bit different.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向编译器提供某些选项来禁止使用抛出语句。对于GNU编译器（`gcc`），请使用`-fno-exceptions`选项与`-fno-unwind-tables`选项一起使用。根据`gcc`手册[此页面](https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html)的描述，所有抛出语句都应该被替换为对`abort()`的调用。不幸的是，这个信息似乎已经过时了。我在写作时使用的最新（当时）`gcc`版本4.8的行为略有不同。
- en: 'When the compilation is performed with the options specified above and there
    is a `throw` statement in the code (for example `throw std::runtime_error("Some
    error")`), the compilation fails with error message:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用上述选项进行编译，并且在代码中存在`throw`语句（例如`throw std::runtime_error("Some error")`）时，编译将失败，并显示错误信息：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, all the `throw` statements from standard library are compiled in and
    cause the whole exception handling support code overhead to be included in the
    final binary image, despite the compilation options forbidding the exceptions.
    The test application [test_cpp_exceptions](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_exceptions)
    has simple code that causes the exceptions to be thrown:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管编译选项禁止了异常，标准库中的所有 `throw` 语句都被编译进去了，导致整个异常处理支持代码的额外开销都包含在最终的二进制映像中。测试应用程序
    [test_cpp_exceptions](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_exceptions)
    包含简单的代码，会导致异常被抛出：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The generated code of the main function looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数生成的代码看起来是这样的：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We also can see there are multiple exception related functions in the produced
    listing, such as `__cxa_allocate_exception`, `__cxa_throw`, `_ZSt20__throw_out_of_rangePKc`,
    `_ZSt21__throw_bad_exceptionv`, etc…​ The size of the binary image will also be
    huge (about 125KB) due to exceptions handling.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，生成的列表中存在多个与异常相关的函数，例如 `__cxa_allocate_exception`、`__cxa_throw`、`_ZSt20__throw_out_of_rangePKc`、`_ZSt21__throw_bad_exceptionv`
    等... 由于异常处理，二进制映像的大小也将非常大（约125KB）。
- en: 'If you would like to use STL classes that may throw exceptions, such as `std::string`,
    `std::vector`, but refuse to pay the expensive price of extra code space for exceptions
    handling, you’ll have to do two things. First, make sure that exception conditions
    never occur in your code run, i.e. if `throw` statement is about to get executed,
    it means there is a bug in your code. Second, override the definition of all the
    "__throw_*" functions the compiler tries to use. In order to identify all these
    functions you’ll have to temporarily disable usage of standard library by passing
    `-nostdlib` compilation option to your `gcc` compiler. For the code example above
    the compilation without standard library will fail with error message:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用可能会抛出异常的STL类，例如 `std::string`、`std::vector`，但又不愿意为异常处理支付额外的代码空间成本，你将不得不做两件事。首先，确保你的代码运行中不会发生异常条件，即如果
    `throw` 语句即将执行，这意味着你的代码中存在错误。其次，覆盖编译器尝试使用的所有 "__throw_*" 函数的定义。为了识别所有这些函数，你将不得不暂时禁用标准库的使用，通过将
    `-nostdlib` 编译选项传递给 `gcc` 编译器。对于上面的代码示例，不使用标准库的编译将因错误信息而失败：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s try to override `std::__throw_out_of_range(char const*)`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们尝试覆盖 `std::__throw_out_of_range(char const*)`:'
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time the compilation will succeed. Let’s now compile the result code with
    standard library included (without using `-nostdlib` option) and check the binary
    image size. With my compiler the size is 1.3KB, which is much much better than
    120KB when exception handling is used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这次编译将成功。现在让我们编译包含标准库的结果代码（不使用 `-nostdlib` 选项）并检查二进制映像大小。使用我的编译器，大小为1.3KB，这比使用异常处理时的120KB要好得多。
- en: '**CONCLUSION:** Excluding exception handling support is a well known and widely
    used practice in C++ bare metal development. Even when relevant compilation options
    are used (`-fno-exceptions` and `-fno-unwind-tables` in GNU compiler), there is
    still a need to override various `__throw_*` functions used by the compiler and
    provided by the standard library.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：在C++裸机开发中，排除异常处理支持是一个众所周知且广泛使用的实践。即使使用了相关的编译选项（GNU编译器中的 `-fno-exceptions`
    和 `-fno-unwind-tables`），仍然需要覆盖编译器使用的和标准库提供的各种 `__throw_*` 函数。'
- en: RTTI
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RTTI
- en: '**Run Time Type Information** is also one of the core features of conventional
    C++. It allows retrieval of the object type information (using [typeid](http://en.cppreference.com/w/cpp/language/typeid)
    operator) as well as checking the inheritance hierarchy (using [dynamic_cast](http://en.cppreference.com/w/cpp/language/dynamic_cast))
    at run time. The RTTI is available only when there is a polymorphic behaviour,
    i.e. the classes have at least one virtual function.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时类型信息** 也是传统C++的核心特性之一。它允许在运行时检索对象类型信息（使用 [typeid](http://en.cppreference.com/w/cpp/language/typeid)
    操作符）以及检查继承层次结构（使用 [dynamic_cast](http://en.cppreference.com/w/cpp/language/dynamic_cast)）。RTTI仅在存在多态行为时才可用，即类至少有一个虚函数。'
- en: Let’s try to analyse the generated code when RTTI is in use. The [test_cpp_rtti](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_rtti)
    application in [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project
    contains the code listed below.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试分析使用RTTI时生成的代码。在 [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)
    项目中的 [test_cpp_rtti](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_rtti)
    应用程序中包含以下代码。
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Somewhere in *.cpp file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个 *.cpp 文件中：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Somewhere in `main` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数的某个地方：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s open the listing file and see what’s going on in there. The address of
    `SomeClass::someFunc()` seems to be `0x8300`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开列表文件，看看里面发生了什么。`SomeClass::someFunc()` 的地址似乎为 `0x8300`：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The virtual table for `SomeClass` class must be somewhere in `.rodata` section
    and contain address of `SomeClass::someFunc()`, i.e. it must have `0x8300` value
    inside:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`SomeClass` 类的虚拟表必须在 `.rodata` 部分中，并包含 `SomeClass::someFunc()` 函数的地址，即它内部必须有
    `0x8300` 的值：'
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is visible that compiler added some more entries to the virtual table in
    addition to the single virtual function we implemented. The address `0x9c04` is
    also located in `.rodata` section. It is some type related table:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，编译器在除了我们实现的单个虚拟函数之外，还向虚拟表添加了一些条目。地址 `0x9c04` 也位于 `.rodata` 部分中。这是一个类型相关表：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Both `0x9c28` and `0x9bf8` are addresses in `.rodata*` section(s). The `0x9bf8`
    address seems to contain some data:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x9c28` 和 `0x9bf8` 都是 `.rodata*` 部分的地址。`0x9bf8` 地址似乎包含一些数据：'
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After a closer look we may decode this data to be `9SomeClass` ascii string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 经过仔细观察，我们可能将此数据解码为 `9SomeClass` ascii 字符串。
- en: 'Address `0x9c28` is in the middle of some type related information table:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 `0x9c28` 位于某些类型相关信息表中：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How these tables are used by the compiler is of little interest to us. What
    is interesting is a code size overhead. Lets check the size of the binary image.
    With my compiler it is a bit more than 13KB.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器如何使用这些表对我们来说兴趣不大。有趣的是代码大小的开销。让我们检查二进制映像的大小。使用我的编译器，它略大于 13KB。
- en: 'For some bare metal platforms it may be undesirable or even impossible to have
    this amount of extra binary code added to the binary image. The GNU compiler (`gcc`)
    provides an ability to disable **RTTI** by using `-no-rtti` option. Let’s check
    the virtual table of `SomeClass` class when this option is used:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些裸机平台，可能不希望甚至不可能将这么多额外的二进制代码添加到二进制映像中。GNU 编译器 (`gcc`) 提供了使用 `-no-rtti` 选项禁用
    **RTTI** 的能力。让我们检查使用此选项时 `SomeClass` 类的虚拟表：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The virtual table looks much simpler now with single pointer to the `SomeClass::someFunc()`
    virtual function. There is no extra code size overhead needed to maintain type
    information. If the application above is compiled without exceptions (using `-fno-exceptions`
    and `-fno-unwind-tables`) as well as without RTTI support (using `-no-rtti`) the
    binary image size will be about 1.3KB which is much better.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表现在看起来要简单得多，只有一个指向 `SomeClass::someFunc()` 虚拟函数的指针。不需要额外的代码大小开销来维护类型信息。如果上面的应用程序在没有异常（使用
    `-fno-exceptions` 和 `-fno-unwind-tables`）以及没有 RTTI 支持（使用 `-no-rtti`）的情况下编译，二进制映像大小将约为
    1.3KB，这要好得多。
- en: However, if `-no-rtti` option is used, the compiler won’t allow usage of [typeid](http://en.cppreference.com/w/cpp/language/typeid)
    operator as well as [dynamic_cast](http://en.cppreference.com/w/cpp/language/dynamic_cast).
    In this case the developer needs to come up with other solutions to differentiate
    between objects of different types (but having the same 'ancestor') at run time.
    There are multiple idioms that can be used, such as using simple C-like approach
    of `switch`-ing on some type enumerator member, or using polymorphic behaviour
    of the objects to perform [double dispatch](http://en.wikipedia.org/wiki/Double_dispatch).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用 `-no-rtti` 选项，编译器将不允许使用 [typeid](http://en.cppreference.com/w/cpp/language/typeid)
    操作符以及 [dynamic_cast](http://en.cppreference.com/w/cpp/language/dynamic_cast)。在这种情况下，开发者需要想出其他解决方案来区分不同类型的对象（但具有相同的
    '祖先'）在运行时。有多种惯用法可以使用，例如使用简单的 C 语言风格的 `switch` 在某些类型枚举成员上，或者使用对象的多态行为来执行 [双重分派](http://en.wikipedia.org/wiki/Double_dispatch)。
- en: '**CONCLUSION**: Disabling **R**un **T**ime **T**ype **I**nformation (RTTI)
    in addition to eliminating exception handling is very common in bare metal C++
    development. It allows to save about 10KB of space overhead in final binary image.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：在裸机 C++ 开发中，禁用 **R**un **T**ime **T**ype **I**nformation (RTTI) 以及消除异常处理是非常常见的。它允许在最终二进制映像中节省大约
    10KB 的空间开销。'
- en: Removing Standard Library and C++ Runtime
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除标准库和 C++ 运行时
- en: 'Due to platform RAM/ROM limitations it may be required to exclude not just
    support for exceptions and RTTI (compiling with `-fno-exceptions` `-fno-unwind-tables`
    `-fno-rtti`), but for dynamic memory allocation too. The latter includes passing
    `-nostdlib` option to the compiler. In case when standard library is excluded,
    there is no startup code help provided by the compiler, the developer will have
    to implement all the startup stages:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于平台RAM/ROM的限制，可能需要排除对异常和RTTI的支持（使用`-fno-exceptions` `-fno-unwind-tables` `-fno-rtti`编译），甚至还需要排除动态内存分配。后者包括向编译器传递`-nostdlib`选项。在排除标准库的情况下，编译器不会提供启动代码的帮助，开发者将不得不实现所有启动阶段：
- en: updating the interrupt vector table
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新中断向量表
- en: setting up correct stack pointers for all the modes of execution
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有执行模式设置正确的栈指针
- en: zeroing `.bss` section
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`.bss`段清零
- en: calling initialisation functions for global objects
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用全局对象的初始化函数
- en: calling “main” function.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用“main”函数。
- en: '[Here](https://github.com/arobenko/embxx_on_rpi/blob/master/src/asm/startup.s)
    is an example of such startup code.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[这里](https://github.com/arobenko/embxx_on_rpi/blob/master/src/asm/startup.s)是一个此类启动代码的示例。'
- en: There also may be a need to provide an implementation of some functions or definition
    of some global symbols. For example, if [std::copy](http://en.cppreference.com/w/cpp/algorithm/copy)
    algorithm is used to copy multiple objects from place to place, the compiler might
    decide to use [memcpy](http://en.cppreference.com/w/c/string/byte/memcpy) function
    provided by the standard library, and as the result the build process will fail
    with “undefined reference” error. The same way, usage of [std::fill](http://en.cppreference.com/w/cpp/algorithm/fill)
    algorithm may require [memset](http://en.cppreference.com/w/c/string/byte/memset)
    function. Be ready to implement them when needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能需要提供某些函数的实现或某些全局符号的定义。例如，如果使用[std::copy](http://en.cppreference.com/w/cpp/algorithm/copy)算法从一处复制多个对象到另一处，编译器可能会决定使用标准库提供的[memcpy](http://en.cppreference.com/w/c/string/byte/memcpy)函数，结果构建过程会因“未定义引用”错误而失败。同样，使用[std::fill](http://en.cppreference.com/w/cpp/algorithm/fill)算法可能需要[memset](http://en.cppreference.com/w/c/string/byte/memset)函数。准备好在需要时实现它们。
- en: 'Another example is having call to [std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)
    function with [std::placeholders::_1](http://en.cppreference.com/w/cpp/utility/functional/placeholders),
    [std::placeholders::_2](http://en.cppreference.com/w/cpp/utility/functional/placeholders),
    etc. There will be a need to define these placeholders as global symbols:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是调用带有[std::placeholders::_1](http://en.cppreference.com/w/cpp/utility/functional/placeholders)、[std::placeholders::_2](http://en.cppreference.com/w/cpp/utility/functional/placeholders)等占位符的[std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)函数。将需要将这些占位符定义为全局符号：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Even if there is a need for the standard library in the product being developed,
    it may be a good exercise as well as good debugging technique to temporarily exclude
    it from the compilation. The compilation will probably fail in the linking stage.
    The list of missing symbols and/or functions will provide a good indication of
    what missing functionality is provided by the library. The developer may notice
    that some components still require exceptions handling, for example, resulting
    int the binary image being too big.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在开发的产品中需要标准库，暂时将其排除在编译之外也是一个好的练习，同时也是良好的调试技术。编译很可能会在链接阶段失败。缺失的符号和/或函数的列表将很好地表明库提供了哪些缺失的功能。开发者可能会注意到某些组件仍然需要异常处理，例如，导致二进制映像过大。
- en: Static Objects
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态对象
- en: Let’s analyse the code that initialises static objects. [test_cpp_statics](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_statics)
    is a simple application that has two static objects, one is in the global scope,
    the other is in the function scope.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析初始化静态对象的代码。[test_cpp_statics](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_statics)是一个简单的应用程序，其中包含两个静态对象，一个在全局作用域中，另一个在函数作用域中。
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note, that compiler will try to inline the code above if implemented in the
    same file. To properly analyse the code that initialises global variables, you
    should put implementation of constructor and `instanceGlobal()`/`instanceLocal()`
    functions into separate files. If `-nostdlib` option is passed to the compiler
    to exclude linking with standard library, the compilation of the code above will
    fail with following error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果上述代码在同一文件中实现，编译器将尝试内联该代码。为了正确分析初始化全局变量的代码，你应该将构造函数和`instanceGlobal()`/`instanceLocal()`函数的实现放入单独的文件中。如果将`-nostdlib`选项传递给编译器以排除与标准库的链接，上述代码的编译将失败，并出现以下错误：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It means that compiler attempts to make static variables initialisation thread-safe.
    The get it compiled you have to either implement the locking functionality yourself
    or allow compiler to do it in an unsafe way by adding `-fno-threadsafe-statics`
    compilation option. I think it is quite safe to use this option in the bare-metal
    development if you make sure the statics are not accessed in the interrupt context
    or have been initialised at the beginning of `main()` function before any interrupts
    are enabled. To grab a reference to such object without any use is enough:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着编译器试图使静态变量的初始化线程安全。为了编译它，你必须自己实现锁定功能，或者通过添加`-fno-threadsafe-statics`编译选项允许编译器以不安全的方式执行。我认为在裸机开发中使用此选项相当安全，前提是你确保静态变量不在中断上下文中访问，或者在启用任何中断之前在`main()`函数的开始处初始化。要获取此类对象的引用而不使用它，只需这样做就足够了：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, let’s analyse the initialisation of `globalObj`. The `.init.array` section
    contains pointer to initialisation function `_GLOBAL__sub_I__ZN7SomeObj9globalObjE`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析`globalObj`的初始化。`.init.array`部分包含指向初始化函数`_GLOBAL__sub_I__ZN7SomeObj9globalObjE`的指针。
- en: 'Disassembly of section .init.array:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`.init.array`部分的反汇编：'
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The initialisation function loads the address of the object and passes it to
    the constructor of `SomeObj` together with the initialisation parameters (“1”
    and “2” integer values).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化函数将对象的地址传递给`SomeObj`的构造函数，并附带初始化参数（“1”和“2”整数值）。
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code above loads the address of the global object (`0x00008168`) into **r0**,
    and initialisation parameters into **r1** and **r2**, then invokes the constructor
    of `SomeObj`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将全局对象的地址（`0x00008168`）加载到**r0**中，并将初始化参数加载到**r1**和**r2**中，然后调用`SomeObj`的构造函数。
- en: Please remember to call all the initialisation functions from `.init.array`
    section in your startup code before calling the `main()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在调用`main()`函数之前，从`.init.array`部分调用所有初始化函数。
- en: 'In the linker file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接器文件中：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the startup code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动代码中：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, if standard library is **NOT** excluded explicitly from the compilation,
    the `__libc_init_array` provided by the standard library may be used:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果未显式排除标准库的编译，标准库提供的`__libc_init_array`可能被使用：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let’s also perform analysis of initialisation of `localObj` in `SomeObj::instanceLocal()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也分析`SomeObj::instanceLocal()`中`localObj`的初始化。
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The code above loads the address of the flag that indicates that the object
    was already initialised into **r4**, then loads the value into **r3** and checks
    it using `tst` instruction. If the flag indicates that the object wasn’t initialised,
    the constructor of the object is called and the flag value is updated prior to
    returning address of the object. Note that `tst r3, #1` instruction performs binary
    **AND** between value **r3** and integer value **#1**, then next `bne` instruction
    performs branch if result is not 0, i.e. the object was already initialised.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '上述代码将表示对象已初始化的标志的地址加载到**r4**中，然后将其值加载到**r3**中，并使用`tst`指令进行检查。如果标志指示对象尚未初始化，则调用对象的构造函数，并在返回对象地址之前更新标志值。请注意，`tst
    r3, #1`指令在**r3**的值和整数值**#1**之间执行二进制**AND**操作，然后下一个`bne`指令在结果不为0时执行分支，即对象已经初始化。'
- en: '**CONCLUSION**: Access to global objects are a bit cheaper than access to local
    static ones, because access to the latter involves a check whether the object
    was already initialised.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：访问全局对象的成本略低于访问局部静态对象，因为后者访问涉及检查对象是否已初始化。'
- en: Custom Destructors
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义析构函数
- en: 'And what about destruction of static objects with non-trivial destructors?
    Let’s add a destructor to the above class and try to compile:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，具有非平凡析构函数的静态对象的销毁又如何呢？让我们在上面的类中添加一个析构函数并尝试编译：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Somewhere in *.cpp file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个*.cpp文件中：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This time the compilation will fail with following errors:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这次编译将失败，并出现以下错误：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'According to [this](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0041d/IHI0041D_cppabi.pdf)
    document, the `__aeabi_atexit` function is used to register pointer to the destructor
    function together with pointer to the relevant static object to be destructed
    after `main` function returns. The reason for this behaviour is that these objects
    must be destructed in the opposite order to which they were constructed. The compiler
    cannot know the exact construction order for local static objects. There may even
    be some static objects are not constructed at all. The `__dso_handle` is a global
    pointer to the current address where the next **{destructor_ptr, object_ptr}**
    pair will be stored. The `main` function of most bare metal applications is not
    supposed to return and global/static objects will not be destructed. In this case
    it will be enough to implement the required function the following way:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[这份](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0041d/IHI0041D_cppabi.pdf)文档，`__aeabi_atexit`函数用于在`main`函数返回后注册指向析构函数的指针以及指向将要析构的相关静态对象的指针。这种行为的原因是这些对象必须按照与它们构造相反的顺序进行析构。编译器无法知道局部静态对象的精确构造顺序。甚至可能存在一些静态对象根本未构造。`__dso_handle`是一个指向下一个**{析构函数指针，对象指针}**对将要存储的当前地址的全局指针。大多数裸机应用的`main`函数不应该返回，全局/静态对象也不会被析构。在这种情况下，以下方式实现所需函数就足够了：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: However, if your `main` function returns and then the code jumps back to the
    initialisation/reset routine, there is a need to properly perform destruction
    of global/static objects. You’ll have to allocate enough space to store all the
    necessary **{destructor_ptr, object_ptr}** pairs, then in `__aeabi_atexit` function
    store the pair in the area pointed by `__dso_handle`, while incrementing value
    of later. Note, that `dso_handle` parameter to the `__aeabi_atexit` function is
    actually a pointer to the global `__dso_handle` value. Then, when the `main` function
    returns, invoke the stored destructors in the opposite order while passing addresses
    of the relevant objects as their first arguments.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的`main`函数返回，然后代码跳回到初始化/重置例程，就需要适当地执行全局/静态对象的析构。你需要分配足够的空间来存储所有必要的**{析构函数指针，对象指针}**对，然后在`__aeabi_atexit`函数中将这对存储在`__dso_handle`指向的区域，同时增加后面的值。注意，`__aeabi_atexit`函数的`dso_handle`参数实际上是指向全局`__dso_handle`值的指针。然后，当`main`函数返回时，以相关对象的地址作为第一个参数，以相反的顺序调用存储的析构函数。
- en: 'To verify all the stated above let’s take a look again at the generated code
    of initialisation function (after the destructor was added):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证上述所有内容，让我们再次查看初始化函数生成的代码（在添加了析构函数之后）：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Indeed, the call to the constructor immediately followed by the call to `__aeabi_atexit`
    with address of the object in **r0** (first parameter), address of the destructor
    in **r1** (second parameter) and address of `__dso_handle` in **r2** (third parameter).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，调用构造函数紧接着调用`__aeabi_atexit`，其中对象地址在**r0**（第一个参数），析构函数地址在**r1**（第二个参数），`__dso_handle`地址在**r2**（第三个参数）。
- en: '**CONCLUSION**: It is better to design the “main” function to contain infinite
    loop and never return to save the implementation of destructing global/static
    objects functionality.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：设计“main”函数包含无限循环并永不返回，以节省全局/静态对象析构功能的实现。'
- en: Abstract Classes
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象类
- en: The next thing to test is having abstract classes with pure virtual functions
    while excluding linkage to standard library (using `-nostdlib` compilation option).
    Below is an excerpt from [test_cpp_abstract_class](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_abstract_class)
    application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要测试的是具有纯虚函数的抽象类，同时排除对标准库的链接（使用`-nostdlib`编译选项）。以下是[测试_cpp_abstract_class](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_abstract_class)应用程序的摘录。
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Somewhere in the “main” function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在“main”函数的某个地方：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The compilation will fail with following errors:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 编译将因以下错误而失败：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `__cxa_pure_virtual` is a function, address of which compiler writes in
    the virtual table when the function is pure virtual. It may be called due to some
    unnatural pointer abuse or when trying to invoke pure virtual function in the
    destructor of the abstract base class. The call to this function should never
    happen in the normal application run. If it happens it means there is a bug. It
    is quite safe to implement this function with infinite loop or some way to report
    the error to the developer, by flashing leds for example.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`__cxa_pure_virtual` 是一个函数，当函数是纯虚函数时，编译器将其地址写入虚拟表。它可能由于某些不自然的指针滥用或在尝试在抽象基类的析构函数中调用纯虚函数时被调用。在正常应用程序运行中不应调用此函数。如果发生这种情况，则意味着存在一个错误。使用无限循环或以某种方式向开发者报告错误（例如闪烁
    led）来实现此函数是相当安全的。'
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The requirement for `operator delete(void*)` is quite strange though, there
    is no dynamic memory allocation in the source code. It has to be investigated.
    Let’s stub the function and check the output of the compiler:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `operator delete(void*)` 的需求相当奇怪，源代码中并没有动态内存分配。这需要调查。让我们模拟该函数并检查编译器的输出：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The virtual tables for the classes reside in `.rodata` section:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 类的虚拟表位于 `.rodata` 部分：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The last entry for both classes has the address of `AbstractBase::nonOverridenFunc`
    function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类的最后一个条目都指向 `AbstractBase::nonOverridenFunc` 函数：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The third entry in the virtual table of **Derived** class has the address of
    `Derived::func` function, while the third entry in the virtual table of **AbstractBase**
    class has the address of `__cxa_pure_virtual`, just like expected.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**Derived** 类的虚拟表中的第三个条目指向 `Derived::func` 函数，而 **AbstractBase** 类的虚拟表中的第三个条目指向
    `__cxa_pure_virtual`，正如预期的那样。'
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first two entries in the virtual tables point to two different implementations
    of the destructor. The first entry has the address of normal destructor implementation,
    and the second one has an address of the second destructor implementation, that
    invokes operator delete (has `_ZdlPv` symbol) after the destruction of the object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表中的前两个条目指向两个不同的析构函数实现。第一个条目包含正常析构函数实现的地址，而第二个条目包含第二个析构函数实现的地址，该实现会在对象销毁后调用
    operator delete（具有 `_ZdlPv` 符号）：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It seems that when there is a virtual destructor, the compiler will have to
    support direct invocation of the destructor as well as usage of operator delete.
    In case of the former the compiler will use the first entry in the virtual table
    for the destructor invocation, and in case of the latter the compiler will use
    the second entry. Let’s try to add the following lines to our `main` function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，当存在虚拟析构函数时，编译器将不得不支持直接调用析构函数以及使用 operator delete。在前一种情况下，编译器将使用虚拟表中的第一个条目来调用析构函数，而在后一种情况下，编译器将使用第二个条目。让我们尝试在我们的
    `main` 函数中添加以下行：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The compiler will add the following instructions to the `main` function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将向 `main` 函数添加以下指令：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The address of the virtual table is written into **r3**, then value of **r3**
    is overwritten with address of the destructor function to call, and the call is
    executed using `blx` instruction. The first invocation takes the address of destructor
    function from the first entry of virtual table, while the second invocation takes
    the address from second entry (offseted by `#4`). This is just like expected.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟表的地址被写入 **r3**，然后 **r3** 的值被覆盖为要调用的析构函数的地址，并通过 `blx` 指令执行调用。第一次调用从虚拟表的第一个条目中获取析构函数的地址，而第二次调用从第二个条目（偏移量为
    `#4`）中获取地址。这正是预期的。
- en: '**CONCLUSION**: Having virtual destructor may require an implementation of
    `operator delete(void*)` even if there is no dynamic memory allocation.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：即使没有动态内存分配，拥有虚拟析构函数可能也需要实现 `operator delete(void*)`。'
- en: Templates
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: 'Templates are notorious for the code bloating they produce. Some organisations
    explicitly forbid usage of templates in their internal C++ coding standards. However,
    templates is a very powerful tool, it is very difficult (if not impossible) to
    write generic source code, that can be reused in multiple independent projects/platforms
    without using templates, and without incurring any significant performance penalties.
    I think developers, who are afraid or not allowed to use templates, will have
    to implement the same concepts/modules over and over again with minor differences,
    which are project/platform specific. To properly master the templates we have
    to see the Assembler code duplication, that is generated by the compiler when
    templates are used. Let’s try to compile a simple application [test_cpp_templates](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_templates)
    that uses templated function with different type of input parameters:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 模板因其产生的代码膨胀而臭名昭著。一些组织明确禁止在其内部 C++ 编码标准中使用模板。然而，模板是一个非常强大的工具，如果不使用模板，编写通用的源代码，在多个独立的项目/平台上重用，而且不产生任何显著的性能损失，是非常困难（如果不是不可能）的。我认为那些害怕或不允许使用模板的开发者，将不得不反复实现相同的概念/模块，这些差异是项目/平台特定的。要正确掌握模板，我们必须看到当使用模板时，编译器生成的汇编代码重复。让我们尝试编译一个简单的应用程序
    [test_cpp_templates](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_templates)，该应用程序使用具有不同输入参数类型的模板函数：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You may notice that function `func` is called with two parameters, one of type
    `int` the other of type `unsigned`. These types have both the same size and should
    generate more or less identical code. Let’s take a look at the generated code
    of `main` function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到函数 `func` 使用了两个参数，一个是 `int` 类型，另一个是 `unsigned` 类型。这两种类型具有相同的大小，应该生成几乎相同的代码。让我们看看
    `main` 函数生成的代码：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Yes, indeed, there are two calls to two different functions. However, the assembler
    code of these functions is almost identical. Let’s also try to reuse the same
    function with the same types but from different source file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实有两个对两个不同函数的调用。然而，这些函数的汇编代码几乎相同。让我们也尝试从不同的源文件中重用具有相同类型但相同的函数：
- en: '[PRE66]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The generated code is:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码是：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We see that the same functions at the same addresses are called, i. e. the linker
    does its job of removing duplicates of the same functions from different object
    files.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到调用的是相同地址上的相同函数，即链接器正在执行其从不同目标文件中删除相同函数重复项的工作。
- en: 'Let’s also try to wrap the same function with a class and add one more template
    argument:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也尝试用类包装相同的函数，并添加一个额外的模板参数：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Please note the dummy template parameter `TDummy` that is not used. Now, we
    add two more calls to the `main` function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意未使用的虚拟模板参数 `TDummy`。现在，我们在 `main` 函数中添加两个额外的调用：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Note, that the functionality of the calls is identical. The only difference
    is the dummy template argument. Let’s take a look at the generated code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些调用的功能是相同的。唯一的区别是虚拟模板参数。让我们看看生成的代码：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The compiler generated calls to two different functions, binary code of which
    is identical.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成了对两个不同函数的调用，它们的二进制代码是相同的。
- en: '**CONCLUSION**: The templates indeed require extra care and consideration.
    It is also important not to overthink things. The well known notion of “Do not
    do premature optimisations. It is much easier to make correct code faster, than
    fast code correct.” is also applicable to code size. Do not try to optimise your
    template code before the need arises. Make it work and work correctly first.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**：模板确实需要额外的关注和考虑。同样重要的是不要过度思考。众所周知的概念“不要过早优化。使正确的代码更快，比使代码更快更正确要容易得多。”也适用于代码大小。在需要之前不要尝试优化你的模板代码。首先让它工作，并且工作正确。'
- en: Tag Dispatching
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签分派
- en: The [tag dispatching](http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching)
    is a widely used idiom in C++ development. It used extensively in the following
    chapters of this book.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[标签分派](http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching)
    是 C++ 开发中广泛使用的一种惯用法。本书的以下章节中广泛使用了它。'
- en: Let’s try to compile [test_cpp_tag_dispatch](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_tag_dispatch)
    application in [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project
    and take a look at the code generated by the compiler.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在 [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) 项目中编译 [test_cpp_tag_dispatch](https://github.com/arobenko/embxx_on_rpi/tree/master/src/test_cpp/test_cpp_tag_dispatch)
    应用程序，并查看编译器生成的代码。
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Somewhere in the `main` function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的某个地方：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The code generated by the compiler looks like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的代码如下所示：
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Although the `Tag1` and `Tag2` are empty classes, the compiler still uses integer
    value `0` as a first parameter to the function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Tag1`和`Tag2`是空类，但编译器仍然使用整数值`0`作为函数的第一个参数。
- en: 'Let’s try to optimise this redundant `mov r0, #0` instruction away by making
    it visible to the compiler that the tag parameter is not used:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们尝试通过让编译器知道标签参数没有被使用来优化掉这个多余的`mov r0, #0`指令：'
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Somewhere in the `main` function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的某个地方：
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The code generated by the compiler looks like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的代码如下所示：
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this case the compiler optimises away the tag parameter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器优化掉了标签参数。
- en: 'Based on the above we may make a **CONCLUSION**: When the [tag dispatching](http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching)
    idiom is used, the function that receives a dummy (tag) parameter should be a
    simple inline wrapper around other function that implements the required functionality.
    In this case the compiler will optimise away the creation of tag object and will
    call the wrapped function directly.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 基于以上内容，我们可以得出**结论**：当使用[标签分派](http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching)习语时，接收虚拟（标签）参数的函数应该是一个简单的内联包装器，包装其他实现所需功能的函数。在这种情况下，编译器将优化掉标签对象的创建，并直接调用包装的函数。
- en: Basic Needs
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本需求
- en: Prior to describing various embedded (bare metal) development concepts I’d like
    to cover several basic needs that, I think, most developers will have to use in
    their products.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述各种嵌入式（裸机）开发概念之前，我想先介绍几个基本需求，我认为大多数开发者都将在他们的产品中使用这些需求。
- en: Assertion
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: One of the basic needs during the development is having an ability to test various
    assumptions and invariants in runtime when compiling the application in DEBUG
    mode and remove the checks when compiling the application in RELEASE mode. The
    standard C++ reuses `assert()` macro from standard C library.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，一个基本需求是能够在编译应用程序时以DEBUG模式测试各种假设和不变量，并在以RELEASE模式编译应用程序时移除检查。标准C++重用了标准C库中的`assert()`宏。
- en: '[PRE77]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `assert()` macro evaluates to nothing in case `NDEBUG` symbol is defined,
    otherwise it evaluates the condition. If the condition doesn’t return `true`,
    it calls the `__assert_fail` function, provided by standard library, which in
    turn calls `printf` to print error message to standard output followed by the
    call to `abort` function, which is supposed to terminate an application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`NDEBUG`符号，`assert()`宏将评估为无内容，否则它将评估条件。如果条件不返回`true`，它将调用标准库提供的`__assert_fail`函数，该函数随后调用`printf`将错误信息打印到标准输出，然后调用`abort`函数，该函数旨在终止应用程序。
- en: Both `printf` and `abort` functions are provided by standard library. However,
    `printf` will require the implementation of `_write` function to print characters
    to the debug output terminal, and `abort` will require implementation of `_exit`
    function to terminate the application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`和`abort`函数都由标准库提供。然而，`printf`将需要实现`_write`函数以将字符打印到调试输出终端，而`abort`将需要实现`_exit`函数以终止应用程序。'
- en: 'If standard library is excluded from the compilation (using `-nostdlib` compilation
    option), the compilation will fail with `undefined reference to __assert_func`
    error message. The developer will have to implement this function with correct
    signature. To retrieve the correct signature you will have to open `assert.h`
    standard header provided by your compiler. It will be something like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从编译中排除了标准库（使用`-nostdlib`编译选项），编译将因`undefined reference to __assert_func`错误信息而失败。开发者必须使用正确的签名实现此函数。要检索正确的签名，您必须打开由您的编译器提供的`assert.h`标准头文件。它可能看起来像这样：
- en: '[PRE78]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The attribute specifies that this function doesn’t return, so the compiler will
    generate a call to it without setting any address to return to.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性指定此函数不会返回，因此编译器将生成对其的调用，而不设置任何返回地址。
- en: The conclusion from all the stated above is that using standard `assert()` macro
    is possible, but somewhat inflexible. It is possible to access only global variables
    from the functions described above, i.e. if there is a need to flash a led to
    indicate assertion failure, then its control must be accessible through global
    variables, which is a bit ugly. Another disadvantage of this approach is that
    there are no convenient means to change the behaviour of the assert failure functionality
    and after a while restore the original behaviour. Such behaviour may be helpful
    to better identify the location of the assert that has failed. For example, override
    the default assert failure behaviour with activating a specific led at the entrance
    of some function, and restore the original assertion failure behaviour when function
    returns.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述所有陈述中得出的结论是，使用标准的 `assert()` 宏是可能的，但有些不够灵活。只能从上述函数中访问全局变量，即如果需要闪烁一个LED来指示断言失败，那么其控制必须通过全局变量来访问，这有点不美观。这种方法的另一个缺点是，没有方便的手段来更改断言失败功能的行为，并在一段时间后恢复原始行为。这种行为可能有助于更好地识别失败的断言位置。例如，通过在某个函数的入口处激活特定的LED来覆盖默认的断言失败行为，并在函数返回时恢复原始的断言失败行为。
- en: Below is a short description of a better way to handle assert checks and failures.
    The code is in [embxx](https://github.com/arobenko/embxx) library and can be reviewed
    [here](https://github.com/arobenko/embxx/blob/master/embxx/util/Assert.h).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是处理断言检查和失败的一种更好的方法的简要描述。代码位于 [embxx](https://github.com/arobenko/embxx) 库中，可以在
    [这里](https://github.com/arobenko/embxx/blob/master/embxx/util/Assert.h) 查阅。
- en: 'To resolve the problems described above and to handle the assertions C++ way
    we will have to create generic assertion failure handling abstract class:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决上述问题并以C++的方式处理断言，我们必须创建一个通用的断言失败处理抽象类：
- en: '[PRE79]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When implementing custom project specific assertion failure behaviour inherit
    from the class above:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现特定项目自定义的断言失败行为时，继承上述类：
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To manage an object of the class above, we will have to create a singleton
    class with static instance. It will store a pointer to the currently registered
    assertion failure behaviour:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理上述类的对象，我们将不得不创建一个具有静态实例的单例类。它将存储当前注册的断言失败行为的指针：
- en: '[PRE81]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `reset` member function registers new object that manages assertion failure
    behaviour and returns previous one, which can be used later to restore original
    behaviour.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset` 成员函数注册新的管理断言失败行为的对象，并返回先前的对象，这可以在以后用来恢复原始行为。'
- en: 'We will require a new macro to check assertion condition and invoke registered
    failing behaviour:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个新宏来检查断言条件并调用已注册的失败行为：
- en: '[PRE82]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Then in case of condition check failure, the `GASSERT()` macro checks whether
    any custom assertion failure functionality registered and invokes its virtual
    `fail` function. If not, then infinite loop is executed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在条件检查失败的情况下，`GASSERT()` 宏检查是否已注册任何自定义的断言失败功能，并调用其虚拟的 `fail` 函数。如果没有，则执行无限循环。
- en: 'To complete the whole picture we have to provide a convenient way to register
    new assertion failure behaviours:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整地展示整个过程，我们必须提供一个方便的方式来注册新的断言失败行为：
- en: '[PRE83]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: From now on, all we have do is to instantiate object of `EnableAssert` with
    the behaviour that we want. Note that constructor of `EnableAssert` class can
    receive any number of parameters and forwards them to the constructor of the internal
    `assert_` object.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们只需实例化 `EnableAssert` 对象，并带有我们想要的行为。请注意，`EnableAssert` 类的构造函数可以接收任何数量的参数，并将它们转发到内部
    `assert_` 对象的构造函数。
- en: '[PRE84]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If there is a need to temporarily override the previous assertion failure behaviour,
    just create another `EnableAssert` object. Once the latter is out of scope (the
    object is destructed), previous behaviour will be restored.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要临时覆盖之前的断言失败行为，只需创建另一个 `EnableAssert` 对象。一旦后者超出作用域（对象被销毁），之前的行将恢复。
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '**SUMMARY**: The approach described above provides a flexible and convenient
    way to control how the failures of various debug mode checks are reported to the
    developer. All the modules in [embxx](https://github.com/arobenko/embxx) library
    use the `GASSERT()` macro to verify their pre- and post-conditions as well as
    internal assumptions.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**：上述描述的方法提供了一种灵活且方便的方式来控制如何将各种调试模式检查的失败报告给开发者。所有在 [embxx](https://github.com/arobenko/embxx)
    库中的模块都使用 `GASSERT()` 宏来验证它们的先决条件和后置条件以及内部假设。'
- en: Callback
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调
- en: 'As has been mentioned in the [Benefits of C++](#overview-benefits) chapter,
    the main reason for choosing C++ over C is code reuse. When having some generic
    piece of code that tries to use platform specific code and needs to receive some
    kind of notifications from the latter, the need for some generic callback facility
    arises. C++ provides [std::function](http://en.cppreference.com/w/cpp/utility/functional/function)
    class for this purpose, it is possible to provide any callable object, such as
    [lambda function](http://en.cppreference.com/w/cpp/language/lambda) or [std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)
    expression:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[C++的优势](#overview-benefits)章节中提到的，选择C++而不是C的主要原因在于代码复用。当有一些通用的代码片段试图使用特定平台的代码，并且需要从后者接收某种类型的通知时，就产生了对某种通用回调机制的需求。C++提供了[std::function](http://en.cppreference.com/w/cpp/utility/functional/function)类来实现这一目的，可以提供任何可调用的对象，例如[lambda函数](http://en.cppreference.com/w/cpp/language/lambda)或[std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)表达式：
- en: '[PRE86]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: There are two problems with using [std::function](http://en.cppreference.com/w/cpp/utility/functional/function).
    It uses dynamic memory allocation and throws exception in case the function is
    invoked without assigning callable object to it first. As a result [std::function](http://en.cppreference.com/w/cpp/utility/functional/function)
    may be not suitable for use in most of the bare metal projects. We will have to
    implement something similar, but without dynamic memory allocations and without
    exceptions. Below is some short explanation of how to implement such a function
    class. The implementation of the `StaticFunction` class is part of [embxx](https://github.com/arobenko/embxx)
    library and its full code listing can be viewed [here](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[std::function](http://en.cppreference.com/w/cpp/utility/functional/function)存在两个问题。它使用动态内存分配，并且在未先分配可调用对象的情况下调用函数时抛出异常。因此，[std::function](http://en.cppreference.com/w/cpp/utility/functional/function)可能不适合在大多数裸机项目中使用。我们将不得不实现类似的功能，但不需要动态内存分配和异常。以下是一些关于如何实现此类函数类的简要说明。`StaticFunction`类的实现是[embxx](https://github.com/arobenko/embxx)库的一部分，其完整代码列表可以在[这里](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h)查看。
- en: 'The restriction of inability to use dynamic memory allocation requires to use
    additional parameter of storage size:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 无法使用动态内存分配的限制要求使用存储大小的额外参数：
- en: '[PRE87]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'It seems that in most cases the callback object will contain pointer to member
    function, pointer to handling object and some additional single parameter. This
    is the reason for specifying the default storage space as equal to the size of
    3 pointers. The “signature” template parameter is exactly the same as with [std::function](http://en.cppreference.com/w/cpp/utility/functional/function)
    plus an optional storage area size template parameter:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，回调对象将包含指向成员函数的指针、指向处理对象的指针和一些额外的单个参数。这就是指定默认存储空间等于3个指针大小的原因。“签名”模板参数与[std::function](http://en.cppreference.com/w/cpp/utility/functional/function)中的完全相同，加上一个可选的存储区域大小模板参数：
- en: '[PRE88]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To properly implement `operator()`, there is a need to split the signature
    into the return type and rest of parameters. To achieve this the following template
    specialisation trick is used:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确实现`operator()`，需要将签名拆分为返回类型和其余参数。为此，使用了以下模板特殊化的技巧：
- en: '[PRE89]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `StaticFunction` object needs an ability to store any type of callable
    object as its internal data member and then invoke it in its `operator()` member
    function. To support this functionality we will require additional helper classes:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticFunction`对象需要能够将其内部数据成员存储为任何类型的可调用对象，并在其`operator()`成员函数中调用它。为了支持这一功能，我们需要额外的辅助类：'
- en: '[PRE90]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The callable object that will be stored in `handler_` data area and it will
    be of type `InvokerBound<…​>` while invoked through interface of its base class
    `Invoker`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储在`handler_`数据区域中的可调用对象，它将通过其基类`Invoker`的接口调用，其类型为`InvokerBound<…​>`。
- en: 'There is a need to properly define `StorageType` for the `handler_` data member:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 需要正确定义`StorageType`以用于`handler_`数据成员：
- en: '[PRE91]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that `StorageType` is an uninitialised storage with alignment required
    to be able to store object of type `Invoker`. The `InvokerBound<…​>` class will
    have the same alignment requirements as its base class `Invoker`, so it is safe
    to store any object of type `InvokerBound<…​>` in the same area, as long as its
    size doesn’t exceed the size of the `StorageType`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`StorageType`是一个未初始化的存储，需要对齐以能够存储`Invoker`类型的对象。`InvokerBound<…>`类将具有与其基类`Invoker`相同的对齐要求，因此只要其大小不超过`StorageType`的大小，就可以安全地将任何`InvokerBound<…>`类型的对象存储在同一区域。
- en: Also note that the actual size of the storage area is the requested `TSize`
    plus the area required to store the object of `Invoker` class. The size of `InvokerBound<…​>`
    object is size of its private member plus the size of its base class `Invoker`,
    which will contain a single (hidden) pointer to its virtual table.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，存储区的实际大小是请求的`TSize`加上存储`Invoker`类对象所需的区域。`InvokerBound<…>`对象的大小是其私有成员的大小加上其基类`Invoker`的大小，其中将包含指向其虚表的单一（隐藏）指针。
- en: 'Any callable object may be assigned to `StaticFunction` using either constructor
    or assignment operator:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可调用对象都可以使用构造函数或赋值运算符分配给`StaticFunction`：
- en: '[PRE92]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Please pay attention that assignment operator has to call the destructor of
    previous function, that was assigned to it, before storing a new callable object
    in its place.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，赋值运算符必须在将新的可调用对象存储在其位置之前调用之前分配给它的函数的析构函数。
- en: Also note that there are compile time checks using [static_assert](http://en.cppreference.com/w/cpp/language/static_assert)
    that the size of the object to store in the storage area doesn’t exceed the allocated
    size as well as alignment requirements still hold.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，使用[static_assert](http://en.cppreference.com/w/cpp/language/static_assert)进行编译时检查，以确保存储区中要存储的对象的大小不超过分配的大小，以及对齐要求仍然保持。
- en: 'The invocation of the function will be implemented like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的调用实现方式如下：
- en: '[PRE93]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note that there are no exceptions in use and then the “must have” pre-condition
    for function invocation is that a valid callable object has been assigned to it.
    That is the reason for assertion check in the body of the function.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里没有使用异常，并且函数调用的“必须满足”前提条件是已经有一个有效的可调用对象被分配给它。这就是为什么在函数体中进行断言检查的原因。
- en: 'To complete the implementation of `StaticFunction` class the following logic
    must also be implemented:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成`StaticFunction`类的实现，以下逻辑也必须实现：
- en: Check whether the `StaticFunction` object is valid, i.e has any callable object
    assigned to it.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`StaticFunction`对象是否有效，即是否有任何可调用对象分配给它。
- en: Default construction - the function is invalid and cannot be invoked.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认构造函数 - 函数无效，无法调用。
- en: Copy/move construction + copy/move assignment functionality.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制/移动构造函数 + 复制/移动赋值功能。
- en: Clearing the function (invalidating).
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除函数（使其无效）。
- en: Supporting both const and non-const `operator()` in the assigned callable object.
    It requires both const and non-const `operator()` implementation of `StaticFunction`
    as well as its internal `Invoker` and `InvokerBound<…​>` classes.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持分配给的可调用对象中的`const`和非常量`operator()`。这需要`StaticFunction`及其内部`Invoker`和`InvokerBound<…>`类的`const`和非常量`operator()`实现。
- en: All this I leave as an exercise to to the reader. To see the complete implementation
    of the functionality described above open [this](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h)
    link.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些我都留给读者作为练习。要查看上述功能描述的完整实现，请打开[这个链接](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h)。
- en: Data Serialisation
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据序列化
- en: Another essential need in embedded development is an ability to serialise data.
    Most embedded products read data from some kind of sensors and/or communicate
    with the control centre via some wired or wireless serial interface.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式开发中，另一个基本需求是能够序列化数据。大多数嵌入式产品从某种传感器读取数据，并通过某种有线或无线串行接口与控制中心通信。
- en: Before data is sent via a communication link, it must be serialised into a buffer,
    and when received, deserialised from bytes also in a different buffer on the other
    end. The data may be serialised using big or little endian, based on the communication
    protocol used. The [embxx](https://github.com/arobenko/embxx) library provides
    a generic code with an ability to read and write integral values from/to any buffer.
    [Here](https://github.com/arobenko/embxx/blob/master/embxx/io/access.h) is the
    source code for the functions described below.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过通信链路发送数据之前，必须将其序列化到缓冲区中，并在接收时，从另一端的缓冲区中反序列化字节。数据可以使用大端或小端序列化，这取决于所使用的通信协议。`[embxx](https://github.com/arobenko/embxx)`
    库提供了一个通用的代码，具有从任何缓冲区中读取和写入整数值的能力。[这里](https://github.com/arobenko/embxx/blob/master/embxx/io/access.h)
    是下面描述的函数的源代码。
- en: 'The functions below (defined in namespace `embxx::io`) support read and write
    of an integral value using any type of iterator:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下（在命名空间 `embxx::io` 中定义）的函数支持使用任何类型的迭代器读取和写入整数值：
- en: '[PRE94]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'These functions receive reference to iterator of a buffer/container. When bytes
    are read/written from/to the buffer, the iterator is incremented. The iterator
    can be of any type as long as it supports dereferencing (`operator*()`), pre-increment
    (`operator++`) and assignment to dereferenced object. For example, serialising
    several values of various lengths into the array using big endian:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数接收缓冲区/容器的迭代器引用。当从/向缓冲区读取/写入字节时，迭代器会递增。只要迭代器支持解引用（`operator*()`）、前递增（`operator++`）和解引用对象的赋值，迭代器可以是任何类型。例如，使用大端将不同长度的多个值序列化到数组中：
- en: '[PRE95]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The contents of the buffer will be: `{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c 0x0d, 0x0e, …}`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区的内容将是：`{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
    0x0c 0x0d, 0x0e, …}`
- en: 'Similar code of reading values from the buffer would be:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓冲区读取值的类似代码如下：
- en: '[PRE96]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Another example is serialising data into a container that has `push_back()`
    member functions, such as [std::vector](http://en.cppreference.com/w/cpp/container/vector)
    or circular buffer. The data will be added at the end of the existing one:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是将数据序列化到具有 `push_back()` 成员函数的容器中，例如 [std::vector](http://en.cppreference.com/w/cpp/container/vector)
    或环形缓冲区。数据将被添加到现有数据的末尾：
- en: '[PRE97]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Depending on a communication protocol there may be a need to serialise only
    part of the value. For example some field of communication protocol is defined
    having only 3 bytes. In this case the value will probably be stored in a variable
    of `std::uint32_t` type. There is similar set of functions, but with additional
    template parameter that specifies how many bytes to read/write:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 根据通信协议，可能需要仅序列化值的一部分。例如，某些通信协议字段定义为只有3个字节。在这种情况下，值可能存储在 `std::uint32_t` 类型的变量中。有一组类似的函数，但它们有一个额外的模板参数，指定要读取/写入的字节数：
- en: '[PRE98]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'So to read/write 3 bytes will look like the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，读取/写入3个字节的代码如下：
- en: '[PRE99]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Sometimes the endianness of data serialisation may depend on some traits class
    parameters. In order to be able to choose “Little” or “Big” variant functions
    at compile time instead of runtime the tag parameter dispatch idiom must be used.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 有时数据序列化的端序可能取决于某些特性类参数。为了能够在编译时而不是运行时选择“小端”或“大端”变体函数，必须使用标签参数分派习语。
- en: 'There are similar read/write functions, but instead of being differentiated
    by name they have additional tag parameter to specify the endianness of serialisation:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有类似的读取/写入函数，但它们不是通过名称区分的，而是有额外的标签参数来指定序列化的端序：
- en: '[PRE100]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `traits::endian::Big` and `traits::endian::Little` are defined as empty
    tag classes:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`traits::endian::Big` 和 `traits::endian::Little` 被定义为空标签类：'
- en: '[PRE101]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'For example:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE102]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: So the code above is not aware what endianness is used to serialise the data.
    It is provided as internal type of `Traits` class named `Endianness`. The compiler
    will generate the call to appropriate `writeData()` function, which in turn forward
    it to `writeBig()` or `writeLittle()`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上面的代码不知道用于序列化数据的端序。它作为名为 `Endianness` 的 `Traits` 类的内部类型提供。编译器将生成对适当的 `writeData()`
    函数的调用，该函数随后将其转发到 `writeBig()` 或 `writeLittle()`。
- en: 'To serialise data using big endian the traits should be defined as following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大端序序列化数据时，特性应该定义为以下内容：
- en: '[PRE103]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The interface described above is very easy and convenient to use and quite
    easy to implement using straightforward approach. However, any variation of template
    parameters create an instantiation of new binary code which may create significant
    code bloat if not used carefully. Consider the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的界面非常易于使用且方便，并且使用直接的方法实现起来相当简单。然而，任何模板参数的变化都会创建一个新的二进制代码实例，如果不小心使用，可能会产生大量的代码膨胀。考虑以下情况：
- en: Read/write of signed vs unsigned integer values. The serialisation/deserialisation
    code is identical for both cases, but won’t be considered as such when instantiating
    the functions. To optimise this case, there is a need to implement read/write
    operations only for unsigned value, while the “signed” functions become wrappers
    around the former. Don’t forget a sign extension operation when retrieving partial
    signed value.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号整数与无符号整数的读写。序列化/反序列化代码在这两种情况下是相同的，但在实例化函数时不会被视为如此。为了优化这种情况，需要仅对无符号值实现读写操作，而“有符号”函数则成为前者的包装器。在检索部分有符号值时，别忘了执行符号扩展操作。
- en: 'The read/write operations are more or less the same for any length of the values,
    i.e of any types: `(unsigned) char`, `(unsigned) short`, `(unsigned) int`, etc…​
    To optimise this case, there is a need for internal function that receives length
    of serialised value as a run time parameter, while the functions described above
    are mere wrappers around it.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何长度的值，即任何类型的读写操作（例如`(unsigned) char`、`(unsigned) short`、`(unsigned) int`等）都或多或少是相同的。为了优化这种情况，需要内部函数，该函数接收序列化值的长度作为运行时参数，而上述函数只是它的包装器。
- en: 'Usage of the iterators also require caution. For example reading values may
    be performed using regular `iterator` as well as `const_iterator`, i.e. iterator
    pointing to const values. These are two different iterator types that will duplicate
    the “read” functionality if both of them are used:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器的使用也需要谨慎。例如，读取值可以使用常规的`iterator`，也可以使用`const_iterator`，即指向常量值的迭代器。这两种不同的迭代器类型，如果都使用，将会重复“读取”功能：
- en: '[PRE104]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: It is possible to optimise the case above for random access iterator by using
    temporary pointers to unsigned characters to read the required value. After retrieval
    is complete, just increment the value of the passed iterator with number of characters
    read.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用指向无符号字符的临时指针来优化上述随机访问迭代器的情况，以读取所需值。检索完成后，只需将传入迭代器的值增加读取的字符数。
- en: All the consideration points stated above require quite complex implementation
    of the serialisation/deserialisation functionality with multiple levels of abstraction
    which is beyond the scope of this book. It would be a nice exercise to try and
    implement it yourself. Another option is to use the code as is from [embxx](https://github.com/arobenko/embxx)
    library.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的所有考虑点都需要相当复杂的序列化/反序列化功能的实现，涉及多个抽象级别，这超出了本书的范围。尝试自己实现它将是一个很好的练习。另一个选择是直接从[embxx](https://github.com/arobenko/embxx)库中获取代码。
- en: Static (Fixed Size) Queue
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态（固定大小）队列
- en: There is almost always a need to have some kind of a queuing functionality.
    A circular buffer is a good compromise between speed of execution and memory consumption
    (vs [std::deque](http://en.cppreference.com/w/cpp/container/deque) for example).
    If your product allows usage of dynamic memory allocation and/or exceptions than
    [boost::circular_buffer](http://www.boost.org/doc/libs/1_55_0/doc/html/circular_buffer.html)
    can be a good choice. However, if using dynamic memory allocation is not an option,
    then there is no other choice but to implement a circular buffer with maximum
    length known at compile time over C array or [std::array](http://en.cppreference.com/w/cpp/container/array).
    [Here](https://github.com/arobenko/embxx/blob/master/embxx/container/StaticQueue.h)
    is the implementation of `StaticQueue` functionality from [embxx](https://github.com/arobenko/embxx)
    library. I won’t go into too much details or explain every line of code. Instead
    I will emphasise several important points that must be taken into consideration.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是需要某种队列功能。循环缓冲区在执行速度和内存消耗之间提供了一个良好的折衷方案（例如与[std::deque](http://en.cppreference.com/w/cpp/container/deque)相比）。如果你的产品允许使用动态内存分配和/或异常处理，那么[boost::circular_buffer](http://www.boost.org/doc/libs/1_55_0/doc/html/circular_buffer.html)可能是一个不错的选择。然而，如果使用动态内存分配不是一个选项，那么除了在编译时已知最大长度的C数组或[std::array](http://en.cppreference.com/w/cpp/container/array)上实现循环缓冲区之外别无选择。[这里](https://github.com/arobenko/embxx/blob/master/embxx/container/StaticQueue.h)是来自[embxx](https://github.com/arobenko/embxx)库的`StaticQueue`功能的实现。我不会过多地深入细节或解释每一行代码。相反，我将强调几个必须考虑的重要点。
- en: Invalid operations
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无效操作
- en: There can always be an attempt to perform an invalid operation, such as access
    an element outside the queue boundaries, or inserting new element when the queue
    is full, or popping an element when queue is empty, etc…​ The conventional way
    in C++ to handle these cases is to throw an exception. However, in embedded and
    especially in bare metal programming it’s not an option. The right way to handle
    these errors would be asserting on pre-conditions. The `StaticQueue` implementation
    in [embxx](https://github.com/arobenko/embxx) library uses `GASSERT()` macro described
    earlier. The checks will be compiled only in non-Release mode (`NDEBUG` not defined)
    and in case of the failure it will invoke the project specific code the developer
    has written to report assertion failure.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 总是可能尝试执行无效操作，例如访问队列边界之外的元素，或者在队列满时插入新元素，或者在队列为空时弹出元素等。在C++中处理这些情况的传统方式是抛出异常。然而，在嵌入式编程，尤其是在裸机编程中，这不是一个选项。处理这些错误的正确方式是在预条件上断言。在[embxx](https://github.com/arobenko/embxx)库中的`StaticQueue`实现使用了前面描述的`GASSERT()`宏。这些检查仅在非发布模式（`NDEBUG`未定义）下编译，并且在失败的情况下将调用开发者编写的特定于项目的代码来报告断言失败。
- en: '[PRE105]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Construction/Destruction of the elements
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元素的构建/销毁
- en: When the queue is created it doesn’t contain any elements. However, it must
    contain uninitialised space where elements can be created in the future. The space
    must be of sufficient size and be properly aligned.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列被创建时，它不包含任何元素。然而，它必须包含未初始化的空间，以便将来可以创建元素。该空间必须足够大并且正确对齐。
- en: '[PRE106]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'When adding a new element to the queue, the “in-place” construction must be
    performed:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当向队列中添加新元素时，必须执行“原地”构建操作：
- en: '[PRE107]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When an element removed from the queue, explicit destruction must be performed:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当从队列中移除一个元素时，必须执行显式销毁操作：
- en: '[PRE108]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Iteration
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代
- en: 'There is often a need to iterate over the elements of the queue. The standard
    sequential random access containers such as [std::array](http://en.cppreference.com/w/cpp/container/array),
    [std::vector](http://en.cppreference.com/w/cpp/container/vector) or [std::deque](http://en.cppreference.com/w/cpp/container/deque)
    may use a simple pointer (or a wrapper class around it) as iterator because address
    of every element is greater than address of its predecessor. Incrementing a pointer
    during the iteration would be enough to get an access to the next element. However,
    in circular queue/buffer there may be a case when address of the beginning of
    the queue is greater than address of the end of the queue:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要遍历队列中的元素。标准的顺序随机访问容器，如[std::array](http://en.cppreference.com/w/cpp/container/array)、[std::vector](http://en.cppreference.com/w/cpp/container/vector)或[std::deque](http://en.cppreference.com/w/cpp/container/deque)，可以使用简单的指针（或围绕它的包装类）作为迭代器，因为每个元素的地址都大于其前驱元素的地址。在迭代过程中增加指针就足以访问下一个元素。然而，在循环队列/缓冲区中，可能存在队列开始地址大于队列结束地址的情况：
- en: '![Non linearised queue image](img/0cfcbd3711b7841ea9c52e2ab0e488f6.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![非线性化队列图像](img/0cfcbd3711b7841ea9c52e2ab0e488f6.png)'
- en: 'In this case having a simple pointer as iterator is not enough. There is a
    need to check a wrap-around case when incrementing an iterator. However always
    using this kind of iterator may incur undesired performance penalties. That is
    when “leniarisation” concept pops up. When the queue is linearised, address of
    every element is greater than the address of its predecessor and simple pointer
    (linearised iterator) may be used to iterate over all the elements in the queue:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，简单地使用指针作为迭代器是不够的。在增加迭代器时需要检查循环覆盖的情况。然而，始终使用这种类型的迭代器可能会带来不期望的性能惩罚。这就是“线性化”概念出现的时候。当队列被线性化时，每个元素的地址都大于其前驱的地址，简单的指针（线性化迭代器）可以用来迭代队列中的所有元素：
- en: '![Linearised queue image](img/12344728af247c8d2f610f4a46738ce7.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![线性化队列图像](img/12344728af247c8d2f610f4a46738ce7.png)'
- en: 'When the queue is not linearised, it either must be linearised (may be a bit
    expensive, depending on the size of the queue) or iterate over all the elements
    in two stages: first on the first (top) part, then on the second (bottom) part.
    The `StaticQueue` implementation in [embxx](https://github.com/arobenko/embxx)
    library provides two functions `arrayOne()` and `arrayTwo()` that return these
    two ranges.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列不是线性化的，它要么必须被线性化（可能有点昂贵，取决于队列的大小），要么在两个阶段迭代所有元素：首先在第一部分（顶部），然后在第二部分（底部）。在[embxx](https://github.com/arobenko/embxx)库中的`StaticQueue`实现提供了两个函数`arrayOne()`和`arrayTwo()`，它们返回这两个范围。
- en: 'However, there may be a need to read/write data from/to the queue without worrying
    about the wrap-around case. Good example of such case would be having such circular
    queue/buffer to contain data read from some communication interface, such as serial
    port, and there is a need to deserialise 4 byte value from this buffer. The most
    convenient way would be to use `embxx::io::readBig<4>(iter)` described previously.
    To properly support this case we will need to have a bit more expensive iterator
    that properly handles wrap-around when incremented and/or dereferenced. This is
    the reason for having two types of iterators for `StaticQueue`: `LinearisedIterator`
    and `Iterator`. The former is a simple `typedef` for a pointer which can be used
    only on the linearised part of the queue and the latter may be used when iterating
    without any knowledge whether there is a wrap-around case during the iteration.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能需要从队列中读取/写入数据，而不必担心循环覆盖的情况。这种情况的良好例子是拥有这样的循环队列/缓冲区来包含从某些通信接口（如串行端口）读取的数据，并且需要从这个缓冲区中反序列化4字节值。最方便的方法是使用之前描述的`embxx::io::readBig<4>(iter)`。为了正确支持这种情况，我们需要一个更昂贵的迭代器，它可以正确处理在增加和/或解引用时的循环覆盖。这就是为什么`StaticQueue`有两个类型迭代器的原因：`LinearisedIterator`和`Iterator`。前者是一个简单的`typedef`，用于指针，只能用于队列的线性部分，而后者可以在迭代时使用，无需知道迭代过程中是否存在循环覆盖的情况。
- en: 'When defining a new custom iterator class, there is a need to properly support
    [std::iterator_traits](http://en.cppreference.com/w/cpp/iterator/iterator_traits)
    for it. The traits are used to implement functions such as [std::advance](http://en.cppreference.com/w/cpp/iterator/advance)
    or [std::distance](http://en.cppreference.com/w/cpp/iterator/distanc)). The requirement
    is to define the following internal types:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个新的自定义迭代器类时，需要为它正确支持[std::iterator_traits](http://en.cppreference.com/w/cpp/iterator/iterator_traits)。这些特性用于实现诸如[std::advance](http://en.cppreference.com/w/cpp/iterator/advance)或[std::distance](http://en.cppreference.com/w/cpp/iterator/distanc))之类的函数。要求定义以下内部类型：
- en: '[PRE109]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Copying queues
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复制队列
- en: Care must be taken when copying/moving elements between the queues. The compiler
    is not aware of the right type of the elements that are stored in the queue as
    well as number of valid elements in the queue is unknown at compile time. When
    using default copy/move constructor and/or assignment operator the compiler will
    generate a code that copies raw bytes in the storage space between the queues.
    It may work for the basic type or POD structs, but it is not the right way to
    do the copying. There is a need to use copy/move constructors in case of constructions
    or copy/move assignment operator in case of assignment of the valid elements and
    not copy/move garbage data from unused space.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列之间复制/移动元素时必须小心。编译器不知道存储在队列中的元素的正确类型，以及在编译时队列中有效元素的数量是未知的。当使用默认的复制/移动构造函数和/或赋值运算符时，编译器将在队列之间存储空间的原始字节之间生成代码。这可能适用于基本类型或POD结构体，但这并不是正确的复制方式。在构造或复制/移动赋值运算符的情况下，需要使用复制/移动构造函数，以及在不复制/移动未使用空间中的垃圾数据的情况下，对有效元素进行赋值。
- en: 'In addition to regular copy/move constructors and assignment operators, there
    may also be a need to provide copy/move construction and/or copy/move assignment
    from the queue that contains elements of the same type, but has different capacity:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的复制/移动构造函数和赋值运算符之外，还可能需要提供从包含相同类型元素但容量不同的队列中进行复制/移动构造和/或复制/移动赋值的操作：
- en: '[PRE110]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Optimising code generation
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优化代码生成
- en: 'As we all know and confirmed in [Templates](#compiler_output-templates) chapter,
    any difference in the value of template parameter will create new instantiation
    of executable code. It means that having multiple queues of the same type, but
    different sizes may bloat the executable in an unacceptable way. The best way
    to solve this problem would be defining a base class that is templated only on
    the type of the stored values and implements the whole logic of the queue while
    the derived `StaticQueue` class will just provide the necessary storage area and
    reuse (wrap) all the functions implemented in the base class:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[模板](#compiler_output-templates)章节中都知道并确认的那样，任何模板参数值的差异都会创建新的可执行代码实例。这意味着，即使有多个相同类型但大小不同的队列，也可能以不可接受的方式膨胀可执行文件。解决这个问题的最佳方法是将基类定义为仅模板化存储值的类型，并实现队列的全部逻辑，而派生的`StaticQueue`类只需提供必要的存储区域并重用（包装）基类中实现的所有函数：
- en: '[PRE111]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: There are ways to optimise even more. Let’s take queues of `int` and `unsigned`
    values for example. They have the same size and from the queue implementation
    perspective there is no difference in handling them, so it would be a waste of
    code space to allow the instantiation of the same binary code for the queue to
    handle both of these types. Using template specialisation tricks we may implement
    queues of signed integral types to be a mere wrappers around queues that contain
    unsigned integral types. Additional example would be storage of the pointers to
    any types. It would be wise to specialise `StaticQueue` of pointers to be a wrapper
    around queue of `void*` pointers or even integral unsigned values of the same
    size as pointers (such as `std::uint32_t` on 32 bit architecture or `std::uint64_t`
    on 64 bit architecture).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 仍有方法可以进一步优化。以`int`和`unsigned`类型的队列为例。它们具有相同的大小，并且从队列实现的角度来看，处理它们之间没有区别，因此允许为队列实例化相同的二进制代码来处理这两种类型将是代码空间的浪费。使用模板特化技巧，我们可以实现带符号整型队列，使其成为包含无符号整型队列的包装器。另一个例子是存储任何类型的指针。明智的做法是将指针的`StaticQueue`特化为包装`void*`指针的队列，甚至可以是将指针大小相同的无符号整数值（例如32位架构上的`std::uint32_t`或64位架构上的`std::uint64_t`）。
- en: Thanks to the template specialisation there are virtually no limits to optimisations
    we may apply. However I would like to remind you the well known saying “Premature
    optimisations are the root of all evil”. Please avoid optimising your `StaticQueue`
    implementation until the need arises.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了模板特化，我们可以几乎无限制地应用优化。然而，我想提醒大家一句众所周知的名言：“过早的优化是万恶之源”。请避免在需要之前对您的`StaticQueue`实现进行优化。
- en: Basic Concepts
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本概念
- en: As already mentioned in [Overview](#overview), this book explains and shows
    examples of how to implement **soft** real time systems. This chapter will explain
    basic concepts of asynchronous event handling as well as how to implement required
    functionality without complex state machines, and/or task scheduing.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如已在[概述](#overview)中提到，本书解释并展示了如何实现**软实时**系统的示例。本章将解释异步事件处理的基本概念，以及如何在不使用复杂状态机或任务调度的情况下实现所需的功能。
- en: Event Loop
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'Most bare-metal embedded products require only two modes of operation:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数裸机嵌入式产品只需要两种操作模式：
- en: Interrupt (or service) mode
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断（或服务）模式
- en: Non-interrupt (or user) mode.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非中断（或用户）模式。
- en: The job of the code, that is executed in interrupt mode, is to respond to hardware
    events (interrupts) by performing minimal job of updating various status registers
    and schedule proper handling of event (if applicable) to be executed in non-interrupt
    mode. In most projects the interrupt handlers are not prioritised, and the next
    hardware event (interrupt) won’t be handled until the previously called interrupt
    handler returns, i.e. CPU is ready to return to non-interrupt mode. Therefore,
    it is important for the interrupt handler to do its job as quickly as possible.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在中断模式下执行代码的任务是响应硬件事件（中断），通过执行最小的工作来更新各种状态寄存器，并在适用的情况下安排在非中断模式下执行的事件处理。在大多数项目中，中断处理程序没有被优先级排序，并且下一个硬件事件（中断）不会处理，直到之前调用的中断处理程序返回，即CPU准备好返回非中断模式。因此，中断处理程序尽快完成其工作非常重要。
- en: 'There are multiple ways to schedule the execution of event handling code in
    non-interrupt mode from code being executed in interrupt mode. One of the easiest
    and straightforward ones is to have some kind of global flag that indicates that
    event has occurred and the processing is required:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在非中断模式下，从中断模式执行中的代码中调度事件处理代码的执行有多种方式。其中最简单直接的一种是设置某种全局标志，以指示事件已发生且需要处理：
- en: '[PRE112]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: It is quite clear that this approach is not scalable, i.e. will quickly become
    a mess when number of hardware events the code needs to handle grows. The events
    may also be handled not in the same order they occurred, which may create undesired
    races and side effects on some systems.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这种方法不可扩展，即当代码需要处理硬件事件的数量增加时，会迅速变得混乱。事件也可能不是按发生的顺序处理的，这可能在某些系统上创建不希望出现的竞态条件和副作用。
- en: 'Another widely used approach is to create a queue-like container (linked list
    or circular buffer) of event IDs which are handled in the similar event loop:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种广泛使用的方法是创建一个类似队列的容器（链表或环形缓冲区），其中包含要处理的事件ID，这些事件在类似的事件循环中处理：
- en: '[PRE113]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The approach above is a bit better, it processes events in the same order they
    occur, but still has its own disadvantages. Sometimes there is a need to attach
    some extra information for the processing of the event. Usually it is done using
    global variables, which introduces some extra complexity to the code and possibility
    for races. The handling of some events may have several internal stages and require
    busy wait(s) during the processing. These busy waits may significantly delay the
    processing of other pending events. The usual way to resolve this kind of problem
    is to create several state machines, that process this kind of events in stages.
    Most of Real-Time OSes provide an ability to create independent tasks (threads),
    that can be used to perform independent complex multiple staged workflows while
    the OS performs context switching between them. Still, the code can very quickly
    become too complex and difficult to maintain.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法稍微好一些，它按事件发生的顺序处理事件，但仍然有其自身的缺点。有时需要为事件处理附加一些额外信息。通常这是通过使用全局变量来完成的，这给代码引入了一些额外的复杂性，并可能引发竞态条件。某些事件的处理可能包含几个内部阶段，并在处理过程中需要忙等待。这些忙等待可能会显著延迟其他挂起事件的处理。解决这类问题的常用方法是创建多个状态机，按阶段处理这类事件。大多数实时操作系统都提供创建独立任务（线程）的能力，这些任务可以在操作系统在它们之间进行上下文切换时执行独立的复杂多阶段工作流程。然而，代码可能会很快变得过于复杂且难以维护。
- en: The approaches above are widely used in bare metal projects developed using
    C programming language. Using C++ language built-in features as well as ready
    to use classes from STL it is possible to simplify the complexity of the code
    and implement proper asynchronous handling of events, which is easier to debug
    and maintain.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法在用C编程语言开发的裸机项目中广泛使用。使用C++语言内置特性和STL中现成的类可以简化代码的复杂性，并实现正确的事件异步处理，这更容易调试和维护。
- en: 'I would recommend using a queue of callable objects created by [std::bind()](http://en.cppreference.com/w/cpp/utility/functional/bind)
    expressions or [lambda functions](http://en.cppreference.com/w/cpp/language/lambda).
    The conventional C++ way would be using [std::list](http://en.cppreference.com/w/cpp/container/list)
    of [std::function](http://en.cppreference.com/w/cpp/utility/functional/function)
    objects. However, these classes use dynamic memory allocation and throw exceptions,
    which may be not suitable for every bare metal project. Anyway, let’s just demonstrate
    the idea using these two classes:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用由[std::bind()](http://en.cppreference.com/w/cpp/utility/functional/bind)表达式或[lambda函数](http://en.cppreference.com/w/cpp/language/lambda)创建的可调用对象队列。传统的C++方法将是使用[std::list](http://en.cppreference.com/w/cpp/container/list)的[std::function](http://en.cppreference.com/w/cpp/utility/functional/function)对象。然而，这些类使用动态内存分配并抛出异常，这可能不适合每个裸机项目。无论如何，让我们使用这两个类来展示这个想法：
- en: '[PRE114]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This approach allows having complex processing of some events with many sub-stages
    and busy waits while still allowing other independent events being processed.
    All the handlers are executed in the same order they were pushed to the queue.
    There is an ability to bind multiples additional parameters together with the
    function call, which reduces a necessity to have global variables to pass values
    around. There is no need to maintain a list of various event IDs, explicitly define
    stages of state machine(s) or implement complex task switching between independent
    threads (tasks).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许对一些具有许多子阶段和忙碌等待的复杂事件进行处理，同时仍然允许其他独立事件被处理。所有处理程序都按照它们被推入队列的顺序执行。有一种能力可以将多个附加参数与函数调用一起绑定，这减少了需要全局变量来传递值的必要性。没有必要维护各种事件ID的列表，明确定义状态机（的）阶段，或实现独立线程（任务）之间的复杂任务切换。
- en: 'Now, let’s try to get rid of dynamic memory allocation and possible exceptions.
    The only way to achieve this is to have a compile time constant that specifies
    the maximal size of the queue. The naive implementation would be using [StaticQueue](https://github.com/arobenko/embxx/blob/master/embxx/container/StaticQueue.h)
    of [StaticFunction](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h)
    objects described in [Basic Needs](#basic_needs-basic_needs) chapter. However,
    the [StaticFunction](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h)
    class definition requires compile time constant to specify the size of the area
    to store all the data of the callable object. It must be big enough to contain
    any possible callable object that will be pushed to the queue. For example:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试消除动态内存分配和可能的异常。实现这一点的唯一方法是在编译时有一个常量，指定队列的最大大小。直观的实现是使用[StaticQueue](https://github.com/arobenko/embxx/blob/master/embxx/container/StaticQueue.h)来存储[StaticFunction](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h)对象，这些对象在[基本需求](#basic_needs-basic_needs)章节中描述。然而，[StaticFunction](https://github.com/arobenko/embxx/blob/master/embxx/util/StaticFunction.h)类的定义需要一个编译时常量来指定存储所有可调用对象数据的区域的大小。它必须足够大，以容纳将被推入队列的任何可能的可调用对象。例如：
- en: '[PRE115]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The queue will look like this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 队列将看起来像这样：
- en: '![Queue of StaticFunction image](img/36e66af77d4ca9c42efd7df19150f1d0.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![StaticFunction的队列图像](img/36e66af77d4ca9c42efd7df19150f1d0.png)'
- en: It is quite clear that lots of space may be wasted and this approach must be
    optimised. What if we could push the callable object to the queue one after another
    regardless of their actual size with a bit of extra space overhead (such as pointer
    to v-table), that will help us to retrieve size of the object at runtime and remove
    appropriate number of bytes from such queue after the callable object did its
    job?
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，可能会浪费很多空间，这种方法必须进行优化。如果我们能够将可调用对象一个接一个地推入队列，而不考虑它们的实际大小，只需一点额外的空间开销（如v-table指针），这将帮助我们运行时检索对象的大小，并在可调用对象完成其工作后从这样的队列中移除适当数量的字节？
- en: '![Optimised queue image](img/c04b0d3fa1439415bce8174fb65ba142.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![优化队列图像](img/c04b0d3fa1439415bce8174fb65ba142.png)'
- en: It looks much better. The space consumption is much more efficient.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来要好得多。空间消耗更加高效。
- en: 'To properly support this type of queue we must:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确支持此类队列，我们必须：
- en: implement polymorphic behaviour when calling every handler with same interface.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用每个处理程序时使用相同的接口实现多态行为。
- en: implement polymorphic behaviour to retrieve the size of single handler in order
    to know how many bytes are to be removed from the queue after the handler has
    been called.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现多态行为以检索单个处理程序的大小，以便知道在调用处理程序后需要从队列中移除多少字节。
- en: properly handle wrap-around cases when the pushed handler cannot fit into the
    area between the end of the queue and end of the allocated space.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当推送的处理程序无法适应队列末尾和分配空间末尾之间的区域时，需要正确处理环绕情况。
- en: 'The code of required classes will be like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 所需类的代码将如下所示：
- en: '[PRE116]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The definition of the Queue type will be:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 队列类型的定义将是：
- en: '[PRE117]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`TSize` is a template parameter that specifies maximum size (in bytes) of the
    queue storage area.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`TSize`是一个模板参数，指定队列存储区域的最大大小（以字节为单位）。'
- en: 'The code of pushing new handler to the queue will look like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 将新处理程序推送到队列的代码将如下所示：
- en: '[PRE118]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note, that job of `getAllocPlace()` function is to make sure that continuous
    storage area that is able to store the required callable object is created (by
    resizing the queue) and return pointer to this area.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getAllocPlace()`函数的职责是确保创建一个能够存储所需可调用对象的连续存储区域（通过调整队列大小），并返回该区域的指针。
- en: '[PRE119]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In case of wrap-around, when there is not enough space between the end of the
    queue and end of its storage area, number of simple `Task` objects which do nothing
    (the body of exec() function is empty) are pushed to fill the space till the end
    of storage area to make the queue non-linearised, which in turn will allow creation
    of continuous area of required size in the second half of the circular queue.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在环绕的情况下，当队列末尾和其存储区域末尾之间没有足够的空间时，将推送一些什么也不做的简单`Task`对象（`exec()`函数的主体为空）来填充空间，直到存储区域的末尾，从而使队列非线性化，这反过来又允许在环形队列的第二半部分创建所需大小的连续区域。
- en: 'The event handling loop will be something like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理循环将类似于以下内容：
- en: '[PRE120]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The only remaining thing is to create a convenient and generic interface to
    be able to add new handlers for execution from both interrupt and non-interrupt
    contexts.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是创建一个方便且通用的接口，以便能够从中断和非中断上下文添加新的处理程序以执行。
- en: Analogy with Threads
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程类比
- en: 'Before diving into implementation of such interface, I’d like to make an analogy
    between interrupt/non-interrupt execution modes and two threads. The inter-threads
    communication is managed using locks (such as [std::mutex](http://en.cppreference.com/w/cpp/thread/mutex))
    and condition variables (such as [std::condition_variable_any](http://en.cppreference.com/w/cpp/thread/condition_variable_any)).
    Using this analogy the handlers execution loop (executed in non-interrupt thread)
    can be implemented like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实现此类接口之前，我想将中断/非中断执行模式与两个线程之间的类比。线程间通信是通过锁（如[std::mutex](http://en.cppreference.com/w/cpp/thread/mutex)）和条件变量（如[std::condition_variable_any](http://en.cppreference.com/w/cpp/thread/condition_variable_any)）管理的。使用这个类比，处理程序执行循环（在非中断线程中执行）可以像这样实现：
- en: '[PRE121]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'And adding new execution handler from any thread can be:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何线程添加新的执行处理程序可以是：
- en: '[PRE122]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If we think about interrupt and non-interrupt execution modes as two threads,
    the locking in non-interrupt thread is equivalent to disabling interrupts; and
    waiting for condition variable to be notified is equivalent for waiting for interrupts
    (using `WFI` or `WFE` instructions in ARM architecture) while notification can
    be automatic due to pending interrupts or implemented using `SEV` instruction.
    However, our interrupt and non-interrupt mode threads differ slightly from conventional
    threads. The non-interrupt mode one can be interrupted at any time by interrupt
    mode, while the interrupt mode “thread” won’t be interrupted and doesn’t actually
    need to protect itself from other thread’s intervention.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将中断和非中断执行模式视为两个线程，则非中断线程中的锁定相当于禁用中断；而等待条件变量被通知相当于等待中断（在ARM架构中使用`WFI`或`WFE`指令）而通知可以自动，因为挂起的中断或使用`SEV`指令实现。然而，我们的中断和非中断模式线程与传统的线程略有不同。非中断模式的线程可以随时被中断模式中断，而中断模式的“线程”不会被中断，实际上也不需要保护自己免受其他线程干预。
- en: The whole logic of event handling loop in non-interrupt context described above
    is generic except locking (disabling interrupts) and waiting for new handlers
    to be added (waiting for interrupts) which are platform and architecture specific.
    As I’ve mentioned before, the whole idea of using C++ instead of C in bare metal
    development is to be able to write and reuse generic code while providing minimal
    platform specific hardware control functionality. The [embxx](https://github.com/arobenko/embxx)
    library provides [EventLoop](https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h)
    class that receives the locking and condition variable classes as template parameters
    and manages safe addition of new handlers and in-order execution of the latter
    in non-interrupt context.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的非中断上下文中事件处理循环的整个逻辑是通用的，除了锁定（禁用中断）和等待新处理程序被添加（等待中断）这些是平台和架构特定的。正如我之前提到的，使用
    C++ 而不是 C 进行裸机开发的整体想法是能够在提供最小平台特定硬件控制功能的同时编写和重用通用代码。`embxx` [库](https://github.com/arobenko/embxx)
    提供了一个 [EventLoop](https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h)
    类，它接受锁定和条件变量类作为模板参数，并在非中断上下文中管理新处理程序的安全添加和有序执行。
- en: '[PRE123]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `TLock` class must expose the following public interface:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`TLock` 类必须公开以下接口：'
- en: '[PRE124]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The `TCond` class must expose the following public interface:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCond` 类必须公开以下接口：'
- en: '[PRE125]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The example of such classes for Raspberry Pi platform may be found [here](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/EventLoopDevices.h).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 对于树莓派平台此类类的示例，可以在此处找到：[这里](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/EventLoopDevices.h)。
- en: '[PRE126]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The [EventLoop](https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h)
    class exposes the following public interface:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[EventLoop](https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h)
    类公开以下接口：'
- en: '[PRE127]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: I’ll leave the implementation of the functions above as an exercise to the reader.
    Don’t forget to call `notify()` member function of condition variable when adding
    new handler to the empty queue.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把上述函数的实现留给读者作为练习。不要忘记在向空队列添加新处理程序时调用条件变量的 `notify()` 成员函数。
- en: If needed, the reference implementation can be found [here](https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以在此处找到参考实现：[这里](https://github.com/arobenko/embxx/blob/master/embxx/util/EventLoop.h)。
- en: Busy Loops
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 忙循环
- en: 'The event loop described above is an easy and convenient way to implement soft
    real-time systems. However, the main rule with such architecture is: **DON’T DO
    BUSY LOOPS!** It means, if there is a real need to perform a busy wait before
    proceeding to the next stage, do it by letting other events being handled as well.
    The `EventLoop` class also provides `busyWait()` member function that does exactly
    that.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述的事件循环是实现软实时系统的一种简单方便的方法。然而，此类架构的主要规则是：**不要执行忙循环**！这意味着，如果在进行下一阶段之前确实需要执行忙等待，可以通过让其他事件也被处理来实现。`EventLoop`
    类还提供了一个 `busyWait()` 成员函数，它正是这样做的。
- en: '[PRE128]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Device-Driver-Component
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备-驱动程序-组件
- en: Now, after understanding what the event loop is and how to implement it in C++,
    I’d like to describe **Device-Driver-Component** stack concept before proceeding
    to practical examples.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在理解了事件循环是什么以及如何在 C++ 中实现它之后，我想在进入实际示例之前，先描述一下 **设备-驱动程序-组件** 堆栈的概念。
- en: '![Image: Device-Driver-Component Stack](img/fdb9009ed5adde6403f5c0424c2eabc4.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![Image: 设备-驱动程序-组件堆栈](img/fdb9009ed5adde6403f5c0424c2eabc4.png)'
- en: The **Device** is a platform specific peripheral(s) control layer. Sometimes
    it is called HAL - **H**ardware **A**bstraction **L**ayer. It has an access to
    platform specific peripheral control registers. Its job is to implement predefined
    interface required by upper **Driver** layer, handle the relevant interrupts and
    report them to the **Driver** via callbacks.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备**是特定平台的外设控制层。有时它被称为 HAL - **硬件**抽象**层**。它有权访问特定平台的控制寄存器。其任务是实现上层**驱动程序**层所需的预定义接口，处理相关中断并通过回调将它们报告给**驱动程序**。'
- en: The **Driver** is a generic platform independent layer. Its job is to receive
    requests for asynchronous operation from the **Component** layer and forward the
    request to the **Device**. It is also responsible for receiving notifications
    about the interrupts from the **Device** via callbacks, perform minimal processing
    of the hardware event if necessary and schedule the execution of proper event
    handling callback from the **Component** in non interrupt context using [Event
    Loop](#basic_concepts-event_loop).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**是一个通用的平台无关层。其任务是接收来自**组件**层的异步操作请求并将其转发到**设备**。它还负责通过回调接收来自**设备**的中断通知，如果需要，对硬件事件进行最小处理，并使用[事件循环](#basic_concepts-event_loop)在非中断上下文中安排从**组件**执行适当的事件处理回调。'
- en: The **Component** is a generic or product specific layer that works fully in
    event loop (non-interrupt) context. It initiates asynchronous operations using
    **Driver** while providing a callback object to be called in event loop context
    when the asynchronous operation is complete.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是一个通用或产品特定层，在事件循环（非中断）上下文中完全工作。它使用**驱动程序**启动异步操作，同时在事件循环上下文中提供当异步操作完成时被调用的回调对象。'
- en: 'There are several main operations required for any asynchronous event handling:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何异步事件处理，需要几个主要操作：
- en: Start the operation.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始操作。
- en: Complete the operation.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成操作。
- en: Cancel the operation.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消操作。
- en: Suspend the operation.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停操作。
- en: Resume suspended operation.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复挂起操作。
- en: All the peripherals described in [Peripherals](#peripherals-peripherals) chapter
    will follow the same scheme for these operations with minor changes, such as having
    extra parameters or intermediate stages.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[外围设备](#peripherals-peripherals)章节中描述的所有外围设备都将遵循相同的操作方案，略有变化，例如有额外的参数或中间阶段。'
- en: Starting Asynchronous Operation
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始异步操作
- en: '![Image: Starting Asynchronous Operation](img/d55ee44d2098506f24f632ed26580331.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Starting Asynchronous Operation](img/d55ee44d2098506f24f632ed26580331.png)'
- en: Any non-interrupt context operation is initiated from some event handler executed
    by the [Event Loop](#basic_concepts-event_loop) or from the `main()` function
    before the event loop started its execution. The handler being executed invokes
    some function in some **Component**, which requests the **Driver** to perform
    some asynchronous operation while providing a callback object to be executed when
    such operation is complete. The **Driver** stores the provided callback object
    and other parameters in its internal data structures, then forwards the request
    to the **Device**, which configures the hardware accordingly and enables all the
    required interrupts.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非中断上下文操作都是从[事件循环](#basic_concepts-event_loop)执行的事件处理器或从事件循环开始执行之前在`main()`函数中调用的处理器发起。正在执行的处理程序在某个**组件**中调用某个函数，该函数请求**驱动程序**执行某些异步操作，并提供在操作完成时执行的回调对象。**驱动程序**将提供的回调对象和其他参数存储在其内部数据结构中，然后将请求转发到**设备**，**设备**相应地配置硬件并启用所有必需的中断。
- en: Completing Asynchronous Operation
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成异步操作
- en: 'The first entity, that is aware of asynchronous operation completion, is **Device**
    when appropriate interrupt occurs. It must report the completion to the **Driver**
    somehow. As was described earlier, the **Device** is a platform specific layer
    that resides at the bottom of the **Device-Driver-Component** stack and is not
    aware of the generic **Driver** layer that uses it. The **Device** must provide
    a way to set an operation completion report object. The **Driver** will usually
    assign such object during construction/initialisation stage:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当适当的中断发生时，第一个意识到异步操作完成的是**设备**。它必须以某种方式向**驱动程序**报告完成。如前所述，**设备**是一个平台特定的层，位于**设备-驱动程序-组件**堆栈的底部，并且不了解使用它的通用**驱动程序**层。**设备**必须提供一种设置操作完成报告对象的方法。**驱动程序**通常在构造/初始化阶段分配此类对象：
- en: '![Image: Assigning callback](img/ff8734b22d0ac7e95e0ba442cee9a2d6.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Assigning callback](img/ff8734b22d0ac7e95e0ba442cee9a2d6.png)'
- en: When the expected interrupt occurs, the **Device** reports operation completion
    to the **Driver**, which in turn schedules execution of the callback object from
    the **Component** in non-interrupt context using [Event Loop](#basic_concepts-event_loop).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当预期的中断发生时，**设备**向**驱动程序**报告操作完成，驱动程序随后在非中断上下文中安排从**组件**执行回调对象，使用[事件循环](#basic_concepts-event_loop)。
- en: '![Image: Completing Asynchronous Operation](img/592317061421f4e71798666cec91c43f.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Completing Asynchronous Operation](img/592317061421f4e71798666cec91c43f.png)'
- en: Note that the operation may fail, due to some hardware faults, This is the reason
    to have `status` parameter reporting success and/or error condition in both callback
    invocations.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，操作可能会失败，由于某些硬件故障，这就是为什么在两次回调调用中都有`status`参数报告成功和/或错误条件的原因。
- en: Canceling Asynchronous Operation
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: There must be an ability to cancel asynchronous operations in progress. For
    example some **Component** activates asynchronous operation request on some hardware
    peripheral together with asynchronous wait request to the timer to measure the
    operation timeout. If timeout callback is invoked first, then there is a need
    to cancel the outstanding asynchronous operation. Or the opposite, once the read
    is successful, the timeout measure should be canceled. However, the cancellation
    may be a bit tricky. One of the main requirements for asynchronous events handling
    is that the **Component**'s callback **MUST** be called and called only **ONCE**.
    It creates a situation when cancellation may become unsuccessful. For instance,
    the callback of the asynchronous operation was posted for execution in Event Loop,
    but hasn’t been executed by the latter yet. It brings us to the necessity to provide
    an indication whether the cancellation request was successful. Simple boolean
    return value is enough.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 必须能够取消正在进行的异步操作。例如，某些**组件**在某个硬件外围设备上激活异步操作请求的同时，向计时器发送异步等待请求以测量操作超时。如果首先调用超时回调，则需要取消挂起的异步操作。或者相反，一旦读取成功，应该取消超时测量。然而，取消可能有点棘手。异步事件处理的主要要求之一是**组件**的回调**必须**被调用，并且只**被调用一次**。这创造了一种情况，使得取消可能失败。例如，异步操作的回调被安排在事件循环中执行，但尚未被后者执行。这使我们有必要提供取消请求是否成功的指示。简单的布尔返回值就足够了。
- en: '![Image: Canceling Asynchronous Operation](img/7e861c7f6aa0619952a0894a92db0c2e.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![图片：取消异步操作](img/7e861c7f6aa0619952a0894a92db0c2e.png)'
- en: When the cancellation is successful the **Component**'s callback object is invoked
    with `status` specifying that operation was `Aborted`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 当取消操作成功时，**组件**的回调对象会被调用，`status`参数指定操作已被`中止`。
- en: One possible case of unsuccessful cancellation is when callback was posted for
    execution in event loop, but hasn’t been executed yet when cancellation is attempted.
    In this case **Driver** is aware that there is no pending asynchronous operation
    and can return `false` immediately.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 取消操作失败的一种可能情况是，当回调被安排在事件循环中执行时，但在尝试取消时尚未执行。在这种情况下，**驱动程序**知道没有挂起的异步操作，可以立即返回`false`。
- en: '![Image: Canceling Asynchronous Operation Unsuccessful1](img/54d7755ee1623080c3da41f98d5a14ee.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图片：取消异步操作失败1](img/54d7755ee1623080c3da41f98d5a14ee.png)'
- en: 'Another possible case of unsuccessful cancellation is when completion interrupt
    occurs in the middle of cancellation request:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 取消操作失败的另一种可能情况是在取消请求过程中发生完成中断：
- en: '![Image: Canceling Asynchronous Operation Unsuccessful2](img/bc2050f265b813e038fe2ce1fc4471bc.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图片：取消异步操作失败2](img/bc2050f265b813e038fe2ce1fc4471bc.png)'
- en: In this case the **Device** must be able to handle such race condition appropriately,
    by temporarily disabling interrupts before checking whether the completion callback
    was executed. The **Driver** must also be able to handle interrupt context execution
    in the middle on non-interrupt one.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**设备**必须能够适当地处理这种竞态条件，通过在检查完成回调是否执行之前暂时禁用中断。**驱动程序**还必须能够处理中断上下文中的非中断执行。
- en: Suspend / Resume Asynchronous Operation
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 暂停/恢复异步操作
- en: There may be a **Driver**, that is required to support multiple asynchronous
    operations at the same time, while managing internal queue of such requests and
    issuing them one by one to the **Device**. In this case there is a need to prevent
    "operation complete" callback being invoked in interrupt mode context, while trying
    to access the internal data structures in the event loop (non-interrupt) context.
    The **Device** must provide both `suspendOp()` and `resumeOp()` to suppress invocation
    of the callback and allow it back again respectively. Usually suspension means
    disabling the interrupts without stopping current operation, while resume means
    re-enabling them again.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一个 **Driver**，它需要同时支持多个异步操作，同时管理这些请求的内部队列并将它们逐个发送到 **Device**。在这种情况下，需要防止在事件循环（非中断）上下文中尝试访问内部数据结构时，在中断模式下调用“操作完成”回调。**Device**
    必须提供 `suspendOp()` 和 `resumeOp()` 来抑制回调的调用，并允许其再次调用。通常，挂起意味着禁用中断而不停止当前操作，而恢复意味着重新启用它们。
- en: '![Image: Suspending Asynchronous Operation](img/d03f3940a750b3576986324647a4ee0f.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Suspending Asynchronous Operation](img/d03f3940a750b3576986324647a4ee0f.png)'
- en: Note that the `suspendOp()` request must also indicate whether the suspension
    was successful or the completion callback has been already invoked in interrupt
    mode, just like with the cancellation. After the operation being successfully
    suspended, it must be either **resumed** or **canceled**.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`suspendOp()` 请求还必须指示挂起是否成功，或者完成回调是否已经在中断模式下被调用，就像取消操作一样。在操作成功挂起后，它必须被**恢复**或**取消**。
- en: '**Device** Function Invocation Context'
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**Device** 函数调用上下文'
- en: Let’s think about the case when **Driver** supports multiple asynchronous operations
    at the same time and queuing them internally while issueing start requests to
    the **Device** one by one.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑当 **Driver** 同时支持多个异步操作并内部排队，同时逐个向 **Device** 发送启动请求的情况。
- en: '![Image: Starting Multiple Asynchronous Operations](img/b5e5887bbb9c6972a4b642fbec02555e.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Starting Multiple Asynchronous Operations](img/b5e5887bbb9c6972a4b642fbec02555e.png)'
- en: The reader may notice that the `startOp()` member function of the **Device**
    was invoked in event loop (non-interrupt) context while the second time it was
    in interrupt context right after the completion of the first operation was reported.
    There may be a need for the **Device**'s implementation to differentiate between
    these calls.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会注意到，**Device** 类的 `startOp()` 成员函数在事件循环（非中断）上下文中被调用，而第二次调用是在第一次操作完成报告后的中断上下文中。可能需要
    **Device** 的实现来区分这些调用。
- en: 'One of the ways to do so is to have different names and make the **Driver**
    use them depending on the current execution context:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 做到这一点的一种方法是有不同的名称，并让 **Driver** 根据当前的执行上下文使用它们：
- en: '[PRE129]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Another way is to use a [tag dispatching idiom](http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching),
    which I decided to use in [embxx](https://github.com/arobenko/embxx) library.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 [tag dispatching idiom](http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching)，我决定在
    [embxx](https://github.com/arobenko/embxx) 库中使用它。
- en: 'It defines two extra tag structs in [embxx/device/context.h](https://github.com/arobenko/embxx/blob/master/embxx/device/context.h):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 [embxx/device/context.h](https://github.com/arobenko/embxx/blob/master/embxx/device/context.h)
    中定义了两个额外的标签结构体：
- en: '[PRE130]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Then, almost every member function defined by **Device** class has to specify
    extra tag parameter indicating context:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，几乎由 **Device** 类定义的每个成员函数都必须指定额外的标签参数来指示上下文：
- en: '[PRE131]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The **Driver** class will invoke the **Device** functions using relevant temporary
    context object passed as the last parameter:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driver** 类将使用相关临时上下文对象作为最后一个参数调用 **Device** 函数：'
- en: '[PRE132]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'If some function needs to be called only in, say `EventLoop` context, and not
    supported in `Interrupt` context, then it is enough to implement only supported
    variant. If **Driver** layer tries to invoke the function with unsupported context
    tag parameter, the compilation will fail:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些函数需要在，比如说 `EventLoop` 上下文中调用，而不在 `Interrupt` 上下文中支持，那么只需要实现支持的变体就足够了。如果
    **Driver** 层尝试使用不支持上下文标签参数调用该函数，编译将失败：
- en: '[PRE133]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'If there is no need to differentiate between the contexts the function is invoked
    in, then it is quite easy to unify them:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要区分函数被调用的上下文，那么统一它们相当简单：
- en: '[PRE134]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Reporting Errors
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 报告错误
- en: When issuing asynchronous operation request to the **Driver** and/or **Component**,
    there must be a way to report success / failure status of the operation, and if
    it failed provide some extra information about the reason of the failure. Providing
    such information as first parameter to the callback functor object is a widely
    used convention among the developers.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当向**驱动程序**和/或**组件**发出异步操作请求时，必须有一种方式来报告操作的成功/失败状态，如果失败，则提供有关失败原因的一些额外信息。将此类信息作为回调函数对象的第一个参数是开发人员中广泛使用的一种约定。
- en: In most cases, the numeric value of error code is good enough.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，错误代码的数值就足够了。
- en: 'The [embxx](https://github.com/arobenko/embxx) library provides a short list
    of such values in enumeration class defined in [embxx/error/ErrorCode.h](https://github.com/arobenko/embxx/blob/master/embxx/error/ErrorCode.h):'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx](https://github.com/arobenko/embxx)库在[embxx/error/ErrorCode.h](https://github.com/arobenko/embxx/blob/master/embxx/error/ErrorCode.h)中定义的枚举类中提供了一组这样的值：'
- en: '[PRE135]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'There is also a wrapper class around the `embxx::error::ErrorCode`, called
    `embxx::error::ErrorStatus` (defined in [embxx/error/ErrorStatus.h](https://github.com/arobenko/embxx/blob/master/embxx/error/ErrorStatus.h)):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在`embxx::error::ErrorCode`周围还有一个包装类，称为`embxx::error::ErrorStatus`（在[embxx/error/ErrorStatus.h](https://github.com/arobenko/embxx/blob/master/embxx/error/ErrorStatus.h)中定义）：
- en: '[PRE136]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'It allows implicit conversion from `embxx::error::ErrorCode` to `embxx::error::ErrorStatus`
    and convenient evaluation whether error has occurred in `if` sentences:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许从`embxx::error::ErrorCode`到`embxx::error::ErrorStatus`的隐式转换，并在`if`语句中方便地评估是否发生了错误：
- en: '[PRE137]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'By convention every callback function provided with any asynchronous request
    to any **Driver** and/or **Component** implemented in [embxx](https://github.com/arobenko/embxx)
    library will receive `const embxx::error::ErrorStatus&` as its first argument:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，任何在[embxx](https://github.com/arobenko/embxx)库中实现的**驱动程序**和/或**组件**提供的异步请求的回调函数都将接收`const
    embxx::error::ErrorStatus&`作为其第一个参数：
- en: '[PRE138]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Cooperation
  id: totrans-519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合作
- en: 'As it is seen in the charts above, the **Driver** must have an access to the
    **Device** as well as **Event Loop** objects. However, the former is not aware
    of the exact type of the latter. In order to write fully generic code, the **Device**
    and **Event Loop** types must be provided as template arguments:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，**驱动程序**必须能够访问**设备**以及**事件循环**对象。然而，前者并不知道后者的确切类型。为了编写完全通用的代码，必须将**设备**和**事件循环**类型作为模板参数提供：
- en: '[PRE139]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The **Component** needs an access only to the **Device** and maybe **Event
    Loop**. The reference to the latter may be retrieved from the **Device** object
    itself:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**只需要对**设备**和可能**事件循环**的访问。后者的引用可以从**设备**对象本身检索：'
- en: '[PRE140]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Storing Callback Object
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储回调对象
- en: The **Driver** needs to provide a callback object to the **Device** to be called
    when appropriate interrupt occurs. The **Component** also provides a callback
    object to be invoked in non-interrupt context when the asynchronous operation
    is complete, aborted or terminated due to some error condition. These callback
    objects need to be stored somewhere. The best way to do so in conventional C++
    is using [std::function](http://en.cppreference.com/w/cpp/utility/functional/function).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**需要向**设备**提供一个回调对象，以便在适当的中断发生时调用。**组件**也提供了一个回调对象，在异步操作完成、取消或由于某些错误条件而终止时在非中断上下文中调用。这些回调对象需要存储在某个地方。在传统的C++中，最佳做法是使用[std::function](http://en.cppreference.com/w/cpp/utility/functional/function)。'
- en: '[PRE141]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'There are two problems with using [std::function](http://en.cppreference.com/w/cpp/utility/functional/function):
    exceptions and dynamic memory allocation. It is possible to suppress the usage
    of exceptions by making sure that function object is never invoked without proper
    object being assigned to it, and by overriding appropriate `__throw_*` function(s)
    to remove exception handling code from binary image (described in [Exceptions](#compiler_output-exceptions)
    chapter). However, it is impossible to get rid of dynamic memory allocation in
    this case, which reduces number of bare metal products the **Driver** code can
    be reused in, i.e. it makes the **Driver** class not fully generic.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[std::function](http://en.cppreference.com/w/cpp/utility/functional/function)有两个问题：异常和动态内存分配。可以通过确保函数对象在没有正确分配对象的情况下永远不会被调用，并覆盖适当的`__throw_*`函数来移除异常处理代码从二进制图像中（在[异常](#compiler_output-exceptions)章节中描述）。然而，在这种情况下无法消除动态内存分配，这减少了**驱动程序**代码可以重用的裸机产品的数量，即它使得**驱动程序**类不是完全通用的。
- en: 'The problem is resolved by defining the callback storage type as a template
    parameter to the **Driver**:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将回调存储类型定义为**驱动程序**的模板参数来解决问题：
- en: '[PRE142]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: For projects that allow dynamic memory allocation `std::function<…​>` can be
    passed, for others `embxx::util::StaticFunction<…​>` or similar must be used.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对于允许动态内存分配的项目，可以传递 `std::function<…>`，对于其他项目，必须使用 `embxx::util::StaticFunction<…>`
    或类似的。
- en: Peripherals
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外设
- en: It this chapter I will describe and give multiple examples of how to drive and
    control multiple hardware peripherals while using [Device-Driver-Component](#basic_concepts-device_driver_component)
    model in conjunction with [Event Loop](#basic_concepts-event_loop).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将描述并给出多个示例，说明如何在结合使用 [Device-Driver-Component](#basic_concepts-device_driver_component)
    模型和 [事件循环](#basic_concepts-event_loop) 的同时驱动和控制多个硬件外设。
- en: All the generic, platform independent code provided here is implemented as part
    of [embxx](https://github.com/arobenko/embxx) library while platform (Raspberry
    Pi) specific code is taken from [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)
    project.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的所有通用、平台无关的代码都是作为 [embxx](https://github.com/arobenko/embxx) 库的一部分实现的，而平台（树莓派）特定的代码则来自
    [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) 项目。
- en: All the platform specific peripheral control classes reside in [src/device](https://github.com/arobenko/embxx_on_rpi/tree/master/src/device)
    directory.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 所有平台特定的外设控制类都位于 [src/device](https://github.com/arobenko/embxx_on_rpi/tree/master/src/device)
    目录中。
- en: The [src/app](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app)
    directory contains several simple applications, such as flashing the led or responding
    to button presses.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[src/app](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app) 目录包含几个简单的应用程序，例如闪烁led或响应按钮按下。'
- en: There are also common **Component** classes shared between the applications.
    They reside in [src/component](https://github.com/arobenko/embxx_on_rpi/tree/master/src/component)
    directory.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序之间还共享一些常见的**组件**类。它们位于 [src/component](https://github.com/arobenko/embxx_on_rpi/tree/master/src/component)
    目录中。
- en: In order to compile all the applications please follow the instructions described
    in [Contents of This Book](#overview-contents).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译所有应用程序，请遵循 [本书内容](#overview-contents) 中描述的说明。
- en: Function Configuration
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数配置
- en: In ARM platform every pin needs to be configured as either gpio input, gpio
    output or having one of several alternative functions the microcontroller supports.
    The `device::Function` class defined in [src/device/Function.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Function.h)
    and [src/device/Function.cpp](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Function.cpp)
    implements simple interface which allows every **Device** class configure the
    pins it uses.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM平台上，每个引脚都需要配置为gpio输入、gpio输出或具有微控制器支持的几种替代功能之一。定义在 [src/device/Function.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Function.h)
    和 [src/device/Function.cpp](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Function.cpp)
    中的 `device::Function` 类实现了简单的接口，允许每个**设备**类配置它使用的引脚。
- en: '[PRE143]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Every implemented **Device** class will receive reference to `Function` object
    in its constructor and will have to use it to configure the pins as required.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实现的**设备**类在其构造函数中都将接收到对 `Function` 对象的引用，并将必须使用它来配置所需的引脚。
- en: Interrupts Management
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断管理
- en: There is one more componenet that every **Device** will use. It’s `device::InterruptMgr`
    defined in [src/device/InterruptMgr.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/InterruptMgr.h).
    The main responsibility of the object of this class is to control global level
    interrupts, register interrupt handlers from various **Device**s and invoke the
    appropriate handler when interrupt occurs.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个所有**设备**都会使用的组件。它是定义在 [src/device/InterruptMgr.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/InterruptMgr.h)
    中的 `device::InterruptMgr`。这个类对象的 主要职责是控制全局级别的中断，从各种**设备**中注册中断处理程序，并在发生中断时调用适当的处理程序。
- en: 'The interface of the `device::InterruptMgr` is defined as following:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`device::InterruptMgr` 的接口定义如下：'
- en: '[PRE144]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Every **Driver** will use `registerHandler()` member function to register its
    member function as the handler for its `IrqId`. The `enableInterrupt()` and `disableInterrupt()`
    are also used by the **Device** objects to control their interrupts on global
    level.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 每个驱动程序都将使用 `registerHandler()` 成员函数来注册其成员函数作为其 `IrqId` 的处理程序。`enableInterrupt()`
    和 `disableInterrupt()` 也被**设备**对象用于控制其在全局级别上的中断。
- en: In order to use the **Interrupt Manager** described above every application
    has to implement proper interrupt handler that will retrieve the reference to
    `device::InterruptMgr` object (via global/static variables) and invoke its `handleInterrupt()`
    function, which in turn check the appropriate status register(s) and invoke registered
    handler(s). Please note, that the handler will be executed in interrupt context.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用上面描述的**中断管理器**，每个应用程序都必须实现适当的中断处理程序，该处理程序将检索`device::InterruptMgr`对象的引用（通过全局/静态变量）并调用其`handleInterrupt()`函数，该函数反过来检查适当的寄存器状态并调用已注册的处理程序。请注意，处理程序将在中断上下文中执行。
- en: 'The code will look something like this:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来可能像这样：
- en: '[PRE145]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'There may also be a need to enable/disable all the interrupts by toggling `i`
    flag in `CPS` register. The same [src/device/InterruptMgr.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/InterruptMgr.h)
    file provides two function for this purpose:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能需要通过在`CPS`寄存器中切换`i`标志来启用/禁用所有中断。同一[src/device/InterruptMgr.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/InterruptMgr.h)文件提供了两个用于此目的的函数：
- en: '[PRE146]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Timer
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计时器
- en: It is customary in bare metal development to flash leds in the first application
    (instead of writing "Hello world"). However most tutorials show how to do it synchronously
    using loops to wait some time before changing state of the led. I’m going to describe
    how to do it asynchronously using timer interrupt in conjunction with [Event Loop](#basic_concepts-event_loop).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在裸机开发中，通常在第一个应用程序中闪烁LED（而不是编写“Hello world”）。然而，大多数教程展示了如何使用循环同步等待一段时间，然后改变LED的状态。我将描述如何使用计时器中断结合[事件循环](#basic_concepts-event_loop)异步地完成它。
- en: Almost every embedded platform has usually one or two timer peripherals. One
    such peripheral can be programmed to provide an interrupt after some period of
    time. However, there may be a need to have multiple timers that can be activated
    independently at the same time. It is quite clear that there should be an entity
    that receives all the wait requests from various **Component**s in non-interrupt
    context, then queues the wait requests internally, programs the timer peripheral
    to provide an interrupt after some time, and finally reports the completion to
    appropriate **Component** via callback also in non-interrupt (event loop) context.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个嵌入式平台通常都有一个或两个计时器外设。这样的外设可以被编程在一段时间后提供中断。然而，可能需要多个计时器，它们可以在同一时间独立激活。很明显，应该有一个实体接收来自各种**组件**的非中断上下文中的所有等待请求，然后在内部排队等待请求，编程计时器外设在一段时间后提供中断，并最终通过回调在非中断（事件循环）上下文中向适当的**组件**报告完成。
- en: Such entity can be a generic (platform independent) **Driver**, if it is provided
    with platform specific **Device** object, that exposes some predefined public
    interface and controls the actual platform specific hardware.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的实体可以是一个通用的（平台无关的）**驱动程序**，如果它提供了平台特定的**设备**对象，该对象公开一些预定义的公共接口并控制实际的平台特定硬件。
- en: '![Image: Timer Manager](img/a67cc244c849a27e966eb416cae967dd.png)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![图像：计时器管理器](img/a67cc244c849a27e966eb416cae967dd.png)'
- en: The asynchronous timer event handling follows the same pattern described in
    [Device-Driver-Component](#basic_concepts-device_driver_component) chapter.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 异步计时器事件处理遵循在[设备驱动组件](#basic_concepts-device_driver_component)章节中描述的相同模式。
- en: Assigning Wait Complete Callback
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分配等待完成回调
- en: 'Just like described in [Device-Driver-Component](#basic_concepts-device_driver_component)
    chapter the **Driver** needs to provide the "Wait Complete" callback object to
    be called when timer interrupt occurs. The assignment is usually performed during
    initialisation/construction stage of the **Driver**:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[设备驱动组件](#basic_concepts-device_driver_component)章节中描述的那样，**驱动程序**需要提供当计时器中断发生时被调用的“等待完成”回调对象。分配通常在**驱动程序**的初始化/构造阶段进行：
- en: '![Image: Assigning callback](img/dccb7071cbc5d9b688d5cee035031989.png)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![图像：分配回调](img/dccb7071cbc5d9b688d5cee035031989.png)'
- en: Starting Asynchronous Wait
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始异步等待
- en: '![Image: Starting Asynchronous Wait](img/4953a6e35964e8156cef471025c09521.png)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![图像：开始异步等待](img/4953a6e35964e8156cef471025c09521.png)'
- en: The **Driver** must be able to support multiple wait requests from various **Components**
    and manage the internal queue accordingly. In the chart above the timer peripheral
    activated on the first `asyncWait()` request. When the second request is issued
    (assuming `timeout1 < timeout2` and existing wait mustn’t be stopped), the **Driver**
    must prevent the completion of the currently scheduled timer countdown being reported
    in interrupt context while interfering with an update to internal data structures.
    The interrupts are disabled by calling `suspendWait()` member function of the
    **Device**. The call to the `suspendWait()` returns `true`, which means the interrupts
    are successfully disabled and it is safe to update internal data structures. If
    the call to `suspendWait()` returns `false`, it means that the interrupt has already
    occurred and there is no existing wait in progress, i.e. the second `asyncWait()`
    actually becomes a first one in the new sequence.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**必须能够支持来自各种**组件**的多个等待请求，并相应地管理内部队列。在上面的图表中，定时器外设是在第一次`asyncWait()`请求上激活的。当发出第二个请求时（假设`timeout1
    < timeout2`且现有的等待不应停止），**驱动程序**必须防止在中断上下文中报告当前计划好的计时器倒计时的完成，同时干扰内部数据结构的更新。通过调用**设备**的`suspendWait()`成员函数来禁用中断。对`suspendWait()`的调用返回`true`，这意味着中断已成功禁用，可以安全地更新内部数据结构。如果对`suspendWait()`的调用返回`false`，则表示中断已经发生，没有正在进行的等待，即第二个`asyncWait()`实际上成为新序列中的第一个。'
- en: There also may be a case when `timeout2 < timeout1` which means the order of
    the timeout requests must be re-evaluated, and new wait re-programmed.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在`timeout2 < timeout1`的情况，这意味着必须重新评估超时请求的顺序，并重新编程新的等待。
- en: '![Image: Starting Asynchronous Wait](img/2f3e997cdf3fb5e2d15e799c32da9232.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Starting Asynchronous Wait](img/2f3e997cdf3fb5e2d15e799c32da9232.png)'
- en: The **Driver** must be able to cancel the existing timer countdown, evaluate
    how much time has passed since the first request, evaluate the new values to reprogram
    the timer **Device** countdown again.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**必须能够取消现有的计时器倒计时，评估自第一次请求以来经过的时间，评估新的值以重新编程计时器**设备**倒计时。'
- en: Completing Asynchronous Wait
  id: totrans-567
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成异步等待
- en: '![Image: Completing Asynchronous Wait](img/4b0b39503611d334698c8651189078e3.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Completing Asynchronous Wait](img/4b0b39503611d334698c8651189078e3.png)'
- en: Due to the fact that **Driver** may receive multiple independent wait requests,
    it must reprogram the next wait (if such exists) while running in interrupt mode.
    Please pay attention to `InterruptCtx()` tag parameter passed to the `startWait()`
    member function of the **Device**. It indicates that the request is executed in
    interrupt context, while the same request used `EventLoopCtx()` as the tag parameter
    to specify that the call was performed in event loop (non-interrupt) context.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**驱动程序**可能接收到多个独立的等待请求，它必须在中断模式下运行时重新编程下一个等待（如果存在）。请注意传递给**设备**的`startWait()`成员函数的`InterruptCtx()`标签参数。它表示请求是在中断上下文中执行的，而相同的请求使用`EventLoopCtx()`作为标签参数来指定调用是在事件循环（非中断）上下文中执行的。
- en: Canceling Asynchronous Wait
  id: totrans-570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消异步等待
- en: If there is a request to cancel the currently executed wait, the **Driver**
    must receive the information about the elapsed time and reprogram the next wait
    if such exists.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有请求取消当前正在执行的等待，**驱动程序**必须接收到关于已过时间的通知，并在存在的情况下重新编程下一个等待。
- en: '![Image: Canceling Asynchronous Operation](img/d422cfa87fbdddd84638c0791d06f5e3.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Canceling Asynchronous Operation](img/d422cfa87fbdddd84638c0791d06f5e3.png)'
- en: If the cancellation request to some other wait, that hasn’t been forwarded to
    the **Device**, the **Driver** just needs to update its internal data structures
    without canceling currently performed timer countdown.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果取消请求是针对某些尚未转发到**设备**的其他等待，**驱动程序**只需更新其内部数据结构，而无需取消当前正在执行的计时器倒计时。
- en: '![Image: Canceling Asynchronous Operation](img/321c0ca2833bfecef585015ffb75db37.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Canceling Asynchronous Operation](img/321c0ca2833bfecef585015ffb75db37.png)'
- en: The unsuccessful attempts to cancel wait is performed in exactly the same way
    as described in [Device-Driver-Component](#basic_concepts-device_driver_component)
    chapter.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 取消等待的不成功尝试与[设备-驱动-组件](#basic_concepts-device_driver_component)章节中描述的方式完全相同。
- en: '![Image: Canceling Asynchronous Operation](img/dde3390665241981d9a217e94adbd00b.png)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Canceling Asynchronous Operation](img/dde3390665241981d9a217e94adbd00b.png)'
- en: Identifying Wait Requests
  id: totrans-577
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别等待请求
- en: 'There is obviously a need to have some kind of identification of the wait requests
    in order to be able to cancel some specific request while keeping the rest in
    waiting queue. One approach would be to have some kind of a handle which can be
    used during the cancellation request:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，需要有一种方式来识别等待请求，以便能够在保持其余请求在等待队列中的同时取消某些特定请求。一种方法是在取消请求期间使用某种类型的句柄：
- en: '[PRE147]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Another one is to hide the handle in some wrapper class, which makes it a bit
    safer to use:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将句柄隐藏在某个包装类中，这使得使用它更加安全：
- en: '[PRE148]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The **Driver** itself has only one public function `allocTimer()`. It is used
    to allocate the `Timer` object. All the wait and/or cancel requests are issued
    to this timer object directly, which is declared to be a `friend` of the **Driver**
    class, i.e. it is able to call private functions of the latter using the handle
    it has. The destructor of the `Timer` makes sure that the handle is properly invalidated.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driver**本身只有一个公共函数`allocTimer()`。它用于分配`Timer`对象。所有等待和/或取消请求都直接向这个定时器对象发出，该对象被声明为**Driver**类的`friend`，即它能够使用其句柄调用后者的私有函数。`Timer`的析构函数确保句柄被正确地无效化。'
- en: '[PRE149]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The second approach is a bit safer than the first one and it is used in the
    implementation of such generic "Timer Management Driver" in [embxx](https://github.com/arobenko/embxx)
    library.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法比第一种方法更安全，并且在[embxx](https://github.com/arobenko/embxx)库中实现了此类通用“定时器管理Driver”。
- en: Specifying the Wait Duration
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指定等待时长
- en: The timer **Device** is platform specific. Some platforms may support wait duration
    granularity of a microsecond, others can achieve only a millisecond. It usually
    depends on the system clock speed. However, when using generic **Driver** and/or
    **Component** there is a need to be able to write platform independent code that
    performs wait of the specified duration regardless of the **Device** in use. The
    **S**tandard **T**emplate **L**ibrary (**STL**) of C++11 standard provides convenient
    [Date and Time Utilities](http://en.cppreference.com/w/cpp/chrono) that make such
    usage possible.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器**Device**是平台特定的。某些平台可能支持微秒级的等待时长粒度，而其他平台只能达到毫秒级。这通常取决于系统时钟速度。然而，当使用通用**Driver**和/或**Component**时，需要能够编写与平台无关的代码，该代码能够执行指定时长等待，而不管使用的**Device**是什么。C++11标准的**标准模板库（STL**）提供了方便的[日期和时间实用工具](http://en.cppreference.com/w/cpp/chrono)，使得这种使用成为可能。
- en: In case the **Device** declares a minimal wait duration unit using [std::chrono::duration](http://en.cppreference.com/w/cpp/chrono/duration)
    type, the **Driver** may use [std::chrono::duration_cast](http://en.cppreference.com/w/cpp/chrono/duration/duration_cast)
    to convert the requested wait duration to supported duration units.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**Device**使用[std::chrono::duration](http://en.cppreference.com/w/cpp/chrono/duration)类型声明最小等待时长单位，**Driver**可以使用[std::chrono::duration_cast](http://en.cppreference.com/w/cpp/chrono/duration/duration_cast)将请求的等待时长转换为支持的时长单位。
- en: '[PRE150]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: In the example above the minimal supported duration unit (`WaitTimeUnitDuration`)
    is declared to be 1 millisecond. Please note that `startWait()` member function
    expects to receive number of wait units, i.e. milliseconds as its first parameter.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，最小支持的时长单位（`WaitTimeUnitDuration`）被声明为1毫秒。请注意，`startWait()`成员函数期望接收等待单元的数量，即毫秒作为其第一个参数。
- en: 'Then the definition of the `asyncWait()` member function of the **Driver**
    may be defined like this:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以像这样定义**Driver**类的`asyncWait()`成员函数：
- en: '[PRE151]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: In the example above the call below will perform correct adjustment of the duration
    and will measure the same timeout with any **Device** whether the latter expects
    milliseconds or microseconds in its `startWait()` member function.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，下面的调用将正确调整时长，并使用任何**Device**测量相同的超时时间，无论后者在其`startWait()`成员函数中期望的是毫秒还是微秒。
- en: '[PRE152]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In case the developer tries to execute a wait of several microseconds when **Driver**
    supports only milliseconds granularity, the compilation will fail.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者在**Driver**只支持毫秒级粒度的情况下尝试执行几个微秒的等待，编译将失败。
- en: '[PRE153]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Driver Implementation
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Driver实现
- en: The timer management **Driver** is a generic layer. It must work on any platform
    with any timer **Device** object that exposes the right interface.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器管理**Driver**是一个通用层。它必须在任何平台上与任何暴露正确接口的定时器**Device**对象一起工作。
- en: Such **Driver** is already implemented in [embxx](https://github.com/arobenko/embxx)
    library as `embxx::driver::TimerMgr` and resides in [embxx/driver/TimerMgr.h](https://github.com/arobenko/embxx/blob/master/embxx/driver/TimerMgr.h)
    while platform specific (Raspberry Pi) peripheral control object is implemented
    in [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project as `device::Timer`
    and resides in [src/device/Timer.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Timer.h).
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 **驱动程序** 已经在 [embxx](https://github.com/arobenko/embxx) 库中作为 `embxx::driver::TimerMgr`
    实现，位于 [embxx/driver/TimerMgr.h](https://github.com/arobenko/embxx/blob/master/embxx/driver/TimerMgr.h)，而平台特定（树莓派）外设控制对象在
    [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) 项目中作为 `device::Timer`
    实现，位于 [src/device/Timer.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Timer.h)。
- en: 'The `embxx::driver::TimerMgr` is defined like this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`embxx::driver::TimerMgr` 的定义如下：'
- en: '[PRE154]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `TDevice` template parameter is Platform specific control class for timer
    peripheral.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`TDevice` 模板参数是定时器外设的平台特定控制类。'
- en: The `TEventLoop` template parameter is the class of the [Event Loop](#basic_concepts-event_loop).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEventLoop` 模板参数是 [事件循环](#basic_concepts-event_loop) 的类。'
- en: The `TMaxTimers` template parameters specifies the maximal number of timer objects
    the `TimerMgr` will be able to allocate. This parameter is required because `embxx::driver::TimerMgr`
    was designed to be used in the systems without dynamic memory allocation. If dynamic
    memory allocation is allowed, then it is quite easy to implement similar functionality
    without this limitation.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`TMaxTimers` 模板参数指定了 `TimerMgr` 将能分配的最大定时器对象数量。此参数是必需的，因为 `embxx::driver::TimerMgr`
    是设计用于没有动态内存分配的系统。如果允许动态内存分配，那么在不限定的条件下实现类似功能就相当容易了。'
- en: The `TTimeoutHandler` template parameter specifies type of the timeout callback
    object. This object must have `void (const embxx::error::ErrorStatus&)` signature
    and expose similar interface to [std::function](http://en.cppreference.com/w/cpp/utility/functional/function)
    or `embxx::util::StaticFunction`.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`TTimeoutHandler` 模板参数指定了超时回调对象的类型。此对象必须具有 `void (const embxx::error::ErrorStatus&)`
    签名，并暴露类似于 [std::function](http://en.cppreference.com/w/cpp/utility/functional/function)
    或 `embxx::util::StaticFunction` 的接口。'
- en: 'The `embxx::driver::TimerMgr` exposes the following public interface:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`embxx::driver::TimerMgr` 提供以下公共接口：'
- en: '[PRE155]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The reader may notice that `embxx::driver::TimerMgr` exposes only one public
    function: `Timer allocTimer();`. This function returns simple `TimerMgr::Timer`
    object which can be used to schedule new wait as well as cancel the previous wait
    request. Also note that `TimerMgr::Timer` class is declared to be a `friend` of
    `TimerMgr`. This is required to allow seamless delegation of the wait/cancel request
    from `TimerMgr::Timer` to `TimerMgr` which is responsible for managing multiple
    simultaneous wait requests and delegating them one by one to the the actual hardware
    control object.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会注意到 `embxx::driver::TimerMgr` 仅公开了一个函数：`Timer allocTimer();`。此函数返回一个简单的
    `TimerMgr::Timer` 对象，可用于安排新的等待以及取消之前的等待请求。此外，请注意 `TimerMgr::Timer` 类被声明为 `TimerMgr`
    的 `friend`。这是为了允许从 `TimerMgr::Timer` 无缝地将等待/取消请求委托给 `TimerMgr`，后者负责管理多个同时进行的等待请求并将它们逐个委托给实际的硬件控制对象。
- en: 'Then the led flashing application (implemented in [src/app/app_led_flash](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_led_flash))
    can be as simple as the code below:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，LED闪烁应用程序（在 [src/app/app_led_flash](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_led_flash)
    中实现）可以像下面的代码一样简单：
- en: '[PRE156]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Platform Specific Timer Device
  id: totrans-610
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平台特定定时器设备
- en: 'As it was already mentioned earlier, the `embxx::driver::TimerMgr` is a generic
    **Driver** class that does most of the work of managing and scheduling independent
    wait requests. It requires support from low level timer **Device** object to program
    the actual hardware of the platform the code runs on. The `embxx::driver::TimerMgr`
    is defined to receive the **Device** class as template parameter as well as reference
    to the **Device** timer object in the constructor. The **Driver** doesn’t know
    the exact **Device** type, but expects it to expose certain public interface:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`embxx::driver::TimerMgr` 是一个通用的 **驱动程序** 类，它执行了管理调度独立等待请求的大部分工作。它需要来自底层定时器
    **设备** 对象的支持来编程代码运行的平台上的实际硬件。`embxx::driver::TimerMgr` 定义为接收 **设备** 类作为模板参数，以及在构造函数中接收对
    **设备** 定时器对象的引用。**驱动程序** 不了解确切的 **设备** 类型，但期望它暴露某些公共接口：
- en: '[PRE157]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The timer control **Device** class must expose the following public interface:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器控制 **设备** 类必须公开以下公共接口：
- en: Define `WaitTimeUnitDuration` type as variation of [std::chrono::duration](https://en.cppreference.com/w/cpp/chrono/duration)
    that specifies duration of single wait unit supported by the **Device**.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WaitTimeUnitDuration`类型定义为[std::chrono::duration](https://en.cppreference.com/w/cpp/chrono/duration)的变体，该类型指定了**设备**支持的单一等待单元的持续时间。
- en: '[PRE158]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Function to set the callback object to be invoked from timer interrupt:'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置从定时器中断调用的回调对象的函数：
- en: '[PRE159]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Functions to start timer countdown in both event loop (non-interrupt) and interrupt
    contexts:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件循环（非中断）和中断上下文中启动定时器倒计时的函数：
- en: '[PRE160]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Function to cancel timer countdown in event loop (non-interrupt) context. The
    function must return true in case the wait was actually canceled and false when
    there is no wait in progress.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件循环（非中断）上下文中取消定时器倒计时的函数。如果等待实际上被取消，则该函数必须返回true，如果没有等待正在进行，则返回false。
- en: '[PRE161]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Function to suspend countdown (disable interrupts while the actual wait countdown
    is not stopped) in event loop (non-interrupt) context. The function must return
    true in case the wait was actually suspended and false when there is no wait in
    progress. The call to this function will be followed either by `resumeWait()`
    or by `cancelWait()`.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件循环（非中断）上下文中挂起倒计时（在实际的等待倒计时未停止时禁用中断）的函数。如果等待实际上被挂起，则该函数必须返回true，如果没有等待正在进行，则返回false。对该函数的调用将跟随`resumeWait()`或`cancelWait()`。
- en: '[PRE162]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Function to resume countdown in event loop (non-interrupt) context.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件循环（非中断）上下文中恢复倒计时的函数。
- en: '[PRE163]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Function to retrieve elapsed time of the last executed wait. It will be called
    right after the `cancelWait()`.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取最后一次执行等待的已过时间的函数。它将在`cancelWait()`之后立即被调用。
- en: '[PRE164]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The definition and implementation of such timer device for Raspberry Pi platform
    can be found in [src/device/Timer.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Timer.h)
    file of [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Raspberry Pi平台，此类定时器的定义和实现可以在[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目的[src/device/Timer.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Timer.h)文件中找到。
- en: UART
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UART
- en: Our next stage will be to support debug logging via UART interface. In conventional
    C++ logging is performed using either [printf](http://en.cppreference.com/w/cpp/io/c/fprintf)
    function or [output streams](http://en.cppreference.com/w/cpp/io/basic_ostream)
    (such as [std::cout](http://en.cppreference.com/w/cpp/io/cout) or [std::cerr](http://en.cppreference.com/w/cpp/io/cerr)).
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下个阶段将是通过UART接口支持调试日志记录。在传统的C++中，日志记录是通过使用[printf](http://en.cppreference.com/w/cpp/io/c/fprintf)函数或[输出流](http://en.cppreference.com/w/cpp/io/basic_ostream)（例如[std::cout](http://en.cppreference.com/w/cpp/io/cout)或[std::cerr](http://en.cppreference.com/w/cpp/io/cerr)）来执行的。
- en: 'If `printf` is used the compilation may fail at the linking stage with following
    errors:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`printf`，则编译可能在链接阶段失败，并出现以下错误：
- en: '[PRE165]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Once these functions are stubbed with empty bodies, the compilation will succeed,
    but the image size will be quite big (around 45KB).
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些函数用空体填充，编译将成功，但映像大小将相当大（约45KB）。
- en: The `_sbrk` function is required to support dynamic memory allocation. The `printf`
    function probably uses `malloc()` to allocate some temporary buffers. If we open
    the assembly listing file we will see calls to `<malloc>` and `<free>`.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`_sbrk`函数是支持动态内存分配所必需的。`printf`函数可能使用`malloc()`来分配一些临时缓冲区。如果我们打开汇编列表文件，我们将看到对`<malloc>`和`<free>`的调用。'
- en: 'The `_write` function is used to write characters into the standard output
    consol, which doesn’t exist in embedded product. The developer must use this function
    implementation to write all the provided characters to UART serial interface.
    Many developers implement this function in a straightforward synchronous way with
    busy loop:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '`_write`函数用于将字符写入标准输出控制台，这在嵌入式产品中不存在。开发者必须使用此函数实现将所有提供的字符写入UART串行接口。许多开发者以直接同步的方式实现此函数，使用忙等待循环：'
- en: '[PRE166]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: In this case the call to `printf` function will be blocking and won’t return
    until all the characters are written one by one to UART, which takes a lot of
    execution time. This approach is suitable for quick and dirty debugging, but will
    quickly become impractical when the project grows.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对`printf`函数的调用将是阻塞的，并且不会返回，直到所有字符逐个写入UART，这需要大量的执行时间。这种方法适用于快速且简单的调试，但当项目增长时将很快变得不切实际。
- en: In order to make the execution of `printf` quick, there must be some kind of
    interrupt driven component that is responsible to buffer all the provided characters
    and forward it to UART asynchronously one by one using "**TX buffer register is
    free**" kind of interrupts.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `printf` 的执行快速，必须有一种中断驱动的组件，负责缓冲所有提供的字符，并使用“**TX缓冲寄存器空闲**”这类中断异步逐个将它们转发到UART。
- en: 'One of disadvantages in using `printf` for logging is a necessity to specify
    an output format of the printed variables:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `printf` 进行日志记录的一个缺点是需要指定打印变量的输出格式：
- en: '[PRE167]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'In case the type of the printed variable changes, the developer must remember
    to update type in the format string too. This is the reason why many C++ developers
    prefer using streams instead of `printf`:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打印变量的类型发生变化，开发者必须记得更新格式字符串中的类型。这也是为什么许多C++开发者更喜欢使用流而不是 `printf` 的原因：
- en: '[PRE168]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Even if type of printed variable changes the compiler will generate a call to
    appropriate overloaded `operator<<` of [std::ostream](http://en.cppreference.com/w/cpp/io/basic_ostream)
    and the value will be printed correctly. The developer will also have to implement
    the missing `_write` function to write provided characters somewhere (UART interface
    in our case).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 即使打印变量的类型发生变化，编译器也会生成对适当的重载 `operator<<` 的调用，值将被正确打印。开发者还必须实现缺失的 `_write` 函数，以便将提供的字符写入某个地方（在我们的例子中是UART接口）。
- en: However using C++ streams in bare metal development is often not an option.
    They use exceptions to handle error cases as well as [locales](http://en.cppreference.com/w/cpp/locale/locale)
    for formatting. The compilation of simple output statement with streams above
    created image of more than 500KB using [GNU Tools for ARM Embedded Processors](https://launchpad.net/gcc-arm-embedded)
    compiler.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在裸机开发中使用C++流通常不是一个选择。它们使用异常来处理错误情况，以及[区域设置](http://en.cppreference.com/w/cpp/locale/locale)来进行格式化。使用
    [GNU Tools for ARM Embedded Processors](https://launchpad.net/gcc-arm-embedded)
    编译器编译简单的输出语句，生成的映像大小超过500KB。
- en: To summarise all the stated above, there may be a problem to use standard [printf](http://en.cppreference.com/w/cpp/io/c/fprintf)
    function or [output streams](http://en.cppreference.com/w/cpp/io/basic_ostream)
    for debug logging, especially in systems with small memory and where dynamic memory
    allocations and exceptions mustn’t be used. Our ultimate goal will be creation
    of standard output stream like interface for debug logging while using asynchronous
    event handling with [Device-Driver-Component](#basic_concepts-device_driver_component)
    model and [Event Loop](#basic_concepts-event_loop) where most of the code is generic
    and only smal part of managing write of a single character to the UART interface
    is platform specific.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 总结上述所有内容，使用标准的 [printf](http://en.cppreference.com/w/cpp/io/c/fprintf) 函数或 [输出流](http://en.cppreference.com/w/cpp/io/basic_ostream)
    进行调试日志记录可能存在问题，尤其是在内存较小且不允许使用动态内存分配和异常的系统。我们的最终目标将是创建一个标准输出流接口，用于调试日志记录，同时使用 [Device-Driver-Component](#basic_concepts-device_driver_component)
    模型和 [事件循环](#basic_concepts-event_loop)，其中大部分代码是通用的，只有一小部分是针对管理写入UART接口的单个字符的平台特定部分。
- en: Asyncrhonous read and write operations on the UART interface are very similar
    to the generic way of programming and handling asynchronous events described earlier
    in [Device-Driver-Component](#basic_concepts-device_driver_component) chapter.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在UART接口上的异步读写操作与前面在[设备驱动组件](#basic_concepts-device_driver_component)章节中描述的通用编程和处理异步事件的方式非常相似。
- en: Writing to UART
  id: totrans-647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向UART写入
- en: '**Stage1** - Sending asynchronous buffer write request from the **Component**
    layer to **Driver** in event loop (non-interrupt) context.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段1** - 在事件循环（非中断）上下文中，从**组件**层向**驱动程序**发送异步缓冲写入请求。'
- en: '![Image: Asyncrhonous write request](img/1f23d34c2bb100dda32ca47d2e438b85.png)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![图片：异步写入请求](img/1f23d34c2bb100dda32ca47d2e438b85.png)'
- en: 'The **Component** calls `asyncWrite()` member function of the **Driver** and
    provides pointer to the buffer, size of the buffer and the callback object to
    invoke when the write is complete. The `asyncWrite()` function needs to be able
    to receive any type of callable object, such as [std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)
    expression or [lambda function](http://en.cppreference.com/w/cpp/language/lambda).
    To achieve this the function must be templated:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**调用**驱动器**的`asyncWrite()`成员函数，并提供缓冲区的指针、缓冲区的大小以及写入完成后要调用的回调对象。`asyncWrite()`函数需要能够接收任何类型的可调用对象，例如[std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)表达式或[lambda函数](http://en.cppreference.com/w/cpp/language/lambda)。为了实现这一点，函数必须是模板化的：'
- en: '[PRE169]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: According to the convention mentioned [earlier](#basic_concepts-device_driver_component),
    the callback must receive an error status of whether the operation is successful
    as its first parameter. When performing asynchronous operation on the buffer,
    it can be required to know how many characters have been read / written before
    the error occurred, in case the operation wasn’t successful. For this purpose
    such callback object must receive number of bytes written as the second parameter,
    i.e. expose the `void (const embxx::error::ErrorStatus& err, std::size_t bytesTransferred)`
    signature.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前提到的约定[基本概念-设备驱动组件](#basic_concepts-device_driver_component)，回调必须接收操作是否成功的错误状态作为其第一个参数。在缓冲区上执行异步操作时，可能需要知道在错误发生之前已读取/写入了多少字符，以防操作未成功。为此，此类回调对象必须接收已写入的字节数作为第二个参数，即暴露`void
    (const embxx::error::ErrorStatus& err, std::size_t bytesTransferred)`签名。
- en: When the **Driver** receives the asynchronous operation request, it forwards
    it to the **Device**, letting the latter know how many bytes will be written during
    the whole process. Please note that **Driver** uses `embxx::device::context::EventLoop`
    tag parameter to specify that `startWrite()` member function of **Device** is
    invoked in event loop (non-interrut) context. The job of the **Device** object
    is to enable appropriate interrupts and return immediately. Once the interrupt
    occurs, the stage of writing the data begins.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 当**驱动器**收到异步操作请求时，它将请求转发给**设备**，让后者知道在整个过程中将写入多少字节。请注意，**驱动器**使用`embxx::device::context::EventLoop`标签参数来指定**设备**的`startWrite()`成员函数在事件循环（非中断）上下文中被调用。**设备**对象的任务是启用适当的中断并立即返回。一旦发生中断，数据写入的阶段就开始了。
- en: '**Stage2** - Writing provided data.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段2** - 写入提供的数据。'
- en: '![Image: Writing provided data](img/2d9122657b5e657b158f66bbe60f14b5.png)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
  zh: '![图片：提供的数据写作](img/2d9122657b5e657b158f66bbe60f14b5.png)'
- en: Once the interrupt of "TX available" occurs, the **Device** must let the **Driver**
    know. There must obviously be some kind of callback involved, which **Driver**
    must provide during its construction / initialisation stage. Let’s assume at this
    moment that such assignment was successfully done, and **Device** is capable of
    successfully notifying the **Driver**, that there is an ability to write character
    to TX FIFO of the peripheral.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生“TX可用”中断，**设备**必须让**驱动器**知道。显然，必须涉及某种回调，**驱动器**必须在构建/初始化阶段提供该回调。让我们假设此时这种分配已成功完成，并且**设备**能够成功通知**驱动器**，可以写入外围的TX
    FIFO字符。
- en: 'When the **Driver** receives such notification, it attempts to write as many
    characters as possible:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 当**驱动器**收到此类通知时，它尝试写入尽可能多的字符：
- en: '[PRE170]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This is because when "TX available" interrupt occurs, there may be a place for
    multiple characters to be sent, not just one. Doing checks and writes in a loop
    may save many CPU cycles.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当“TX可用”中断发生时，可能有多个字符可以发送，而不仅仅是单个字符。在循环中进行检查和写入可以节省许多CPU周期。
- en: Please note, that all these calls are performed in interrupt context. They are
    marked in red in the picture above.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些调用都是在中断上下文中执行的。它们在上面的图片中被标记为红色。
- en: Once the Tx FIFO of the underlying **Device** is full or there are no more characters
    to write, the callback returns. The whole cycle described above is repeated on
    every "TX available" interrupt until the whole provided buffer is sent to the
    **Device** for writing.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦底层**设备**的Tx FIFO已满或没有更多字符可以写入，回调返回。上述整个周期将在每个“TX可用”中断上重复，直到整个提供的缓冲区被发送到**设备**进行写入。
- en: '**Stage3** - Notifying caller about completion:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段3** - 通知调用者完成情况：'
- en: Once the whole buffer is sent to the **Device** for writing, the **Driver**
    is aware that there will be no more writes performed. However it doesn’t report
    completion until the **Device** itself calls appropriate callback indicating that
    the operation has been indeed completed. Shifting the responsibility of identifying
    when the operation is complete to **Device** will be needed later when we will
    want to reuse the same **Driver** for [I2C](#peripherals-i2c) and [SPI](#peripherals-spi)
    peripherals. It will be important to know when internal Tx FIFO of the peripheral
    becomes empty after all the characters from previous operation have been written.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦整个缓冲区被发送到 **设备** 进行写入，**驱动程序** 意识到将不再执行更多写入操作。然而，它不会报告完成，直到 **设备** 本身调用适当的回调指示操作确实已完成。将识别操作何时完成的职责转移到
    **设备** 将在稍后需要时需要，那时我们希望重用相同的 **驱动程序** 用于 [I2C](#peripherals-i2c) 和 [SPI](#peripherals-spi)
    外设。在所有先前操作中的字符都已写入后，了解外设内部 Tx FIFO 是否为空将非常重要。
- en: '![Image: Notifying caller about completion](img/8e530f50bca824ce889ecad3c8fbb1dd.png)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
  zh: '![图片：通知调用者完成](img/8e530f50bca824ce889ecad3c8fbb1dd.png)'
- en: Once the **Driver** receives notification from the **Device** (still in interrupt
    context), that the write operation is complete, it bundles the callback object,
    provided with initial `asyncWrite()` request, together with error status and number
    of actual bytes transferred using [std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)
    expression and sends the callable object to [Event Loop](#basic_concepts-event_loop)
    for execution in event loop (non-interrupt) context.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 **驱动程序** 从 **设备**（仍在中断上下文中）收到通知，表示写入操作已完成，它将使用 [std::bind](http://en.cppreference.com/w/cpp/utility/functional/bind)
    表达式将提供的回调对象与错误状态和实际传输的字节数捆绑在一起，并将可调用对象发送到 [事件循环](#basic_concepts-event_loop) 以在事件循环（非中断）上下文中执行。
- en: Reading from UART
  id: totrans-666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 UART 读取
- en: The reading from UART is done in a very similar manner.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 从 UART 的读取操作以非常相似的方式进行。
- en: '**Stage1** - Sending asynchronous buffer read request from the **Component**
    layer to **Driver** in event loop (non-interrupt) context.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段1** - 从 **组件** 层向事件循环（非中断）上下文中的 **驱动程序** 发送异步缓冲区读取请求。'
- en: '![Image: Asynchronous read request](img/608ac57466ab250b39f488a4b120a8a6.png)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
  zh: '![图片：异步读取请求](img/608ac57466ab250b39f488a4b120a8a6.png)'
- en: The `asyncRead()` member function of the **Driver** should allow callback to
    be callable object of any type (but one that exposes predefined signature of course).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序** 的 `asyncRead()` 成员函数应允许回调为任何类型的可调用对象（但当然必须暴露预定义的签名）。'
- en: '[PRE171]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '**Stage2** - Reading data into the buffer.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段2** - 将数据读取到缓冲区中。'
- en: '![Image: Writing provided data](img/9762f32a9d0fdf0f3d5f112c1181d5c4.png)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![图片：写入提供的数据](img/9762f32a9d0fdf0f3d5f112c1181d5c4.png)'
- en: 'The callback’s implementation will be something like:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的实现可能如下：
- en: '[PRE172]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '**Stage3** - Notifying caller about completion:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**阶段3** - 通知调用者完成：'
- en: '![Image: Notifying caller about completion](img/33a83c0be75b520214c954774d258999.png)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
  zh: '![图片：通知调用者完成](img/33a83c0be75b520214c954774d258999.png)'
- en: Cancelling Asynchronous Operations
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: 'The cancellation flow is very similar to the one described in [Device-Driver-Component](#basic_concepts-device_driver_component)
    chapter:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 取消流程与 [Device-Driver-Component](#basic_concepts-device_driver_component) 章节中描述的非常相似：
- en: '![Image: Cancel read](img/2e0270bc64ba753a54379ca1985870d1.png)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![图片：取消读取](img/2e0270bc64ba753a54379ca1985870d1.png)'
- en: If the cancellation is successful, the callback must be invoked with error code
    indicating that the operation was aborted (`embxx::error::ErrorCode::Aborted`).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果取消操作成功，回调必须使用指示操作已中止的错误代码调用（`embxx::error::ErrorCode::Aborted`）。
- en: One possible case of unsuccessful cancellation is when callback was posted for
    execution in event loop, but hasn’t been executed yet when cancellation is attempted.
    In this case **Driver** is aware that there is no pending asynchronous operation
    and can return `false` immediately.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 取消操作不成功的一个可能情况是，当回调被发布到事件循环以执行时，但在尝试取消时尚未执行。在这种情况下，**驱动程序** 意识到没有挂起的异步操作，可以立即返回
    `false`。
- en: '![Image: Cancel read](img/445034b4edb611b0168373383791eee9.png)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![图片：取消读取](img/445034b4edb611b0168373383791eee9.png)'
- en: 'Another possible case of unsuccessful cancellation is when completion interrupt
    occurs in the middle of cancellation request:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种取消操作不成功的可能情况是在取消请求过程中发生完成中断：
- en: '![Image: Cancel read](img/e0da1847dc7bfd273cd06b82865c02db.png)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![图片：取消读取](img/e0da1847dc7bfd273cd06b82865c02db.png)'
- en: Reading "Until"
  id: totrans-686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取 "Until"
- en: 'There may be a case, when partial read needs to be performed, for example until
    specific character is encountered. In this case the **Driver** is responsible
    to monitor incoming characters and cancel the read into the buffer operation before
    its completion:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在需要执行部分读取的情况，例如直到遇到特定字符。在这种情况下，**Driver** 负责监控传入的字符，并在缓冲区读取完成之前取消读取操作：
- en: '![Image: Notifying caller about completion](img/0a896be41f04e713ace306cf9f7f3273.png)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Notifying caller about completion](img/0a896be41f04e713ace306cf9f7f3273.png)'
- en: 'Note, that previously **Driver** called `cancelRead()` member function of the
    **Device** in event loop (non-interrupt) context, while in "read until" situation
    the cancellation happens in interrupt mode. That requires **Device** to implement
    these functions for both modes:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前 **Driver** 在事件循环（非中断）上下文中调用 **Device** 的 `cancelRead()` 成员函数，而在“读取直到”情况下，取消操作发生在中断模式下。这要求
    **Device** 为两种模式都实现这些函数：
- en: '[PRE173]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The `asyncReadUntil()` member function of the **Driver** should be able to receive
    any stateless predicate object that defines `bool operator()(CharType ch) const`.
    The predicate invocation should return `true` when expected character is received
    and reading operation must be stopped.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driver** 类的 `asyncReadUntil()` 成员函数应该能够接收任何定义了 `bool operator()(CharType
    ch) const` 的无状态谓词对象。当接收到期望的字符时，谓词调用应返回 `true`，并且读取操作必须停止。'
- en: '[PRE174]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'It allows using complex conditions in evaluating the character. For example,
    stopping when either `''\r''` or `''\n''` is encountered:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在评估字符时使用复杂条件。例如，当遇到 `'\r'` 或 `'\n'` 时停止：
- en: '[PRE175]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Device Implementation
  id: totrans-695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Device 实现部分
- en: 'In this section I will try to describe in more details what **Device** class
    needs to provide for the **Driver** to work correctly. First of all it needs to
    define the type of characters used:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将尝试更详细地描述 **Device** 类需要为 **Driver** 正确工作提供什么。首先，它需要定义使用的字符类型：
- en: '[PRE176]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The **Driver** layer will reuse the definition of the character in its internal
    functions:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driver** 层将在其内部函数中重用字符的定义：'
- en: '[PRE177]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: There is a need for **Device** to be able to record callback objects from the
    **Driver** in order to notify the latter about an ability to read/write next character
    and about operation completion.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 需要能够从 **Driver** 记录回调对象，以便通知后者关于读取/写入下一个字符的能力以及操作完成的情况。
- en: '[PRE178]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The `OpAvailableHandler` and `OpCompleteHandler` type may be either hard coded
    to be `std::function<void ()>` and `std::function<void (const embxx::error::ErrorStatus&)>`
    respectively or passed as template parameters:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpAvailableHandler` 和 `OpCompleteHandler` 类型可以是硬编码为 `std::function<void ()>`
    和 `std::function<void (const embxx::error::ErrorStatus&)>`，或者作为模板参数传递：'
- en: '[PRE179]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Choosing the "template parameters option" is useful when the same **Device**
    class is reused between multiple applications for the same product line.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“模板参数选项”在多个应用程序之间重用相同的 **Device** 类时很有用，这些应用程序属于同一产品线。
- en: 'The next stage would be implementing all the required functions:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是实现所有必需的函数：
- en: '[PRE180]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Note, that there may be extra configuration functions specific for the peripheral
    being controlled. For example baud rate, parity, flow control for UART. Such configuration
    is almost always platform and/or product specific and usually performed at application
    startup. It is irrelevant to the [Device-Driver-Component](#basic_concepts-device_driver_component)
    model introduced in this book.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能存在针对被控制的外设的特定配置函数。例如，UART 的波特率、奇偶校验、流控制。这种配置几乎总是平台和/或产品特定的，通常在应用程序启动时执行。这与本书中引入的
    [Device-Driver-Component](#basic_concepts-device_driver_component) 模型无关。
- en: '[PRE181]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project has multiple
    applications that use UART1 interface for logging. The peripheral control code
    is the same for all of them and is implemented in [src/device/Uart1.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Uart1.h).
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) 项目有多个应用程序使用 UART1
    接口进行日志记录。所有这些应用程序的外设控制代码都是相同的，并在 [src/device/Uart1.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Uart1.h)
    中实现。'
- en: Driver Implementation
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Driver 实现部分
- en: '**Driver** must be a generic piece of code, that can be reused with any **Device**
    control object (as long as it exposed right public interface) and in any application,
    including ones without dynamic memory allocation.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**Driver** 必须是一段通用的代码，可以与任何 **Device** 控制对象（只要它公开了正确的公共接口）以及任何应用程序（包括没有动态内存分配的应用程序）重用。'
- en: 'First of all, we will need references to **Device** as well as [Event Loop](#basic_concepts-event_loop)
    objects:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要引用**设备**以及[事件循环](#basic_concepts-event_loop)对象：
- en: '[PRE182]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: We will also need to store callbacks provided with any asynchronous operation.
    Note that the "read" and "write" are independent operations and it should be possible
    to perform `asyncRead()` and `asyncWrite()` calls at the same time.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要存储与任何异步操作一起提供的回调。请注意，“读取”和“写入”是独立的操作，应该可以同时执行`asyncRead()`和`asyncWrite()`调用。
- en: 'The only way to make **Driver** generic is to move responsibility of specifying
    callback storage type up one level, i.e. we must put them as template parameters:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 使**驱动程序**通用的唯一方法是将指定回调存储类型的责任提升一级，即我们必须将它们作为模板参数：
- en: '[PRE183]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'As it was mentioned earlier in [Reading "Until"](#peripherals-uart-reading_until)
    section, there is quite often a need to stop reading characters into the provided
    buffer when some condition evaluates to true. It means there is also a need to
    provide storage for the character evaluation predicate:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[读取“直到”](#peripherals-uart-reading_until)部分，经常需要停止将字符读取到提供的缓冲区中，当某些条件评估为真时。这意味着还需要提供用于字符评估谓词的存储空间：
- en: '[PRE184]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The example code above may work, but it contradicts to one of the basic principles
    of C++: "You should pay only for what you use". In case of using UART for logging,
    there is no input from the peripheral and it is a waist to keep data members for
    "read" required to manage "read" operations. Let’s try to improve the situation
    a little bit by using template specialisation as well as reduce number of template
    parameters by using "Traits" aggregation struct.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例代码可能可行，但它违反了C++的一个基本原则：“你应该只为你所用的付费”。在用UART进行日志记录的情况下，外围设备没有输入，保留用于管理“读取”操作所需的“读取”数据成员是一种浪费。让我们通过使用模板特化和使用“特质”聚合结构来减少模板参数的数量，来尝试稍微改善一下这种情况。
- en: '[PRE185]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Please note, that allowed number of pending "read" requests is specified as
    0 in the traits struct above, i.e. the read operations are not allowed. The "read
    complete" and "read until predicate" types are irrelevant and specified as [std::nullptr_t](http://en.cppreference.com/w/cpp/types/nullptr_t).
    The instantiation of the **Driver** object must take it into account and not include
    any "read" related functionality. In order to achieve this the **Driver** class
    needs to have two independent sub-functionalities of "read" and "write". It may
    be achieved by inheriting from two base classes.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的特质结构中，允许挂起的“读取”请求数量被指定为0，即不允许读取操作。“读取完成”和“读取直到谓词”类型是不相关的，被指定为[std::nullptr_t](http://en.cppreference.com/w/cpp/types/nullptr_t)。**驱动程序**对象的实例化必须考虑到这一点，并且不包括任何与“读取”相关的功能。为了实现这一点，**驱动程序**类需要有两个独立的“读取”和“写入”子功能。这可以通过从两个基类继承来实现。
- en: '[PRE186]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Now, the template specialisation based on queue size should do the job:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于队列大小的模板特化应该可以完成这项工作：
- en: '[PRE187]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Note, that it is possible to implement general case when read/write queue size
    is greater than 1. It will require some kind of request queuing (using [Static
    (Fixed Size) Queue](#basic_needs-queue) for example) and will allow issuing multiple
    asynchronous read/write requests at the same time.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当读写队列大小大于1时，可以实现通用情况。这需要某种请求排队（例如使用[静态（固定大小）队列](#basic_needs-queue)），并允许同时发出多个异步读写请求。
- en: 'In order to support this extension, the **Device** class must implement some
    extra functionality too:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个扩展，**设备**类也必须实现一些额外的功能：
- en: The new read/write request can be issued by the **Driver** in interrupt context,
    after previous operation reported completion.
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的读写请求可以在中断上下文中由**驱动程序**发出，在先前的操作报告完成之后。
- en: '[PRE188]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'When new asynchronous read/write request is issued to the **Driver** it must
    be able to prevent interrupt context callbacks from being invoked to avoid races
    on the internal data structure:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当向**驱动程序**发出新的异步读写请求时，它必须能够防止中断上下文回调被调用，以避免在内部数据结构上发生竞争：
- en: '[PRE189]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Please pay attention to the boolean return value of `suspend*()` functions.
    They are like `cancel*()` ones, there is an indication whether the invocation
    of the callbacks is suspended or there is no operation currently in progress.
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意`suspend*()`函数的布尔返回值。它们类似于`cancel*()`函数，有一个指示是否暂停回调调用或当前没有正在进行的操作。
- en: Such generic **Driver** is already implemented in [embxx/driver/Character.h](https://github.com/arobenko/embxx/blob/master/embxx/driver/Character.h)
    file of [embxx](https://github.com/arobenko/embxx) library. The **Driver** is
    called "Character", because it reads/writes the provided buffer one character
    at a time.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的通用**驱动程序**已经在[embxx/driver/Character.h](https://github.com/arobenko/embxx/blob/master/embxx/driver/Character.h)文件中的[embxx](https://github.com/arobenko/embxx)库中实现。该**驱动程序**被称为“Character”，因为它一次读取/写入提供的缓冲区中的一个字符。
- en: Character Echo Application
  id: totrans-733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符回显应用程序
- en: Now, it is time to do something practical. The [app_uart1_echo](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_echo)
    application in [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project
    implements simple single character echo.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候做一些实际的事情了。[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目中的[app_uart1_echo](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_echo)应用程序实现了简单的单个字符回显。
- en: 'The `System` class in [System.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/app/app_uart1_echo/System.h)
    file defines the **Device** and **Driver** layers:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在[app_uart1_echo](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_echo)应用程序中，[System.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/app/app_uart1_echo/System.h)文件定义了**设备**和**驱动程序**层：
- en: '[PRE190]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Note that `UartSocket` uses default "TTraits" template parameter of `embxx::driver::Character`,
    which is defined to be:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`UartSocket`使用`embxx::driver::Character`的默认“TTraits”模板参数，该参数被定义为：
- en: '[PRE191]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'It allows usage of both "read" and "write" operations at the same time. Having
    the definitions in place it is quite easy to implement the "echo" functionality:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许同时使用“读取”和“写入”操作。有了这些定义，实现“回显”功能相当简单：
- en: '[PRE192]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Stream-like Printing Interface
  id: totrans-741
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 流式打印接口
- en: As was mentioned earlier, our ultimate goal would be having standard output
    stream like interface for debug output, which works asynchronously without any
    blocking busy waits. Such interface must be a generic **Component**, which works
    in non-interrupt context, while using recently covered generic "Character" **Driver**
    in conjunction with platform specific "Uart" **Device**.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的最终目标是有标准输出流接口，用于调试输出，该接口异步工作，没有任何阻塞的忙等待。这样的接口必须是一个通用的**组件**，在非中断上下文中工作，同时使用最近介绍的通用“字符”**驱动程序**与平台特定的“Uart”**设备**一起使用。
- en: Such **Component** should be implemented as two sub-**Components**. One is "Stream
    Buffer" which is responsible to maintain circular buffer of written characters
    and flush them to the peripheral using "Character" **Driver** when needed. The
    characters, that have been successfully written, are removed from the internal
    buffer. The second one is "Stream" itself, which is responsible to convert various
    values into characters and write them to the end of the "Stream Buffer".
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的**组件**应该实现为两个子**组件**。一个是“流缓冲区”，负责维护已写入字符的循环缓冲区，并在需要时使用“字符”**驱动程序**将它们刷新到外围设备。成功写入的字符将从内部缓冲区中删除。另一个是“流”本身，负责将各种值转换为字符并将它们写入“流缓冲区”的末尾。
- en: '![Image: Stream](img/f6f2c3c8358634753d5c061f5eed6193.png)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![Image: Stream](img/f6f2c3c8358634753d5c061f5eed6193.png)'
- en: 'Let’s start with "Output Stream Buffer" first. It needs to receive reference
    to the **Driver** it’s going to use:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从“输出流缓冲区”开始。它需要接收将要使用的**驱动程序**的引用：
- en: '[PRE193]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'There is also a need to have a buffer, where characters are stored before they
    are written to the device. Remember that we are trying to create a **Component**,
    which can be reused in multiple independent projects, including ones that do not
    support dynamic memory allocation. Hence, [Static (Fixed Size) Queue](#basic_needs-queue)
    may be a good choice for it. It means, there is a need to provide size of the
    buffer as one of the template arguments:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要有一个缓冲区，用于在将字符写入设备之前存储它们。记住，我们正在尝试创建一个**组件**，该组件可以在多个独立的项目中重复使用，包括不支持动态内存分配的项目。因此，[静态（固定大小）队列](#basic_needs-queue)可能是一个不错的选择。这意味着需要提供缓冲区的大小作为模板参数之一：
- en: '[PRE194]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'The "Output Stream Buffer" needs to support two main operations:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: “输出流缓冲区”需要支持两个主要操作：
- en: Pushing new single character at the end of the buffer.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的单个字符推送到缓冲区的末尾。
- en: Flushing all (or part of) written characters, i.e. activate asynchronous write
    with **Driver**.
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除所有（或部分）已写入的字符，即激活与**驱动程序**的异步写入。
- en: When pushing a new character, there may be a case when the internal buffer is
    full. In this case, the pushed character needs to be discarded and there must
    be an indication whether "push" operation was successful. The function may return
    either `bool` to indicate success of the operation or `std::size_t` to inform
    the caller how may characters where written. If `0` is returned, the character
    wasn’t written.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 当推送一个新字符时，可能会出现内部缓冲区已满的情况。在这种情况下，需要丢弃推送的字符，并且必须有指示“推送”操作是否成功的标志。函数可以返回`bool`来指示操作的成功，或者返回`std::size_t`来通知调用者已写入多少个字符。如果返回`0`，则表示字符没有被写入。
- en: '[PRE195]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'This limited number of operations is enough to implement "Output Stream" -
    like interface. However, "Output Stream Buffer" can be useful in writing any serialised
    data into the peripheral, not only the debug output. For example using standard
    algorithms:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这有限数量的操作足以实现类似“输出流”的接口。然而，“输出流缓冲区”在将任何序列化数据写入外围设备时可能很有用，而不仅仅是调试输出。例如，使用标准算法：
- en: '[PRE196]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'In the example above, [std::back_inserter](http://en.cppreference.com/w/cpp/iterator/back_inserter)
    requires a container to define `push_back()` member function:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，[std::back_inserter](http://en.cppreference.com/w/cpp/iterator/back_inserter)需要一个容器来定义`push_back()`成员函数：
- en: '[PRE197]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'There also may be a need to iterate over written, but still not flushed, characters
    and update some of them before the call to `flush()`. In other words the "Output
    Stream Buffer" must be treated as random access container:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能需要遍历已写入但尚未刷新的字符，并在调用`flush()`之前更新其中的一些字符。换句话说，“输出流缓冲区”必须被视为随机访问容器：
- en: '[PRE198]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'As was mentioned earlier, the `OutStreamBuf` uses [Static (Fixed Size) Queue](#basic_needs-queue)
    as its internal buffer and any characters pushed beyond the capacity gets discarded.
    There must be a way to identify available capacity as well as request asynchronous
    notification via callback when requested capacity becomes available:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`OutStreamBuf`使用[静态（固定大小）队列](#basic_needs-queue)作为其内部缓冲区，任何超出容量的字符都会被丢弃。必须有一种方法来识别可用容量，以及在请求的容量变得可用时通过回调进行异步通知：
- en: '[PRE199]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Such "Output Stream Buffer" is already implemented in [embxx/io/OutStreamBuf.h](https://github.com/arobenko/embxx/blob/master/embxx/io/OutStreamBuf.h)
    file of [embxx](https://github.com/arobenko/embxx) library.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的“输出流缓冲区”已经在[embxx/io/OutStreamBuf.h](https://github.com/arobenko/embxx/blob/master/embxx/io/OutStreamBuf.h)文件中实现，该文件位于[embxx](https://github.com/arobenko/embxx)库中。
- en: The next stage would be defining the "Output Stream" class, which will allow
    printing of null terminated strings as well as various integral values.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段将是定义“输出流”类，这将允许打印以null结尾的字符串以及各种整数值。
- en: '[PRE200]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We will also require the numeric base representation and manipulator. Unfortunately,
    usage of `std::oct`, ``std::dec`or `std::hex`` manipulators will require inclusion
    of standard library header [<ios>](http://en.cppreference.com/w/cpp/header/ios),
    which in turn includes other standard stream related headers, which define some
    static objects, which in turn are defined and instantiated in standard library.
    It contradicts our main goal of writing generic code that doesn’t require standard
    library to be used. It is better to define such manipulators ourselves:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将需要数值基表示和操作符。不幸的是，使用`std::oct`、`std::dec`或`std::hex`操作符将需要包含标准库头文件 [<ios>](http://en.cppreference.com/w/cpp/header/ios)，这反过来又包含其他标准流相关头文件，这些头文件定义了一些静态对象，这些静态对象又是在标准库中定义和实例化的。这与我们编写不使用标准库的泛型代码的主要目标相矛盾。最好是自己定义这样的操作符：
- en: '[PRE201]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'The value of the numeric base representation must be taken into account when
    creating string representation of numeric values. The usage is very similar to
    standard:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数值的字符串表示时，必须考虑数值基表示的值。其用法与标准类似：
- en: '[PRE202]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'It may be convenient to support a little bit of formatting, such as specifying
    minimal width of the output as well as fill character:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 支持一些格式化功能可能很方便，例如指定输出的最小宽度以及填充字符：
- en: '[PRE203]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'The usage is very similar to the base manipulator:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 其用法与基本操作符非常相似：
- en: '[PRE204]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Another useful manipulator is adding ''\n'' at the end as well as calling `flush()`,
    just like `std::endl` does when using standard output streams:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的操作符是在末尾添加'\n'以及调用`flush()`，就像使用标准输出流时`std::endl`所做的那样：
- en: '[PRE205]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Then usage example may be changed to:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用示例可以更改为：
- en: '[PRE206]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '**To summarise**: The "Output Stream" object converts given integer value into
    the printable characters and uses `pushBack()` member function of "Output Stream
    Buffer" to pass these characters further. The request to `flush()` is also passed
    on. When "Output Stream Buffer" receives a request to flush internal buffer it
    activates the "Character" **Driver**, which it turn uses "UART" **Device** to
    write characters to serial interface one by one. As the result of such cooperation,
    the "printing" statement is very quick, there is no wait for all the characters
    to be written before the function returns, like it is usually done with `printf()`.
    All the characters are written at the background using interrupts, while the main
    thread of the application continues its execution without stalling.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**： "输出流" 对象将给定的整数值转换为可打印字符，并使用 "输出流缓冲区" 的 `pushBack()` 成员函数将这些字符进一步传递。对
    `flush()` 的请求也会传递。当 "输出流缓冲区" 收到刷新内部缓冲区的请求时，它激活 "字符" **驱动程序**，然后它使用 "UART" **设备**逐个将字符写入串行接口。作为这种合作的结果，"打印"
    语句非常快，不需要等待所有字符写入函数返回，就像通常使用 `printf()` 一样。所有字符都在后台使用中断写入，而应用程序的主线程继续执行，不会停滞。'
- en: Such "Output Stream" is already implemented in [embxx/io/OutStream.h](https://github.com/arobenko/embxx/blob/master/embxx/io/OutStream.h)
    file of [embxx](https://github.com/arobenko/embxx) library.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 "输出流" 已经在 [embxx/io/OutStream.h](https://github.com/arobenko/embxx/blob/master/embxx/io/OutStream.h)
    文件中的 [embxx](https://github.com/arobenko/embxx) 库中实现。
- en: Logging
  id: totrans-779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日志记录
- en: In general, debug logging should be under conditional compilation, for example
    only in **DEBUG** mode, while the printing code is excluded when compiling in
    **RELEASE** mode.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调试日志应该在条件编译下，例如仅在 **DEBUG** 模式下，而在 **RELEASE** 模式下编译时排除打印代码。
- en: '[PRE207]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Sometimes there is a need to easily change the amount of debug messages being
    printed. For that purpose, the concept of logging levels is widely used:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要轻松地更改打印的调试消息的数量。为此，广泛使用日志级别概念：
- en: '[PRE208]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The logging statement becomes a macro:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 日志语句变成一个宏：
- en: '[PRE209]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'In this case all the logging attempts for level below `log::Info` get optimised
    away by the compiler, because the `if` statement known to evaluate to `false`
    at compile time:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有低于 `log::Info` 级别的日志尝试都会被编译器优化掉，因为 `if` 语句在编译时已知评估为 `false`：
- en: '[PRE210]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: It would be nice to be able to add some automatic formatting to the logged statements,
    such as printing the log level and/or adding '\n' and flushing at the end. For
    example, the code below
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在日志语句中添加一些自动格式化功能会很好，例如打印日志级别和/或添加 '\n' 并在末尾刷新。例如，下面的代码
- en: '[PRE211]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: to produce the following output
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 生成以下输出
- en: '[PRE212]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: with `'\n'` character and call to `flush()` at the end.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾添加 `'\n'` 字符和调用 `flush()`。
- en: 'It is easy to achieve when using some kind of wrapper logging class around
    the output stream as well as relevant formatters. For example:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用某种类型的包装日志类以及相关的格式化程序时，这很容易实现。例如：
- en: '[PRE213]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'The logging macro will look like this:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 日志宏将看起来像这样：
- en: '[PRE214]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'A formatter can be defined by exposing the same interface, but wraps the original
    `StreamLogger` or another formatter. For example let’s define formatter that calls
    `flush()` member function of the stream when output is complete:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过暴露相同的接口来定义格式化程序，但它包装了原始的 `StreamLogger` 或另一个格式化程序。例如，让我们定义一个在输出完成时调用流成员函数
    `flush()` 的格式化程序：
- en: '[PRE215]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The definition of such logger would be:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这样日志记录器的定义如下：
- en: '[PRE216]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The same `SLOG()` macro will work for this logger with extra formatting:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的 `SLOG()` 宏将适用于此日志记录器，并具有额外的格式化：
- en: '[PRE217]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Let’s also add a formatter that capable of printing any value (and `'\n'` in
    particular) at the end of the output.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个能够打印任何值（特别是 `'\n'`）的格式化程序。
- en: '[PRE218]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The definition of the logger that adds `''\n''` character and then calls `flush()`
    member function of the underlying stream would be:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个在添加 `'\n'` 字符后调用底层流 `flush()` 成员函数的日志记录器的函数如下：
- en: '[PRE219]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: While the construction will require to specify the character which is going
    to be printed at the end, but before call to `flush()`.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然构造函数将需要指定在调用 `flush()` 之前打印在末尾的字符。
- en: '[PRE220]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'As the last formatter, let’s do the one that prefixes the output with log level
    information:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个格式化程序，让我们做一个在输出前缀添加日志级别信息的格式化程序：
- en: '[PRE221]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The definition of the logger that prints such a prefix at the beginning and
    `''\n''` at the end together with call to `flush()` would be:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个日志记录器，它在开头打印这样的前缀并在末尾打印 `'\n'` 以及调用 `flush()` 的函数如下：
- en: '[PRE222]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Such `StreamLogger` together with multiple formatters is already implemented
    in [embxx/util/StreamLogger.h](https://github.com/arobenko/embxx/blob/master/embxx/util/StreamLogger.h)
    file of [embxx](https://github.com/arobenko/embxx) library.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的`StreamLogger`与多个格式化程序一起已在[embxx](https://github.com/arobenko/embxx)库的[embxx/util/StreamLogger.h](https://github.com/arobenko/embxx/blob/master/embxx/util/StreamLogger.h)文件中实现。
- en: Logging Application
  id: totrans-814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日志应用程序
- en: 'The [app_uart1_logging](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_logging)
    application in [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project
    implements logging of simple counter that gets incremented once a second:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目中的[app_uart1_logging](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_logging)应用程序实现了每秒增加一次的简单计数器的日志记录：'
- en: '[PRE223]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'The [System.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/app/app_uart1_logging/System.h)
    file defines the whole output stack:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '[System.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/app/app_uart1_logging/System.h)文件定义了整个输出堆栈：'
- en: '[PRE224]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'This application will produce the following output to the UART interface with
    new line appearing every second:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将以下输出发送到UART接口，每秒出现一个新行：
- en: '[PRE225]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Buffered Input
  id: totrans-821
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓冲输入
- en: In many systems the UART interfaces are also used to communicate between various
    microcontrollers on the same board or with external devices. When there are incoming
    messages, the characters must be stored in some buffer before they can be processed
    by some **Component**. Just like we had "Output Stream Buffer" for buffering outgoing
    characters, we must have "Input Stream Buffer" for buffering incoming ones.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统中，UART接口也用于同一板上的各种微控制器或外部设备之间的通信。当有传入的消息时，字符必须在它们可以被某些**组件**处理之前存储在某个缓冲区中。就像我们有“输出流缓冲区”用于缓冲传出字符一样，我们必须有“输入流缓冲区”用于缓冲传入的字符。
- en: It must obviously have an access to the Character **Driver** and will probably
    have a circular buffer to store incoming characters.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，它必须能够访问**字符驱动程序**，并且可能有一个环形缓冲区来存储传入的字符。
- en: '[PRE226]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The **Driver** won’t perform any read operations unless it is explicitly requested
    to do so with its `asyncRead()` member function. Sometimes, there is a need to
    keep characters flowing in and being stored in the buffer, even when the **Component**
    responsible for processing them is not ready. In order to make this happen, the
    "Input Stream Buffer" must be responsible for constantly requesting the **Driver**
    to perform asynchronous read while providing space where these characters are
    going to be stored.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**不会执行任何读取操作，除非它被明确请求通过其`asyncRead()`成员函数来这样做。有时，即使负责处理这些字符的**组件**尚未准备好，也需要保持字符在流动并在缓冲区中存储。为了实现这一点，“输入流缓冲区”必须负责不断请求**驱动程序**执行异步读取，同时提供存储这些字符的空间。'
- en: '[PRE227]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Most of the times the responsible **Component** will require some number of
    characters to be accumulated before their processing can be started. There is
    a need to provide asynchronous notification callback request when appropriate
    number of characters becomes available. The callback must be stored in the internal
    data structures of the "Input Stream Buffer" and invoked when needed. Due to the
    latter being developed as a generic class, there is a need to provide callback
    storage type as a template parameter.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，负责的**组件**将需要在开始处理之前积累一定数量的字符。需要提供异步通知回调请求，当适当数量的字符可用时。回调必须存储在“输入流缓冲区”的内部数据结构中，并在需要时调用。由于后者被开发为一个通用类，因此需要提供回调存储类型作为模板参数。
- en: '[PRE228]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Once the required number of characters is accumulated, the **Component** must
    be able to access and process them. It means that "Input Stream Buffer" must also
    be a container with random access iterators.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦积累到所需数量的字符，**组件**必须能够访问和处理它们。这意味着“输入流缓冲区”也必须是一个具有随机访问迭代器的容器。
- en: '[PRE229]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Please note, that all the access to the characters are done using const iterator.
    It means we do not allow external and uncontrolled update of the characters inside
    of the buffer.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有对字符的访问都是通过const迭代器完成的。这意味着我们不允许外部和无控制的更新缓冲区内的字符。
- en: When the characters inside the buffer got processed and aren’t needed any more,
    they need to be discarded to free the space inside the buffer for new ones to
    come.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓冲区内的字符被处理并且不再需要时，它们需要被丢弃以释放缓冲区内的空间，为新字符的到来腾出空间。
- en: '[PRE230]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Morse Code Application
  id: totrans-834
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 摩尔斯电码应用程序
- en: The [app_uart1_morse](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_morse)
    application in [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project
    implements buffering of incoming characters in the "Input Stream Buffer" and uses
    the [Morse Code](http://en.wikipedia.org/wiki/Morse_code) method to display them
    by flashing the on-board led.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目中的[app_uart1_morse](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_uart1_morse)应用程序实现了在“输入流缓冲区”中缓冲输入字符，并使用[莫尔斯电码](http://en.wikipedia.org/wiki/Morse_code)方法通过闪烁板载LED来显示它们。'
- en: First of all there is a need to have an access to the led to flash, input buffer
    to store the incoming characters and timer manager to allocate a timer to measure
    timeouts.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要访问要闪烁的LED、输入缓冲区以存储输入字符和定时器管理器以分配一个计时器来测量超时。
- en: '[PRE231]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Second, there is a need to define a Morse code sequences in terms of dots and
    dashes duration as well as mapping an incoming character to the respective sequence.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，需要定义莫尔斯电码序列，包括点划的持续时间，以及将输入字符映射到相应的序列。
- en: '[PRE232]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Now, the code that is responsible to flash a led is quite simple:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，负责闪烁LED的代码相当简单：
- en: '[PRE233]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The `nextLetter()` member function waits until one character becomes available
    in the buffer, then maps it to the sequence and removes it from the buffer. If
    the mapping exists it calls the `nextSyllable()` member function to start the
    flashing sequence. The function activates the led and waits the relevant amount
    of time, based on the provided dot or dash duration. After the timeout, the led
    goes off and new wait is activated. However if the end of sequence is reached,
    the wait will be of `InterSpacing` duration and `nextLetter()` member function
    will be called again, otherwise the wait will be of `Spacing` duration and `nextSyllable()`
    will be called again to activate the led and wait for the next period in the sequence.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextLetter()`成员函数等待缓冲区中有一个字符可用，然后将它映射到序列并从缓冲区中移除。如果存在映射，它将调用`nextSyllable()`成员函数以启动闪烁序列。该函数激活LED并等待基于提供的点或划持续时间的相关时间。超时后，LED熄灭并启动新的等待。然而，如果达到序列的末尾，等待将持续`InterSpacing`持续时间，然后再次调用`nextLetter()`成员函数，否则等待将持续`Spacing`持续时间，然后再次调用`nextSyllable()`以激活LED并等待序列中的下一个周期。'
- en: Summary
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 摘要
- en: After this quite a significant effort we’ve created a full generic stack to
    perform asynchronous input/output operations over serial interface, such as UART.
    It may be reused in multiple independent projects while providing platform specific
    low level device control object at the bottom of this stack.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 经过相当大的努力，我们创建了一个完整的通用堆栈，用于在串行接口（如UART）上执行异步输入/输出操作。它可以在多个独立的项目中重用，同时在堆栈的底部提供平台特定的低级设备控制对象。
- en: GPIO
  id: totrans-845
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPIO
- en: In many cases, the GPIO input doesn’t need to be processed at the same time
    the interrupt has occured. It can easilily be scheduled for execution in event
    loop (non-interrupt) context using [Device-Driver-Component](#basic_concepts-device_driver_component)
    model.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，GPIO输入不需要在中断发生时同时处理。它可以很容易地使用[设备驱动组件](#basic_concepts-device_driver_component)模型在事件循环（非中断）上下文中调度执行。
- en: According to what was written in [Device-Driver-Component](#basic_concepts-device_driver_component)
    chapter and to what we’ve seen so far, the **Component** provides a callback object
    together with the asynchronous operation request. The callback is executed only
    **once** when the operation is compete, canceled or terminated due to some error.
    If the operation needs to be repeated, another asynchronous operation needs to
    be issued to the **Driver** while providing another callback object to be called
    on operation completion.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在[设备驱动组件](#basic_concepts-device_driver_component)章节中所述以及我们所看到的，**组件**提供了一个回调对象以及异步操作请求。回调函数仅在操作完成、取消或由于某些错误而终止时执行一次。如果需要重复操作，则需要向**驱动器**发出另一个异步操作，并提供另一个回调对象，以便在操作完成时调用。
- en: The need for GPIO input handling is a bit different though. The line may change
    its value multiple times between the reporting of the event to the **Component**
    and the latter re-requesting asynchronous wait on value change. The **Driver**
    must preserve the callback object, provided by the **Component**, and invoke it
    every time the GPIO input value changes until the **Component** cancels the operation.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GPIO输入处理的需求略有不同。在将事件报告给**组件**以及后者重新请求异步等待值变化之间，该行可能多次更改其值。**驱动程序**必须保留由**组件**提供的回调对象，并在GPIO输入值每次变化时调用它，直到**组件**取消操作。
- en: Let’s go through all the stages in more detail.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解所有这些阶段。
- en: Configuration
  id: totrans-850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置
- en: '![Image: GPIO register handler](img/90e3ce14c1196f65aa782b230c17f3b2.png)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
  zh: '![Image: GPIO寄存器处理程序](img/90e3ce14c1196f65aa782b230c17f3b2.png)'
- en: The **Device** must provide a callback object to handle GPIO interrupts on all
    the requested input lines.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备**必须提供回调对象来处理所有请求的输入线路上的GPIO中断。'
- en: 'The hardware must also be configured properly: input/output lines, the interrupts
    on the rising/falling edges, etc. Such configuration is platform/product specific
    and is not part of the generic [Device-Driver-Component](#basic_concepts-device_driver_component)
    model presented in this book. Hence, the product specific **Component** must get
    an access to the device object and configure it as needed.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件也必须正确配置：输入/输出线路、上升/下降沿上的中断等。此类配置是平台/产品特定的，不属于本书中介绍的通用[设备-驱动程序-组件](#basic_concepts-device_driver_component)模型的一部分。因此，产品特定的**组件**必须获取对设备对象的访问权限，并根据需要对其进行配置。
- en: Start Continuous Asynchronous Read Operation
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始连续异步读取操作
- en: The **Driver** must be able to support multiple asynchronous read operations
    on different inputs. It means that it must protect an access to the internal data
    structures by requesting the **Device** to suspend the callback invocation (i.e.
    disable interrupts). Also to follow the pattern we used so far, there must be
    a request to start or enable the **Device**'s operation on the first read request
    and cancel or disable it on the last.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**必须能够支持在不同输入上执行多个异步读取操作。这意味着它必须通过请求**设备**暂停回调调用（即禁用中断）来保护对内部数据结构的访问。此外，为了遵循我们迄今为止使用的模式，必须在第一次读取请求时请求或启用**设备**的操作，并在最后一次读取请求时取消或禁用它。'
- en: '![Image: GPIO read](img/f6b081b9112e86a15eaaa5006301ad64.png)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![Image: GPIO读取](img/f6b081b9112e86a15eaaa5006301ad64.png)'
- en: The reader may notice that on the first `asyncReadCont()` request, the **Driver**
    issued `suspend()` request to the **Device** and got `false` in return. It means
    that the **Device**'s monitoring of the GPIO inputs hasn’t been started yet. That’s
    the reason for the following call to `enable()`. On the second `asyncReadCont()`
    request the call to `suspend()` returned true which was followed by the `resume()`
    later.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会注意到，在第一次`asyncReadCont()`请求时，**驱动程序**向**设备**发出了`suspend()`请求，并返回了`false`。这意味着**设备**对GPIO输入的监控尚未开始。这就是为什么接下来会调用`enable()`的原因。在第二次`asyncReadCont()`请求中，`suspend()`的调用返回了`true`，随后是`resume()`。
- en: Reporting GPIO Input Event
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 报告GPIO输入事件
- en: Now, every time the relevant GPIO interrupt occurs, the **Driver**'s handler
    is invoked in interrupt mode context. It is responsible to schedule the execution
    of **Component**'s handler in event loop (non-interrupt) context.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当相关的GPIO中断发生时，**驱动程序**的处理程序就会在中断模式上下文中被调用。它负责在事件循环（非中断）上下文中调度**组件**的处理程序的执行。
- en: '![Image: GPIO interrupt report](img/1b681a9229882a3589b8ae8b5839b8a9.png)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
  zh: '![Image: GPIO中断报告](img/1b681a9229882a3589b8ae8b5839b8a9.png)'
- en: Cancel Continuous Read Operation
  id: totrans-861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消连续读取操作
- en: 'When the there is no need to monitor some input any more, the **Component**
    may request the **Driver** to cancel the continuous asynchronous read operation.
    In case of last recorded asynchronous read operation being canceled, the **Driver**
    is responsible to let the **Device** know that no more GPIO interrupts are needed:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要监控某些输入时，**组件**可以请求**驱动程序**取消连续的异步读取操作。如果最后记录的异步读取操作被取消，**驱动程序**负责让**设备**知道不再需要GPIO中断。
- en: '![Image: GPIO cancel read](img/b5b76c4f10ec0cf51f3d62624461ef41.png)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
  zh: '![Image: GPIO取消读取](img/b5b76c4f10ec0cf51f3d62624461ef41.png)'
- en: GPIO Device
  id: totrans-864
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPIO设备
- en: 'Based on the information above, the platform specific GPIO control **Device**
    object must provide the following public interface:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述信息，平台特定的GPIO控制**设备**对象必须提供以下公共接口：
- en: Define pin identification type.
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义引脚识别类型。
- en: '[PRE234]'
  id: totrans-867
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'Function to provide a callback object to be called when interrupt occurs. The
    callback parameters must provide an information of pin as well as final input
    value that caused the interrupt. The callback object must implement the following
    signature: "void (PinIdType, bool)" where the first parameter is pin and second
    parameter is input value.'
  id: totrans-868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在发生中断时调用回调对象的功能。回调参数必须提供有关引脚的信息以及导致中断的最终输入值。回调对象必须实现以下签名：“void (PinIdType,
    bool)”其中第一个参数是引脚，第二个参数是输入值。
- en: '[PRE235]'
  id: totrans-869
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Function to start / enable the GPIO input monitoring.
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于启动/启用GPIO输入监控的功能。
- en: '[PRE236]'
  id: totrans-871
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Function to cancel / disable the GPIO input monitoring.
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于取消/禁用GPIO输入监控的功能。
- en: '[PRE237]'
  id: totrans-873
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Function to enable/disable gpio interrupts for single pin.
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于启用/禁用单个引脚的GPIO中断的功能。
- en: '[PRE238]'
  id: totrans-875
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Function to suspend invocation of callback in interrupt mode, i.e. disable gpio
    interrupts.
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在中断模式下挂起回调调用，即禁用GPIO中断。
- en: '[PRE239]'
  id: totrans-877
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Function to resume suspended invocation of callback in interrupt mode, i.e.
    enable gpio interrupts.
  id: totrans-878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在中断模式下恢复挂起的回调调用，即启用GPIO中断。
- en: '[PRE240]'
  id: totrans-879
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Such GPIO control **Device** class for RaspberryPi platform is implemented in
    [src/device/Gpio.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Gpio.h)
    file of [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 RaspberryPi 平台的这种GPIO控制 **设备** 类已在[src/device/Gpio.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Gpio.h)文件中实现，该文件位于[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目中。
- en: GPIO Driver
  id: totrans-881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GPIO 驱动程序
- en: 'First of all, we will need references to **Device** as well as [Event Loop](#basic_concepts-event_loop)
    objects:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要**设备**以及[事件循环](#basic_concepts-event_loop)对象的引用：
- en: '[PRE241]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'The **Driver** must also provide an ability to perform and cancel continuous
    asynchronous read operations for multiple pins:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**还必须提供执行和取消多个引脚的连续异步读取操作的能力：'
- en: '[PRE242]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Like with any asynchronous operation so far the callback must receive status
    information as its first parameter and probably the value of the input as the
    second one. When the operation canceled with `cancelReadCont()`, the callback
    must be invoked one last time with status specifying that operation was `Aborted`.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止的任何异步操作一样，回调必须接收状态信息作为其第一个参数，以及可能作为第二个参数的输入值。当使用`cancelReadCont()`取消操作时，回调必须最后一次被调用，状态指定操作已“中止”。
- en: The **Driver** is supposed to be a generic piece of code that can be reused
    in multiple independent products, including ones without dynamic memory allocation
    and/or exceptions. It means that the **Driver** class must receive maximum number
    of the pins it is going to support and type of the callback storage.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**应该是一段通用的代码，可以在多个独立的产品中重用，包括那些没有动态内存分配和/或异常的产品。这意味着**驱动程序**类必须接收它将要支持的引脚的最大数量以及回调存储的类型。'
- en: '[PRE243]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The **Driver** doesn’t do anything special, it just receives the notification
    from the **Device** that gpio interrupt has occurred, locates the appropriate
    registered **Component**'s callback object (based on the pin information provided
    by the **Device**), and uses **Event Loop** to schedule an execution of the **Component**'s
    callback together with information about input’s value in event loop (non-interrupt)
    context.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '**驱动程序**不做任何特别的事情，它只是接收**设备**通知的GPIO中断，根据**设备**提供的引脚信息定位适当的已注册**组件**的回调对象，并使用**事件循环**在事件循环（非中断）上下文中调度**组件**的回调以及关于输入值的详细信息。'
- en: Such generic GPIO **Driver** is already implemented in [embxx/driver/Gpio.h](https://github.com/arobenko/embxx/blob/master/embxx/driver/Gpio.h)
    file of [embxx](https://github.com/arobenko/embxx) library.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用的GPIO **驱动程序**已经在[embxx/driver/Gpio.h](https://github.com/arobenko/embxx/blob/master/embxx/driver/Gpio.h)文件中实现，该文件位于[embxx](https://github.com/arobenko/embxx)库中。
- en: Button Component
  id: totrans-891
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按钮组件
- en: The [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project has a simple
    button **Component**, implemented in [src/component/Button.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/component/Button.h).
    It configures provided GPIO line to be an input and to have both rising and falling
    edges interrupts. It also exposes simple interface to be able to monitor button
    presses and releases.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目有一个简单的按钮**组件**，在[src/component/Button.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/component/Button.h)中实现。它配置提供的GPIO线路作为输入，并具有上升和下降沿中断。它还提供了一个简单的接口，以便能够监控按钮的按压和释放。'
- en: '[PRE244]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Button Press Monitoring Application
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按钮按压监控应用
- en: The [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project also contains
    a simple application called [app_button](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_button).
    It monitors presses and releases of a single button connected to one of the GPIO
    lines. When the button is pressed, the led is turned on for 1 second and "Button
    Pressed" string is logged to UART. When the button is released, just "Button Released"
    string is logged to UART without influencing the led state. If new button press
    is recognised prior to 1 second timeout for the led being on, the led stays on
    and a new 1 second timer countdown is started.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) 项目还包含一个名为 [app_button](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_button)
    的简单应用程序。它监控连接到GPIO线之一的单个按钮的按下和释放。当按钮被按下时，LED灯亮1秒钟，并将 "Button Pressed" 字符串记录到UART。当按钮释放时，仅将
    "Button Released" 字符串记录到UART，而不会影响LED状态。如果在LED亮起1秒钟之前检测到新的按钮按下，LED保持亮起，并重新开始1秒钟的计时器倒计时。'
- en: Thanks to the [Device-Driver-Component](#basic_concepts-device_driver_component)
    model and all levels of abstractions, the application code is quite simple.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 [Device-Driver-Component](#basic_concepts-device_driver_component) 模型和所有级别的抽象，应用程序代码相当简单。
- en: '[PRE245]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'The code for "button pressed" is as following:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '"按钮按下"的代码如下：'
- en: '[PRE246]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'The code for "button release" is very simple:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '"按钮释放"的代码非常简单：'
- en: '[PRE247]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: I2C
  id: totrans-902
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C
- en: '[I2C](http://en.wikipedia.org/wiki/I%C2%B2C) is serial communication bus. It
    is very popular in embedded development and mostly used to communicate to various
    low speed peripherals, such as eeproms and various sensors.'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '[I2C](http://en.wikipedia.org/wiki/I%C2%B2C) 是串行通信总线。它在嵌入式开发中非常流行，主要用于与各种低速外围设备通信，例如EEPROM和各种传感器。'
- en: The control and use of I2C fits nicely into the [Device-Driver-Component](#basic_concepts-device_driver_component)
    model described in this book. It is a serial interface and the controlling **Device**
    object will have to read/write characters one by one, just like it was with [UART](#peripherals-uart).
    It would be nice if we coud reuse the Character **Driver** we implemented before.
    However, the I2C is multi-master / multi-slave bus and there is a need to specify
    the slave ID (or address) when initiating read and/or write operation.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: I2C的控制和使用非常适合本书中描述的 [Device-Driver-Component](#basic_concepts-device_driver_component)
    模型。它是一个串行接口，控制 **设备** 对象将不得不逐个读取/写入字符，就像与 [UART](#peripherals-uart) 一样。如果我们能重用之前实现的字符
    **驱动程序** 那就太好了。然而，I2C是多主/多从总线，在启动读取和/或写入操作时需要指定从设备ID（或地址）。
- en: ID Adaptor
  id: totrans-905
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ID适配器
- en: It is quite clear that some kind of **ID Device Adaptor** is needed. It will
    be constructed with additional ID parameter and will be responsible to forward
    all the API calls from the Character **Driver** to I2C **Device** while adding
    one extra parameter of ID.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，需要某种类型的 **ID 设备适配器**。它将使用额外的ID参数构建，并将负责将所有API调用从字符 **驱动程序** 转发到I2C **设备**，同时添加一个额外的ID参数。
- en: '![Image: Using ID Adapter](img/b53298dd7361c1f5e475378b3c82990c.png)'
  id: totrans-907
  prefs: []
  type: TYPE_IMG
  zh: '![图片：使用ID适配器](img/b53298dd7361c1f5e475378b3c82990c.png)'
- en: 'The implementation of such adaptor is very simple and straightforward:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 这种适配器的实现非常简单直接：
- en: '[PRE248]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: The same adaptor class is implemented in [embxx/device/IdDeviceCharAdapter.h](https://github.com/arobenko/embxx/blob/master/embxx/device/IdDeviceCharAdapter.h)
    file of [embxx](https://github.com/arobenko/embxx) library.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的适配器类在 [embxx](https://github.com/arobenko/embxx) 库的 [embxx/device/IdDeviceCharAdapter.h](https://github.com/arobenko/embxx/blob/master/embxx/device/IdDeviceCharAdapter.h)
    文件中实现。
- en: Operations Queue
  id: totrans-911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作队列
- en: The I2C protocol allows existence of multiple independent slaves on the same
    bus. It means there may be several independent **Components** that communicate
    to different I2C devices (for example EEPROM and temperature sensor), but must
    share the same **Device** control object and may issue read/write requests to
    it in parallel. To resolve this problem, there must be some kind of operation
    queuing facility that is responsible to queue all the read/write requests to the
    **Device** and issue them one by one.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: I2C协议允许同一总线上存在多个独立的从设备。这意味着可能有多个独立的 **组件** 与不同的I2C设备（例如EEPROM和温度传感器）通信，但必须共享相同的
    **设备** 控制对象，并且可以并行向其发出读写请求。为了解决这个问题，必须有一种操作排队设施，负责排队所有对 **设备** 的读写请求，并依次发出。
- en: 'The objects'' usage map looks like this:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 对象使用图如下：
- en: '![Image: Using Op Queue](img/68d05676fa65cb1c6dc3c67e44b905ea.png)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![图片：使用操作队列](img/68d05676fa65cb1c6dc3c67e44b905ea.png)'
- en: Such queue is a platform/product independent piece of code and it should be
    implemented without using dynamic memory allocation and/or exceptions. It means
    that it should receive number of various **Driver** objects, that may issue independent
    read/write requests to it (i.e. size of the internal queue), as a template parameter
    and probably use [Static (Fixed Size) Queue](#basic_needs-queue) to queue all
    the requests that are coming in. It should also receive callback storage types
    to report when a new character can be read/written, as well as when read/write
    operation is complete.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 此队列是一段平台/产品无关的代码，它应该在不使用动态内存分配和/或异常的情况下实现。这意味着它应该接收各种**驱动器**对象的数量，这些对象可以独立地向它发出读写请求（即内部队列的大小），作为一个模板参数，并且可能使用[静态（固定大小）队列](#basic_needs-queue)来排队所有传入的请求。它还应接收回调存储类型，以报告何时可以读取/写入新字符，以及何时读写操作完成。
- en: '[PRE249]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'When the `TSize` template parameter is set to `1`, there is no need for all
    the queuing facility and the `DeviceOpQueue` class may become a simple pass-through
    inline class using template specialisation:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 当`TSize`模板参数设置为`1`时，不需要所有排队功能，`DeviceOpQueue`类可能成为一个简单的透传内联类，使用模板特化：
- en: '[PRE250]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Such queue is also implemented in [embxx](https://github.com/arobenko/embxx)
    library. It resides in the [embxx/device/DeviceOpQueue.h](https://github.com/arobenko/embxx/blob/master/embxx/device/DeviceOpQueue.h)
    file.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 此队列也在[embxx](https://github.com/arobenko/embxx)库中实现。它位于[embxx/device/DeviceOpQueue.h](https://github.com/arobenko/embxx/blob/master/embxx/device/DeviceOpQueue.h)文件中。
- en: Please note that [ID Adaptor](#peripherals-i2c-id_adaptor) and [[peripherals-i2c-operations_queue]](#peripherals-i2c-operations_queue)
    are both **Device** layer classes. The serve as wrappers to actual peripheral
    control **Device** in order to expose the right interface to the upper layer **Driver**.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[ID适配器](#peripherals-i2c-id_adaptor)和[[peripherals-i2c-operations_queue]](#peripherals-i2c-operations_queue)都是**设备**层类。它们作为包装实际外围控制**设备**的包装器，以便向上层**驱动器**暴露正确的接口。
- en: I2C Device
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: I2C设备
- en: The only thing that remains is to properly implement I2C control device, which
    can be used by the `DeviceOpQueue`, which in turn is used by the `IdAdaptor`.
    The `IdAdaptor` object can be used with the existing `Character` **Driver** implemented
    to be used with the [UART](#peripherals-uart) peripheral.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是正确实现I2C控制设备，该设备可以被`DeviceOpQueue`使用，而`DeviceOpQueue`反过来又被`IdAdaptor`使用。`IdAdaptor`对象可以与现有的用于[UART](#peripherals-uart)外围设备的`Character`**驱动器**一起使用。
- en: 'Based on the information above, the platform specific I2C control **Device**
    object must provide the following public interface:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述信息，特定平台的I2C控制**设备**对象必须提供以下公共接口：
- en: '[PRE251]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Such device to control **I2C0** interface on RaspberryPi platform is implemented
    in [src/device/I2C0.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/I2C0.h)
    file of [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 在RaspberryPi平台上控制**I2C0**接口的此类设备在[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目的[src/device/I2C0.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/I2C0.h)文件中实现。
- en: EEPROM Access Application
  id: totrans-926
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EEPROM访问应用程序
- en: The [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project contains
    an application called [app_i2c0_eeprom](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_i2c0_eeprom).
    It implements a parallel access to 2 EEPROMs connected to the same I2C0 bus, but
    having different addresses. The EEPROMs are accessed independently at the same
    time with read/write operations. These operations are queued and managed by the
    `DeviceOpQueue` object that wraps actual I2C control **Device** and forwards the
    requests one by one.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '[embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)项目包含一个名为[app_i2c0_eeprom](https://github.com/arobenko/embxx_on_rpi/tree/master/src/app/app_i2c0_eeprom)的应用程序。它实现了对连接到同一I2C0总线但具有不同地址的2个EEPROM的并行访问。EEPROM同时以读写操作独立访问。这些操作由包装实际I2C控制**设备**并逐个转发请求的`DeviceOpQueue`对象排队和管理。'
- en: SPI
  id: totrans-928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SPI
- en: '[SPI](http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus) is also
    quite popular serial communication interface. It is very similar to [I2C](#peripherals-i2c)
    in terms of using it the [Device-Driver-Component](#basic_concepts-device_driver_component)
    model described in this book. The main differences are:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '[SPI](http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus)也是一种相当流行的串行通信接口。在它使用本书中描述的[设备-驱动器-组件](#basic_concepts-device_driver_component)模型方面，它与[I2C](#peripherals-i2c)非常相似。主要区别是：'
- en: SPI uses "chip select" identification method instead of "address" of the peripheral.
  id: totrans-930
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SPI使用“芯片选择”识别方法而不是外围设备的“地址”。
- en: SPI is a double direction link - there are always read and write operations
    that are executed in parallel (instead of only read or only write).
  id: totrans-931
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SPI 是一个双向链接 - 总是会并行执行读取和写入操作（而不是只有读取或只有写入）。
- en: The "chip select" slave identefication will require the same "**ID Adaptor**"
    that was used for [I2C](#peripherals-i2c) integration.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: “芯片选择”从机识别将需要与 [I2C](#peripherals-i2c) 集成时使用的相同的 "**ID 适配器**"。
- en: Just like with [I2C](#peripherals-i2c), the [SPI](http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus)
    is a multi-slave bus. It allows connection of multiple independent devices to
    the same MISO/MOSI/CLK lines of the SPI interface. It means there is a need for
    the same "**Operations Queue**" that was used for [I2C](#peripherals-i2c) integration.
    Due to the fact that SPI is a double direction link, the "**Operations Queue**"
    must be able to forward, say, read operation request to the actual **Device**
    even if "write" operation to the same slave device is already in progress.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 [I2C](#peripherals-i2c) 一样，[SPI](http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus)
    是一个多从机总线。它允许将多个独立设备连接到 SPI 接口的相同 MISO/MOSI/CLK 线。这意味着需要与 [I2C](#peripherals-i2c)
    集成时使用的相同的 "**操作队列**"。由于 SPI 是一个双向链接，所以 "**操作队列**" 必须能够转发，例如，读取操作请求到实际的 **设备**，即使对同一从设备的“写入”操作已经在进行中。
- en: It means that the objects' usage map is exactly the same as with [I2C](#peripherals-i2c).
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对象的用法图与 [I2C](#peripherals-i2c) 完全相同。
- en: '![Image: Using Op Queue](img/68d05676fa65cb1c6dc3c67e44b905ea.png)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![图像：使用操作队列](img/68d05676fa65cb1c6dc3c67e44b905ea.png)'
- en: All the intermediate layers (Character **Driver**, ID Adaptor, Operations Queue)
    in the map above must allow issuing read and write operations at the same time.
    It becomes a responsibility of the product specific **Component** to be aware
    what kind of the **Device** is used and not to issue these requests in parallel
    if the actual **Device** (such as I2C) doesn’t support it.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中的所有中间层（字符 **驱动程序**、ID 适配器、操作队列）都必须允许同时发出读取和写入操作。这成为特定产品 **组件** 的责任，使其意识到使用了哪种类型的
    **设备**，并且如果实际 **设备**（如 I2C）不支持，则不要并行发出这些请求。
- en: SPI Device
  id: totrans-937
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SPI 设备
- en: 'Based on the information above, the platform specific SPI control **Device**
    object must provide and implement exactly the same interface as [I2C](#peripherals-i2c)
    **Device**:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述信息，特定平台 SPI 控制设备对象必须提供并实现与 [I2C](#peripherals-i2c) **设备** 完全相同的接口：
- en: '[PRE252]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Such device to control **SPI0** interface on RaspberryPi platform is implemented
    in [src/device/Spi0.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Spi0.h)
    file of [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi) project.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RaspberryPi 平台上控制 **SPI0** 接口的此类设备在 [embxx_on_rpi](https://github.com/arobenko/embxx_on_rpi)
    项目的 [src/device/Spi0.h](https://github.com/arobenko/embxx_on_rpi/blob/master/src/device/Spi0.h)
    文件中实现。
- en: Other Nuances
  id: totrans-941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他细微差别
- en: SPI is quite often used with external persistent storage, such as SD card. Such
    devices may have some significant delays between the block write operation on
    the `MOSI` line and the time they send an acknowledgement about operation completion
    on the `MISO` line. The SPI **Device** must constantly read the incoming bytes
    until the expected `ACK`/`NACK` byte is received without de-asserting the `CS`
    (chip select). If the **Component**, responsible for managing SPI flash memory,
    issues only single "read" operation to wait for such an acknowledgement, the provided
    buffer may get full before the required byte is received. In this case the SPI
    control **Device** object is not aware that the new "read" request may follow
    and has to de-assert the `CS`, which is undesireble.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 经常与外部持久存储设备一起使用，例如 SD 卡。这些设备在 `MOSI` 线上的块写入操作和它们在 `MISO` 线上发送关于操作完成确认之间可能会有一些显著的延迟。SPI
    **设备** 必须不断读取传入的字节，直到接收到预期的 `ACK`/`NACK` 字节，而不释放 `CS`（芯片选择）。如果负责管理 SPI 闪存内存的 **组件**
    只发出单个“读取”操作以等待此类确认，提供的缓冲区可能会在接收到所需的字节之前就满了。在这种情况下，SPI 控制设备对象不知道新的“读取”请求可能随后到来，并必须释放
    `CS`，这是不希望的。
- en: In order to solve this problem, the Character **Driver** described in [UART](#peripherals-uart)
    chapter must be extended to support issuing multiple read/write operations at
    the same time. Such extension is based on the values of `ReadQueueSize`/`WriteQueueSize`
    in the provided `Traits` class. These values indicate maximal number of simultaneous
    read/write operations that may be issued to the **Driver**. The responsible **Component**,
    in turn, must perform 2 or 3 "read until" operations at the same time to wait
    for the expected response. Once the first buffer is full, the **Driver** will
    post the **Component**'s callback object for execution in the event loop context,
    while calling `startRead()` member function of the **Device** for the next pending
    "read until" operation still in interrupt context to fill the second buffer. The
    **Device** is responsible to continue its read operation without de-asserting
    the `CS` line. While the second buffer being filled, the **Component** has enough
    time to identify that there is no response in the filled buffer and re-issue the
    "read until" request to the **Driver** while reusing the same buffer. This circle
    of "read until" requests must continue until expected response is encountered
    or until operation timeout, which is measured independently by the asynchronous
    wait request to the [Timer](timer.md). It is up to the responsible **Component**
    object to manage the operations to the Character **Driver** as well as the Timer
    in event loop context and cancel one upon execution of callback from another.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，[UART](#peripherals-uart)章节中描述的字符**驱动程序**必须扩展以支持同时执行多个读写操作。这种扩展基于提供的`Traits`类中的`ReadQueueSize`/`WriteQueueSize`值。这些值表示可以发送给**驱动程序**的最大并发读写操作数。负责的**组件**必须同时执行2或3次“读取直到”操作以等待预期的响应。一旦第一个缓冲区填满，**驱动程序**将发布**组件**的回调对象以在事件循环上下文中执行，同时调用**设备**的`startRead()`成员函数以在中断上下文中填充下一个挂起的“读取直到”操作，以填充第二个缓冲区。**设备**负责继续其读取操作而不释放`CS`线。当第二个缓冲区被填充时，**组件**有足够的时间识别填充的缓冲区中没有响应，并重新向**驱动程序**发出“读取直到”请求，同时重用相同的缓冲区。这个“读取直到”请求的循环必须继续，直到遇到预期的响应或操作超时，超时是通过异步等待请求到[定时器](timer.md)独立测量的。负责的**组件**对象必须管理对字符**驱动程序**的操作以及事件循环上下文中的定时器，并在执行来自另一个回调的回调时取消一个。
- en: External Storage
  id: totrans-944
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外部存储
- en: 'As was mentioned in previous section, SPI is often used with external persistent
    storage, such as SD card. In order to properly support it, there must be some
    kind of `SpiFlash` management **Component**, that is responsible to implement
    proper [communication protocol](https://www.sdcard.org/downloads/pls/simplified_specs/part1_410.pdf)
    while providing necessary public interface. The minimal required interface will
    have to be able to:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SPI通常与外部持久存储一起使用，例如SD卡。为了正确支持它，必须有一种`SpiFlash`管理**组件**，该组件负责实现适当的[通信协议](https://www.sdcard.org/downloads/pls/simplified_specs/part1_410.pdf)，同时提供必要的公共接口。所需的最小接口必须能够：
- en: Asynchronously initialise the device.
  id: totrans-946
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步初始化设备。
- en: Asynchronously read block of data.
  id: totrans-947
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步读取数据块。
- en: Asynchronously write block of data.
  id: totrans-948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步写入数据块。
- en: Once such **Component** is implemented and tested, the next stage would be implementing
    proper file system (FAT32) management **Component**, using the asynchronous functions
    of the former. It will allow processing time consuming file system reads and writes
    while still allowing processing of all other events without creating any performance
    bottlenecks and without requiring any complex independent task scheduling.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这样的**组件**被实现和测试，下一个阶段将是实现适当的文件系统（FAT32）管理**组件**，使用前者的异步函数。这将允许在处理所有其他事件的同时处理耗时的文件系统读写操作，而不会创建任何性能瓶颈，也不需要任何复杂的独立任务调度。
- en: Other
  id: totrans-950
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他
- en: There are many other peripherals and/or protocols (such as I2S, USB, one wire).
    The implementation and the main concepts should be pretty similar to the peripherals
    covered so far. At this stage I do not plan to do it in this book. At least not
    in the near future.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他外围设备或协议（例如I2S、USB、单线）。实现和主要概念应该与迄今为止涵盖的外围设备非常相似。在这个阶段，我并不打算在本书中实现它。至少在近期内不会。
- en: Various micro-controllers may also support [DMA](http://en.wikipedia.org/wiki/Direct_memory_access)
    access to some peripherals. In this case the `Character` **Driver** that was covered
    in [UART](#peripherals-uart) chapter must be replaced with some kind of `Block`
    **Driver**, that will allow issuing of multiple read/write requests at the same
    time and will receive only "operation complete" notifications from the **Device**.
    I leave implementation of it as an excercise for the reader. At least for now.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 各种微控制器也可能支持对某些外设的 [DMA](http://en.wikipedia.org/wiki/Direct_memory_access) 访问。在这种情况下，[UART](#peripherals-uart)
    章节中提到的 `Character` **驱动程序** 必须替换为某种 `Block` **驱动程序**，这将允许同时发出多个读写请求，并且只会从 **设备**
    接收“操作完成”通知。我将其实施留作读者的练习。至少目前是这样。
