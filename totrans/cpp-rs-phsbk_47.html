<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Curiously recurring template pattern (CRTP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Curiously recurring template pattern (CRTP)</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/patterns/crtp.html">https://cel.cs.brown.edu/crp/patterns/crtp.html</a></blockquote>
                        
<p>The C++ <a href="https://en.cppreference.com/w/cpp/language/crtp">curiously recurring template
pattern</a> is used to make the
concrete type of the derived class available in the definition of methods
defined in the base class.</p>
<h2 id="sharing-implementations-with-static-polymorphism"><a class="header" href="#sharing-implementations-with-static-polymorphism">Sharing implementations with static polymorphism</a></h2>
<p>The basic use of the CRTP is for reducing redundancy in implementations that
make use of static polymorphism. In this use case, the <code>this</code> pointer is cast to
the type provided by the template parameter so that methods from the derived
class can be called. This enables methods implemented in the base class to call
methods in the derived class without having to declare them virtual, avoiding
the cost of dynamic dispatch.</p>
<p>In the following example, <code>Triangle</code> and <code>Square</code> have a common implementation
of <code>twiceArea</code> without the need for dynamic dispatch. This use case is addressed
in Rust using default trait methods.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;

template &lt;typename T&gt;
struct Shape {
  // This implementation is shared and can call
  // the area method from derived classes without
  // declaring it virtual.
  double twiceArea() {
    return 2.0 * static_cast&lt;T *&gt;(this)-&gt;area();
  }
};

struct Triangle : public Shape&lt;Triangle&gt; {
  double base;
  double height;

  Triangle(double base, double height)
      : base(base), height(height) {}

  double area() {
    return 0.5 * base * height;
  }
};

struct Square : public Shape&lt;Square&gt; {
  double side;

  Square(double side) : side(side) {}

  double area() {
    return side * side;
  }
};

int main() {
  Triangle triangle{2.0, 1.0};
  Square square{2.0};

  std::cout &lt;&lt; triangle.twiceArea() &lt;&lt; std::endl;
  std::cout &lt;&lt; square.twiceArea() &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">trait Shape {
    fn area(&amp;self) -&gt; f64;

    fn twice_area(&amp;self) -&gt; f64 {
        2.0 * self.area()
    }
}

struct Triangle {
    base: f64,
    height: f64,
}

impl Shape for Triangle {
    fn area(&amp;self) -&gt; f64 {
        0.5 * self.base * self.height
    }
}

struct Square {
    side: f64,
}

impl Shape for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn main() {
    let triangle = Triangle {
        base: 2.0,
        height: 1.0,
    };
    let square = Square { side: 2.0 };
    println!("{}", triangle.twice_area());
    println!("{}", square.twice_area());
}</code></pre></pre>
</div>
<p>The reason why nothing additional needs to be done for the default method to
invoke area statically in Rust is that calls to methods on <code>self</code> are always
resolved statically in Rust. This is possible because <a href="../idioms/data_modeling/inheritance_and_reuse.html">Rust does not have
inheritance between concrete
types</a>. Despite being defined in
the trait, the default method is actually implemented as part of the
implementing struct.</p>
<h2 id="method-chaining"><a class="header" href="#method-chaining">Method chaining</a></h2>
<p>Another common use for the CRTP is for implementing method chaining when an
implementation of a method to be chained is provided by a base class.</p>
<p>In C++ the template parameter is used to ensure that the type returned from the
shared function is that of the derived class, so that further methods defined in
the derived class can be called on it. The template parameter is also used to
call a method on the derived type without declaring the method as virtual.</p>
<p>In Rust the template parameter is not required because the <code>Self</code> type is
available in traits to refer to the type of the implementing struct.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;span&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

// D is the type of the derived class
template &lt;typename D&gt;
struct Combinable {
  D combineWith(D &amp;d);

  // concat is implemented in the base class, but
  // operates on values of the derived class.
  D concat(std::span&lt;D&gt; vec) {
    D acc(*static_cast&lt;D *&gt;(this));

    for (D &amp;v : vec) {
      acc = acc.combineWith(v);
    }

    return acc;
  }
};

struct Sum : Combinable&lt;Sum&gt; {
  int sum;

  Sum(int sum) : sum(sum) {}

  Sum combineWith(Sum s) {
    return Sum(sum + s.sum);
  }

  // Sum includes an additional method that can be
  // chained.
  Sum mult(int n) {
    return Sum(sum * n);
  }
};

int main() {
  Sum s(0);
  std::vector&lt;Sum&gt; v{1, 2, 3, 4};
  Sum x = s.concat(v)
              // Even though concat is part of the
              // base class, it returns a value of
              // the implementing class, making it
              // possible to chain methods
              // specific to that class.
              .mult(2)
              .combineWith(5);
  std::cout &lt;&lt; x.sum &lt;&lt; std::endl;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">// No generic type is required: Self already
// refers to implementing type.
trait Combinable {
    fn combine_with(&amp;self, other: &amp;Self) -&gt; Self;

    // concat has a default implementation in
    // terms of Self.
    fn concat(&amp;self, others: &amp;[Self]) -&gt; Self
    where
        Self: Clone,
    {
        let mut acc = self.clone();

        for v in others {
            acc = acc.combine_with(v);
        }
        acc
    }
}

#[derive(Clone)]
struct Sum(i32);

impl Sum {
    // Sum includes an additional method that can be
    // chained.
    fn mult(&amp;self, n: i32) -&gt; Self {
        Self(self.0 * n)
    }
}

impl Combinable for Sum {
    fn combine_with(&amp;self, other: &amp;Self) -&gt; Self {
        Self(self.0 + other.0)
    }
}

fn main() {
    let s = Sum(0);
    let v = vec![Sum(1), Sum(2), Sum(3), Sum(4)];
    let x = s
        .concat(&amp;v)
        // Even though concat is part of the
        // trait, it returns a value of the
        // implementing type, making it possible
        // to chain methods specific to that type.
        .mult(2)
        .combine_with(&amp;Sum(5));
    println!("{}", x.0)
}</code></pre></pre>
</div>
<p>Again, the reason why <code>Self</code> can refer to the implementing type is that <a href="../idioms/data_modeling/inheritance_and_reuse.html">Rust
does not have inheritance between concrete
types</a>. This contrasts with C++
where a value may be used at any number of types which are concrete, and so it
would not be clear which type something like <code>Self</code> should refer to.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;crtp&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Dynamic dispatch in Rust only occurs when invoking a method on a trait object.\nSome of the patterns used to ensure static dispatch is used in C++ are not\nneeded in Rust.\n&quot;,&quot;id&quot;:&quot;9dd51ab1-5e7a-441b-bc59-c80a73bde71f&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;`total += shape.area(); // 2`\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`2.0 * self.area() // 1`\n&quot;,&quot;`println!(\&quot;{}\&quot;, triangle.twice_area()); // 3`\n&quot;,&quot;`println!(\&quot;{}\&quot;, square.twice_area()); // 4`\n&quot;,&quot;`2.0 * self.area() // 1` when invoked via `sum_areas`.\n&quot;],&quot;prompt&quot;:&quot;In the following Rust program, which calls are resolved using dynamic dispatch?\n\n```rust\ntrait Shape {\n    fn area(&amp;self) -&gt; f64;\n\n    fn twice_area(&amp;self) -&gt; f64 {\n        2.0 * self.area() // 1\n    }\n}\n\nstruct Triangle {\n    base: f64,\n    height: f64,\n}\n\nimpl Shape for Triangle {\n    fn area(&amp;self) -&gt; f64 {\n        0.5 * self.base * self.height\n    }\n}\n\nstruct Square {\n    side: f64,\n}\n\nimpl Shape for Square {\n    fn area(&amp;self) -&gt; f64 {\n        self.side * self.side\n    }\n}\n\nfn sum_areas(shapes: &amp;[&amp;dyn Shape]) -&gt; f64 {\n    let mut total = 0.0;\n    for shape in shapes {\n        total += shape.area(); // 2\n    }\n    total\n}\n\nfn main() {\n    let triangle = Triangle {\n        base: 2.0,\n        height: 1.0,\n    };\n    let square = Square { side: 2.0 };\n    println!(\&quot;{}\&quot;, triangle.twice_area()); // 3\n    println!(\&quot;{}\&quot;, square.twice_area()); // 4\n\n    println!(\n        \&quot;{}\&quot;,\n        sum_areas(&amp;[&amp;triangle, &amp;square])\n    );\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Curiously recurring template pattern (CRTP)">Click here to leave us feedback about this page.</a>
                        
</body>
</html>