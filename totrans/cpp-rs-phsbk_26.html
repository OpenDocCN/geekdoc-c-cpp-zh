<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Exceptions and error handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Exceptions and error handling</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/exceptions.html">https://cel.cs.brown.edu/crp/idioms/exceptions.html</a></blockquote>
                        
<p>In C++ errors that are to be handled by the caller are sometimes indicated by
sentinel values (e.g., <code>std::map::find</code> producing an empty iterator), sometimes
indicated by exceptions (e.g., <code>std::vector::at</code> throwing <code>std::out_of_range</code>),
and sometimes indicated by setting an error bit (e.g., <code>std::fstream::fail</code>).
Errors that are not intended to be handled by the caller are usually indicated
by exceptions (e.g., <code>std::bad_cast</code>). Errors that are due to programming bugs
often just result in undefined behavior (e.g., <code>std::vector::operator[]</code> when
the index is out-of-bounds).</p>
<p>In contrast, safe Rust has two mechanisms for indicating errors. When the error
is expected to be handled by the caller (because it is due to, e.g., user
input), the function returns a
<a href="https://doc.rust-lang.org/std/result/index.html"><code>Result</code></a> or
<a href="https://doc.rust-lang.org/std/option/index.html"><code>Option</code></a>. When the error is
due to a programming bug, the function panics. Undefined behavior can only occur
if unchecked variants of functions are used with unsafe Rust.</p>
<p>Some libraries in Rust will offer two versions of an API, one which returns a
<code>Result</code> or <code>Option</code> type and one of which panics, so that the interpretation of
the error (expected exceptional case or programmer bug) can be chosen by the
caller.</p>
<p>The major differences between using <code>Result</code> or <code>Option</code> and using exceptions
are that</p>
<ol>
<li><code>Result</code> and <code>Option</code> force explicit handling of the error case in order to
access the contained value. This also differs from <code>std::expected</code> in C++23.</li>
<li>When propagating errors with <code>Result</code>, the types of the errors must match.
There are libraries for making this easier to handle.</li>
</ol>
<h2 id="result-vs-option"><a class="header" href="#result-vs-option"><code>Result</code> vs <code>Option</code></a></h2>
<p>The approaches demonstrated in the Rust examples in this chapter apply to both
<code>Result</code> and <code>Option</code>. When the type is <code>Option</code> it indicates that there is no
additional information to provide in the error case: <code>Option::None</code> does not
contain a value, but <code>Result::Err</code> does. When there is no additional
information, is usually because there is exactly one circumstance which can
cause the error case.</p>
<p>It is possible to convert between the two types.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let r: Result&lt;i32, &amp;'static str&gt; =
        None.ok_or("my error message");
    let r2: Result&lt;i32, &amp;'static str&gt; =
        None.ok_or_else(|| "expensive error message");
    let o: Option&lt;i32&gt; = r.ok();
}</code></pre></pre>


                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Exceptions and error handling">Click here to leave us feedback about this page.</a>
                        
</body>
</html>