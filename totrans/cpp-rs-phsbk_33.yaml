- en: RTTI and dynamic_cast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/rtti.html](https://cel.cs.brown.edu/crp/idioms/rtti.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rust does not have built-in support for generalized RTTI, nor does Rust have
    a direct analog to `dynamic_cast`.
  prefs: []
  type: TYPE_NORMAL
- en: The only language primitive provided by Rust in this vein is [`TypeId`](https://doc.rust-lang.org/std/any/struct.TypeId.html),
    which is a globally unique identifier for a type. Rust's standard library builds
    on `TypeId` to provide an [`Any` trait](https://doc.rust-lang.org/std/any/trait.Any.html)
    that supports similar uses to `std::any` in C++. However, `Any` does not enable
    testing for implementation of, or converting to, another trait. It only enables
    testing for and converting to a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: Every type with a `'static` lifetime bound (i.e., that does not contain references
    with a non-static lifetime) implements `Any` via a blanket implementation in the
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: use std::any::Any;
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_if_string(x: &dyn Any) {'
  prefs: []
  type: TYPE_NORMAL
- en: match x.downcast_ref::<String>() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(s) => println!("{}", s),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: None    => println!("Not a string!")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: print_if_string(&String::from("hello world"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_if_string(&5);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Event handling](#event-handling)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One practical use of RTTI and `dynamic_cast` in C++ is for event handling in
    situations where both the subsystem generating events and the events themselves
    need to be decoupled from the handling logic. This is usually because the events
    are generated by a framework, such as a GUI or game framework, while the response
    to the events is application-specific.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { enum Event {'
  prefs: []
  type: TYPE_NORMAL
- en: ClickEvent {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'x: i32,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'y: i32,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ResizeEvent {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'old_height: i32,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'old_width: i32,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'new_height: i32,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'new_width: i32,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn handle_event(e: Event) {'
  prefs: []
  type: TYPE_NORMAL
- en: match e {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Event::ClickEvent { x, y } => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Event::ResizeEvent {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: old_height,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: old_width,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: new_height,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: new_width,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} => {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even when the a client of the library is needs to be able to define custom events,
    it is usually possible to make use of an event enum. This is the approach taken
    by the [winit crate](https://docs.rs/winit/latest/winit/event/enum.Event.html),
    which does cross-platform window and event loop management.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { enum Event<T> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'ClickEvent { x: i32, y: i32, }, ResizeEvent { old_height: i32, old_width: i32,
    new_height: i32, new_width: i32, },    // ...'
  prefs: []
  type: TYPE_NORMAL
- en: UserEvent(T),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: enum UserEvent {
  prefs: []
  type: TYPE_NORMAL
- en: 'DoSomething { how_much: f64 },'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DoSomethingElse { how_many: i32 },'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn handle_event(e: Event<UserEvent>) {'
  prefs: []
  type: TYPE_NORMAL
- en: match e {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Event::ClickEvent { x, y } => { // ... } Event::ResizeEvent { old_height, old_width,
    new_height, new_width, } => { // ... }        // ...
  prefs: []
  type: TYPE_NORMAL
- en: Event::UserEvent(
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: UserEvent::DoSomething { how_much },
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Event::UserEvent(
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: UserEvent::DoSomethingElse {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: how_many,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) => {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When representing events as an enum truly isn't feasible, sometimes double dispatch
    can be used instead. Otherwise it may be necessary to use the `Any` trait or to
    define an `Event` trait that exposes a type identifier that an be used for safe
    downcasting (via `Any`) or unsafe downcasting behind a safe interface.^([1](#footnote-safe-event-handler))
  prefs: []
  type: TYPE_NORMAL
- en: '[Library support for reflection via macros](#library-support-for-reflection-via-macros)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the use cases of RTTI can be achieved in Rust by using one of the third-party
    reflection libraries. These libraries implement reflection by providing macros
    for deriving traits to support common reflection operations. Rust reflection libraries
    include [bevy_reflect](https://docs.rs/bevy_reflect/latest/bevy_reflect/), [facet](https://facet.rs/),
    and [mirror-mirror](https://docs.rs/mirror-mirror/latest/mirror_mirror/).
  prefs: []
  type: TYPE_NORMAL
- en: The derive-macro approach to reflection essentially makes it opt-in, so that
    software that does not use reflection does not have to pay a price for it (performance
    costs or binary size). However, due to Rust's [orphan rule](https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules),
    this approach makes it more difficult to integrate third-party types that lack
    the derived trait.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Such an interface usually involves providing individual event handling functions
    for specific types, rather than a single large event handling function, so that
    the underlying implementation can managing the enforcement of the invariants required
    to make the casting safe. [↩](#fr-safe-event-handler-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Click here to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=RTTI
    and dynamic_cast)'
  prefs: []
  type: TYPE_NORMAL
