["```rs\n#include <string>\n#include <vector>\n\ntemplate <typename T>\nvoid push_if_even(int n,\n                  std::vector<T> &collection,\n                  T item) {\n  if (n % 2 == 0) {\n    collection.push_back(std::move(item));\n  }\n}\n\nint main() {\n  // Operate on the default std::vector\n  // implementation\n  std::vector<std::string> v{\"a\", \"b\"};\n  push_if_even(2, v, std::string(\"c\"));\n\n  // Operate on the (likely space-optimized)\n  // std::vector implementation\n  std::vector<bool> bv{false, true};\n  push_if_even(2, bv, false);\n} \n```", "```rs\n// The Extend trait is for types that support\n// appending values to the collection.\nfn push_if_even<T, I: Extend<T>>(\n    n: u32,\n    collection: &mut I,\n    item: T,\n) {\n    if n % 2 == 0 {\n        collection.extend([item]);\n    }\n}\n\nuse bitvec::prelude::*;\n\nfn main() {\n    // Operate on Vec\n    let mut v =\n        vec![\"a\".to_string(), \"b\".to_string()];\n    push_if_even(2, &mut v, \"c\".to_string());\n\n    // Operate on BitVec\n    let mut bv = bitvec![0, 1];\n    push_if_even(2, &mut bv, 0);\n}\n```", "```rs\ntemplate <totally_ordered T>\nT max(const T &x, const T &y) {\n  return (x > y) ? x : y;\n}\n\ntemplate <>\nint max(const int &x, const int &y) {\n  return (x > y) ? x + 1 : y + 1;\n} \n```", "```rs\n\n```", "```rs\n\n```"]