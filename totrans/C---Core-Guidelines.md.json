["```\n[[gsl::suppress(\"tag\")]] \n```", "```\n[[gsl::suppress(\"tag\", justification: \"message\")]] \n```", "```\nclass Date {\npublic:\n    Month month() const;  // do\n    int month();          // don't\n    // ...\n}; \n```", "```\nvoid f(vector<string>& v)\n{\n    string val;\n    cin >> val;\n    // ...\n    int index = -1;                    // bad, plus should use gsl::index\n    for (int i = 0; i < v.size(); ++i) {\n        if (v[i] == val) {\n            index = i;\n            break;\n        }\n    }\n    // ...\n} \n```", "```\nvoid f(vector<string>& v)\n{\n    string val;\n    cin >> val;\n    // ...\n    auto p = find(begin(v), end(v), val);  // better\n    // ...\n} \n```", "```\nchange_speed(double s);   // bad: what does s signify?\n// ...\nchange_speed(2.3); \n```", "```\nchange_speed(Speed s);    // better: the meaning of s is specified\n// ...\nchange_speed(2.3);        // error: no unit\nchange_speed(23_m / 10s);  // meters per second \n```", "```\ngsl::index i = 0;\nwhile (i < v.size()) {\n    // ... do something with v[i] ...\n} \n```", "```\nfor (const auto& x : v) { /* do something with the value of x */ } \n```", "```\nfor (auto& x : v) { /* modify x */ } \n```", "```\nfor_each(v, [](int x) { /* do something with the value of x */ });\nfor_each(par, v, [](int x) { /* do something with the value of x */ }); \n```", "```\ndraw_line(int, int, int, int);  // obscure: (x1,y1,x2,y2)? (x,y,h,w)? ...?\n                                // need to look up documentation to know\n\ndraw_line(Point, Point);        // clearer \n```", "```\n// Int is an alias used for integers\nint bits = 0;         // don't: avoidable code\nfor (Int i = 1; i; i <<= 1)\n    ++bits;\nif (bits < 32)\n    cerr << \"Int too small\\n\"; \n```", "```\n// Int is an alias used for integers\nstatic_assert(sizeof(Int) >= 4);    // do: compile-time check \n```", "```\nvoid read(int* p, int n);   // read max n integers into *p\n\nint a[100];\nread(a, 1000);    // bad, off the end \n```", "```\nvoid read(span<int> r); // read into the range of integers r\n\nint a[100];\nread(a);        // better: let the compiler figure out the number of elements \n```", "```\n// separately compiled, possibly dynamically loaded\nextern void f(int* p);\n\nvoid g(int n)\n{\n    // bad: the number of elements is not passed to f()\n    f(new int[n]);\n} \n```", "```\n// separately compiled, possibly dynamically loaded\nextern void f2(int* p, int n);\n\nvoid g2(int n)\n{\n    // bad: the wrong number of elements can be passed to f2()\n    f2(new int[n], n);\n} \n```", "```\n// separately compiled, possibly dynamically loaded\n// NB: this assumes the calling code is ABI-compatible, using a\n// compatible C++ compiler and the same stdlib implementation\nextern void f3(unique_ptr<int[]>, int n);\n\nvoid g3(int n)\n{\n    f3(make_unique<int[]>(n), m);    // bad: pass ownership and size separately\n} \n```", "```\nextern void f4(vector<int>&);   // separately compiled, possibly dynamically loaded\nextern void f4(span<int>);      // separately compiled, possibly dynamically loaded\n                                // NB: this assumes the calling code is ABI-compatible, using a\n                                // compatible C++ compiler and the same stdlib implementation\n\nvoid g3(int n)\n{\n    vector<int> v(n);\n    f4(v);                     // pass a reference, retain ownership\n    f4(span<int>{v});          // pass a view, retain ownership\n} \n```", "```\nvector<int> f5(int n)    // OK: move\n{\n    vector<int> v(n);\n    // ... initialize v ...\n    return v;\n}\n\nunique_ptr<int[]> f6(int n)    // bad: loses n\n{\n    auto p = make_unique<int[]>(n);\n    // ... initialize *p ...\n    return p;\n}\n\nowner<int*> f7(int n)    // bad: loses n and we might forget to delete\n{\n    owner<int*> p = new int[n];\n    // ... initialize *p ...\n    return p;\n} \n```", "```\nvoid increment1(int* p, int n)    // bad: error-prone\n{\n    for (int i = 0; i < n; ++i) ++p[i];\n}\n\nvoid use1(int m)\n{\n    const int n = 10;\n    int a[n] = {};\n    // ...\n    increment1(a, m);   // maybe typo, maybe m <= n is supposed\n                        // but assume that m == 20\n    // ...\n} \n```", "```\nvoid increment2(span<int> p)\n{\n    for (int& x : p) ++x;\n}\n\nvoid use2(int m)\n{\n    const int n = 10;\n    int a[n] = {};\n    // ...\n    increment2({a, m});    // maybe typo, maybe m <= n is supposed\n    // ...\n} \n```", "```\nvoid use3(int m)\n{\n    const int n = 10;\n    int a[n] = {};\n    // ...\n    increment2(a);   // the number of elements of a need not be repeated\n    // ...\n} \n```", "```\nDate read_date(istream& is);    // read date from istream\n\nDate extract_date(const string& s);    // extract date from string\n\nvoid user1(const string& date)    // manipulate date\n{\n    auto d = extract_date(date);\n    // ...\n}\n\nvoid user2()\n{\n    Date d = read_date(cin);\n    // ...\n    user1(d.to_string());\n    // ...\n} \n```", "```\nclass Jet {    // Physics says: e * e < x * x + y * y + z * z\n    float x;\n    float y;\n    float z;\n    float e;\npublic:\n    Jet(float x, float y, float z, float e)\n        :x(x), y(y), z(z), e(e)\n    {\n        // Should I check here that the values are physically meaningful?\n    }\n\n    float m() const\n    {\n        // Should I handle the degenerate case here?\n        return sqrt(x * x + y * y + z * z - e * e);\n    }\n\n    ???\n}; \n```", "```\nvoid f(char* name)\n{\n    FILE* input = fopen(name, \"r\");\n    // ...\n    if (something) return;   // bad: if something == true, a file handle is leaked\n    // ...\n    fclose(input);\n} \n```", "```\nvoid f(char* name)\n{\n    ifstream input {name};\n    // ...\n    if (something) return;   // OK: no leak\n    // ...\n} \n```", "```\nstruct X {\n    char ch;\n    int i;\n    string s;\n    char ch2;\n\n    X& operator=(const X& a);\n    X(const X&);\n};\n\nX waste(const char* p)\n{\n    if (!p) throw Nullptr_error{};\n    int n = strlen(p);\n    auto buf = new char[n];\n    if (!buf) throw Allocation_error{};\n    for (int i = 0; i < n; ++i) buf[i] = p[i];\n    // ... manipulate buffer ...\n    X x;\n    x.ch = 'a';\n    x.s = string(n);    // give x.s space for *p\n    for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // copy buf into x.s\n    delete[] buf;\n    return x;\n}\n\nvoid driver()\n{\n    X x = waste(\"Typical argument\");\n    // ...\n} \n```", "```\nvoid lower(zstring s)\n{\n    for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);\n} \n```", "```\nint sz = 100;\nint* p = (int*) malloc(sizeof(int) * sz);\nint count = 0;\n// ...\nfor (;;) {\n    // ... read an int into x, exit loop if end of file is reached ...\n    // ... check that x is valid ...\n    if (count == sz)\n        p = (int*) realloc(p, sizeof(int) * sz * 2);\n    p[count++] = x;\n    // ...\n} \n```", "```\nvector<int> v;\nv.reserve(100);\n// ...\nfor (int x; cin >> x; ) {\n    // ... check that x is valid ...\n    v.push_back(x);\n} \n```", "```\nstd::sort(begin(v), end(v), std::greater<>()); \n```", "```\nint round(double d)\n{\n    return (round_up) ? ceil(d) : d;    // don't: \"invisible\" dependency\n} \n```", "```\n// don't: no test of fprintf's return value\nfprintf(connection, \"logging: %d %d %d\\n\", x, y, s); \n```", "```\nstruct Data {\n    // ... lots of stuff ...\n} data;            // non-const data\n\nvoid compute()     // don't\n{\n    // ... use data ...\n}\n\nvoid output()     // don't\n{\n    // ... use data ...\n} \n```", "```\nclass Singleton {\n    // ... lots of stuff to ensure that only one Singleton object is created,\n    // that it is initialized properly, etc.\n}; \n```", "```\nX& myX()\n{\n    static X my_x {3};\n    return my_x;\n} \n```", "```\nX& myX()\n{\n    static auto p = new X {3};\n    return *p;  // potential leak\n} \n```", "```\nvoid pass(void* data);    // weak and under-qualified type void* is suspicious \n```", "```\ndraw_rect(100, 200, 100, 500); // what do the numbers specify?\n\ndraw_rect(p.x, p.y, 10, 20); // what units are 10 and 20 in? \n```", "```\nvoid draw_rectangle(Point top_left, Point bottom_right);\nvoid draw_rectangle(Point top_left, Size height_width);\n\ndraw_rectangle(p, Point{10, 20});  // two corners\ndraw_rectangle(p, Size{10, 20});   // one corner and a (height, width) pair \n```", "```\nset_settings(true, false, 42); // what do the numbers specify? \n```", "```\nalarm_settings s{};\ns.enabled = true;\ns.displayMode = alarm_settings::mode::spinning_light;\ns.frequency = alarm_settings::every_10_seconds;\nset_settings(s); \n```", "```\nenable_lamp_options(lamp_option::on | lamp_option::animate_state_transitions); \n```", "```\nvoid blink_led(int time_to_blink) // bad -- the unit is ambiguous\n{\n    // ...\n    // do something with time_to_blink\n    // ...\n}\n\nvoid use()\n{\n    blink_led(2);\n} \n```", "```\nvoid blink_led(milliseconds time_to_blink) // good -- the unit is explicit\n{\n    // ...\n    // do something with time_to_blink\n    // ...\n}\n\nvoid use()\n{\n    blink_led(1500ms);\n} \n```", "```\ntemplate<class rep, class period>\nvoid blink_led(duration<rep, period> time_to_blink) // good -- accepts any unit\n{\n    // assuming that millisecond is the smallest relevant unit\n    auto milliseconds_to_blink = duration_cast<milliseconds>(time_to_blink);\n    // ...\n    // do something with milliseconds_to_blink\n    // ...\n}\n\nvoid use()\n{\n    blink_led(2s);\n    blink_led(1500ms);\n} \n```", "```\ndouble sqrt(double x); \n```", "```\ndouble sqrt(double x); // x must be non-negative \n```", "```\ndouble sqrt(double x) { Expects(x >= 0); /* ... */ } \n```", "```\nint area(int height, int width)\n{\n    Expects(height > 0 && width > 0);            // good\n    if (height <= 0 || width <= 0) my_error();   // obscure\n    // ...\n} \n```", "```\nint area(int height, int width) { return height * width; }  // bad \n```", "```\nint area(int height, int width)\n{\n    auto res = height * width;\n    Ensures(res > 0);\n    return res;\n} \n```", "```\nvoid f()    // problematic\n{\n    char buffer[MAX];\n    // ...\n    memset(buffer, 0, sizeof(buffer));\n} \n```", "```\nvoid f()    // better\n{\n    char buffer[MAX];\n    // ...\n    memset(buffer, 0, sizeof(buffer));\n    Ensures(buffer[0] == 0);\n} \n```", "```\nmutex m;\n\nvoid manipulate(Record& r)    // don't\n{\n    m.lock();\n    // ... no m.unlock() ...\n} \n```", "```\nvoid manipulate(Record& r)    // postcondition: m is unlocked upon exit\n{\n    m.lock();\n    // ... no m.unlock() ...\n} \n```", "```\nvoid manipulate(Record& r)    // best\n{\n    lock_guard<mutex> _ {m};\n    // ...\n} \n```", "```\nvoid f()\n{\n    char buffer[MAX];\n    // ...\n    memset(buffer, 0, MAX);\n    Ensures(buffer[0] == 0);\n} \n```", "```\ntemplate<typename Iter, typename Val>\n  requires input_iterator<Iter> && equality_comparable_with<iter_value_t<Iter>, Val>\nIter find(Iter first, Iter last, Val v)\n{\n    // ...\n} \n```", "```\nint printf(const char* ...);    // bad: return negative number if output fails\n\ntemplate<class F, class ...Args>\n// good: throw system_error if unable to start the new thread\nexplicit thread(F&& f, Args&&... args); \n```", "```\nint val;\nint error_code;\ntie(val, error_code) = do_something();\nif (error_code) {\n    // ... handle the error or exit ...\n}\n// ... use val ... \n```", "```\nauto [val, error_code] = do_something();\nif (error_code) {\n    // ... handle the error or exit ...\n}\n// ... use val ... \n```", "```\nX* compute(args)    // don't\n{\n    X* res = new X{};\n    // ...\n    return res;\n} \n```", "```\nvector<double> compute(args)  // good\n{\n    vector<double> res(10000);\n    // ...\n    return res;\n} \n```", "```\nowner<X*> compute(args)    // It is now clear that ownership is transferred\n{\n    owner<X*> res = new X{};\n    // ...\n    return res;\n} \n```", "```\nint length(const char* p);            // it is not clear whether length(nullptr) is valid\n\nlength(nullptr);                      // OK?\n\nint length(not_null<const char*> p);  // better: we can assume that p cannot be nullptr\n\nint length(const char* p);            // we must assume that p can be nullptr \n```", "```\n// we can assume that p cannot be nullptr\n// we can assume that p points to a zero-terminated array of characters\nint length(not_null<czstring> p); \n```", "```\nvoid copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n) \n```", "```\nvoid copy(span<const T> r, span<T> r2); // copy r to r2 \n```", "```\nvoid draw(Shape* p, int n);  // poor interface; poor code\nCircle arr[10];\n// ...\ndraw(arr, 10); \n```", "```\nvoid draw2(span<Circle>);\nCircle arr[10];\n// ...\ndraw2(span<Circle>(arr));  // deduce the number of elements\ndraw2(arr);    // deduce the element type and array size\n\nvoid draw3(span<Shape>);\ndraw3(arr);    // error: cannot convert Circle[10] to span<Shape> \n```", "```\n// file1.c\n\nextern const X x;\n\nconst Y y = f(x);   // read x; write y\n\n// file2.c\n\nextern const Y y;\n\nconst X x = g(y);   // read y; write x \n```", "```\ntemplate<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\nOutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2,\n                     OutputIterator result, Compare comp); \n```", "```\ntemplate<class InputIterator1, class InputIterator2, class OutputIterator>\nOutputIterator merge(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2,\n                     OutputIterator result); \n```", "```\ntemplate<class InputRange1, class InputRange2, class OutputIterator>\nOutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result); \n```", "```\ntemplate<class In1, class In2, class Out>\n  requires mergeable<In1, In2, Out>\nOut merge(In1 r1, In2 r2, Out result); \n```", "```\nvoid f(int* some_ints, int some_ints_length);  // BAD: C style, unsafe \n```", "```\nvoid f(gsl::span<int> some_ints);              // GOOD: safe, bounds-checked \n```", "```\nvoid copy_n(T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n) \n```", "```\nvoid copy_n(const T* p, T* q, int n);  // copy from [p:p + n) to [q:q + n) \n```", "```\nint max(int a, int b); \n```", "```\nvoid copy_n(span<const T> p, span<T> q);  // copy from p to q \n```", "```\nstruct SystemParams {\n    string config_file;\n    string output_path;\n    seconds timeout;\n};\nvoid initialize(SystemParams p); \n```", "```\nclass Shape {  // bad: interface class loaded with data\npublic:\n    Point center() const { return c; }\n    virtual void draw() const;\n    virtual void rotate(int);\n    // ...\nprivate:\n    Point c;\n    vector<Point> outline;\n    Color col;\n}; \n```", "```\nclass Shape {    // better: Shape is a pure interface\npublic:\n    virtual Point center() const = 0;   // pure virtual functions\n    virtual void draw() const = 0;\n    virtual void rotate(int) = 0;\n    // ...\n    // ... no data members ...\n    // ...\n    virtual ~Shape() = default;\n}; \n```", "```\nclass widget {\n    class impl;\n    std::unique_ptr<impl> pimpl;\npublic:\n    void draw(); // public API that will be forwarded to the implementation\n    widget(int); // defined in the implementation file\n    ~widget();   // defined in the implementation file, where impl is a complete type\n    widget(widget&&) noexcept; // defined in the implementation file\n    widget(const widget&) = delete;\n    widget& operator=(widget&&) noexcept; // defined in the implementation file\n    widget& operator=(const widget&) = delete;\n}; \n```", "```\nclass widget::impl {\n    int n; // private data\npublic:\n    void draw(const widget& w) { /* ... */ }\n    impl(int n) : n(n) {}\n};\nvoid widget::draw() { pimpl->draw(*this); }\nwidget::widget(int n) : pimpl{std::make_unique<impl>(n)} {}\nwidget::widget(widget&&) noexcept = default;\nwidget::~widget() = default;\nwidget& widget::operator=(widget&&) noexcept = default; \n```", "```\nbool owned;\nowner<istream*> inp;\nswitch (source) {\ncase std_in:        owned = false; inp = &cin;                       break;\ncase command_line:  owned = true;  inp = new istringstream{argv[2]}; break;\ncase file:          owned = true;  inp = new ifstream{argv[2]};      break;\n}\nistream& in = *inp; \n```", "```\nif (owned) delete inp; \n```", "```\nclass Istream { [[gsl::suppress(\"lifetime\")]]\npublic:\n    enum Opt { from_line = 1 };\n    Istream() { }\n    Istream(czstring p) : owned{true}, inp{new ifstream{p}} {}            // read from file\n    Istream(czstring p, Opt) : owned{true}, inp{new istringstream{p}} {}  // read from command line\n    ~Istream() { if (owned) delete inp; }\n    operator istream&() { return *inp; }\nprivate:\n    bool owned = false;\n    istream* inp = &cin;\n}; \n```", "```\nvoid read_and_print(istream& is)    // read and print an int\n{\n    int x;\n    if (is >> x)\n        cout << \"the int is \" << x << '\\n';\n    else\n        cerr << \"no int on input\\n\";\n} \n```", "```\nsort(a, b, [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); }); \n```", "```\nauto lessT = [](T x, T y) { return x.rank() < y.rank() && x.value() < y.value(); };\n\nsort(a, b, lessT); \n```", "```\nvoid read_and_print()    // bad\n{\n    int x;\n    cin >> x;\n    // check for errors\n    cout << x << \"\\n\";\n} \n```", "```\nint read(istream& is)    // better\n{\n    int x;\n    is >> x;\n    // check for errors\n    return x;\n}\n\nvoid print(ostream& os, int x)\n{\n    os << x << \"\\n\";\n} \n```", "```\nvoid read_and_print()\n{\n    auto x = read(cin);\n    print(cout, x);\n} \n```", "```\nauto read = [](auto& input, auto& value)    // better\n{\n    input >> value;\n    // check for errors\n};\n\nvoid print(auto& output, const auto& value)\n{\n    output << value << \"\\n\";\n} \n```", "```\ndouble simple_func(double val, int flag1, int flag2)\n    // simple_func: takes a value and calculates the expected ASIC output,\n    // given the two mode flags.\n{\n    double intermediate;\n    if (flag1 > 0) {\n        intermediate = func1(val);\n        if (flag2 % 2)\n             intermediate = sqrt(intermediate);\n    }\n    else if (flag1 == -1) {\n        intermediate = func1(-val);\n        if (flag2 % 2)\n             intermediate = sqrt(-intermediate);\n        flag1 = -flag1;\n    }\n    if (abs(flag2) > 10) {\n        intermediate = func2(intermediate);\n    }\n    switch (flag2 / 10) {\n    case 1: if (flag1 == -1) return finalize(intermediate, 1.171);\n            break;\n    case 2: return finalize(intermediate, 13.1);\n    default: break;\n    }\n    return finalize(intermediate, 0.);\n} \n```", "```\ndouble func1_muon(double val, int flag)\n{\n    // ???\n}\n\ndouble func1_tau(double val, int flag1, int flag2)\n{\n    // ???\n}\n\ndouble simple_func(double val, int flag1, int flag2)\n    // simple_func: takes a value and calculates the expected ASIC output,\n    // given the two mode flags.\n{\n    if (flag1 > 0)\n        return func1_muon(val, flag2);\n    if (flag1 == -1)\n        // handled by func1_tau: flag1 = -flag1;\n        return func1_tau(-val, flag1, flag2);\n    return 0.;\n} \n```", "```\nconstexpr int fac(int n)\n{\n    constexpr int max_exp = 17;      // constexpr enables max_exp to be used in Expects\n    Expects(0 <= n && n < max_exp);  // prevent silliness and overflow\n    int x = 1;\n    for (int i = 2; i <= n; ++i) x *= i;\n    return x;\n} \n```", "```\nconstexpr int min(int x, int y) { return x < y ? x : y; }\n\nvoid test(int v)\n{\n    int m1 = min(-1, 2);            // probably compile-time evaluation\n    constexpr int m2 = min(-1, 2);  // compile-time evaluation\n    int m3 = min(-1, v);            // run-time evaluation\n    constexpr int m4 = min(-1, v);  // error: cannot evaluate at compile time\n} \n```", "```\ninline string cat(const string& s, const string& s2) { return s + s2; } \n```", "```\nvector<string> collect(istream& is) noexcept\n{\n    vector<string> res;\n    for (string s; is >> s;)\n        res.push_back(s);\n    return res;\n} \n```", "```\n// accepts any int*\nvoid f(int*);\n\n// can only accept ints for which you want to transfer ownership\nvoid g(unique_ptr<int>);\n\n// can only accept ints for which you are willing to share ownership\nvoid g(shared_ptr<int>);\n\n// doesn't change ownership, but requires a particular ownership of the caller\nvoid h(const unique_ptr<int>&);\n\n// accepts any int\nvoid h(int&); \n```", "```\n// callee\nvoid f(shared_ptr<widget>& w)\n{\n    // ...\n    use(*w); // only use of w -- the lifetime is not used at all\n    // ...\n};\n\n// caller\nshared_ptr<widget> my_widget = /* ... */;\nf(my_widget);\n\nwidget stack_widget;\nf(stack_widget); // error \n```", "```\n// callee\nvoid f(widget& w)\n{\n    // ...\n    use(w);\n    // ...\n};\n\n// caller\nshared_ptr<widget> my_widget = /* ... */;\nf(*my_widget);\n\nwidget stack_widget;\nf(stack_widget); // ok -- now this works \n```", "```\ntemplate<class T>\nauto square(T t) { return t * t; } \n```", "```\nwidget* find(const set<widget>& s, const widget& w, Hint);   // once upon a time, a hint was used \n```", "```\ntemplate <typename Value>\nValue* find(const set<Value>& s, const Value& v, [[maybe_unused]] Hint h)\n{\n    if constexpr (sizeof(Value) > CacheSize)\n    {\n        // a hint is used only if Value is of a certain size\n    }\n} \n```", "```\nstruct Rec {\n    string name;\n    string addr;\n    int id;         // unique identifier\n};\n\nbool same(const Rec& a, const Rec& b)\n{\n    return a.id == b.id;\n}\n\nvector<Rec*> find_id(const string& name);    // find all records for \"name\"\n\nauto x = find_if(vr.begin(), vr.end(),\n    [&](Rec& r) {\n        if (r.name.size() != n.size()) return false; // name to compare to is in n\n        for (int i = 0; i < r.name.size(); ++i)\n            if (tolower(r.name[i]) != tolower(n[i])) return false;\n        return true;\n    }\n); \n```", "```\nbool compare_insensitive(const string& a, const string& b)\n{\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;\n    return true;\n}\n\nauto x = find_if(vr.begin(), vr.end(),\n    [&](Rec& r) { return compare_insensitive(r.name, n); }\n); \n```", "```\nauto cmp_to_n = [&n](const string& a) { return compare_insensitive(a, n); };\n\nauto x = find_if(vr.begin(), vr.end(),\n    [](const Rec& r) { return cmp_to_n(r.name); }\n); \n```", "```\nauto earlyUsersEnd = std::remove_if(users.begin(), users.end(),\n                                    [](const User &a) { return a.id > 100; }); \n```", "```\nvoid f1(const string& s);  // OK: pass by reference to const; always cheap\n\nvoid f2(string s);         // bad: potentially expensive\n\nvoid f3(int x);            // OK: Unbeatable\n\nvoid f4(const int& x);     // bad: overhead on access in f4() \n```", "```\nint multiply(int, int); // just input ints, pass by value\n\n// suffix is input-only but not as cheap as an int, pass by const&\nstring& concatenate(string&, const string& suffix);\n\nvoid sink(unique_ptr<widget>);  // input only, and moves ownership of the widget \n```", "```\nvoid update(Record& r);  // assume that update writes to r \n```", "```\nvoid increment_all(span<int> a)\n{\n  for (auto&& e : a)\n    ++e;\n} \n```", "```\nvoid f(string& s)\n{\n    s = \"New York\";  // non-obvious error\n}\n\nvoid g()\n{\n    string buffer = \".................................\";\n    f(buffer);\n    // ...\n} \n```", "```\nvoid sink(vector<int>&& v)  // sink takes ownership of whatever the argument owned\n{\n    // usually there might be const accesses of v here\n    store_somewhere(std::move(v));\n    // usually no more use of v here; it is moved-from\n} \n```", "```\ntemplate<class T>\nvoid sink(std::unique_ptr<T> p)\n{\n    // use p ... possibly std::move(p) onward somewhere else\n}   // p gets destroyed \n```", "```\ntemplate<class F, class... Args>\ninline decltype(auto) invoke(F&& f, Args&&... args)\n{\n    return forward<F>(f)(forward<Args>(args)...);\n} \n```", "```\ntemplate<class PairLike>\ninline auto test(PairLike&& pairlike)\n{\n    // ...\n    f1(some, args, and, forward<PairLike>(pairlike).first);           // forward .first\n    f2(and, forward<PairLike>(pairlike).second, in, another, call);   // forward .second\n} \n```", "```\n// OK: return pointers to elements with the value x\nvector<const int*> find_all(const vector<int>&, int x);\n\n// Bad: place pointers to elements with value x in-out\nvoid find_all(const vector<int>&, vector<const int*>& out, int x); \n```", "```\nMatrix operator+(const Matrix& a, const Matrix& b)\n{\n    Matrix res;\n    // ... fill res with the sum ...\n    return res;\n}\n\nMatrix x = m1 + m2;  // move constructor\n\ny = m3 + m3;         // move assignment \n```", "```\nstruct Package {      // exceptional case: expensive-to-move object\n    char header[16];\n    char load[2024 - 16];\n};\n\nPackage fill();       // Bad: large return value\nvoid fill(Package&);  // OK\n\nint val();            // OK\nvoid val(int&);       // Bad: Is val reading its argument \n```", "```\n// BAD: output-only parameter documented in a comment\nint f(const string& input, /*output only*/ string& output_data)\n{\n    // ...\n    output_data = something();\n    return status;\n}\n\n// GOOD: self-documenting\nstruct f_result { int status; string data; };\n\nf_result f(const string& input)\n{\n    // ...\n    return {status, something()};\n} \n```", "```\n// C++98\npair<set::iterator, bool> result = my_set.insert(\"Hello\");\nif (result.second)\n    do_something_with(result.first);    // workaround \n```", "```\nif (auto [ iter, success ] = my_set.insert(\"Hello\"); success)\n    do_something_with(iter); \n```", "```\nistream& operator>>(istream& in, string& s);    // much like std::operator>>()\n\nfor (string s; in >> s; ) {\n    // do something with line\n} \n```", "```\nstruct get_string_result { istream& in; string s; };\n\nget_string_result get_string(istream& in)  // not recommended\n{\n    string s;\n    in >> s;\n    return { in, move(s) };\n}\n\nfor (auto [in, s] = get_string(cin); in; s = get_string(in).s) {\n    // do something with string\n} \n```", "```\nstruct Distance {\n    int value;\n    int unit = 1;   // 1 means meters\n};\n\nDistance d1 = measure(obj1);        // access d1.value and d1.unit\nauto d2 = measure(obj2);            // access d2.value and d2.unit\nauto [value, unit] = measure(obj3); // access value and unit; somewhat redundant\n                                    // to people who know measure()\nauto [x, y] = measure(obj4);        // don't; it's likely to be confusing \n```", "```\npair<LargeObject, LargeObject> f(const string& input)\n{\n    LargeObject large1 = g(input);\n    LargeObject large2 = h(input);\n    // ...\n    return { move(large1), move(large2) }; // no copies\n} \n```", "```\npair<LargeObject, LargeObject> f(const string& input)\n{\n    // ...\n    return { g(input), h(input) }; // no copies, no moves\n} \n```", "```\nstring zstring_to_string(zstring p) // zstring is a char*; that is a C-style string\n{\n    if (!p) return string{};    // p might be nullptr; remember to check\n    return string{p};\n}\n\nvoid print(const vector<int>& r)\n{\n    // r refers to a vector<int>; no check needed\n} \n```", "```\nvoid use(int* p, int n, char* s, int* q)\n{\n    p[n - 1] = 666; // Bad: we don't know if p points to n elements;\n                    // assume it does not or use span<int>\n    cout << s;      // Bad: we don't know if that s points to a zero-terminated array of char;\n                    // assume it does not or use zstring\n    delete q;       // Bad: we don't know if *q is allocated on the free store;\n                    // assume it does not or use owner\n} \n```", "```\nvoid use2(span<int> p, zstring s, owner<int*> q)\n{\n    p[p.size() - 1] = 666; // OK, a range error can be caught\n    cout << s; // OK\n    delete q;  // OK\n} \n```", "```\nint length(Record* p); \n```", "```\n// it is the caller's job to make sure p != nullptr\nint length(not_null<Record*> p);\n\n// the implementor of length() must assume that p == nullptr is possible\nint length(Record* p); \n```", "```\nX* find(span<X> r, const X& v);    // find v in r\n\nvector<X> vec;\n// ...\nauto p = find({vec.begin(), vec.end()}, X{});  // find X{} in vec \n```", "```\nvoid f(span<int> s)\n{\n    // range traversal (guaranteed correct)\n    for (int x : s) cout << x << '\\n';\n\n    // C-style traversal (potentially checked)\n    for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\\n';\n\n    // random access (potentially checked)\n    s[7] = 9;\n\n    // extract pointers (potentially checked)\n    std::sort(&s[0], &s[s.size() / 2]);\n} \n```", "```\nint length(const char* p); \n```", "```\n// the implementor of length() must assume that p == nullptr is possible\nint length(zstring p);\n\n// it is the caller's job to make sure p != nullptr\nint length(not_null<zstring> p); \n```", "```\nunique_ptr<Shape> get_shape(istream& is)  // assemble shape from input stream\n{\n    auto kind = read_header(is); // read header and identify the next shape on input\n    switch (kind) {\n    case kCircle:\n        return make_unique<Circle>(is);\n    case kTriangle:\n        return make_unique<Triangle>(is);\n    // ...\n    }\n} \n```", "```\n{\n    shared_ptr<const Image> im { read_image(somewhere) };\n\n    std::thread t0 {shade, args0, top_left, im};\n    std::thread t1 {shade, args1, top_right, im};\n    std::thread t2 {shade, args2, bottom_left, im};\n    std::thread t3 {shade, args3, bottom_right, im};\n\n    // detaching threads requires extra care (e.g., to join before\n    // main ends), but even if we do detach the four threads here ...\n}\n// ... shared_ptr ensures that eventually the last thread to\n//     finish safely deletes the image \n```", "```\nNode* find(Node* t, const string& s)  // find s in a binary tree of Nodes\n{\n    if (!t || t->name == s) return t;\n    if ((auto p = find(t->left, s))) return p;\n    if ((auto p = find(t->right, s))) return p;\n    return nullptr;\n} \n```", "```\nint* f()\n{\n    int fx = 9;\n    return &fx;  // BAD\n}\n\nvoid g(int* p)   // looks innocent enough\n{\n    int gx;\n    cout << \"*p == \" << *p << '\\n';\n    *p = 999;\n    cout << \"gx == \" << gx << '\\n';\n}\n\nvoid h()\n{\n    int* p = f();\n    int z = *p;  // read from abandoned stack frame (bad)\n    g(p);        // pass pointer to abandoned stack frame to function (bad)\n} \n```", "```\n*p == 999\ngx == 999 \n```", "```\nint& f()\n{\n    int x = 7;\n    // ...\n    return x;  // Bad: returns reference to object that is about to be destroyed\n} \n```", "```\nint* glob;       // global variables are bad in so many ways\n\ntemplate<class T>\nvoid steal(T x)\n{\n    glob = x();  // BAD\n}\n\nvoid f()\n{\n    int i = 99;\n    steal([&] { return &i; });\n}\n\nint main()\n{\n    f();\n    cout << *glob << '\\n';\n} \n```", "```\nclass Car\n{\n    array<wheel, 4> w;\n    // ...\npublic:\n    wheel& get_wheel(int i) { Expects(i < w.size()); return w[i]; }\n    // ...\n};\n\nvoid use()\n{\n    Car c;\n    wheel& w0 = c.get_wheel(0); // w0 has the same lifetime as c\n} \n```", "```\nauto&& x = max(0, 1);   // OK, so far\nfoo(x);                 // Undefined behavior \n```", "```\ntemplate<class F>\nauto&& wrapper(F f)\n{\n    log_call(typeid(f)); // or whatever instrumentation\n    return f();          // BAD: returns a reference to a temporary\n} \n```", "```\ntemplate<class F>\nauto wrapper(F f)\n{\n    log_call(typeid(f)); // or whatever instrumentation\n    return f();          // OK\n} \n```", "```\n void main() { /* ... */ };  // bad, not C++\n\n    int main()\n    {\n        std::cout << \"This is the way to do it\\n\";\n    } \n```", "```\nclass Foo\n{\n public:\n    ...\n    Foo& operator=(const Foo& rhs)\n    {\n      // Copy members.\n      ...\n      return *this;\n    }\n}; \n```", "```\nS bad()\n{\n  S result;\n  return std::move(result);\n} \n```", "```\nS good()\n{\n  S result;\n  // Named RVO: move elision at best, move construction at worst\n  return result;\n} \n```", "```\nconst vector<int> fct();    // bad: that \"const\" is more trouble than it is worth\n\nvoid g(vector<int>& vx)\n{\n    // ...\n    fct() = vx;   // prevented by the \"const\"\n    // ...\n    vx = fct(); // expensive copy: move semantics suppressed by the \"const\"\n    // ...\n} \n```", "```\n// writing a function that should only take an int or a string\n// -- overloading is natural\nvoid f(int);\nvoid f(const string&);\n\n// writing a function object that needs to capture local state and appear\n// at statement or expression scope -- a lambda is natural\nvector<work> v = lots_of_work();\nfor (int tasknum = 0; tasknum < max; ++tasknum) {\n    pool.run([=, &v] {\n        /*\n        ...\n        ... process (1/max)-th of v, the tasknum-th chunk\n        ...\n        */\n    });\n}\npool.join(); \n```", "```\nvoid print(const string& s, format f = {}); \n```", "```\nvoid print(const string& s);  // use default format\nvoid print(const string& s, format f); \n```", "```\nvoid print(const char&);\nvoid print(int);\nvoid print(zstring); \n```", "```\nstd::for_each(begin(sockets), end(sockets), [&message](auto& socket)\n{\n    socket.send(message);\n}); \n```", "```\nvoid send_packets(buffers& bufs)\n{\n    stage encryptor([](buffer& b) { encrypt(b); });\n    stage compressor([&](buffer& b) { compress(b); encryptor.process(b); });\n    stage decorator([&](buffer& b) { decorate(b); compressor.process(b); });\n    for (auto& b : bufs) { decorator.process(b); }\n}  // automatically blocks waiting for pipeline to finish \n```", "```\nint local = 42;\n\n// Want a reference to local.\n// Note that after program exits this scope,\n// local no longer exists, therefore\n// process() call will have undefined behavior!\nthread_pool.queue_work([&] { process(local); }); \n```", "```\nint local = 42;\n// Want a copy of local.\n// Since a copy of local is made, it will\n// always be available for the call.\nthread_pool.queue_work([=] { process(local); }); \n```", "```\nclass My_class {\n    int x = 0;\n    // ...\n\n    void f()\n    {\n        int i = 0;\n        // ...\n\n        auto lambda = [=] { use(i, x); };   // BAD: \"looks like\" copy/value capture\n\n        x = 42;\n        lambda(); // calls use(0, 42);\n        x = 43;\n        lambda(); // calls use(0, 43);\n\n        // ...\n\n        auto lambda2 = [i, this] { use(i, x); }; // ok, most explicit and least confusing\n\n        // ...\n    }\n}; \n```", "```\nint sum(...)\n{\n    // ...\n    while (/*...*/)\n        result += va_arg(list, int); // BAD, assumes it will be passed ints\n    // ...\n}\n\nsum(3, 2); // ok\nsum(3.14159, 2.71828); // BAD, undefined\n\ntemplate<class ...Args>\nauto sum(Args... args) // GOOD, and much more flexible\n{\n    return (... + args); // note: C++17 \"fold expression\"\n}\n\nsum(3, 2); // ok: 5\nsum(3.14159, 2.71828); // ok: ~5.85987 \n```", "```\n// Bad: Deep nesting\nvoid foo() {\n    ...\n    if (x) {\n        computeImportantThings(x);\n    }\n}\n\n// Bad: Still a redundant else.\nvoid foo() {\n    ...\n    if (!x) {\n        return;\n    }\n    else {\n        computeImportantThings(x);\n    }\n}\n\n// Good: Early return, no redundant else\nvoid foo() {\n    ...\n    if (!x)\n        return;\n\n    computeImportantThings(x);\n} \n```", "```\n// Bad: Unnecessary nesting of conditions\nvoid foo() {\n    ...\n    if (x) {\n        if (y) {\n            computeImportantThings(x);\n        }\n    }\n}\n\n// Good: Merge conditions + return early\nvoid foo() {\n    ...\n    if (!(x && y))\n        return;\n\n    computeImportantThings(x);\n} \n```", "```\nvoid draw(int x, int y, int x2, int y2);  // BAD: unnecessary implicit relationships\nvoid draw(Point from, Point to);          // better \n```", "```\nstruct Pair {  // the members can vary independently\n    string name;\n    int volume;\n}; \n```", "```\nclass Date {\npublic:\n    // validate that {yy, mm, dd} is a valid date and initialize\n    Date(int yy, Month mm, char dd);\n    // ...\nprivate:\n    int y;\n    Month m;\n    char d;    // day\n}; \n```", "```\nclass Date {\npublic:\n    Date();\n    // validate that {yy, mm, dd} is a valid date and initialize\n    Date(int yy, Month mm, char dd);\n\n    int day() const;\n    Month month() const;\n    // ...\nprivate:\n    // ... some representation ...\n}; \n```", "```\nclass Date {\n    // ... relatively small interface ...\n};\n\n// helper functions:\nDate next_weekday(Date);\nbool operator==(Date, Date); \n```", "```\nclass Foobar {\npublic:\n    void foo(long x) { /* manipulate private data */ }\n    void foo(double x) { foo(std::lround(x)); }\n    // ...\nprivate:\n    // ...\n}; \n```", "```\nx.scale(0.5).rotate(45).set_color(Color::red); \n```", "```\nnamespace Chrono { // here we keep time-related services\n\n    class Time { /* ... */ };\n    class Date { /* ... */ };\n\n    // helper functions:\n    bool operator==(Date, Date);\n    Date next_weekday(Date);\n    // ...\n} \n```", "```\nstruct Data { /*...*/ } data{ /*...*/ }; \n```", "```\nstruct Data { /*...*/ };\nData data{ /*...*/ }; \n```", "```\nstruct Date {\n    int d, m;\n\n    Date(int i, Month m);\n    // ... lots of functions ...\nprivate:\n    int y;  // year\n}; \n```", "```\ntemplate<typename T, typename U>\nstruct pair {\n    T a;\n    U b;\n    // ...\n}; \n```", "```\nclass Distance {\npublic:\n    // ...\n    double meters() const { return magnitude*unit; }\n    void set_unit(double u)\n    {\n            // ... check that u is a factor of 10 ...\n            // ... change magnitude appropriately ...\n            unit = u;\n    }\n    // ...\nprivate:\n    double magnitude;\n    double unit;    // 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc.\n}; \n```", "```\nclass Foo {\npublic:\n    int bar(int x) { check(x); return do_bar(x); }\n    // ...\nprotected:\n    int do_bar(int x); // do some operation on the data\n    // ...\nprivate:\n    // ... data ...\n};\n\nclass Dir : public Foo {\n    //...\n    int mem(int x, int y)\n    {\n        /* ... do something ... */\n        return do_bar(x + y); // OK: derived class can bypass check\n    }\n};\n\nvoid user(Foo& x)\n{\n    int r1 = x.bar(1);      // OK, will check\n    int r2 = x.do_bar(2);   // error: would bypass check\n    // ...\n} \n```", "```\nclass Point1 {\n    int x, y;\n    // ... operations ...\n    // ... no virtual functions ...\n};\n\nclass Point2 {\n    int x, y;\n    // ... operations, some virtual ...\n    virtual ~Point2();\n};\n\nvoid use()\n{\n    Point1 p11 {1, 2};   // make an object on the stack\n    Point1 p12 {p11};    // a copy\n\n    auto p21 = make_unique<Point2>(1, 2);   // make an object on the free store\n    auto p22 = p21->clone();                // make a copy\n    // ...\n} \n```", "```\nstruct Bundle {\n    string name;\n    vector<Record> vr;\n};\n\nbool operator==(const Bundle& a, const Bundle& b)\n{\n    return a.name == b.name && a.vr == b.vr;\n}\n\nBundle b1 { \"my bundle\", {r1, r2, r3}};\nBundle b2 = b1;\nif (!(b1 == b2)) error(\"impossible!\");\nb2.name = \"the other bundle\";\nif (b1 == b2) error(\"No!\"); \n```", "```\nclass bad {\n    const int i;    // bad\n    string& s;      // bad\n    // ...\n}; \n```", "```\nstruct Named_map {\npublic:\n    explicit Named_map(const string& n) : name(n) {}\n    // no copy/move constructors\n    // no copy/move assignment operators\n    // no destructor\nprivate:\n    string name;\n    map<int, int> rep;\n};\n\nNamed_map nm(\"map\"); // construct\nNamed_map nm2 {nm};  // copy construct \n```", "```\nstruct M2 {   // bad: incomplete set of copy/move/destructor operations\npublic:\n    // ...\n    // ... no copy or move operations ...\n    ~M2() { delete[] rep; }\nprivate:\n    pair<int, int>* rep;  // zero-terminated set of pairs\n};\n\nvoid use()\n{\n    M2 x;\n    M2 y;\n    // ...\n    x = y;   // the default assignment\n    // ...\n} \n```", "```\nclass AbstractBase {\npublic:\n    virtual void foo() = 0;  // at least one abstract method to make the class abstract\n    virtual ~AbstractBase() = default;\n    // ...\n}; \n```", "```\nclass CloneableBase {\npublic:\n    virtual unique_ptr<CloneableBase> clone() const;\n    virtual ~CloneableBase() = default;\n    CloneableBase() = default;\n    CloneableBase(const CloneableBase&) = delete;\n    CloneableBase& operator=(const CloneableBase&) = delete;\n    CloneableBase(CloneableBase&&) = delete;\n    CloneableBase& operator=(CloneableBase&&) = delete;\n    // ... other constructors and functions ...\n}; \n```", "```\nclass X {\npublic:\n    // ...\n    virtual ~X() = default;               // destructor (virtual if X is meant to be a base class)\n    X(const X&) = default;                // copy constructor\n    X& operator=(const X&) = default;     // copy assignment\n    X(X&&) noexcept = default;            // move constructor\n    X& operator=(X&&) noexcept = default; // move assignment\n}; \n```", "```\nclass Silly {   // BAD: Inconsistent copy operations\n    class Impl {\n        // ...\n    };\n    shared_ptr<Impl> p;\npublic:\n    Silly(const Silly& a) : p(make_shared<Impl>()) { *p = *a.p; }   // deep copy\n    Silly& operator=(const Silly& a) { p = a.p; return *this; }   // shallow copy\n    // ...\n}; \n```", "```\ntemplate<typename A>\nstruct final_action {   // slightly simplified\n    A act;\n    final_action(A a) : act{a} {}\n    ~final_action() { act(); }\n};\n\ntemplate<typename A>\nfinal_action<A> finally(A act)   // deduce action type\n{\n    return final_action<A>{act};\n}\n\nvoid test()\n{\n    auto act = finally([] { cout << \"Exit test\\n\"; });  // establish exit action\n    // ...\n    if (something) return;   // act done here\n    // ...\n} // act done here \n```", "```\nclass Foo {   // bad; use the default destructor\npublic:\n    // ...\n    ~Foo() { s = \"\"; i = 0; vi.clear(); }  // clean up\nprivate:\n    string s;\n    int i;\n    vector<int> vi;\n}; \n```", "```\nclass X {\n    ifstream f;   // might own a file\n    // ... no default operations defined or =deleted ...\n}; \n```", "```\nclass X2 {     // bad\n    FILE* f;   // might own a file\n    // ... no default operations defined or =deleted ...\n}; \n```", "```\nPreprocessor pp { /* ... */ };\nParser p { pp, /* ... */ };\nType_checker tc { p, /* ... */ }; \n```", "```\nclass legacy_class\n{\n    foo* m_owning;   // Bad: change to unique_ptr<T> or owner<T*>\n    bar* m_observer; // OK: keep\n} \n```", "```\ntemplate<typename T>\nclass Smart_ptr {\n    T* p;   // BAD: vague about ownership of *p\n    // ...\npublic:\n    // ... no user-defined default operations ...\n};\n\nvoid use(Smart_ptr<int> p1)\n{\n    // error: p2.p leaked (if not nullptr and not owned by some other code)\n    auto p2 = p1;\n} \n```", "```\ntemplate<typename T>\nclass Smart_ptr2 {\n    T* p;   // BAD: vague about ownership of *p\n    // ...\npublic:\n    // ... no user-defined copy operations ...\n    ~Smart_ptr2() { delete p; }  // p is an owner!\n};\n\nvoid use(Smart_ptr2<int> p1)\n{\n    auto p2 = p1;   // error: double deletion\n} \n```", "```\ntemplate<typename T>\nclass Smart_ptr3 {\n    owner<T*> p;   // OK: explicit about ownership of *p\n    // ...\npublic:\n    // ...\n    // ... copy and move operations ...\n    ~Smart_ptr3() { delete p; }\n};\n\nvoid use(Smart_ptr3<int> p1)\n{\n    auto p2 = p1;   // OK: no double deletion\n} \n```", "```\nstruct Base {  // BAD: implicitly has a public non-virtual destructor\n    virtual void f();\n};\n\nstruct D : Base {\n    string s {\"a resource needing cleanup\"};\n    ~D() { /* ... do some cleanup ... */ }\n    // ...\n};\n\nvoid use()\n{\n    unique_ptr<Base> p = make_unique<D>();\n    // ...\n} // p's destruction calls ~Base(), not ~D(), which leaks D::s and possibly more \n```", "```\nclass X {\n    ~X();   // private destructor\n    // ...\n};\n\nvoid use()\n{\n    X a;                        // error: cannot destroy\n    auto p = make_unique<X>();  // error: cannot destroy\n} \n```", "```\nclass X {\npublic:\n    ~X() noexcept;\n    // ...\n};\n\nX::~X() noexcept\n{\n    // ...\n    if (cannot_release_a_resource) terminate();\n    // ...\n} \n```", "```\nstruct X {\n    Details x;  // happens to have a throwing destructor\n    // ...\n    ~X() { }    // implicitly noexcept(false); aka can throw\n}; \n```", "```\nclass Date {  // a Date represents a valid date\n              // in the January 1, 1900 to December 31, 2100 range\n    Date(int dd, int mm, int yy)\n        :d{dd}, m{mm}, y{yy}\n    {\n        if (!is_valid(d, m, y)) throw Bad_date{};  // enforce invariant\n    }\n    // ...\nprivate:\n    int d, m, y;\n}; \n```", "```\nstruct Rec {\n    string s;\n    int i {0};\n    Rec(const string& ss) : s{ss} {}\n    Rec(int ii) :i{ii} {}\n};\n\nRec r1 {7};\nRec r2 {\"Foo bar\"}; \n```", "```\nstruct Rec2{\n    string s;\n    int i;\n    Rec2(const string& ss, int ii = 0) :s{ss}, i{ii} {}   // redundant\n};\n\nRec2 r1 {\"Foo\", 7};\nRec2 r2 {\"Bar\"}; \n```", "```\nclass X1 {\n    FILE* f;   // call init() before any other function\n    // ...\npublic:\n    X1() {}\n    void init();   // initialize f\n    void read();   // read from f\n    // ...\n};\n\nvoid f()\n{\n    X1 file;\n    file.read();   // crash or bad read!\n    // ...\n    file.init();   // too late\n    // ...\n} \n```", "```\nclass X2 {\n    FILE* f;\n    // ...\npublic:\n    X2(const string& name)\n        :f{fopen(name.c_str(), \"r\")}\n    {\n        if (!f) throw runtime_error{\"could not open\" + name};\n        // ...\n    }\n\n    void read();      // read from f\n    // ...\n};\n\nvoid f()\n{\n    X2 file {\"Zeno\"}; // throws if file isn't open\n    file.read();      // fine\n    // ...\n} \n```", "```\nclass X3 {     // bad: the constructor leaves a non-valid object behind\n    FILE* f;   // call is_valid() before any other function\n    bool valid;\n    // ...\npublic:\n    X3(const string& name)\n        :f{fopen(name.c_str(), \"r\")}, valid{false}\n    {\n        if (f) valid = true;\n        // ...\n    }\n\n    bool is_valid() { return valid; }\n    void read();   // read from f\n    // ...\n};\n\nvoid f()\n{\n    X3 file {\"Heraclides\"};\n    file.read();   // crash or bad read!\n    // ...\n    if (file.is_valid()) {\n        file.read();\n        // ...\n    }\n    else {\n        // ... handle error ...\n    }\n    // ...\n} \n```", "```\nclass Date { // BAD: no default constructor\npublic:\n    Date(int dd, int mm, int yyyy);\n    // ...\n};\n\nvector<Date> vd1(1000);   // default Date needed here\nvector<Date> vd2(1000, Date{7, Month::October, 1885});   // alternative \n```", "```\nclass Date {\npublic:\n    Date(int dd, int mm, int yyyy);\n    Date() = default; // [See also](#rc-default)\n    // ...\nprivate:\n    int dd {1};\n    int mm {1};\n    int yyyy {1970};\n    // ...\n};\n\nvector<Date> vd1(1000); \n```", "```\nstruct X {\n    string s;\n    vector<int> v;\n};\n\nX x; // means X{ { }, { } }; that is the empty string and the empty vector \n```", "```\nstruct X {\n    string s;\n    int i;\n};\n\nvoid f()\n{\n    X x;    // x.s is initialized to the empty string; x.i is uninitialized\n\n    cout << x.s << ' ' << x.i << '\\n';\n    ++x.i;\n} \n```", "```\nstruct X {\n    string s;\n    int i {};   // default initialize (to 0)\n}; \n```", "```\n// Shape is an abstract base class, not a copyable type.\n// It might or might not need a default constructor.\nstruct Shape {\n    virtual void draw() = 0;\n    virtual void rotate(int) = 0;\n    // =delete copy/move functions\n    // ...\n}; \n```", "```\n// std::lock_guard is not a copyable type.\n// It does not have a default constructor.\nlock_guard g {mx};  // guard the mutex mx\nlock_guard g2;      // error: guarding nothing \n```", "```\n// std::ofstream is not a copyable type.\n// It does happen to have a default constructor\n// that goes along with a special \"not open\" state.\nofstream out {\"Foobar\"};\n// ...\nout << log(time, transaction); \n```", "```\ntemplate<typename T>\n// elem points to space-elem element allocated using new\nclass Vector0 {\npublic:\n    Vector0() :Vector0{0} {}\n    Vector0(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}\n    // ...\nprivate:\n    own<T*> elem;\n    T* space;\n    T* last;\n}; \n```", "```\ntemplate<typename T>\n// elem is nullptr or elem points to space-elem element allocated using new\nclass Vector1 {\npublic:\n    // sets the representation to {nullptr, nullptr, nullptr}; doesn't throw\n    Vector1() noexcept {}\n    Vector1(int n) :elem{new T[n]}, space{elem + n}, last{elem} {}\n    // ...\nprivate:\n    own<T*> elem {};\n    T* space {};\n    T* last {};\n}; \n```", "```\nclass X1 { // BAD: doesn't use member initializers\n    string s;\n    int i;\npublic:\n    X1() :s{\"default\"}, i{1} { }\n    // ...\n}; \n```", "```\nclass X2 {\n    string s {\"default\"};\n    int i {1};\npublic:\n    // use compiler-generated default constructor\n    // ...\n}; \n```", "```\nclass String {\npublic:\n    String(int);   // BAD\n    // ...\n};\n\nString s = 10;   // surprise: string of size 10 \n```", "```\nclass Complex {\npublic:\n    Complex(double d);   // OK: we want a conversion from d to {d, 0}\n    // ...\n};\n\nComplex z = 10.7;   // unsurprising conversion \n```", "```\nclass Foo {\n    int m1;\n    int m2;\npublic:\n    Foo(int x) :m2{x}, m1{++x} { }   // BAD: misleading initializer order\n    // ...\n};\n\nFoo x(1); // surprise: x.m1 == x.m2 == 2 \n```", "```\nclass X {   // BAD\n    int i;\n    string s;\n    int j;\npublic:\n    X() :i{666}, s{\"qqq\"} { }   // j is uninitialized\n    X(int ii) :i{ii} {}         // s is \"\" and j is uninitialized\n    // ...\n}; \n```", "```\nclass X2 {\n    int i {666};\n    string s {\"qqq\"};\n    int j {0};\npublic:\n    X2() = default;        // all members are initialized to their defaults\n    X2(int ii) :i{ii} {}   // s and j initialized to their defaults\n    // ...\n}; \n```", "```\nclass X3 {   // BAD: inexplicit, argument passing overhead\n    int i;\n    string s;\n    int j;\npublic:\n    X3(int ii = 666, const string& ss = \"qqq\", int jj = 0)\n        :i{ii}, s{ss}, j{jj} { }   // all members are initialized to their defaults\n    // ...\n}; \n```", "```\nclass A {   // Good\n    string s1;\npublic:\n    A(czstring p) : s1{p} { }    // GOOD: directly construct (and the C-string is explicitly named)\n    // ...\n}; \n```", "```\nclass B {   // BAD\n    string s1;\npublic:\n    B(const char* p) { s1 = p; }   // BAD: default constructor followed by assignment\n    // ...\n};\n\nclass C {   // UGLY, aka very bad\n    int* p;\npublic:\n    C() { cout << *p; p = new int{10}; }   // accidental use before initialized\n    // ...\n}; \n```", "```\nclass D {   // Good\n    string s1;\npublic:\n    D(string_view v) : s1{v} { }    // GOOD: directly construct\n    // ...\n}; \n```", "```\nclass B {\npublic:\n    B()\n    {\n        /* ... */\n        f(); // BAD: C.82: Don't call virtual functions in constructors and destructors\n        /* ... */\n    }\n\n    virtual void f() = 0;\n}; \n```", "```\nclass B {\nprotected:\n    class Token {};\n\npublic:\n    explicit B(Token) { /* ... */ }  // create an imperfectly initialized object\n    virtual void f() = 0;\n\n    template<class T>\n    static shared_ptr<T> create()    // interface for creating shared objects\n    {\n        auto p = make_shared<T>(typename T::Token{});\n        p->post_initialize();\n        return p;\n    }\n\nprotected:\n    virtual void post_initialize()   // called right after construction\n        { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe\n};\n\nclass D : public B {                 // some derived class\nprotected:\n    class Token {};\n\npublic:\n    explicit D(Token) : B{ B::Token{} } {}\n    void f() override { /* ...  */ };\n\nprotected:\n    template<class T>\n    friend shared_ptr<T> B::create();\n};\n\nshared_ptr<D> p = D::create<D>();  // creating a D object \n```", "```\nclass Date {   // BAD: repetitive\n    int d;\n    Month m;\n    int y;\npublic:\n    Date(int dd, Month mm, year yy)\n        :d{dd}, m{mm}, y{yy}\n        { if (!valid(d, m, y)) throw Bad_date{}; }\n\n    Date(int dd, Month mm)\n        :d{dd}, m{mm} y{current_year()}\n        { if (!valid(d, m, y)) throw Bad_date{}; }\n    // ...\n}; \n```", "```\nclass Date2 {\n    int d;\n    Month m;\n    int y;\npublic:\n    Date2(int dd, Month mm, year yy)\n        :d{dd}, m{mm}, y{yy}\n        { if (!valid(d, m, y)) throw Bad_date{}; }\n\n    Date2(int dd, Month mm)\n        :Date2{dd, mm, current_year()} {}\n    // ...\n}; \n```", "```\nclass Rec {\n    // ... data and lots of nice constructors ...\n};\n\nclass Oper : public Rec {\n    using Rec::Rec;\n    // ... no data members ...\n    // ... lots of nice utility functions ...\n}; \n```", "```\nstruct Rec2 : public Rec {\n    int x;\n    using Rec::Rec;\n};\n\nRec2 r {\"foo\", 7};\nint val = r.x;   // uninitialized \n```", "```\nclass Foo {\npublic:\n    Foo& operator=(const Foo& x)\n    {\n        // GOOD: no need to check for self-assignment (other than performance)\n        auto tmp = x;\n        swap(tmp); // see C.83\n        return *this;\n    }\n    // ...\n};\n\nFoo a;\nFoo b;\nFoo f();\n\na = b;    // assign lvalue: copy\na = f();  // assign rvalue: potentially move \n```", "```\ntemplate<typename T>\nclass Vector {\npublic:\n    Vector& operator=(const Vector&);\n    // ...\nprivate:\n    T* elem;\n    int sz;\n};\n\nVector& Vector::operator=(const Vector& a)\n{\n    if (a.sz > sz) {\n        // ... use the swap technique, it can't be bettered ...\n        return *this;\n    }\n    // ... copy sz elements from *a.elem to elem ...\n    if (a.sz < sz) {\n        // ... destroy the surplus elements in *this and adjust size ...\n    }\n    return *this;\n} \n```", "```\nclass X {   // OK: value semantics\npublic:\n    X();\n    X(const X&);     // copy X\n    void modify();   // change the value of X\n    // ...\n    ~X() { delete[] p; }\nprivate:\n    T* p;\n    int sz;\n};\n\nbool operator==(const X& a, const X& b)\n{\n    return a.sz == b.sz && equal(a.p, a.p + a.sz, b.p, b.p + b.sz);\n}\n\nX::X(const X& a)\n    :p{new T[a.sz]}, sz{a.sz}\n{\n    copy(a.p, a.p + sz, p);\n}\n\nX x;\nX y = x;\nif (x != y) throw Bad{};\nx.modify();\nif (x == y) throw Bad{};   // assume value semantics \n```", "```\nclass X2 {  // OK: pointer semantics\npublic:\n    X2();\n    X2(const X2&) = default; // shallow copy\n    ~X2() = default;\n    void modify();          // change the pointed-to value\n    // ...\nprivate:\n    T* p;\n    int sz;\n};\n\nbool operator==(const X2& a, const X2& b)\n{\n    return a.sz == b.sz && a.p == b.p;\n}\n\nX2 x;\nX2 y = x;\nif (x != y) throw Bad{};\nx.modify();\nif (x != y) throw Bad{};  // assume pointer semantics \n```", "```\nstd::vector<int> v = {3, 1, 4, 1, 5, 9};\nv = v;\n// the value of v is still {3, 1, 4, 1, 5, 9} \n```", "```\nstruct Bar {\n    vector<pair<int, int>> v;\n    map<string, int> m;\n    string s;\n};\n\nBar b;\n// ...\nb = b;   // correct and efficient \n```", "```\nclass Foo {\n    string s;\n    int i;\npublic:\n    Foo& operator=(const Foo& a);\n    // ...\n};\n\nFoo& Foo::operator=(const Foo& a)   // OK, but there is a cost\n{\n    if (this == &a) return *this;\n    s = a.s;\n    i = a.i;\n    return *this;\n} \n```", "```\nFoo& Foo::operator=(const Foo& a)   // simpler, and probably much better\n{\n    s = a.s;\n    i = a.i;\n    return *this;\n} \n```", "```\nclass X {   // OK: value semantics\npublic:\n    X();\n    X(X&& a) noexcept;  // move X\n    X& operator=(X&& a) noexcept; // move-assign X\n    void modify();     // change the value of X\n    // ...\n    ~X() { delete[] p; }\nprivate:\n    T* p;\n    int sz;\n};\n\nX::X(X&& a) noexcept\n    :p{a.p}, sz{a.sz}  // steal representation\n{\n    a.p = nullptr;     // set to \"empty\"\n    a.sz = 0;\n}\n\nvoid use()\n{\n    X x{};\n    // ...\n    X y = std::move(x);\n    x = X{};   // OK\n} // OK: x can be destroyed \n```", "```\nclass Foo {\n    string s;\n    int i;\npublic:\n    Foo& operator=(Foo&& a) noexcept;\n    // ...\n};\n\nFoo& Foo::operator=(Foo&& a) noexcept  // OK, but there is a cost\n{\n    if (this == &a) return *this;  // this line is redundant\n    s = std::move(a.s);\n    i = a.i;\n    return *this;\n} \n```", "```\n// move from other.ptr to this->ptr\nT* temp = other.ptr;\nother.ptr = nullptr;\ndelete ptr; // in self-move, this->ptr is also null; delete is a no-op\nptr = temp; // in self-move, the original ptr is restored \n```", "```\ntemplate<typename T>\nclass Vector {\npublic:\n    Vector(Vector&& a) noexcept :elem{a.elem}, sz{a.sz} { a.elem = nullptr; a.sz = 0; }\n    Vector& operator=(Vector&& a) noexcept {\n        if (&a != this) {\n            delete elem;\n            elem = a.elem; a.elem = nullptr;\n            sz   = a.sz;   a.sz   = 0;\n        }\n        return *this;\n    }\n    // ...\nprivate:\n    T* elem;\n    int sz;\n}; \n```", "```\ntemplate<typename T>\nclass Vector2 {\npublic:\n    Vector2(Vector2&& a) noexcept { *this = a; }             // just use the copy\n    Vector2& operator=(Vector2&& a) noexcept { *this = a; }  // just use the copy\n    // ...\nprivate:\n    T* elem;\n    int sz;\n}; \n```", "```\nclass B { // BAD: polymorphic base class doesn't suppress copying\npublic:\n    virtual char m() { return 'B'; }\n    // ... nothing about copy operations, so uses default ...\n};\n\nclass D : public B {\npublic:\n    char m() override { return 'D'; }\n    // ...\n};\n\nvoid f(B& b)\n{\n    auto b2 = b; // oops, slices the object; b2.m() will return 'B'\n}\n\nD d;\nf(d); \n```", "```\nclass B { // GOOD: polymorphic class suppresses copying\npublic:\n    B() = default;\n    B(const B&) = delete;\n    B& operator=(const B&) = delete;\n    virtual char m() { return 'B'; }\n    // ...\n};\n\nclass D : public B {\npublic:\n    char m() override { return 'D'; }\n    // ...\n};\n\nvoid f(B& b)\n{\n    auto b2 = b; // ok, compiler will detect inadvertent copying, and protest\n}\n\nD d;\nf(d); \n```", "```\nclass Tracer {\n    string message;\npublic:\n    Tracer(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; }\n    ~Tracer() { cerr << \"exiting \" << message << '\\n'; }\n\n    Tracer(const Tracer&) = default;\n    Tracer& operator=(const Tracer&) = default;\n    Tracer(Tracer&&) noexcept = default;\n    Tracer& operator=(Tracer&&) noexcept = default;\n}; \n```", "```\nclass Tracer2 {\n    string message;\npublic:\n    Tracer2(const string& m) : message{m} { cerr << \"entering \" << message << '\\n'; }\n    ~Tracer2() { cerr << \"exiting \" << message << '\\n'; }\n\n    Tracer2(const Tracer2& a) : message{a.message} {}\n    Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; }\n    Tracer2(Tracer2&& a) noexcept :message{a.message} {}\n    Tracer2& operator=(Tracer2&& a) noexcept { message = a.message; return *this; }\n}; \n```", "```\nclass Immortal {\npublic:\n    ~Immortal() = delete;   // do not allow destruction\n    // ...\n};\n\nvoid use()\n{\n    Immortal ugh;   // error: ugh cannot be destroyed\n    Immortal* p = new Immortal{};\n    delete p;       // error: cannot destroy *p\n} \n```", "```\ntemplate<class T, class D = default_delete<T>> class unique_ptr {\npublic:\n    // ...\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    // ...\n    unique_ptr(unique_ptr&& u) noexcept;   // move constructor\n    // ...\n    unique_ptr(const unique_ptr&) = delete; // disable copy from lvalue\n    // ...\n};\n\nunique_ptr<int> make();   // make \"something\" and return it by moving\n\nvoid f()\n{\n    unique_ptr<int> pi {};\n    auto pi2 {pi};      // error: no move constructor from lvalue\n    auto pi3 {make()};  // OK, move: the result of make() is an rvalue\n} \n```", "```\nclass Base {\npublic:\n    virtual void f() = 0;   // not implemented\n    virtual void g();       // implemented with Base version\n    virtual void h();       // implemented with Base version\n    virtual ~Base();        // implemented with Base version\n};\n\nclass Derived : public Base {\npublic:\n    void g() override;   // provide Derived implementation\n    void h() final;      // provide Derived implementation\n\n    Derived()\n    {\n        // BAD: attempt to call an unimplemented virtual function\n        f();\n\n        // BAD: will call Derived::g, not dispatch further virtually\n        g();\n\n        // GOOD: explicitly state intent to call only the visible version\n        Derived::g();\n\n        // ok, no qualification needed, h is final\n        h();\n    }\n}; \n```", "```\nclass Foo {\npublic:\n    void swap(Foo& rhs) noexcept\n    {\n        m1.swap(rhs.m1);\n        std::swap(m2, rhs.m2);\n    }\nprivate:\n    Bar m1;\n    int m2;\n}; \n```", "```\nvoid swap(Foo& a, Foo& b)\n{\n    a.swap(b);\n} \n```", "```\nvoid swap(My_vector& x, My_vector& y)\n{\n    auto tmp = x;   // copy elements\n    x = y;\n    y = tmp;\n} \n```", "```\nstruct X {\n    string name;\n    int number;\n};\n\nbool operator==(const X& a, const X& b) noexcept {\n    return a.name == b.name && a.number == b.number;\n} \n```", "```\nclass B {\n    string name;\n    int number;\n    bool operator==(const B& a) const {\n        return name == a.name && number == a.number;\n    }\n    // ...\n}; \n```", "```\nclass B {\n    string name;\n    int number;\npublic:\n    virtual bool operator==(const B& a) const\n    {\n         return name == a.name && number == a.number;\n    }\n    // ...\n}; \n```", "```\nclass D : public B {\n    char character;\npublic:\n    virtual bool operator==(const D& a) const\n    {\n        return B::operator==(a) && character == a.character;\n    }\n    // ...\n};\n\nB b = ...\nD d = ...\nb == d;    // compares name and number, ignores d's character\nd == b;    // compares name and number, ignores d's character\nD d2;\nd == d2;   // compares name, number, and character\nB& b2 = d2;\nb2 == d;   // compares name and number, ignores d2's and d's character \n```", "```\ntemplate<>\nstruct hash<My_type> {  // thoroughly bad hash specialization\n    using result_type = size_t;\n    using argument_type = My_type;\n\n    size_t operator()(const My_type & x) const\n    {\n        size_t xs = x.s.size();\n        if (xs < 4) throw Bad_My_type{};    // \"Nobody expects the Spanish inquisition!\"\n        return hash<size_t>()(x.s.size()) ^ trim(x.s);\n    }\n};\n\nint main()\n{\n    unordered_map<My_type, int> m;\n    My_type mt{ \"asdfg\" };\n    m[mt] = 7;\n    cout << m[My_type{ \"asdfg\" }] << '\\n';\n} \n```", "```\nstruct base {\n    virtual void update() = 0;\n    std::shared_ptr<int> sp;\n};\n\nstruct derived : public base {\n    void update() override {}\n}; \n```", "```\nvoid init(derived& a)\n{\n    memset(&a, 0, sizeof(derived));\n} \n```", "```\nvoid copy(derived& a, derived& b)\n{\n    memcpy(&a, &b, sizeof(derived));\n} \n```", "```\n// simplified (e.g., no allocators):\n\ntemplate<typename T>\nclass Sorted_vector {\n    using value_type = T;\n    // ... iterator types ...\n\n    Sorted_vector() = default;\n    Sorted_vector(initializer_list<T>);    // initializer-list constructor: sort and store\n    Sorted_vector(const Sorted_vector&) = default;\n    Sorted_vector(Sorted_vector&&) noexcept = default;\n    Sorted_vector& operator=(const Sorted_vector&) = default;     // copy assignment\n    Sorted_vector& operator=(Sorted_vector&&) noexcept = default; // move assignment\n    ~Sorted_vector() = default;\n\n    Sorted_vector(const std::vector<T>& v);   // store and sort\n    Sorted_vector(std::vector<T>&& v);        // sort and \"steal representation\"\n\n    const T& operator[](int i) const { return rep[i]; }\n    // no non-const direct access to preserve order\n\n    void push_back(const T&);   // insert in the right place (not necessarily at back)\n    void push_back(T&&);        // insert in the right place (not necessarily at back)\n\n    // ... cbegin(), cend() ...\nprivate:\n    std::vector<T> rep;  // use a std::vector to hold elements\n};\n\ntemplate<typename T> bool operator==(const Sorted_vector<T>&, const Sorted_vector<T>&);\ntemplate<typename T> bool operator!=(const Sorted_vector<T>&, const Sorted_vector<T>&);\n// ... \n```", "```\nvoid f(const Sorted_vector<string>& v)\n{\n    Sorted_vector<string> v2 {v};\n    if (v != v2)\n        cout << \"Behavior against reason and logic.\\n\";\n    // ...\n} \n```", "```\nSorted_vector<int> read_sorted(istream& is)\n{\n    vector<int> v;\n    cin >> v;   // assume we have a read operation for vectors\n    Sorted_vector<int> sv = v;  // sorts\n    return sv;\n} \n```", "```\nSorted_vector<int> sv {1, 3, -1, 7, 0, 0}; // Sorted_vector sorts elements as needed \n```", "```\nvector<Sorted_sequence<string>> vs(100);    // 100 Sorted_sequences each with the value \"\" \n```", "```\n??? \n```", "```\nclass DrawableUIElement {\npublic:\n    virtual void render() const = 0;\n    // ...\n};\n\nclass AbstractButton : public DrawableUIElement {\npublic:\n    virtual void onClick() = 0;\n    // ...\n};\n\nclass PushButton : public AbstractButton {\n    void render() const override;\n    void onClick() override;\n    // ...\n};\n\nclass Checkbox : public AbstractButton {\n// ...\n}; \n```", "```\ntemplate<typename T>\nclass Container {\npublic:\n    // list operations:\n    virtual T& get() = 0;\n    virtual void put(T&) = 0;\n    virtual void insert(Position) = 0;\n    // ...\n    // vector operations:\n    virtual T& operator[](int) = 0;\n    virtual void sort() = 0;\n    // ...\n    // tree operations:\n    virtual void balance() = 0;\n    // ...\n}; \n```", "```\nclass My_interface {\npublic:\n    // ... only pure virtual functions here ...\n    virtual ~My_interface() {}   // or =default\n}; \n```", "```\nclass Goof {\npublic:\n    // ... only pure virtual functions here ...\n    // no virtual destructor\n};\n\nclass Derived : public Goof {\n    string s;\n    // ...\n};\n\nvoid use()\n{\n    unique_ptr<Goof> p {new Derived{\"here we go\"}};\n    f(p.get()); // use Derived through the Goof interface\n    g(p.get()); // use Derived through the Goof interface\n} // leak \n```", "```\nstruct Device {\n    virtual ~Device() = default;\n    virtual void write(span<const char> outbuf) = 0;\n    virtual void read(span<char> inbuf) = 0;\n};\n\nclass D1 : public Device {\n    // ... data ...\n\n    void write(span<const char> outbuf) override;\n    void read(span<char> inbuf) override;\n};\n\nclass D2 : public Device {\n    // ... different data ...\n\n    void write(span<const char> outbuf) override;\n    void read(span<char> inbuf) override;\n}; \n```", "```\n??? \n```", "```\nclass Shape {\npublic:\n    // no user-written constructor needed in abstract base class\n    virtual Point center() const = 0;    // pure virtual\n    virtual void move(Point to) = 0;\n    // ... more pure virtual functions ...\n    virtual ~Shape() {}                 // destructor\n};\n\nclass Circle : public Shape {\npublic:\n    Circle(Point p, int rad);           // constructor in derived class\n    Point center() const override { return x; }\n}; \n```", "```\nstruct B {\n    virtual int f() = 0;\n    // ... no user-written destructor, defaults to public non-virtual ...\n};\n\n// bad: derived from a class without a virtual destructor\nstruct D : B {\n    string s {\"default\"};\n    // ...\n};\n\nvoid use()\n{\n    unique_ptr<B> p = make_unique<D>();\n    // ...\n} // undefined behavior, might call B::~B only and leak the string \n```", "```\nstruct B {\n    void f1(int);\n    virtual void f2(int) const;\n    virtual void f3(int);\n    // ...\n};\n\nstruct D : B {\n    void f1(int);        // bad (hope for a warning): D::f1() hides B::f1()\n    void f2(int) const;  // bad (but conventional and valid): no explicit override\n    void f3(double);     // bad (hope for a warning): D::f3() hides B::f3()\n    // ...\n}; \n```", "```\nstruct Better : B {\n    void f1(int) override;        // error (caught): Better::f1() hides B::f1()\n    void f2(int) const override;\n    void f3(double) override;     // error (caught): Better::f3() hides B::f3()\n    // ...\n}; \n```", "```\nclass Shape {   // BAD, mixed interface and implementation\npublic:\n    Shape();\n    Shape(Point ce = {0, 0}, Color co = none): cent{ce}, col {co} { /* ... */}\n\n    Point center() const { return cent; }\n    Color color() const { return col; }\n\n    virtual void rotate(int) = 0;\n    virtual void move(Point p) { cent = p; redraw(); }\n\n    virtual void redraw();\n\n    // ...\nprivate:\n    Point cent;\n    Color col;\n};\n\nclass Circle : public Shape {\npublic:\n    Circle(Point c, int r) : Shape{c}, rad{r} { /* ... */ }\n\n    // ...\nprivate:\n    int rad;\n};\n\nclass Triangle : public Shape {\npublic:\n    Triangle(Point p1, Point p2, Point p3); // calculate center\n    // ...\n}; \n```", "```\nclass Shape {  // pure interface\npublic:\n    virtual Point center() const = 0;\n    virtual Color color() const = 0;\n\n    virtual void rotate(int) = 0;\n    virtual void move(Point p) = 0;\n\n    virtual void redraw() = 0;\n\n    // ...\n}; \n```", "```\nclass Circle : public Shape {\npublic:\n    Circle(Point c, int r, Color c) : cent{c}, rad{r}, col{c} { /* ... */ }\n\n    Point center() const override { return cent; }\n    Color color() const override { return col; }\n\n    // ...\nprivate:\n    Point cent;\n    int rad;\n    Color col;\n}; \n```", "```\nclass Shape {   // pure interface\npublic:\n    virtual Point center() const = 0;\n    virtual Color color() const = 0;\n\n    virtual void rotate(int) = 0;\n    virtual void move(Point p) = 0;\n\n    virtual void redraw() = 0;\n\n    // ...\n};\n\nclass Circle : public virtual Shape {   // pure interface\npublic:\n    virtual int radius() = 0;\n    // ...\n}; \n```", "```\nclass Impl::Shape : public virtual ::Shape { // implementation\npublic:\n    // constructors, destructor\n    // ...\n    Point center() const override { /* ... */ }\n    Color color() const override { /* ... */ }\n\n    void rotate(int) override { /* ... */ }\n    void move(Point p) override { /* ... */ }\n\n    void redraw() override { /* ... */ }\n\n    // ...\n}; \n```", "```\nclass Impl::Circle : public virtual ::Circle, public Impl::Shape {   // implementation\npublic:\n    // constructors, destructor\n\n    int radius() override { /* ... */ }\n    // ...\n}; \n```", "```\nclass Smiley : public virtual Circle { // pure interface\npublic:\n    // ...\n};\n\nclass Impl::Smiley : public virtual ::Smiley, public Impl::Circle {   // implementation\npublic:\n    // constructors, destructor\n    // ...\n} \n```", "```\nSmiley     ->         Circle     ->  Shape\n  ^                     ^               ^\n  |                     |               |\nImpl::Smiley -> Impl::Circle -> Impl::Shape \n```", "```\nvoid work_with_shape(Shape&);\n\nint user()\n{\n    Impl::Smiley my_smiley{ /* args */ };   // create concrete shape\n    // ...\n    my_smiley.some_member();        // use implementation class directly\n    // ...\n    work_with_shape(my_smiley);     // use implementation through abstract interface\n    // ...\n} \n```", "```\nclass B {\npublic:\n    B() = default;\n    virtual ~B() = default;\n    virtual gsl::owner<B*> clone() const = 0;\nprotected:\n     B(const B&) = default;\n     B& operator=(const B&) = default;\n     B(B&&) noexcept = default;\n     B& operator=(B&&) noexcept = default;\n    // ...\n};\n\nclass D : public B {\npublic:\n    gsl::owner<D*> clone() const override\n    {\n        return new D{*this};\n    };\n}; \n```", "```\nclass Point {   // Bad: verbose\n    int x;\n    int y;\npublic:\n    Point(int xx, int yy) : x{xx}, y{yy} { }\n    int get_x() const { return x; }\n    void set_x(int xx) { x = xx; }\n    int get_y() const { return y; }\n    void set_y(int yy) { y = yy; }\n    // no behavioral member functions\n}; \n```", "```\nstruct Point {\n    int x {0};\n    int y {0};\n}; \n```", "```\ntemplate<class T>\nclass Vector {\npublic:\n    // ...\n    virtual int size() const { return sz; }   // bad: what good could a derived class do?\nprivate:\n    T* elem;   // the elements\n    int sz;    // number of elements\n}; \n```", "```\nclass Shape {\npublic:\n    // ... interface functions ...\nprotected:\n    // data for use in derived classes:\n    Color fill_color;\n    Color edge_color;\n    Style st;\n}; \n```", "```\nclass iostream : public istream, public ostream {   // very simplified\n    // ...\n}; \n```", "```\nclass iostream : public istream, public ostream {   // very simplified\n    // ...\n}; \n```", "```\nstruct Interface {\n    virtual void f();\n    virtual int g();\n    // ... no data here ...\n};\n\nclass Utility {  // with data\n    void utility1();\n    virtual void utility2();    // customization point\npublic:\n    int x;\n    int y;\n};\n\nclass Derive1 : public Interface, virtual protected Utility {\n    // override Interface functions\n    // Maybe override Utility virtual functions\n    // ...\n};\n\nclass Derive2 : public Interface, virtual protected Utility {\n    // override Interface functions\n    // Maybe override Utility virtual functions\n    // ...\n}; \n```", "```\n#include <iostream>\nclass B {\npublic:\n    virtual int f(int i) { std::cout << \"f(int): \"; return i; }\n    virtual double f(double d) { std::cout << \"f(double): \"; return d; }\n    virtual ~B() = default;\n};\nclass D: public B {\npublic:\n    int f(int i) override { std::cout << \"f(int): \"; return i + 1; }\n};\nint main()\n{\n    D d;\n    std::cout << d.f(2) << '\\n';   // prints \"f(int): 3\"\n    std::cout << d.f(2.3) << '\\n'; // prints \"f(int): 3\"\n} \n```", "```\nclass D: public B {\npublic:\n    int f(int i) override { std::cout << \"f(int): \"; return i + 1; }\n    using B::f; // exposes f(double)\n}; \n```", "```\ntemplate<class... Ts>\nstruct Overloader : Ts... {\n    using Ts::operator()...; // exposes operator() from every base\n}; \n```", "```\nclass Widget { /* ... */ };\n\n// nobody will ever want to improve My_widget (or so you thought)\nclass My_widget final : public Widget { /* ... */ };\n\nclass My_improved_widget : public My_widget { /* ... */ };  // error: can't do that \n```", "```\nclass Base {\npublic:\n    virtual int multiply(int value, int factor = 2) = 0;\n    virtual ~Base() = default;\n};\n\nclass Derived : public Base {\npublic:\n    int multiply(int value, int factor = 10) override;\n};\n\nDerived d;\nBase& b = d;\n\nb.multiply(10);  // these two calls will call the same function but\nd.multiply(10);  // with different arguments and so different results \n```", "```\nstruct B { int a; virtual int f(); virtual ~B() = default };\nstruct D : B { int b; int f() override; };\n\nvoid use(B b)\n{\n    D d;\n    B b2 = d;   // slice\n    B b3 = b;\n}\n\nvoid use2()\n{\n    D d;\n    use(d);   // slice\n} \n```", "```\nvoid use3()\n{\n    D d;\n    d.f();   // OK\n} \n```", "```\nstruct B {   // an interface\n    virtual void f();\n    virtual void g();\n    virtual ~B();\n};\n\nstruct D : B {   // a wider interface\n    void f() override;\n    virtual void h();\n};\n\nvoid user(B* pb)\n{\n    if (D* pd = dynamic_cast<D*>(pb)) {\n        // ... use D's interface ...\n    }\n    else {\n        // ... make do with B's interface ...\n    }\n} \n```", "```\nvoid user2(B* pb)   // bad\n{\n    D* pd = static_cast<D*>(pb);    // I know that pb really points to a D; trust me\n    // ... use D's interface ...\n}\n\nvoid user3(B* pb)    // unsafe\n{\n    if (some_condition) {\n        D* pd = static_cast<D*>(pb);   // I know that pb really points to a D; trust me\n        // ... use D's interface ...\n    }\n    else {\n        // ... make do with B's interface ...\n    }\n}\n\nvoid f()\n{\n    B b;\n    user(&b);   // OK\n    user2(&b);  // bad error\n    user3(&b);  // OK *if* the programmer got the some_condition check right\n} \n```", "```\nstruct B {\n    const char* name {\"B\"};\n    // if pb1->id() == pb2->id() *pb1 is the same type as *pb2\n    virtual const char* id() const { return name; }\n    // ...\n};\n\nstruct D : B {\n    const char* name {\"D\"};\n    const char* id() const override { return name; }\n    // ...\n};\n\nvoid use()\n{\n    B* pb1 = new B;\n    B* pb2 = new D;\n\n    cout << pb1->id(); // \"B\"\n    cout << pb2->id(); // \"D\"\n\n    if (pb2->id() == \"D\") {         // looks innocent\n        D* pd = static_cast<D*>(pb2);\n        // ...\n    }\n    // ...\n} \n```", "```\ntemplate<typename B>\nclass Dx : B {\n    // ...\n}; \n```", "```\nstd::string f(Base& b)\n{\n    return dynamic_cast<Derived&>(b).to_string();\n} \n```", "```\nvoid add(Shape* const item)\n{\n  // Ownership is always taken\n  owned_shapes.emplace_back(item);\n\n  // Check the Geometric_attributes and add the shape to none/one/some/all of the views\n\n  if (auto even = dynamic_cast<Even_sided*>(item))\n  {\n    view_of_evens.emplace_back(even);\n  }\n\n  if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item))\n  {\n    view_of_trisyms.emplace_back(trisym);\n  }\n} \n```", "```\nvoid use(int i)\n{\n    auto p = new int {7};           // bad: initialize local pointers with new\n    auto q = make_unique<int>(9);   // ok: guarantee the release of the memory-allocated for 9\n    if (0 < i) return;              // maybe return and leak\n    delete p;                       // too late\n} \n```", "```\nstruct B { int x; };\nstruct D : B { int y; };\n\nvoid use(B*);\n\nD a[] = { {1, 2}, {3, 4}, {5, 6} };\nB* p = a;     // bad: a decays to &a[0] which is converted to a B*\np[1].x = 7;   // overwrite a[0].y\n\nuse(a);       // bad: a decays to &a[0] which is converted to a B* \n```", "```\n??? \n```", "```\nclass X {\npublic:\n    // ...\n    X& operator=(const X&); // member function defining assignment\n    friend bool operator==(const X&, const X&); // == needs access to representation\n                                                // after a = b we have a == b\n    // ...\n}; \n```", "```\nX operator+(X a, X b) { return a.v - b.v; }   // bad: makes + subtract \n```", "```\nbool operator==(Point a, Point b) { return a.x == b.x && a.y == b.y; } \n```", "```\nvoid print(int a);\nvoid print(int a, int base);\nvoid print(const string&); \n```", "```\nvoid print_int(int a);\nvoid print_based(int a, int base);\nvoid print_string(const string&); \n```", "```\nvoid open_gate(Gate& g);   // remove obstacle from garage exit lane\nvoid fopen(const char* name, const char* mode);   // open file \n```", "```\nvoid open(Gate& g);   // remove obstacle from garage exit lane\nvoid open(const char* name, const char* mode =\"r\");   // open file \n```", "```\nstruct S1 {\n    string s;\n    // ...\n    operator char*() { return s.data(); }  // BAD, likely to cause surprises\n};\n\nstruct S2 {\n    string s;\n    // ...\n    explicit operator char*() { return s.data(); }\n};\n\nvoid f(S1 s1, S2 s2)\n{\n    char* x1 = s1;     // OK, but can cause surprises in many contexts\n    char* x2 = s2;     // error (and that's usually a good thing)\n    char* x3 = static_cast<char*>(s2); // we can be explicit (on your head be it)\n} \n```", "```\nS1 ff();\n\nchar* g()\n{\n    return ff();\n} \n```", "```\nnamespace N {\n    My_type X { /* ... */ };\n    void swap(X&, X&);   // optimized swap for N::X\n    // ...\n}\n\nvoid f1(N::X& a, N::X& b)\n{\n    std::swap(a, b);   // probably not what we wanted: calls std::swap()\n} \n```", "```\nvoid f2(N::X& a, N::X& b)\n{\n    swap(a, b);   // calls N::swap\n} \n```", "```\nvoid f3(N::X& a, N::X& b)\n{\n    using std::swap;  // make std::swap available\n    swap(a, b);        // calls N::swap if it exists, otherwise std::swap\n} \n```", "```\nclass Ptr { // a somewhat smart pointer\n    Ptr(X* pp) : p(pp) { /* check */ }\n    X* operator->() { /* check */ return p; }\n    X operator[](int i);\n    X operator*();\nprivate:\n    T* p;\n};\n\nclass X {\n    Ptr operator&() { return Ptr{this}; }\n    // ...\n}; \n```", "```\nvoid cout_my_class(const My_class& c) // confusing, not conventional, not generic\n{\n    std::cout << /* class members here */;\n}\n\nstd::ostream& operator<<(std::ostream& os, const my_class& c) // OK\n{\n    return os << /* class members here */;\n} \n```", "```\nMy_class var { /* ... */ };\n// ...\ncout << \"var = \" << var << '\\n'; \n```", "```\nstruct S { };\nS operator+(S, S);   // OK: in the same namespace as S, and even next to S\nS s;\n\nS r = s + s; \n```", "```\nnamespace N {\n    struct S { };\n    S operator+(S, S);   // OK: in the same namespace as S, and even next to S\n}\n\nN::S s;\n\nS r = s + s;  // finds N::operator+() by ADL \n```", "```\nstruct S { };\nS s;\n\nnamespace N {\n    bool operator!(S a) { return true; }\n    bool not_s = !s;\n}\n\nnamespace M {\n    bool operator!(S a) { return false; }\n    bool not_s = !s;\n} \n```", "```\nVec::Vector operator*(const Vec::Vector&, const Mat::Matrix&); \n```", "```\nvoid f(int);\nvoid f(double);\nauto f = [](char);   // error: cannot overload variable and function\n\nauto g = [](int) { /* ... */ };\nauto g = [](double) { /* ... */ };   // error: cannot overload variables\n\nauto h = [](auto) { /* ... */ };   // OK \n```", "```\nunion Value {\n    int x;\n    double d;\n};\n\nValue v = { 123 };  // now v holds an int\ncout << v.x << '\\n';    // write 123\nv.d = 987.654;  // now v holds a double\ncout << v.d << '\\n';    // write 987.654 \n```", "```\n// Short-string optimization\n\nconstexpr size_t buffer_size = 16; // Slightly larger than the size of a pointer\n\nclass Immutable_string {\npublic:\n    Immutable_string(const char* str) :\n        size(strlen(str))\n    {\n        if (size < buffer_size)\n            strcpy_s(string_buffer, buffer_size, str);\n        else {\n            string_ptr = new char[size + 1];\n            strcpy_s(string_ptr, size + 1, str);\n        }\n    }\n\n    ~Immutable_string()\n    {\n        if (size >= buffer_size)\n            delete[] string_ptr;\n    }\n\n    const char* get_str() const\n    {\n        return (size < buffer_size) ? string_buffer : string_ptr;\n    }\n\nprivate:\n    // If the string is short enough, we store the string itself\n    // instead of a pointer to the string.\n    union {\n        char* string_ptr;\n        char string_buffer[buffer_size];\n    };\n\n    const size_t size;\n}; \n```", "```\nunion Value {\n    int x;\n    double d;\n};\n\nValue v;\nv.d = 987.654;  // v holds a double \n```", "```\ncout << v.x << '\\n';    // BAD, undefined behavior: v holds a double, but we read it as an int \n```", "```\nv.x = 123;\ncout << v.d << '\\n';    // BAD: undefined behavior \n```", "```\nvariant<int, double> v;\nv = 123;        // v holds an int\nint x = get<int>(v);\nv = 123.456;    // v holds a double\ndouble w = get<double>(v); \n```", "```\nclass Value { // two alternative representations represented as a union\nprivate:\n    enum class Tag { number, text };\n    Tag type; // discriminant\n\n    union { // representation (note: anonymous union)\n        int i;\n        string s; // string has default constructor, copy operations, and destructor\n    };\npublic:\n    struct Bad_entry { }; // used for exceptions\n\n    ~Value();\n    Value& operator=(const Value&);   // necessary because of the string variant\n    Value(const Value&);\n    // ...\n    int number() const;\n    string text() const;\n\n    void set_number(int n);\n    void set_text(const string&);\n    // ...\n};\n\nint Value::number() const\n{\n    if (type != Tag::number) throw Bad_entry{};\n    return i;\n}\n\nstring Value::text() const\n{\n    if (type != Tag::text) throw Bad_entry{};\n    return s;\n}\n\nvoid Value::set_number(int n)\n{\n    if (type == Tag::text) {\n        s.~string();      // explicitly destroy string\n        type = Tag::number;\n    }\n    i = n;\n}\n\nvoid Value::set_text(const string& ss)\n{\n    if (type == Tag::text)\n        s = ss;\n    else {\n        new(&s) string{ss};   // placement new: explicitly construct string\n        type = Tag::text;\n    }\n}\n\nValue& Value::operator=(const Value& e)   // necessary because of the string variant\n{\n    if (type == Tag::text && e.type == Tag::text) {\n        s = e.s;    // usual string assignment\n        return *this;\n    }\n\n    if (type == Tag::text) s.~string(); // explicit destroy\n\n    switch (e.type) {\n    case Tag::number:\n        i = e.i;\n        break;\n    case Tag::text:\n        new(&s) string(e.s);   // placement new: explicit construct\n    }\n\n    type = e.type;\n    return *this;\n}\n\nValue::~Value()\n{\n    if (type == Tag::text) s.~string(); // explicit destroy\n} \n```", "```\nunion Pun {\n    int x;\n    unsigned char c[sizeof(int)];\n}; \n```", "```\nvoid bad(Pun& u)\n{\n    u.x = 'x';\n    cout << u.c[0] << '\\n';     // undefined behavior\n} \n```", "```\nvoid if_you_must_pun(int& x)\n{\n    auto p = reinterpret_cast<std::byte*>(&x);\n    cout << to_integer<unsigned>(p[0]) << '\\n'; // OK; better\n    // ...\n} \n```", "```\n// webcolors.h (third party header)\n#define RED   0xFF0000\n#define GREEN 0x00FF00\n#define BLUE  0x0000FF\n\n// productinfo.h\n// The following define product subtypes based on color\n#define RED    0\n#define PURPLE 1\n#define BLUE   2\n\nint webby = BLUE;   // webby == 2; probably not what was desired \n```", "```\nenum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };\nenum class Product_info { red = 0, purple = 1, blue = 2 };\n\nint webby = blue;   // error: be specific\nWeb_color webby = Web_color::blue; \n```", "```\nenum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; \n```", "```\nenum class Product_info { red = 0, purple = 1, blue = 2 };\n\nvoid print(Product_info inf)\n{\n    switch (inf) {\n    case Product_info::red: cout << \"red\"; break;\n    case Product_info::purple: cout << \"purple\"; break;\n    }\n} \n```", "```\nvoid Print_color(int color);\n\nenum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };\nenum Product_info { red = 0, purple = 1, blue = 2 };\n\nWeb_color webby = Web_color::blue;\n\n// Clearly at least one of these calls is buggy.\nPrint_color(webby);\nPrint_color(Product_info::blue); \n```", "```\nvoid Print_color(int color);\n\nenum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };\nenum class Product_info { red = 0, purple = 1, blue = 2 };\n\nWeb_color webby = Web_color::blue;\nPrint_color(webby);  // Error: cannot convert Web_color to int.\nPrint_color(Product_info::red);  // Error: cannot convert Product_info to int. \n```", "```\nenum class Day { mon, tue, wed, thu, fri, sat, sun };\n\nDay& operator++(Day& d)\n{\n    return d = (d == Day::sun) ? Day::mon : static_cast<Day>(static_cast<int>(d)+1);\n}\n\nDay today = Day::sat;\nDay tomorrow = ++today; \n```", "```\nDay& operator++(Day& d)\n{\n    return d = (d == Day::sun) ? Day::mon : Day{++d};    // error\n} \n```", "```\n // webcolors.h (third party header)\n#define RED   0xFF0000\n#define GREEN 0x00FF00\n#define BLUE  0x0000FF\n\n// productinfo.h\n// The following define product subtypes based on color\n\nenum class Product_info { RED, PURPLE, BLUE };   // syntax error \n```", "```\nenum { red = 0xFF0000, scale = 4, is_signed = 1 }; \n```", "```\nconstexpr int red = 0xFF0000;\nconstexpr short scale = 4;\nconstexpr bool is_signed = true; \n```", "```\nenum class Direction : char { n, s, e, w,\n                              ne, nw, se, sw };  // underlying type saves space\n\nenum class Web_color : int32_t { red   = 0xFF0000,\n                                 green = 0x00FF00,\n                                 blue  = 0x0000FF };  // underlying type is redundant \n```", "```\nenum Flags : char;\n\nvoid f(Flags);\n\n// ....\n\nenum Flags : char { /* ... */ }; \n```", "```\nenum Bitboard : uint64_t { /* ... */ }; \n```", "```\nenum class Col1 { red, yellow, blue };\nenum class Col2 { red = 1, yellow = 2, blue = 2 }; // typo\nenum class Month { jan = 1, feb, mar, apr, may, jun,\n                   jul, august, sep, oct, nov, dec }; // starting with 1 is conventional\nenum class Base_flag { dec = 1, oct = dec << 1, hex = dec << 2 }; // set of bits \n```", "```\nvoid send(X* x, string_view destination)\n{\n    auto port = open_port(destination);\n    my_mutex.lock();\n    // ...\n    send(port, x);\n    // ...\n    my_mutex.unlock();\n    close_port(port);\n    delete x;\n} \n```", "```\nvoid send(unique_ptr<X> x, string_view destination)  // x owns the X\n{\n    Port port{destination};            // port owns the PortHandle\n    lock_guard<mutex> guard{my_mutex}; // guard owns the lock\n    // ...\n    send(port, x);\n    // ...\n} // automatically unlocks my_mutex and deletes the pointer in x \n```", "```\nclass Port {\n    PortHandle port;\npublic:\n    Port(string_view destination) : port{open_port(destination)} { }\n    ~Port() { close_port(port); }\n    operator PortHandle() { return port; }\n\n    // port handles can't usually be cloned, so disable copying and assignment if necessary\n    Port(const Port&) = delete;\n    Port& operator=(const Port&) = delete;\n}; \n```", "```\nvoid f(int* p, int n)   // n is the number of elements in p[]\n{\n    // ...\n    p[2] = 7;   // bad: subscript raw pointer\n    // ...\n} \n```", "```\nvoid g(int* p, int fmt)   // print *p using format #fmt\n{\n    // ... uses *p and p[0] only ...\n} \n```", "```\nvoid f()\n{\n    int* p1 = new int{7};           // bad: raw owning pointer\n    auto p2 = make_unique<int>(7);  // OK: the int is owned by a unique pointer\n    // ...\n} \n```", "```\ntemplate<typename T>\nclass X {\npublic:\n    T* p;   // bad: it is unclear whether p is owning or not\n    T* q;   // bad: it is unclear whether q is owning or not\n    // ...\n}; \n```", "```\ntemplate<typename T>\nclass X2 {\npublic:\n    owner<T*> p;  // OK: p is owning\n    T* q;         // OK: q is not owning\n    // ...\n}; \n```", "```\nGadget* make_gadget(int n)\n{\n    auto p = new Gadget{n};\n    // ...\n    return p;\n}\n\nvoid caller(int n)\n{\n    auto p = make_gadget(n);   // remember to delete p\n    // ...\n    delete p;\n} \n```", "```\nGadget make_gadget(int n)\n{\n    Gadget g{n};\n    // ...\n    return g;\n} \n```", "```\nvoid f()\n{\n    int& r = *new int{7};  // bad: raw owning reference\n    // ...\n    delete &r;             // bad: violated the rule against deleting raw pointers\n} \n```", "```\nvoid f(int n)\n{\n    auto p = new Gadget{n};\n    // ...\n    delete p;\n} \n```", "```\nvoid f(int n)\n{\n    Gadget g{n};\n    // ...\n} \n```", "```\nclass Record {\n    int id;\n    string name;\n    // ...\n};\n\nvoid use()\n{\n    // p1 might be nullptr\n    // *p1 is not initialized; in particular,\n    // that string isn't a string, but a string-sized bag of bits\n    Record* p1 = static_cast<Record*>(malloc(sizeof(Record)));\n\n    auto p2 = new Record;\n\n    // unless an exception is thrown, *p2 is default initialized\n    auto p3 = new(nothrow) Record;\n    // p3 might be nullptr; if not, *p3 is default initialized\n\n    // ...\n\n    delete p1;    // error: cannot delete object allocated by malloc()\n    free(p2);    // error: cannot free() object allocated by new\n} \n```", "```\nvoid func(const string& name)\n{\n    FILE* f = fopen(name, \"r\");            // open the file\n    vector<char> buf(1024);\n    auto _ = finally([f] { fclose(f); });  // remember to close the file\n    // ...\n} \n```", "```\nvoid func(const string& name)\n{\n    ifstream f{name};   // open the file\n    vector<char> buf(1024);\n    // ...\n} \n```", "```\nvoid fun(shared_ptr<Widget> sp1, shared_ptr<Widget> sp2); \n```", "```\n// BAD: potential leak\nfun(shared_ptr<Widget>(new Widget(a, b)), shared_ptr<Widget>(new Widget(c, d))); \n```", "```\nshared_ptr<Widget> sp1(new Widget(a, b)); // Better, but messy\nfun(sp1, new Widget(c, d)); \n```", "```\nfun(make_shared<Widget>(a, b), make_shared<Widget>(c, d)); // Best \n```", "```\nvoid f(int[]);          // not recommended\n\nvoid f(int*);           // not recommended for multiple objects\n                        // (a pointer should point to a single object, do not subscript)\n\nvoid f(gsl::span<int>); // good, recommended \n```", "```\nclass X {\n    // ...\n    void* operator new(size_t s);\n    void operator delete(void*);\n    // ...\n}; \n```", "```\nvoid f()\n{\n    X* p1 { new X };              // bad, p1 will leak\n    auto p2 = make_unique<X>();   // good, unique ownership\n    auto p3 = make_shared<X>();   // good, shared ownership\n} \n```", "```\nvoid f()\n{\n    shared_ptr<Base> base = make_shared<Derived>();\n    // use base locally, without copying it -- refcount never exceeds 1\n} // destroy base \n```", "```\nvoid f()\n{\n    unique_ptr<Base> base = make_unique<Derived>();\n    // use base locally\n} // destroy base \n```", "```\nshared_ptr<X> p1 { new X{2} }; // bad\nauto p = make_shared<X>(2);    // good \n```", "```\nunique_ptr<Foo> p {new Foo{7}};    // OK: but repetitive\n\nauto q = make_unique<Foo>(7);      // Better: no repetition of Foo \n```", "```\n#include <memory>\n\nclass bar;\n\nclass foo {\npublic:\n  explicit foo(const std::shared_ptr<bar>& forward_reference)\n    : forward_reference_(forward_reference)\n  { }\nprivate:\n  std::shared_ptr<bar> forward_reference_;\n};\n\nclass bar {\npublic:\n  explicit bar(const std::weak_ptr<foo>& back_reference)\n    : back_reference_(back_reference)\n  { }\n  void do_something()\n  {\n    if (auto shared_back_reference = back_reference_.lock()) {\n      // Use *shared_back_reference\n    }\n  }\nprivate:\n  std::weak_ptr<foo> back_reference_;\n}; \n```", "```\n// use Boost's intrusive_ptr\n#include <boost/intrusive_ptr.hpp>\nvoid f(boost::intrusive_ptr<widget> p)  // error under rule 'sharedptrparam'\n{\n    p->foo();\n}\n\n// use Microsoft's CComPtr\n#include <atlbase.h>\nvoid f(CComPtr<widget> p)               // error under rule 'sharedptrparam'\n{\n    p->foo();\n} \n```", "```\nvoid sink(unique_ptr<widget>); // takes ownership of the widget\n\nvoid uses(widget*);            // just uses the widget \n```", "```\nvoid reseat(unique_ptr<widget>&); // \"will\" or \"might\" reseat pointer \n```", "```\nclass WidgetUser\n{\npublic:\n    // WidgetUser will share ownership of the widget\n    explicit WidgetUser(std::shared_ptr<widget> w) noexcept:\n        m_widget{std::move(w)} {}\n    // ...\nprivate:\n    std::shared_ptr<widget> m_widget;\n}; \n```", "```\nvoid ChangeWidget(std::shared_ptr<widget>& w)\n{\n    // This will change the callers widget\n    w = std::make_shared<widget>(widget{});\n} \n```", "```\nvoid share(shared_ptr<widget>);            // share -- \"will\" retain refcount\n\nvoid reseat(shared_ptr<widget>&);          // \"might\" reseat ptr\n\nvoid may_share(const shared_ptr<widget>&); // \"might\" retain refcount \n```", "```\n// global (static or heap), or aliased local ...\nshared_ptr<widget> g_p = ...;\n\nvoid f(widget& w)\n{\n    g();\n    use(w);  // A\n}\n\nvoid g()\n{\n    g_p = ...; // oops, if this was the last shared_ptr to that widget, destroys the widget\n} \n```", "```\nvoid my_code()\n{\n    // BAD: passing pointer or reference obtained from a non-local smart pointer\n    //      that could be inadvertently reset somewhere inside f or its callees\n    f(*g_p);\n\n    // BAD: same reason, just passing it as a \"this\" pointer\n    g_p->func();\n} \n```", "```\nvoid my_code()\n{\n    // cheap: 1 increment covers this entire function and all the call trees below us\n    auto pin = g_p;\n\n    // GOOD: passing pointer or reference obtained from a local unaliased smart pointer\n    f(*pin);\n\n    // GOOD: same reason\n    pin->func();\n} \n```", "```\nauto sum = accumulate(begin(a), end(a), 0.0);   // good \n```", "```\nauto sum = accumulate(v, 0.0); // better \n```", "```\nint max = v.size();   // bad: verbose, purpose unstated\ndouble sum = 0.0;\nfor (int i = 0; i < max; ++i)\n    sum = sum + v[i]; \n```", "```\nvector<string> read1(istream& is)   // good\n{\n    vector<string> res;\n    for (string s; is >> s;)\n        res.push_back(s);\n    return res;\n} \n```", "```\nchar** read2(istream& is, int maxelem, int maxstring, int* nread)   // bad: verbose and incomplete\n{\n    auto res = new char*[maxelem];\n    int elemcount = 0;\n    while (is && elemcount < maxelem) {\n        auto s = new char[maxstring];\n        is.read(s, maxstring);\n        res[elemcount++] = s;\n    }\n    *nread = elemcount;\n    return res;\n} \n```", "```\nvoid func(bool flag)    // Bad, duplicated code.\n{\n    if (flag) {\n        x();\n        y();\n    }\n    else {\n        x();\n        z();\n    }\n}\n\nvoid func(bool flag)    // Better, no duplicated code.\n{\n    x();\n\n    if (flag)\n        y();\n    else\n        z();\n} \n```", "```\nvoid use()\n{\n    int i;    // bad: i is needlessly accessible after loop\n    for (i = 0; i < 20; ++i) { /* ... */ }\n    // no intended use of i here\n    for (int i = 0; i < 20; ++i) { /* ... */ }  // good: i is local to for-loop\n\n    if (auto pc = dynamic_cast<Circle*>(ps)) {  // good: pc is local to if-statement\n        // ... deal with Circle ...\n    }\n    else {\n        // ... handle error ...\n    }\n} \n```", "```\nvoid use(const string& name)\n{\n    string fn = name + \".txt\";\n    ifstream is {fn};\n    Record r;\n    is >> r;\n    // ... 200 lines of code without intended use of fn or is ...\n} \n```", "```\nRecord load_record(const string& name)\n{\n    string fn = name + \".txt\";\n    ifstream is {fn};\n    Record r;\n    is >> r;\n    return r;\n}\n\nvoid use(const string& name)\n{\n    Record r = load_record(name);\n    // ... 200 lines of code ...\n} \n```", "```\nvoid use()\n{\n    for (string s; cin >> s;)\n        v.push_back(s);\n\n    for (int i = 0; i < 20; ++i) {   // good: i is local to for-loop\n        // ...\n    }\n\n    if (auto pc = dynamic_cast<Circle*>(ps)) {   // good: pc is local to if-statement\n        // ... deal with Circle ...\n    }\n    else {\n        // ... handle error ...\n    }\n} \n```", "```\nint j;                            // BAD: j is visible outside the loop\nfor (j = 0; j < 100; ++j) {\n    // ...\n}\n// j is still visible here and isn't needed \n```", "```\nmap<int, string> mymap;\n\nif (auto result = mymap.insert(value); result.second) {\n    // insert succeeded, and result is valid for this block\n    use(result.first);  // ok\n    // ...\n} // result is destroyed here \n```", "```\ntemplate<typename T>    // good\nvoid print(ostream& os, const vector<T>& v)\n{\n    for (gsl::index i = 0; i < v.size(); ++i)\n        os << v[i] << '\\n';\n} \n```", "```\ntemplate<typename Element_type>   // bad: verbose, hard to read\nvoid print(ostream& target_stream, const vector<Element_type>& current_vector)\n{\n    for (gsl::index current_element_index = 0;\n         current_element_index < current_vector.size();\n         ++current_element_index\n    )\n    target_stream << current_vector[current_element_index] << '\\n';\n} \n```", "```\nvoid use1(const string& s)\n{\n    // ...\n    tt(s);   // bad: what is tt()?\n    // ...\n} \n```", "```\nvoid use1(const string& s)\n{\n    // ...\n    trim_tail(s);   // better\n    // ...\n} \n```", "```\nvoid complicated_algorithm(vector<Record>& vr, const vector<int>& vi, map<string, int>& out)\n// read from events in vr (marking used Records) for the indices in\n// vi placing (name, index) pairs into out\n{\n    // ... 500 lines of code using vr, vi, and out ...\n} \n```", "```\nif (readable(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) surprise(); \n```", "```\nstruct foo { int n; };\nstruct foo foo();       // BAD, foo is a type already in scope\nstruct foo x = foo();   // requires disambiguation \n```", "```\n// somewhere in some header:\n#define NE !=\n\n// somewhere else in some other header:\nenum Coord { N, NE, NW, S, SE, SW, E, W };\n\n// somewhere third in some poor programmer's .cpp:\nswitch (direction) {\ncase N:\n    // ...\ncase NE:\n    // ...\n// ...\n} \n```", "```\nchar *p, c, a[7], *pp[7], **aa[10];   // yuck! \n```", "```\nauto [iter, inserted] = m.insert_or_assign(k, val);\nif (inserted) { /* new entry was inserted */ } \n```", "```\ntemplate<class InputIterator, class Predicate>\nbool any_of(InputIterator first, InputIterator last, Predicate pred); \n```", "```\nbool any_of(input_iterator auto first, input_iterator auto last, predicate auto pred); \n```", "```\ndouble scalbn(double x, int n);   // OK: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2 \n```", "```\ndouble scalbn(    // better: x * pow(FLT_RADIX, n); FLT_RADIX is usually 2\n    double x,     // base value\n    int n         // exponent\n); \n```", "```\n// better: base * pow(FLT_RADIX, exponent); FLT_RADIX is usually 2\ndouble scalbn(double base, int exponent); \n```", "```\nint a = 10, b = 11, c = 12, d, e = 14, f = 15; \n```", "```\nauto p = v.begin();      // vector<DataRecord>::iterator\nauto z1 = v[3];          // makes copy of DataRecord\nauto& z2 = v[3];         // avoids copy\nconst auto& z3 = v[3];   // const and avoids copy\nauto h = t.future();\nauto q = make_unique<int[]>(s);\nauto f = [](int x) { return x + 10; }; \n```", "```\ntemplate<class T>\nauto Container<T>::first() -> Iterator;   // Container<T>::Iterator \n```", "```\nauto lst = { 1, 2, 3 };   // lst is an initializer list\nauto x{1};   // x is an int (in C++17; initializer_list in C++11) \n```", "```\n// ...\nforward_iterator auto p = algo(x, y, z); \n```", "```\nstd::set<int> values;\n// ...\nauto [ position, newly_inserted ] = values.insert(5);   // break out the members of the std::pair \n```", "```\nint d = 0;\n// ...\nif (cond) {\n    // ...\n    d = 9;\n    // ...\n}\nelse {\n    // ...\n    int d = 7;\n    // ...\n    d = value_to_be_returned;\n    // ...\n}\n\nreturn d; \n```", "```\nvoid f(int x)\n{\n    int x = 4;  // error: reuse of function argument name\n\n    if (x) {\n        int x = 7;  // allowed, but bad\n        // ...\n    }\n} \n```", "```\nstruct S {\n    int m;\n    void f(int x);\n};\n\nvoid S::f(int x)\n{\n    m = 7;    // assign to member\n    if (x) {\n        int m = 9;\n        // ...\n        m = 99; // assign to local variable\n        // ...\n    }\n} \n```", "```\nstruct B {\n    void f(int);\n};\n\nstruct D : B {\n    void f(double);\n    using B::f;\n}; \n```", "```\nvoid use(int arg)\n{\n    int i;   // bad: uninitialized variable\n    // ...\n    i = 7;   // initialize i\n} \n```", "```\nvoid use(int arg)   // OK\n{\n    int i = 7;   // OK: initialized\n    string s;    // OK: default initialized\n    // ...\n} \n```", "```\nwidget i;    // \"widget\" a type that's expensive to initialize, possibly a large trivial type\nwidget j;\n\nif (cond) {  // bad: i and j are initialized \"late\"\n    i = f1();\n    j = f2();\n}\nelse {\n    i = f3();\n    j = f4();\n} \n```", "```\npair<widget, widget> make_related_widgets(bool x)\n{\n    return (x) ? {f1(), f2()} : {f3(), f4()};\n}\n\nauto [i, j] = make_related_widgets(cond);    // C++17 \n```", "```\nauto [i, j] = [x] { return (x) ? pair{f1(), f2()} : pair{f3(), f4()} }();    // C++17 \n```", "```\nwidget i = uninit;  // bad\nwidget j = uninit;\n\n// ...\nuse(i);         // possibly used before set\n// ...\n\nif (cond) {     // bad: i and j are initialized \"late\"\n    i = f1();\n    j = f2();\n}\nelse {\n    i = f3();\n    j = f4();\n} \n```", "```\nclass X {\npublic:\n    X(int i, int ci) : m2{i}, cm2{ci} {}\n    // ...\n\nprivate:\n    int m1 = 7;\n    int m2;\n    int m3;\n\n    const int cm1 = 7;\n    const int cm2;\n    const int cm3;\n}; \n```", "```\nconstexpr int max = 8 * 1024;\nint buf[max];         // OK, but suspicious: uninitialized\nf.read(buf, max); \n```", "```\nconstexpr int max = 8 * 1024;\nint buf[max] = {};   // zero all elements; better in some situations\nf.read(buf, max); \n```", "```\nstring s;   // s is default initialized to \"\"\ncin >> s;   // s expands to hold the string \n```", "```\nint i;   // bad\n// ...\ncin >> i; \n```", "```\nint i2 = 0;   // better, assuming that zero is an acceptable value for i2\n// ...\ncin >> i2; \n```", "```\nerror_code ec;\nValue v = [&] {\n    auto p = get_value();   // get_value() returns a pair<error_code, Value>\n    ec = p.first;\n    return p.second;\n}(); \n```", "```\nValue v = [] {\n    auto p = get_value();   // get_value() returns a pair<error_code, Value>\n    if (p.first) throw Bad_value{p.first};\n    return p.second;\n}(); \n```", "```\nint x = 7;\n// ... no use of x here ...\n++x; \n```", "```\nstring s;\n// ... no use of s here ...\ns = \"what a waste\"; \n```", "```\nSomeLargeType var;  // Hard-to-read CaMeLcAsEvArIaBlE\n\nif (cond)   // some non-trivial condition\n    Set(&var);\nelse if (cond2 || !cond3) {\n    var = Set2(3.14);\n}\nelse {\n    var = 0;\n    for (auto& e : something)\n        var += e;\n}\n\n// use var; that this isn't done too early can be enforced statically with only control flow \n```", "```\nint x {f(99)};\nint y = x;\nvector<int> v = {1, 2, 3, 4, 5, 6}; \n```", "```\nvector<int> v1(10);    // vector of 10 elements with the default value 0\nvector<int> v2{10};    // vector of 1 element with the value 10\n\nvector<int> v3(1, 2);  // vector of 1 element with the value 2\nvector<int> v4{1, 2};  // vector of 2 elements with the values 1 and 2 \n```", "```\nint x {7.9};   // error: narrowing\nint y = 7.9;   // OK: y becomes 7\\. Hope for a compiler warning\nint z {gsl::narrow_cast<int>(7.9)};    // OK: you asked for it\nauto zz = gsl::narrow_cast<int>(7.9);  // OK: you asked for it \n```", "```\nauto p = new vector<int> {1, 2, 3, 4, 5};   // initialized vector\nD::D(int a, int b) :m{a, b} {   // member initializer (e.g., m might be a pair)\n    // ...\n};\nX var {};   // initialize var to be empty\nstruct S {\n    int m {7};   // default initializer for a member\n    // ...\n}; \n```", "```\nauto x1 {7};        // x1 is an int with the value 7\nauto x2 = {7};      // x2 is an initializer_list<int> with an element 7\n\nauto x11 {7, 8};    // error: two initializers\nauto x22 = {7, 8};  // x22 is an initializer_list<int> with elements 7 and 8 \n```", "```\nauto fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};   // fib10 is a list \n```", "```\nstruct Z { explicit Z() {} };\n\nZ z1{};     // OK: direct initialization, so we use explicit constructor\nZ z2 = {};  // error: copy initialization, so we cannot use the explicit constructor \n```", "```\ntemplate<typename T>\nvoid f()\n{\n    T x1(1);    // T initialized with 1\n    T x0();     // bad: function declaration (often a mistake)\n\n    T y1 {1};   // T initialized with 1\n    T y0 {};    // default initialized T\n    // ...\n} \n```", "```\nvoid use(bool leak)\n{\n    auto p1 = make_unique<int>(7);   // OK\n    int* p2 = new int{7};            // bad: might leak\n    // ... no assignment to p2 ...\n    if (leak) return;\n    // ... no assignment to p2 ...\n    vector<int> v(7);\n    v.at(7) = 0;                    // exception thrown\n    delete p2;                      // too late to prevent leaks\n    // ...\n} \n```", "```\nvoid f(int n)\n{\n    const int bufmax = 2 * n + 2;  // good: we can't change bufmax by accident\n    int xmax = n;                  // suspicious: is xmax intended to change?\n    // ...\n} \n```", "```\nvoid use()\n{\n    int i;\n    for (i = 0; i < 20; ++i) { /* ... */ }\n    for (i = 0; i < 200; ++i) { /* ... */ } // bad: i recycled\n} \n```", "```\nvoid write_to_file()\n{\n    std::string buffer;             // to avoid reallocations on every loop iteration\n    for (auto& o : objects) {\n        // First part of the work.\n        generate_first_string(buffer, o);\n        write_to_file(buffer);\n\n        // Second part of the work.\n        generate_second_string(buffer, o);\n        write_to_file(buffer);\n\n        // etc...\n    }\n} \n```", "```\nconst int n = 7;\nint m = 9;\n\nvoid f()\n{\n    int a1[n];\n    int a2[m];   // error: not ISO C++\n    // ...\n} \n```", "```\nconst int n = 7;\nint m = 9;\n\nvoid f()\n{\n    array<int, n> a1;\n    stack_array<int> a2(m);\n    // ...\n} \n```", "```\nwidget x;   // should be const, but:\nfor (auto i = 2; i <= N; ++i) {          // this could be some\n    x += some_obj.do_something_with(i);  // arbitrarily long code\n}                                        // needed to initialize x\n// from here, x should be const, but we can't say so in code in this style \n```", "```\nconst widget x = [&] {\n    widget val;                                // assume that widget has a default constructor\n    for (auto i = 2; i <= N; ++i) {            // this could be some\n        val += some_obj.do_something_with(i);  // arbitrarily long code\n    }                                          // needed to initialize x\n    return val;\n}(); \n```", "```\n#define Case break; case   /* BAD */ \n```", "```\n#define CAT(a, b) a ## b\n#define STRINGIFY(a) #a\n\nvoid f(int x, int y)\n{\n    string CAT(x, y) = \"asdf\";   // BAD: hard for tools to handle (and ugly)\n    string sx2 = STRINGIFY(x);\n    // ...\n} \n```", "```\nenum E { a, b };\n\ntemplate<int x>\nconstexpr const char* stringify()\n{\n    switch (x) {\n    case a: return \"a\";\n    case b: return \"b\";\n    }\n}\n\nvoid f()\n{\n    string s1 = stringify<a>();\n    string s2 = stringify<b>();\n    // ...\n} \n```", "```\n#define PI 3.14\n#define SQUARE(a, b) (a * b) \n```", "```\nconstexpr double pi = 3.14;\ntemplate<typename T> T square(T a, T b) { return a * b; } \n```", "```\n#define forever for (;;)   /* very BAD */\n\n#define FOREVER for (;;)   /* Still evil, but at least visible to humans */ \n```", "```\n#define MYCHAR        /* BAD, will eventually clash with someone else's MYCHAR*/\n\n#define ZCORP_CHAR    /* Still evil, but less likely to clash */ \n```", "```\n#include <cstdarg>\n\n// \"severity\" followed by a zero-terminated list of char*s; write the C-style strings to cerr\nvoid error(int severity ...)\n{\n    va_list ap;             // a magic type for holding arguments\n    va_start(ap, severity); // arg startup: \"severity\" is the first argument of error()\n\n    for (;;) {\n        // treat the next var as a char*; no checking: a cast in disguise\n        char* p = va_arg(ap, char*);\n        if (!p) break;\n        cerr << p << ' ';\n    }\n\n    va_end(ap);             // arg cleanup (don't forget this)\n\n    cerr << '\\n';\n    if (severity) exit(severity);\n}\n\nvoid use()\n{\n    error(7, \"this\", \"is\", \"an\", \"error\", nullptr);\n    error(7); // crash\n    error(7, \"this\", \"is\", \"an\", \"error\");  // crash\n    const char* is = \"is\";\n    string an = \"an\";\n    error(7, \"this\", is, an, \"error\"); // crash\n} \n```", "```\n#include <iostream>\n\nvoid error(int severity)\n{\n    std::cerr << '\\n';\n    std::exit(severity);\n}\n\ntemplate<typename T, typename... Ts>\nconstexpr void error(int severity, T head, Ts... tail)\n{\n    std::cerr << head;\n    error(severity, tail...);\n}\n\nvoid use()\n{\n    error(7); // No crash!\n    error(5, \"this\", \"is\", \"not\", \"an\", \"error\"); // No crash!\n\n    std::string an = \"an\";\n    error(7, \"this\", \"is\", \"not\", an, \"error\"); // No crash!\n\n    error(5, \"oh\", \"no\", nullptr); // Compile error! No need for nullptr.\n} \n```", "```\n// bad: assignment hidden in subexpression\nwhile ((c = getc()) != -1)\n\n// bad: two non-local variables assigned in sub-expressions\nwhile ((cin >> c1, cin >> c2), c1 == c2)\n\n// better, but possibly still too complicated\nfor (char c1, c2; cin >> c1 >> c2 && c1 == c2;)\n\n// OK: if i and j are not aliased\nint x = ++i + ++j;\n\n// OK: if i != j and i != k\nv[i] = v[j] + v[k];\n\n// bad: multiple assignments \"hidden\" in subexpressions\nx = a + (b = f()) + (c = g()) * 7;\n\n// bad: relies on commonly misunderstood precedence rules\nx = a & b + c * d && e ^ f == 7;\n\n// bad: undefined behavior\nx = x++ + x++ + ++x; \n```", "```\nx = k * y + z;             // OK\n\nauto t1 = k * y;           // bad: unnecessarily verbose\nx = t1 + z;\n\nif (0 <= x && x < max)   // OK\n\nauto t1 = 0 <= x;        // bad: unnecessarily verbose\nauto t2 = x < max;\nif (t1 && t2)            // ... \n```", "```\nconst unsigned int flag = 2;\nunsigned int a = flag;\n\nif (a & flag != 0)  // bad: means a&(flag != 0) \n```", "```\nif ((a & flag) != 0)  // OK: works as intended \n```", "```\nif (a < 0 || a <= max) {\n    // ...\n} \n```", "```\nvoid f(int* p, int count)\n{\n    if (count < 2) return;\n\n    int* q = p + 1;    // BAD\n\n    ptrdiff_t d;\n    int n;\n    d = (p - &n);      // OK\n    d = (q - p);       // OK\n\n    int n = *p++;      // BAD\n\n    if (count < 6) return;\n\n    p[4] = 1;          // BAD\n\n    p[count - 1] = 2;  // BAD\n\n    use(&p[0], 3);     // BAD\n} \n```", "```\nvoid f(span<int> a) // BETTER: use span in the function declaration\n{\n    if (a.size() < 2) return;\n\n    int n = a[0];      // OK\n\n    span<int> q = a.subspan(1); // OK\n\n    if (a.size() < 6) return;\n\n    a[4] = 1;          // OK\n\n    a[a.size() - 1] = 2;  // OK\n\n    use(a.data(), 3);  // OK\n} \n```", "```\nvoid f(array<int, 10> a, int pos)\n{\n    a[pos / 2] = 1; // BAD\n    a[pos - 1] = 2; // BAD\n    a[-1] = 3;    // BAD (but easily caught by tools) -- no replacement, just don't do this\n    a[10] = 4;    // BAD (but easily caught by tools) -- no replacement, just don't do this\n} \n```", "```\nvoid f1(span<int, 10> a, int pos) // A1: Change parameter type to use span\n{\n    a[pos / 2] = 1; // OK\n    a[pos - 1] = 2; // OK\n}\n\nvoid f2(array<int, 10> arr, int pos) // A2: Add local span and use that\n{\n    span<int> a = {arr.data(), pos};\n    a[pos / 2] = 1; // OK\n    a[pos - 1] = 2; // OK\n} \n```", "```\nvoid f3(array<int, 10> a, int pos) // ALTERNATIVE B: Use at() for access\n{\n    at(a, pos / 2) = 1; // OK\n    at(a, pos - 1) = 2; // OK\n} \n```", "```\nvoid f()\n{\n    int arr[COUNT];\n    for (int i = 0; i < COUNT; ++i)\n        arr[i] = i; // BAD, cannot use non-constant indexer\n} \n```", "```\nvoid f1()\n{\n    int arr[COUNT];\n    span<int> av = arr;\n    for (int i = 0; i < COUNT; ++i)\n        av[i] = i;\n} \n```", "```\nvoid f1a()\n{\n     int arr[COUNT];\n     span<int, COUNT> av = arr;\n     int i = 0;\n     for (auto& e : av)\n         e = i++;\n} \n```", "```\nvoid f2()\n{\n    int arr[COUNT];\n    for (int i = 0; i < COUNT; ++i)\n        at(arr, i) = i;\n} \n```", "```\nvoid f3()\n{\n    int arr[COUNT];\n    int i = 0;\n    for (auto& e : arr)\n         e = i++;\n} \n```", "```\nstatic int a[10];\n\nvoid f(int i, int j)\n{\n    a[i + j] = 12;      // BAD, could be rewritten as ...\n    at(a, i + j) = 12;  // OK -- bounds-checked\n} \n```", "```\nvoid g(int* p);\n\nvoid f()\n{\n    int a[5];\n    g(a);        // BAD: are we trying to pass an array?\n    g(&a[0]);    // OK: passing one object\n} \n```", "```\nvoid g(int* p, size_t length);  // old (dangerous) code\n\nvoid g1(span<int> av); // BETTER: get g() changed.\n\nvoid f2()\n{\n    int a[5];\n    span<int> av = a;\n\n    g(av.data(), av.size());   // OK, if you have no choice\n    g1(a);                     // OK -- no decay here, instead use implicit span ctor\n} \n```", "```\nv[i] = ++i;   //  the result is undefined \n```", "```\nint i = 0;\nf(++i, ++i); \n```", "```\nf1()->m(f2());          // m(f1(), f2())\ncout << f1() << f2();   // operator<<(operator<<(cout, f1()), f2()) \n```", "```\nf1() = f2();    // undefined behavior in C++14; in C++17, f2() is evaluated before f1() \n```", "```\nfor (int m = 1; m <= 12; ++m)   // don't: magic constant 12\n    cout << month[m] << '\\n'; \n```", "```\n// months are indexed 1..12\nconstexpr int first_month = 1;\nconstexpr int last_month = 12;\n\nfor (int m = first_month; m <= last_month; ++m)   // better\n    cout << month[m] << '\\n'; \n```", "```\nfor (auto m : month)\n    cout << m << '\\n'; \n```", "```\ndouble d = 7.9;\nint i = d;    // bad: narrowing: i becomes 7\ni = (int) d;  // bad: we're going to claim this is still not explicit enough\n\nvoid f(int x, long y, double d)\n{\n    char c1 = x;   // bad: narrowing\n    char c2 = y;   // bad: narrowing\n    char c3 = d;   // bad: narrowing\n} \n```", "```\ni = gsl::narrow_cast<int>(d);   // OK (you asked for it): narrowing: i becomes 7\ni = gsl::narrow<int>(d);        // OK: throws narrowing_error \n```", "```\ndouble d = -7.9;\nunsigned u = 0;\n\nu = d;                               // bad: narrowing\nu = gsl::narrow_cast<unsigned>(d);   // OK (you asked for it): u becomes 4294967289\nu = gsl::narrow<unsigned>(d);        // OK: throws narrowing_error \n```", "```\nif (ptr) do_something(*ptr);   // OK: ptr is used as a condition\nbool b = ptr;                  // bad: narrowing \n```", "```\nvoid f(int);\nvoid f(char*);\nf(0);         // call f(int)\nf(nullptr);   // call f(char*) \n```", "```\ndouble d = 2;\nauto p = (long*)&d;\nauto q = (long long*)&d;\ncout << d << ' ' << *p << ' ' << *q << '\\n'; \n```", "```\n2 0 4611686018427387904 \n```", "```\n*q = 666;\ncout << d << ' ' << *p << ' ' << *q << '\\n'; \n```", "```\n3.29048e-321 666 666 \n```", "```\nclass B { /* ... */ };\nclass D { /* ... */ };\n\ntemplate<typename D> D* upcast(B* pb)\n{\n    D* pd0 = pb;                        // error: no implicit conversion from B* to D*\n    D* pd1 = (D*)pb;                    // legal, but what is done?\n    D* pd2 = static_cast<D*>(pb);       // error: D is not derived from B\n    D* pd3 = reinterpret_cast<D*>(pb);  // OK: on your head be it!\n    D* pd4 = dynamic_cast<D*>(pb);      // OK: return nullptr\n    // ...\n} \n```", "```\ndouble d {some_float};\nint64_t i {some_int32}; \n```", "```\nauto p = reinterpret_cast<Device_register>(0x800);  // inherently dangerous \n```", "```\nvoid f(const int& x)\n{\n    const_cast<int&>(x) = 42;   // BAD\n}\n\nstatic int i = 0;\nstatic const int j = 0;\n\nf(i); // silent side effect\nf(j); // undefined behavior \n```", "```\nclass Bar;\n\nclass Foo {\npublic:\n    // BAD, duplicates logic\n    Bar& get_bar()\n    {\n        /* complex logic around getting a non-const reference to my_bar */\n    }\n\n    const Bar& get_bar() const\n    {\n        /* same complex logic around getting a const reference to my_bar */\n    }\nprivate:\n    Bar my_bar;\n}; \n```", "```\nclass Foo {\npublic:\n    // not great, non-const calls const version but resorts to const_cast\n    Bar& get_bar()\n    {\n        return const_cast<Bar&>(static_cast<const Foo&>(*this).get_bar());\n    }\n    const Bar& get_bar() const\n    {\n        /* the complex logic around getting a const reference to my_bar */\n    }\nprivate:\n    Bar my_bar;\n}; \n```", "```\nclass Foo {\npublic:                         // good\n          Bar& get_bar()       { return get_bar_impl(*this); }\n    const Bar& get_bar() const { return get_bar_impl(*this); }\nprivate:\n    Bar my_bar;\n\n    template<class T>           // good, deduces whether T is const or non-const\n    static auto& get_bar_impl(T& t)\n        { /* the complex logic around getting a possibly-const reference to my_bar */ }\n}; \n```", "```\nint compute(int x); // compute a value for x; assume this to be costly\n\nclass Cache {   // some type implementing a cache for an int->int operation\npublic:\n    pair<bool, int> find(int x) const;   // is there a value for x?\n    void set(int x, int v);             // make y the value for x\n    // ...\nprivate:\n    // ...\n};\n\nclass X {\npublic:\n    int get_val(int x)\n    {\n        auto p = cache.find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        cache.set(x, val); // insert value for x\n        return val;\n    }\n    // ...\nprivate:\n    Cache cache;\n}; \n```", "```\nclass X {   // Suspicious solution based on casting\npublic:\n    int get_val(int x) const\n    {\n        auto p = cache.find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        const_cast<Cache&>(cache).set(x, val);   // ugly\n        return val;\n    }\n    // ...\nprivate:\n    Cache cache;\n}; \n```", "```\nclass X {   // better solution\npublic:\n    int get_val(int x) const\n    {\n        auto p = cache.find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        cache.set(x, val);\n        return val;\n    }\n    // ...\nprivate:\n    mutable Cache cache;\n}; \n```", "```\nclass X {   // OK, but slightly messier solution\npublic:\n    int get_val(int x) const\n    {\n        auto p = cache->find(x);\n        if (p.first) return p.second;\n        int val = compute(x);\n        cache->set(x, val);\n        return val;\n    }\n    // ...\nprivate:\n    unique_ptr<Cache> cache;\n}; \n```", "```\nfor (auto& x : v)      // print all elements of v\n    cout << x << '\\n';\n\nauto p = find(v, x);   // find x in v \n```", "```\nvoid sink(X&& x);   // sink takes ownership of x\n\nvoid user()\n{\n    X x;\n    // error: cannot bind an lvalue to a rvalue reference\n    sink(x);\n    // OK: sink takes the contents of x, x must now be assumed to be empty\n    sink(std::move(x));\n\n    // ...\n\n    // probably a mistake\n    use(x);\n} \n```", "```\nvoid f()\n{\n    string s1 = \"supercalifragilisticexpialidocious\";\n\n    string s2 = s1;             // ok, takes a copy\n    assert(s1 == \"supercalifragilisticexpialidocious\");  // ok\n\n    // bad, if you want to keep using s1's value\n    string s3 = move(s1);\n\n    // bad, assert will likely fail, s1 likely changed\n    assert(s1 == \"supercalifragilisticexpialidocious\");\n} \n```", "```\nvoid sink(unique_ptr<widget> p);  // pass ownership of p to sink()\n\nvoid f()\n{\n    auto w = make_unique<widget>();\n    // ...\n    sink(std::move(w));               // ok, give to sink()\n    // ...\n    sink(w);    // Error: unique_ptr is carefully designed so that you cannot copy it\n} \n```", "```\nvector<int> make_vector()\n{\n    vector<int> result;\n    // ... load result with data\n    return std::move(result);       // bad; just write \"return result;\"\n} \n```", "```\nvector<int> v = std::move(make_vector());   // bad; the std::move is entirely redundant \n```", "```\nvoid mover(X&& x)\n{\n    call_something(std::move(x));         // ok\n    call_something(std::forward<X>(x));   // bad, don't std::forward an rvalue reference\n    call_something(x);                    // suspicious, why not std::move?\n}\n\ntemplate<class T>\nvoid forwarder(T&& t)\n{\n    call_something(std::move(t));         // bad, don't std::move a forwarding reference\n    call_something(std::forward<T>(t));   // ok\n    call_something(t);                    // suspicious, why not std::forward?\n} \n```", "```\nvoid f(int n)\n{\n    auto p = new X[n];   // n default constructed Xs\n    // ...\n    delete[] p;\n} \n```", "```\nvoid f(int n)\n{\n    auto p = new X[n];   // n default constructed Xs\n    // ...\n    delete p;   // error: just delete the object p, rather than delete the array p[]\n} \n```", "```\nvoid f()\n{\n    int a1[7];\n    int a2[9];\n    if (&a1[5] < &a2[7]) {}       // bad: undefined\n    if (0 < &a1[5] - &a2[7]) {}   // bad: undefined\n} \n```", "```\nclass Shape { /* ... */ };\nclass Circle : public Shape { /* ... */ Point c; int r; };\n\nCircle c { {0, 0}, 42 };\nShape s {c};    // copy construct only the Shape part of Circle\ns = c;          // or copy assign only the Shape part of Circle\n\nvoid assign(const Shape& src, Shape& dest)\n{\n    dest = src;\n}\nCircle c2 { {1, 1}, 43 };\nassign(c, c2);   // oops, not the whole state is transferred\nassert(c == c2); // if we supply copying, we should also provide comparison,\n                 // but this will likely return false \n```", "```\nclass Smiley : public Circle {\n    public:\n    Circle copy_circle();\n    // ...\n};\n\nSmiley sm { /* ... */ };\nCircle c1 {sm};  // ideally prevented by the definition of Circle\nCircle c2 {sm.copy_circle()}; \n```", "```\nvoid use(char ch, int i, double d, char* p, long long lng)\n{\n    int x1 = int{ch};     // OK, but redundant\n    int x2 = int{d};      // error: double->int narrowing; use a cast if you need to\n    int x3 = int{p};      // error: pointer to->int; use a reinterpret_cast if you really need to\n    int x4 = int{lng};    // error: long long->int narrowing; use a cast if you need to\n\n    int y1 = int(ch);     // OK, but redundant\n    int y2 = int(d);      // bad: double->int narrowing; use a cast if you need to\n    int y3 = int(p);      // bad: pointer to->int; use a reinterpret_cast if you really need to\n    int y4 = int(lng);    // bad: long long->int narrowing; use a cast if you need to\n\n    int z1 = (int)ch;     // OK, but redundant\n    int z2 = (int)d;      // bad: double->int narrowing; use a cast if you need to\n    int z3 = (int)p;      // bad: pointer to->int; use a reinterpret_cast if you really need to\n    int z4 = (int)lng;    // bad: long long->int narrowing; use a cast if you need to\n} \n```", "```\ncomplex<double> f(complex<double>);\n\nauto z = f({2*pi, 1}); \n```", "```\nvector<string> vs {10};                           // ten empty strings\nvector<int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  // ten elements 1..10\nvector<int> vi2 {10};                             // one element with the value 10 \n```", "```\nvector<int> v3(10); // ten elements with value 0 \n```", "```\nstruct Count { int n; };\n\ntemplate<typename T>\nclass Vector {\npublic:\n    Vector(Count n);                     // n default-initialized elements\n    Vector(initializer_list<T> init);    // init.size() elements\n    // ...\n};\n\nVector<int> v1{10};\nVector<int> v2{Count{10}};\nVector<Count> v3{Count{10}};    // yes, there is still a very minor problem \n```", "```\nvoid f()\n{\n    int x = 0;\n    int* p = &x;\n\n    if (condition()) {\n        int y = 0;\n        p = &y;\n    } // invalidates p\n\n    *p = 42;            // BAD, p might be invalid if the branch was taken\n} \n```", "```\nvoid f1()\n{\n    int x = 0;\n    int* p = &x;\n\n    int y = 0;\n    if (condition()) {\n        p = &y;\n    }\n\n    *p = 42;            // OK, p points to x or y and both are still in scope\n} \n```", "```\nvoid f(int* p)\n{\n    int x = *p; // BAD: how do we know that p is valid?\n} \n```", "```\nvoid f1(int* p) // deal with nullptr\n{\n    if (!p) {\n        // deal with nullptr (allocate, return, throw, make p point to something, whatever)\n    }\n    int x = *p;\n} \n```", "```\nvoid f2(int* p) // state that p is not supposed to be nullptr\n{\n    assert(p);\n    int x = *p;\n} \n```", "```\nvoid f3(int* p) // state that p is not supposed to be nullptr\n    [[expects: p]]\n{\n    int x = *p;\n} \n```", "```\nvoid f(not_null<int*> p)\n{\n    int x = *p;\n} \n```", "```\nvoid f(int* p)  // old code, doesn't use owner\n{\n    delete p;\n}\n\nvoid g()        // old code: uses naked new\n{\n    auto q = new int{7};\n    f(q);\n    int x = *q; // BAD: dereferences invalid pointer\n} \n```", "```\nvoid f()\n{\n    vector<int> v(10);\n    int* p = &v[5];\n    v.push_back(99); // could reallocate v's elements\n    int x = *p; // BAD: dereferences potentially invalid pointer\n} \n```", "```\nvoid use(int n)\n{\n    switch (n) {   // good\n    case 0:\n        // ...\n        break;\n    case 7:\n        // ...\n        break;\n    default:\n        // ...\n        break;\n    }\n} \n```", "```\nvoid use2(int n)\n{\n    if (n == 0)   // bad: if-then-else chain comparing against a set of constants\n        // ...\n    else if (n == 7)\n        // ...\n} \n```", "```\nfor (gsl::index i = 0; i < v.size(); ++i)   // bad\n    cout << v[i] << '\\n';\n\nfor (auto p = v.begin(); p != v.end(); ++p)   // bad\n    cout << *p << '\\n';\n\nfor (auto& x : v)    // OK\n    cout << x << '\\n';\n\nfor (gsl::index i = 1; i < v.size(); ++i) // touches two elements: can't be a range-for\n    cout << v[i] + v[i - 1] << '\\n';\n\nfor (gsl::index i = 0; i < v.size(); ++i) // possible side effect: can't be a range-for\n    cout << f(v, &v[i]) << '\\n';\n\nfor (gsl::index i = 0; i < v.size(); ++i) { // body messes with loop variable: can't be a range-for\n    if (i % 2 != 0)\n        cout << v[i] << '\\n'; // output odd elements\n} \n```", "```\nfor (string s : vs) // ... \n```", "```\nfor (string& s : vs) // ... \n```", "```\nfor (const string& s : vs) // ... \n```", "```\nfor (gsl::index i = 0; i < vec.size(); i++) {\n    // do work\n} \n```", "```\nint i = 0;\nwhile (i < vec.size()) {\n    // do work\n    i++;\n} \n```", "```\nint events = 0;\nfor (; wait_for_event(); ++events) {  // bad, confusing\n    // ...\n} \n```", "```\nint events = 0;\nwhile (wait_for_event()) {      // better\n    ++events;\n    // ...\n} \n```", "```\nint x;\ndo {\n    cin >> x;\n    // ...\n} while (x < 0); \n```", "```\nfor (int i = 0; i < imax; ++i)\n    for (int j = 0; j < jmax; ++j) {\n        if (a[i][j] > elem_max) goto finished;\n        // ...\n    }\nfinished:\n// ... \n```", "```\nvoid f()\n{\n    // ...\n        goto exit;\n    // ...\n        goto exit;\n    // ...\nexit:\n    // ... common cleanup code ...\n} \n```", "```\nswitch(x) {\ncase 1 :\n    while (/* some condition */) {\n        // ...\n    break;\n    } // Oops! break switch or break while intended?\ncase 2 :\n    // ...\n    break;\n} \n```", "```\n//Original code: break inside loop\nvoid use1()\n{\n    std::vector<T> vec = {/* initialized with some values */};\n    T value;\n    for (const T item : vec) {\n        if (/* some condition*/) {\n            value = item;\n            break;\n        }\n    }\n    /* then do something with value */\n}\n\n//BETTER: create a function and return inside loop\nT search(const std::vector<T> &vec)\n{\n    for (const T &item : vec) {\n        if (/* some condition*/) return item;\n    }\n    return T(); //default value\n}\n\nvoid use2()\n{\n    std::vector<T> vec = {/* initialized with some values */};\n    T value = search(vec);\n    /* then do something with value */\n} \n```", "```\nfor (int item : vec) {  // BAD\n    if (item%2 == 0) continue;\n    if (item == 5) continue;\n    if (item > 10) continue;\n    /* do something with item */\n}\n\nfor (int item : vec) {  // GOOD\n    if (item%2 != 0 && item != 5 && item <= 10) {\n        /* do something with item */\n    }\n} \n```", "```\nswitch (eventType) {\ncase Information:\n    update_status_bar();\n    break;\ncase Warning:\n    write_event_log();\n    // Bad - implicit fallthrough\ncase Error:\n    display_error_window();\n    break;\n} \n```", "```\nswitch (x) {\ncase 'a':\ncase 'b':\ncase 'f':\n    do_something(x);\n    break;\n} \n```", "```\nswitch (x) {\ncase 'a':\n    return 1;\ncase 'b':\n    return 2;\ncase 'c':\n    return 3;\n} \n```", "```\nswitch (eventType) {\ncase Information:\n    update_status_bar();\n    break;\ncase Warning:\n    write_event_log();\n    [[fallthrough]];\ncase Error:\n    display_error_window();\n    break;\n} \n```", "```\nenum E { a, b, c, d };\n\nvoid f1(E x)\n{\n    switch (x) {\n    case a:\n        do_something();\n        break;\n    case b:\n        do_something_else();\n        break;\n    default:\n        take_the_default_action();\n        break;\n    }\n} \n```", "```\nvoid f2(E x)\n{\n    switch (x) {\n    case a:\n        do_something();\n        break;\n    case b:\n        do_something_else();\n        break;\n    default:\n        // do nothing for the rest of the cases\n        break;\n    }\n} \n```", "```\nvoid f2(E x)\n{\n    switch (x) {\n    case a:\n        do_something();\n        break;\n    case b:\n    case c:\n        do_something_else();\n        break;\n    }\n} \n```", "```\nvoid f()\n{\n    lock_guard<mutex>{mx};   // Bad\n    // ...\n} \n```", "```\nfor (i = 0; i < max; ++i);   // BAD: the empty statement is easily overlooked\nv[i] = f(v[i]);\n\nfor (auto x : v) {           // better\n    // nothing\n}\nv[i] = f(v[i]); \n```", "```\nfor (int i = 0; i < 10; ++i) {\n    // no updates to i -- ok\n}\n\nfor (int i = 0; i < 10; ++i) {\n    //\n    if (/* something */) ++i; // BAD\n    //\n}\n\nbool skip = false;\nfor (int i = 0; i < 10; ++i) {\n    if (skip) { skip = false; continue; }\n    //\n    if (/* something */) skip = true;  // Better: using two variables for two concepts.\n    //\n} \n```", "```\n// These all mean \"if p is not nullptr\"\nif (p) { ... }            // good\nif (p != 0) { ... }       // redundant !=0, bad: don't use 0 for pointers\nif (p != nullptr) { ... } // redundant !=nullptr, not recommended \n```", "```\nif (auto pc = dynamic_cast<Circle*>(ps)) { ... } // execute if ps points to a kind of Circle, good\n\nif (auto pc = dynamic_cast<Circle*>(ps); pc != nullptr) { ... } // not recommended \n```", "```\nfor (string s; cin >> s; ) v.push_back(s); \n```", "```\nvoid f(int i)\n{\n    if (i)            // suspect\n    // ...\n    if (i == success) // possibly better\n    // ...\n} \n```", "```\nif(strcmp(p1, p2)) { ... }   // are the two C-style strings equal? (mistake!) \n```", "```\nif(strcmp(p1, p2) != 0) { ... }   // are the two C-style strings equal? (mistake!) \n```", "```\n// These all mean \"if p is nullptr\"\nif (!p) { ... }           // good\nif (p == 0) { ... }       // redundant == 0, bad: don't use 0 for pointers\nif (p == nullptr) { ... } // redundant == nullptr, not recommended \n```", "```\nint x = -3;\nunsigned int y = 7;\n\ncout << x - y << '\\n';  // unsigned result, possibly 4294967286\ncout << x + y << '\\n';  // unsigned result: 4\ncout << x * y << '\\n';  // unsigned result, possibly 4294967275 \n```", "```\nunsigned char x = 0b1010'1010;\nunsigned char y = ~x;   // y == 0b0101'0101; \n```", "```\ntemplate<typename T, typename T2>\nT subtract(T x, T2 y)\n{\n    return x - y;\n}\n\nvoid test()\n{\n    int s = 5;\n    unsigned int us = 5;\n    cout << subtract(s, 7) << '\\n';       // -2\n    cout << subtract(us, 7u) << '\\n';     // 4294967294\n    cout << subtract(s, 7u) << '\\n';      // -2\n    cout << subtract(us, 7) << '\\n';      // 4294967294\n    cout << subtract(s, us + 2) << '\\n';  // -2\n    cout << subtract(us, s + 2) << '\\n';  // 4294967294\n} \n```", "```\nint a[10];\nfor (int i = 0; i < 10; ++i) a[i] = i;\nvector<int> v(10);\n// compares signed to unsigned; some compilers warn, but we should not\nfor (gsl::index i = 0; i < v.size(); ++i) v[i] = i;\n\nint a2[-2];         // error: negative size\n\n// OK, but the number of ints (4294967294) is so large that we should get an exception\nvector<int> v2(-2); \n```", "```\nint a[10];\na[10] = 7;   // bad, array bounds overflow\n\nfor (int n = 0; n <= 10; ++n)\n    a[n] = 9;   // bad, array bounds overflow \n```", "```\nint n = numeric_limits<int>::max();\nint m = n + 1;   // bad, numeric overflow \n```", "```\nint area(int h, int w) { return h * w; }\n\nauto a = area(10'000'000, 100'000'000);   // bad, numeric overflow \n```", "```\nint a[10];\na[-2] = 7;   // bad\n\nint n = 101;\nwhile (n--)\n    a[n - 1] = 9;   // bad (twice) \n```", "```\nint divide(int a, int b)\n{\n    // BAD, should be checked (e.g., in a precondition)\n    return a / b;\n} \n```", "```\nint divide(int a, int b)\n{\n    // good, address via precondition (and replace with contracts once C++ gets them)\n    Expects(b != 0);\n    return a / b;\n}\n\ndouble divide(double a, double b)\n{\n    // good, address via using double instead\n    return a / b;\n} \n```", "```\nunsigned int u1 = -2;   // Valid: the value of u1 is 4294967294\nint i1 = -2;\nunsigned int u2 = i1;   // Valid: the value of u2 is 4294967294\nint i2 = u2;            // Valid: the value of i2 is -2 \n```", "```\nunsigned area(unsigned height, unsigned width) { return height*width; } // [see also](#ri-expects)\n// ...\nint height;\ncin >> height;\nauto a = area(height, 2);   // if the input is -2 a becomes 4294967292 \n```", "```\nunsigned max = 100000;    // \"accidental typo\", I mean to say 10'000\nunsigned short x = 100;\nwhile (x < max) x += 100; // infinite loop \n```", "```\nstruct Positive {\n    int val;\n    Positive(int x) :val{x} { Assert(0 < x); }\n    operator int() { return val; }\n};\n\nint f(Positive arg) { return arg; }\n\nint r1 = f(2);\nint r2 = f(-2);  // throws \n```", "```\nvector<int> vec = /*...*/;\n\nfor (int i = 0; i < vec.size(); i += 2)                    // might not be big enough\n    cout << vec[i] << '\\n';\nfor (unsigned i = 0; i < vec.size(); i += 2)               // risk wraparound\n    cout << vec[i] << '\\n';\nfor (auto i = 0; i < vec.size(); i += 2)                   // might not be big enough\n    cout << vec[i] << '\\n';\nfor (vector<int>::size_type i = 0; i < vec.size(); i += 2) // verbose\n    cout << vec[i] << '\\n';\nfor (auto i = vec.size()-1; i >= 0; i -= 2)                // bug\n    cout << vec[i] << '\\n';\nfor (int i = vec.size()-1; i >= 0; i -= 2)                 // might not be big enough\n    cout << vec[i] << '\\n'; \n```", "```\nvector<int> vec = /*...*/;\n\nfor (gsl::index i = 0; i < vec.size(); i += 2)             // ok\n    cout << vec[i] << '\\n';\nfor (gsl::index i = vec.size()-1; i >= 0; i -= 2)          // ok\n    cout << vec[i] << '\\n'; \n```", "```\ntemplate<typename T>\nstruct My_container {\npublic:\n    // ...\n    T& operator[](gsl::index i);    // not unsigned\n    // ...\n}; \n```", "```\n??? demonstrate improved code generation and potential for error detection ??? \n```", "```\n// clear expression of intent, fast execution\n\nvector<uint8_t> v(100000);\n\nfor (auto& c : v)\n    c = ~c; \n```", "```\n// intended to be faster, but is often slower\n\nvector<uint8_t> v(100000);\n\nfor (size_t i = 0; i < v.size(); i += sizeof(uint64_t)) {\n    uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]);\n    quad_word = ~quad_word;\n} \n```", "```\nvoid qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*)); \n```", "```\ndouble data[100];\n// ... fill a ...\n\n// 100 chunks of memory of sizeof(double) starting at\n// address data using the order defined by compare_doubles\nqsort(data, 100, sizeof(double), compare_doubles); \n```", "```\ntemplate<typename Iter>\n    void sort(Iter b, Iter e);  // sort [b:e)\n\nsort(data, data + 100); \n```", "```\n// sortable specifies that c must be a\n// random-access sequence of elements comparable with <\nvoid sort(sortable auto& c);\n\nsort(c); \n```", "```\n// compare elements of c using r\ntemplate<random_access_range R, class C> requires sortable<R, C>\nvoid sort(R&& r, C c); \n```", "```\ntemplate<class ForwardIterator, class T>\nbool binary_search(ForwardIterator first, ForwardIterator last, const T& val); \n```", "```\ntemplate<class ForwardIterator, class T>\nForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val); \n```", "```\ntemplate<class ForwardIterator, class T>\npair<ForwardIterator, ForwardIterator>\nequal_range(ForwardIterator first, ForwardIterator last, const T& val); \n```", "```\nauto r = equal_range(begin(c), end(c), 7);\nfor (auto p = r.first; p != r.second; ++p)\n    cout << *p << '\\n'; \n```", "```\ndouble square(double d) { return d*d; }\nstatic double s2 = square(2);    // old-style: dynamic initialization\n\nconstexpr double ntimes(double d, int n)   // assume 0 <= n\n{\n        double m = 1;\n        while (n--) m *= d;\n        return m;\n}\nconstexpr double s3 {ntimes(2, 3)};  // modern-style: compile-time initialization \n```", "```\nconstexpr int on_stack_max = 20;\n\ntemplate<typename T>\nstruct Scoped {     // store a T in Scoped\n        // ...\n    T obj;\n};\n\ntemplate<typename T>\nstruct On_heap {    // store a T on the free store\n        // ...\n        T* objp;\n};\n\ntemplate<typename T>\nusing Handle = typename std::conditional<(sizeof(T) <= on_stack_max),\n                    Scoped<T>,      // first alternative\n                    On_heap<T>      // second alternative\n               >::type;\n\nvoid f()\n{\n    Handle<double> v1;                   // the double goes on the stack\n    Handle<std::array<double, 200>> v2;  // the array goes on the free store\n    // ...\n} \n```", "```\nint matrix[rows][cols];\n\n// bad\nfor (int c = 0; c < cols; ++c)\n    for (int r = 0; r < rows; ++r)\n        sum += matrix[r][c];\n\n// good\nfor (int r = 0; r < rows; ++r)\n    for (int c = 0; c < cols; ++c)\n        sum += matrix[r][c]; \n```", "```\ndouble cached_computation(int x)\n{\n    // bad: these statics cause data races in multi-threaded usage\n    static int cached_x = 0.0;\n    static double cached_result = COMPUTATION_OF_ZERO;\n\n    if (cached_x != x) {\n        cached_x = x;\n        cached_result = computation(x);\n    }\n    return cached_result;\n} \n```", "```\nstruct ComputationCache {\n    int cached_x = 0;\n    double cached_result = COMPUTATION_OF_ZERO;\n\n    double compute(int x) {\n        if (cached_x != x) {\n            cached_x = x;\n            cached_result = computation(x);\n        }\n        return cached_result;\n    }\n}; \n```", "```\nint get_id()\n{\n  static int id = 1;\n  return id++;\n} \n```", "```\nvoid f(fstream& fs, regex pattern)\n{\n    array<double, max> buf;\n    int sz = read_vec(fs, buf, max);            // read from fs into buf\n    gsl::span<double> s {buf};\n    // ...\n    auto h1 = async([&] { sort(std::execution::par, s); });     // spawn a task to sort\n    // ...\n    auto h2 = async([&] { return find_all(buf, sz, pattern); });   // spawn a task to find matches\n    // ...\n} \n```", "```\n// code not controlled by a lock\n\nunsigned val;\n\nif (val < 5) {\n    // ... other thread can change val here ...\n    switch (val) {\n    case 0: // ...\n    case 1: // ...\n    case 2: // ...\n    case 3: // ...\n    case 4: // ...\n    }\n} \n```", "```\nbool validate(const vector<Reading>&);\nGraph<Temp_node> temperature_gradients(const vector<Reading>&);\nImage altitude_map(const vector<Reading>&);\n// ...\n\nvoid process_readings(const vector<Reading>& surface_readings)\n{\n    auto h1 = async([&] { if (!validate(surface_readings)) throw Invalid_data{}; });\n    auto h2 = async([&] { return temperature_gradients(surface_readings); });\n    auto h3 = async([&] { return altitude_map(surface_readings); });\n    // ...\n    h1.get();\n    auto v2 = h2.get();\n    auto v3 = h3.get();\n    // ...\n} \n```", "```\nvoid some_fun(const std::string& msg)\n{\n    std::thread publisher([=] { std::cout << msg; });      // bad: less expressive\n                                                           //      and more error-prone\n    auto pubtask = std::async([=] { std::cout << msg; });  // OK\n    // ...\n    publisher.join();\n} \n```", "```\nint free_slots = max_slots; // current source of memory for objects\n\nPool* use()\n{\n    if (int n = free_slots--) return &pool[n];\n} \n```", "```\nvolatile int free_slots = max_slots; // current source of memory for objects\n\nPool* use()\n{\n    if (int n = free_slots--) return &pool[n];\n} \n```", "```\natomic<int> free_slots = max_slots; // current source of memory for objects\n\nPool* use()\n{\n    if (int n = free_slots--) return &pool[n];\n} \n```", "```\n??? \n```", "```\nmutex mtx;\n\nvoid do_stuff()\n{\n    mtx.lock();\n    // ... do stuff ...\n    mtx.unlock();\n} \n```", "```\nmutex mtx;\n\nvoid do_stuff()\n{\n    unique_lock<mutex> lck {mtx};\n    // ... do stuff ...\n} \n```", "```\n// thread 1\nlock_guard<mutex> lck1(m1);\nlock_guard<mutex> lck2(m2);\n\n// thread 2\nlock_guard<mutex> lck2(m2);\nlock_guard<mutex> lck1(m1); \n```", "```\n// thread 1\nlock(m1, m2);\nlock_guard<mutex> lck1(m1, adopt_lock);\nlock_guard<mutex> lck2(m2, adopt_lock);\n\n// thread 2\nlock(m2, m1);\nlock_guard<mutex> lck2(m2, adopt_lock);\nlock_guard<mutex> lck1(m1, adopt_lock); \n```", "```\n// thread 1\nscoped_lock<mutex, mutex> lck1(m1, m2);\n\n// thread 2\nscoped_lock<mutex, mutex> lck2(m2, m1); \n```", "```\nlock_guard lck1(m1, adopt_lock); \n```", "```\nvoid do_this(Foo* p)\n{\n    lock_guard<mutex> lck {my_mutex};\n    // ... do something ...\n    p->act(my_data);\n    // ...\n} \n```", "```\nrecursive_mutex my_mutex;\n\ntemplate<typename Action>\nvoid do_something(Action f)\n{\n    unique_lock<recursive_mutex> lck {my_mutex};\n    // ... do something ...\n    f(this);    // f will do something to *this\n    // ...\n} \n```", "```\nvoid f(int* p)\n{\n    // ...\n    *p = 99;\n    // ...\n}\nint glob = 33;\n\nvoid some_fct(int* p)\n{\n    int x = 77;\n    joining_thread t0(f, &x);           // OK\n    joining_thread t1(f, p);            // OK\n    joining_thread t2(f, &glob);        // OK\n    auto q = make_unique<int>(99);\n    joining_thread t3(f, q.get());      // OK\n    // ...\n} \n```", "```\nvoid f(int* p)\n{\n    // ...\n    *p = 99;\n    // ...\n}\n\nint glob = 33;\n\nvoid some_fct(int* p)\n{\n    int x = 77;\n    std::thread t0(f, &x);           // bad\n    std::thread t1(f, p);            // bad\n    std::thread t2(f, &glob);        // OK\n    auto q = make_unique<int>(99);\n    std::thread t3(f, q.get());      // bad\n    // ...\n    t0.detach();\n    t1.detach();\n    t2.detach();\n    t3.detach();\n    // ...\n} \n```", "```\nvoid f() { std::cout << \"Hello \"; }\n\nstruct F {\n    void operator()() const { std::cout << \"parallel world \"; }\n};\n\nint main()\n{\n    std::thread t1{f};      // f() executes in separate thread\n    std::thread t2{F()};    // F()() executes in separate thread\n}  // spot the bugs \n```", "```\nvoid f() { std::cout << \"Hello \"; }\n\nstruct F {\n    void operator()() const { std::cout << \"parallel world \"; }\n};\n\nint main()\n{\n    std::thread t1{f};      // f() executes in separate thread\n    std::thread t2{F()};    // F()() executes in separate thread\n\n    t1.join();\n    t2.join();\n}  // one bad bug left \n```", "```\nvoid heartbeat();\n\nvoid use()\n{\n    std::thread t(heartbeat);             // don't join; heartbeat is meant to run forever\n    t.detach();\n    // ...\n} \n```", "```\nvoid heartbeat();\n\ngsl::joining_thread t(heartbeat);             // heartbeat is meant to run \"forever\" \n```", "```\nvoid heartbeat();\n\nunique_ptr<gsl::joining_thread> tick_tock {nullptr};\n\nvoid use()\n{\n    // heartbeat is meant to run as long as tick_tock lives\n    tick_tock = make_unique<gsl::joining_thread>(heartbeat);\n    // ...\n} \n```", "```\nstring modify1(string);\nvoid modify2(string&);\n\nvoid fct(string& s)\n{\n    auto res = async(modify1, s);\n    async(modify2, s);\n} \n```", "```\n??? \n```", "```\n??? \n```", "```\nvoid worker(Message m)\n{\n    // process\n}\n\nvoid dispatcher(istream& is)\n{\n    for (Message m; is >> m; )\n        run_list.push_back(new thread(worker, m));\n} \n```", "```\nSync_queue<Message> work;\n\nvoid dispatcher(istream& is)\n{\n    for (Message m; is >> m; )\n        work.put(m);\n}\n\nvoid worker()\n{\n    for (Message m; m = work.get(); ) {\n        // process\n    }\n}\n\nvoid workers()  // set up worker threads (specifically 4 worker threads)\n{\n    joining_thread w1 {worker};\n    joining_thread w2 {worker};\n    joining_thread w3 {worker};\n    joining_thread w4 {worker};\n} \n```", "```\nstd::condition_variable cv;\nstd::mutex mx;\n\nvoid thread1()\n{\n    while (true) {\n        // do some work ...\n        std::unique_lock<std::mutex> lock(mx);\n        cv.notify_one();    // wake other thread\n    }\n}\n\nvoid thread2()\n{\n    while (true) {\n        std::unique_lock<std::mutex> lock(mx);\n        cv.wait(lock);    // might block forever\n        // do work ...\n    }\n} \n```", "```\ntemplate<typename T>\nclass Sync_queue {\npublic:\n    void put(const T& val);\n    void put(T&& val);\n    void get(T& val);\nprivate:\n    mutex mtx;\n    condition_variable cond;    // this controls access\n    list<T> q;\n};\n\ntemplate<typename T>\nvoid Sync_queue<T>::put(const T& val)\n{\n    lock_guard<mutex> lck(mtx);\n    q.push_back(val);\n    cond.notify_one();\n}\n\ntemplate<typename T>\nvoid Sync_queue<T>::get(T& val)\n{\n    unique_lock<mutex> lck(mtx);\n    cond.wait(lck, [this] { return !q.empty(); });    // prevent spurious wakeup\n    val = q.front();\n    q.pop_front();\n} \n```", "```\nvoid do_something() // bad\n{\n    unique_lock<mutex> lck(my_lock);\n    do0();  // preparation: does not need lock\n    do1();  // transaction: needs locking\n    do2();  // cleanup: does not need locking\n} \n```", "```\nvoid do_something() // bad\n{\n    do0();  // preparation: does not need lock\n    my_lock.lock();\n    do1();  // transaction: needs locking\n    my_lock.unlock();\n    do2();  // cleanup: does not need locking\n} \n```", "```\nvoid do_something() // OK\n{\n    do0();  // preparation: does not need lock\n    {\n        unique_lock<mutex> lck(my_lock);\n        do1();  // transaction: needs locking\n    }\n    do2();  // cleanup: does not need locking\n} \n```", "```\n// global mutexes\nmutex m1;\nmutex m2;\n\nvoid f()\n{\n    unique_lock<mutex>(m1); // (A)\n    lock_guard<mutex> {m2}; // (B)\n    // do work in critical section ...\n} \n```", "```\nstruct Record {\n    std::mutex m;   // take this mutex before accessing other members\n    // ...\n};\n\nclass MyClass {\n    struct DataRecord {\n       // ...\n    };\n    synchronized_value<DataRecord> data; // Protect the data with a mutex\n}; \n```", "```\nint value = get_value();\nstd::shared_ptr<Foo> sharedFoo = get_foo();\n{\n  const auto lambda = [value, sharedFoo]() -> std::future<void>\n  {\n    co_await something();\n    // \"sharedFoo\" and \"value\" have already been destroyed\n    // the \"shared\" pointer didn't accomplish anything\n  };\n  lambda();\n} // the lambda closure object has now gone out of scope \n```", "```\nint value = get_value();\nstd::shared_ptr<Foo> sharedFoo = get_foo();\n{\n  // take as by-value parameter instead of as a capture\n  const auto lambda = [](auto sharedFoo, auto value) -> std::future<void>\n  {\n    co_await something();\n    // sharedFoo and value are still valid at this point\n  };\n  lambda(sharedFoo, value);\n} // the lambda closure object has now gone out of scope \n```", "```\nstd::future<void> Class::do_something(int value, std::shared_ptr<Foo> sharedFoo)\n{\n  co_await something();\n  // sharedFoo and value are still valid at this point\n}\n\nvoid SomeOtherFunction()\n{\n  int value = get_value();\n  std::shared_ptr<Foo> sharedFoo = get_foo();\n  do_something(value, sharedFoo);\n} \n```", "```\nstd::mutex g_lock;\n\nstd::future<void> Class::do_something()\n{\n    std::lock_guard<std::mutex> guard(g_lock);\n    co_await something(); // DANGER: coroutine has suspended execution while holding a lock\n    co_await somethingElse();\n} \n```", "```\nstd::mutex g_lock;\n\nstd::future<void> Class::do_something()\n{\n    {\n        std::lock_guard<std::mutex> guard(g_lock);\n        // modify data protected by lock\n    }\n    co_await something(); // OK: lock has been released before coroutine suspends\n    co_await somethingElse();\n} \n```", "```\nstd::future<int> Class::do_something(const std::shared_ptr<int>& input)\n{\n    co_await something();\n\n    // DANGER: the reference to input may no longer be valid and may be freed memory\n    co_return *input + 1;\n} \n```", "```\nstd::future<int> Class::do_something(std::shared_ptr<int> input)\n{\n    co_await something();\n    co_return *input + 1; // input is a copy that is still valid here\n} \n```", "```\n??? \n```", "```\nint read_value(const std::string& filename)\n{\n    std::ifstream in(filename);\n    in.exceptions(std::ifstream::failbit);\n    int value;\n    in >> value;\n    return value;\n}\n\nvoid async_example()\n{\n    try {\n        std::future<int> f1 = std::async(read_value, \"v1.txt\");\n        std::future<int> f2 = std::async(read_value, \"v2.txt\");\n        std::cout << f1.get() + f2.get() << '\\n';\n    } catch (const std::ios_base::failure& fail) {\n        // handle exception here\n    }\n} \n```", "```\nvoid async_example()\n{\n    std::promise<int> p1;\n    std::future<int> f1 = p1.get_future();\n    std::thread t1([p1 = std::move(p1)]() mutable {\n        p1.set_value(read_value(\"v1.txt\"));\n    });\n    t1.detach(); // evil\n\n    std::packaged_task<int()> pt2(read_value, \"v2.txt\");\n    std::future<int> f2 = pt2.get_future();\n    std::thread(std::move(pt2)).detach();\n\n    std::cout << f1.get() + f2.get() << '\\n';\n} \n```", "```\nvoid async_example(WorkQueue& wq)\n{\n    std::future<int> f1 = wq.enqueue([]() {\n        return read_value(\"v1.txt\");\n    });\n    std::future<int> f2 = wq.enqueue([]() {\n        return read_value(\"v2.txt\");\n    });\n    std::cout << f1.get() + f2.get() << '\\n';\n} \n```", "```\nextern atomic<Link*> head;        // the shared head of a linked list\n\nLink* nh = new Link(data, nullptr);    // make a link ready for insertion\nLink* h = head.load();                 // read the shared head of the list\n\ndo {\n    if (h->data <= data) break;        // if so, insert elsewhere\n    nh->next = h;                      // next element is the previous head\n} while (!head.compare_exchange_weak(h, nh));    // write nh to head or to h \n```", "```\nvoid f()\n{\n    static std::once_flag my_once_flag;\n    std::call_once(my_once_flag, []()\n    {\n        // do this only once\n    });\n    // ...\n} \n```", "```\nvoid f()\n{\n    // Assuming the compiler is compliant with C++11\n    static My_class my_object; // Constructor called only once\n    // ...\n}\n\nclass My_class\n{\npublic:\n    My_class()\n    {\n        // do this only once\n    }\n}; \n```", "```\nmutex action_mutex;\nvolatile bool action_needed;\n\nif (action_needed) {\n    std::lock_guard<std::mutex> lock(action_mutex);\n    if (action_needed) {\n        take_action();\n        action_needed = false;\n    }\n} \n```", "```\nmutex action_mutex;\natomic<bool> action_needed;\n\nif (action_needed) {\n    std::lock_guard<std::mutex> lock(action_mutex);\n    if (action_needed) {\n        take_action();\n        action_needed = false;\n    }\n} \n```", "```\nmutex action_mutex;\natomic<bool> action_needed;\n\nif (action_needed.load(memory_order_acquire)) {\n    lock_guard<std::mutex> lock(action_mutex);\n    if (action_needed.load(memory_order_relaxed)) {\n        take_action();\n        action_needed.store(false, memory_order_release);\n    }\n} \n```", "```\nconst volatile long clock; \n```", "```\nlong t1 = clock;\n// ... no use of clock here ...\nlong t2 = clock; \n```", "```\nint volatile* vi = get_hardware_memory_location();\n    // note: we get a pointer to someone else's memory here\n    // volatile says \"treat this with extra respect\" \n```", "```\nstatic volatile long vl;\nplease_use_this(&vl);   // escape a reference to this to \"elsewhere\" (not C++) \n```", "```\nvoid f()\n{\n    volatile int i = 0; // bad, volatile local variable\n    // etc.\n}\n\nclass My_type {\n    volatile int i = 0; // suspicious, volatile data member\n    // etc.\n}; \n```", "```\nstruct Foo {\n    vector<Thing> v;\n    File_handle f;\n    string s;\n};\n\nvoid use()\n{\n    Foo bar { {Thing{1}, Thing{2}, Thing{monkey} }, {\"my_file\", \"r\"}, \"Here we go!\"};\n    // ...\n} \n```", "```\nFile_handle::File_handle(const string& name, const string& mode)\n    : f{fopen(name.c_str(), mode.c_str())}\n{\n    if (!f)\n        throw runtime_error{\"File_handle: could not open \" + name + \" as \" + mode};\n} \n```", "```\n// don't: exception not used for error handling\nint find_index(vector<string>& vec, const string& x)\n{\n    try {\n        for (gsl::index i = 0; i < vec.size(); ++i)\n            if (vec[i] == x) throw i;  // found x\n    }\n    catch (int i) {\n        return i;\n    }\n    return -1;   // not found\n} \n```", "```\nclass Vector {  // very simplified vector of doubles\n    // if elem != nullptr then elem points to sz doubles\npublic:\n    Vector() : elem{nullptr}, sz{0}{}\n    Vector(int s) : elem{new double[s]}, sz{s} { /* initialize elements */ }\n    ~Vector() { delete [] elem; }\n    double& operator[](int s) { return elem[s]; }\n    // ...\nprivate:\n    owner<double*> elem;\n    int sz;\n}; \n```", "```\nvoid f1(int i)   // Bad: possible leak\n{\n    int* p = new int[12];\n    // ...\n    if (i < 17) throw Bad{\"in f()\", i};\n    // ...\n} \n```", "```\nvoid f2(int i)   // Clumsy and error-prone: explicit release\n{\n    int* p = new int[12];\n    // ...\n    if (i < 17) {\n        delete[] p;\n        throw Bad{\"in f()\", i};\n    }\n    // ...\n} \n```", "```\nvoid f3(int i)   // OK: resource management done by a handle (but see below)\n{\n    auto p = make_unique<int[]>(12);\n    // ...\n    if (i < 17) throw Bad{\"in f()\", i};\n    // ...\n} \n```", "```\nvoid f4(int i)   // OK: resource management done by a handle (but see below)\n{\n    auto p = make_unique<int[]>(12);\n    // ...\n    helper(i);   // might throw\n    // ...\n} \n```", "```\nvoid f5(int i)   // OK: resource management done by local object\n{\n    vector<int> v(12);\n    // ...\n    helper(i);   // might throw\n    // ...\n} \n```", "```\nvoid f()\n{\n    vector<string> vs(100);   // not std::vector: valid() added\n    if (!vs.valid()) {\n        // handle error or exit\n    }\n\n    ifstream fs(\"foo\");   // not std::ifstream: valid() added\n    if (!fs.valid()) {\n        // handle error or exit\n    }\n\n    // ...\n} // destructors clean up as usual \n```", "```\ndouble compute(double d) noexcept\n{\n    return log(sqrt(d <= 0 ? 1 : d));\n} \n```", "```\nvector<double> munge(const vector<double>& v) noexcept\n{\n    vector<double> v2(v.size());\n    // ... do something ...\n} \n```", "```\nvoid leak(int x)   // don't: might leak\n{\n    auto p = new int{7};\n    if (x < 0) throw Get_me_out_of_here{};  // might leak *p\n    // ...\n    delete p;   // we might never get here\n} \n```", "```\nvoid no_leak(int x)\n{\n    auto p = make_unique<int>(7);\n    if (x < 0) throw Get_me_out_of_here{};  // will delete *p if necessary\n    // ...\n    // no need for delete p\n} \n```", "```\nvoid no_leak_simplified(int x)\n{\n    vector<int> v(7);\n    // ...\n} \n```", "```\nthrow 7; // bad\n\nthrow \"something bad\";  // bad\n\nthrow std::exception{}; // bad - no info \n```", "```\nclass MyException : public std::runtime_error\n{\npublic:\n    MyException(const string& msg) : std::runtime_error{msg} {}\n    // ...\n};\n\n// ...\n\nthrow MyException{\"something bad\"};  // good \n```", "```\nclass MyCustomError final {};  // not derived from std::exception\n\n// ...\n\nthrow MyCustomError{};  // good - handlers must catch this type (or ...) \n```", "```\nthrow std::runtime_error(\"something bad\"); // good\n\n// ...\n\nthrow std::invalid_argument(\"i is not even\"); // good \n```", "```\nenum class alert {RED, YELLOW, GREEN};\n\nthrow alert::RED; // good \n```", "```\nvoid f()\n{\n    try {\n        // ...\n        throw new widget{}; // don't: throw by value, not by raw pointer\n        // ...\n    }\n    catch (base_class e) {  // don't: might slice\n        // ...\n    }\n} \n```", "```\ncatch (base_class& e) { /* ... */ } \n```", "```\ncatch (const base_class& e) { /* ... */ } \n```", "```\nclass Connection {\n    // ...\npublic:\n    ~Connection()   // Don't: very bad destructor\n    {\n        if (cannot_disconnect()) throw I_give_up{information};\n        // ...\n    }\n}; \n```", "```\nvoid f()   // bad\n{\n    try {\n        // ...\n    }\n    catch (...) {\n        // no action\n        throw;   // propagate exception\n    }\n} \n```", "```\nvoid f(zstring s)\n{\n    Gadget* p;\n    try {\n        p = new Gadget(s);\n        // ...\n        delete p;\n    }\n    catch (Gadget_construction_failure) {\n        delete p;\n        throw;\n    }\n} \n```", "```\nvoid f2(zstring s)\n{\n    Gadget g {s};\n} \n```", "```\nvoid f(int n)\n{\n    void* p = malloc(n);\n    auto _ = gsl::finally([p] { free(p); });\n    // ...\n} \n```", "```\nvoid func(zstring arg)\n{\n    Gadget g {arg};\n    // ...\n} \n```", "```\nerror_indicator func(zstring arg)\n{\n    Gadget g {arg};\n    if (!g.valid()) return gadget_construction_error;\n    // ...\n    return 0;   // zero indicates \"good\"\n} \n```", "```\nvoid f(int n)\n{\n    // ...\n    p = static_cast<X*>(malloc(n * sizeof(X)));\n    if (!p) abort();     // abort if memory is exhausted\n    // ...\n} \n```", "```\nvoid f(int n)\n{\n    // ...\n    p = new X[n];    // throw if memory is exhausted (by default, terminate)\n    // ...\n} \n```", "```\nGadget make_gadget(int n)\n{\n    // ...\n}\n\nvoid user()\n{\n    Gadget g = make_gadget(17);\n    if (!g.valid()) {\n            // error handling\n    }\n    // ...\n} \n```", "```\nstd::pair<Gadget, error_indicator> make_gadget(int n)\n{\n    // ...\n}\n\nvoid user()\n{\n    auto r = make_gadget(17);\n    if (!r.second) {\n            // error handling\n    }\n    Gadget& g = r.first;\n    // ...\n} \n```", "```\nGval make_gadget(int n)\n{\n    // ...\n}\n\nvoid user()\n{\n    auto r = make_gadget(17);\n    if (!r.err) {\n            // error handling\n    }\n    Gadget& g = r.val;\n    // ...\n} \n```", "```\nstd::pair<int, error_indicator> user()\n{\n    Gadget g1 = make_gadget(17);\n    if (!g1.valid()) {\n        return {0, g1_error};\n    }\n\n    Gadget g2 = make_gadget(31);\n    if (!g2.valid()) {\n        cleanup(g1);\n        return {0, g2_error};\n    }\n\n    // ...\n\n    if (all_foobar(g1, g2)) {\n        cleanup(g2);\n        cleanup(g1);\n        return {0, foobar_error};\n    }\n\n    // ...\n\n    cleanup(g2);\n    cleanup(g1);\n    return {res, 0};\n} \n```", "```\nstd::pair<int, error_indicator> user()\n{\n    error_indicator err = 0;\n    int res = 0;\n\n    Gadget g1 = make_gadget(17);\n    if (!g1.valid()) {\n        err = g1_error;\n        goto g1_exit;\n    }\n\n    {\n        Gadget g2 = make_gadget(31);\n        if (!g2.valid()) {\n            err = g2_error;\n            goto g2_exit;\n        }\n\n        if (all_foobar(g1, g2)) {\n            err = foobar_error;\n            goto g2_exit;\n        }\n\n        // ...\n\n    g2_exit:\n        if (g2.valid()) cleanup(g2);\n    }\n\ng1_exit:\n    if (g1.valid()) cleanup(g1);\n    return {res, err};\n} \n```", "```\nint last_err;\n\nvoid f(int n)\n{\n    // ...\n    p = static_cast<X*>(malloc(n * sizeof(X)));\n    if (!p) last_err = -1;     // error if memory is exhausted\n    // ...\n} \n```", "```\nint use(int arg)\n    throw(X, Y)\n{\n    // ...\n    auto x = f(arg);\n    // ...\n} \n```", "```\nvoid f()\n{\n    // ...\n    try {\n            // ...\n    }\n    catch (Base& b) { /* ... */ }\n    catch (Derived& d) { /* ... */ }\n    catch (...) { /* ... */ }\n    catch (std::exception& e) { /* ... */ }\n} \n```", "```\nfor (const int i : c) cout << i << '\\n';    // just reading: const\n\nfor (int i : c) cout << i << '\\n';          // BAD: just reading \n```", "```\nstd::vector<int> f(int i)\n{\n    std::vector<int> v{ i, i, i };  // const not needed\n    return v;\n} \n```", "```\nvoid g(const int i) { ... }  // pedantic \n```", "```\nclass Point {\n    int x, y;\npublic:\n    int getx() { return x; }    // BAD, should be const as it doesn't modify the object's state\n    // ...\n};\n\nvoid f(const Point& pt)\n{\n    int x = pt.getx();          // ERROR, doesn't compile because getx was not marked const\n} \n```", "```\nvoid f(int* p);   // old code: f() does not modify `*p`\nvoid f(const int* p) { f(const_cast<int*>(p)); } // wrapper \n```", "```\nclass Date {\npublic:\n    // ...\n    const string& string_ref() const\n    {\n        if (string_val == \"\") compute_string_rep();\n        return string_val;\n    }\n    // ...\nprivate:\n    void compute_string_rep() const;    // compute string representation and place it in string_val\n    mutable string string_val;\n    // ...\n}; \n```", "```\nvoid f(char* p);        // does f modify *p? (assume it does)\nvoid g(const char* p);  // g does not modify *p \n```", "```\nvoid f()\n{\n    int x = 7;\n    const int y = 9;\n\n    for (;;) {\n        // ...\n    }\n    // ...\n} \n```", "```\ndouble x = f(2);            // possible run-time evaluation\nconst double y = f(2);      // possible run-time evaluation\nconstexpr double z = f(2);  // error unless f(2) can be evaluated at compile time \n```", "```\ntemplate<typename T>\n    requires Incrementable<T>\nT sum1(vector<T>& v, T s)\n{\n    for (auto x : v) s += x;\n    return s;\n}\n\ntemplate<typename T>\n    requires Simple_number<T>\nT sum2(vector<T>& v, T s)\n{\n    for (auto x : v) s = s + x;\n    return s;\n} \n```", "```\ntemplate<typename T>\n    requires Arithmetic<T>\nT sum(vector<T>& v, T s)\n{\n    for (auto x : v) s += x;\n    return s;\n} \n```", "```\ntemplate<typename Iter, typename Val>\n    // requires Input_iterator<Iter>\n    //       && Equality_comparable<Value_type<Iter>, Val>\nIter find(Iter b, Iter e, Val v)\n{\n    // ...\n} \n```", "```\ntemplate<typename T>\n    // requires Regular<T>\nclass Vector {\n    // ...\n    T* elem;   // points to sz Ts\n    int sz;\n};\n\nVector<double> v(10);\nv[7] = 9.9; \n```", "```\nclass Container {\n    // ...\n    void* elem;   // points to size elements of some type\n    int sz;\n};\n\nContainer c(10, sizeof(double));\n((double*) c.elem)[7] = 9.9; \n```", "```\n??? \n```", "```\nclass Command {\n    // pure virtual functions\n};\n\n// implementations\ntemplate</*...*/>\nclass ConcreteCommand : public Command {\n    // implement virtuals\n}; \n```", "```\n#include <memory>\n\nclass Object {\npublic:\n    template<typename T>\n    Object(T&& obj)\n        : concept_(std::make_shared<ConcreteCommand<T>>(std::forward<T>(obj))) {}\n\n    int get_id() const { return concept_->get_id(); }\n\nprivate:\n    struct Command {\n        virtual ~Command() {}\n        virtual int get_id() const = 0;\n    };\n\n    template<typename T>\n    struct ConcreteCommand final : Command {\n        ConcreteCommand(T&& obj) noexcept : object_(std::forward<T>(obj)) {}\n        int get_id() const final { return object_.get_id(); }\n\n    private:\n        T object_;\n    };\n\n    std::shared_ptr<Command> concept_;\n};\n\nclass Bar {\npublic:\n    int get_id() const { return 1; }\n};\n\nstruct Foo {\npublic:\n    int get_id() const { return 2; }\n};\n\nObject o(Bar{});\nObject o2(Foo{}); \n```", "```\ntemplate<typename Iter, typename Val>\n    requires input_iterator<Iter>\n             && equality_comparable_with<iter_value_t<Iter>, Val>\nIter find(Iter b, Iter e, Val v)\n{\n    // ...\n} \n```", "```\ntemplate<input_iterator Iter, typename Val>\n    requires equality_comparable_with<iter_value_t<Iter>, Val>\nIter find(Iter b, Iter e, Val v)\n{\n    // ...\n} \n```", "```\ntemplate<typename T>\n    // don't define this: sortable is in <iterator>\nconcept Ordered_container = Sequence<T> && Random_access<Iterator<T>> && Ordered<Value_type<T>>;\n\nvoid sort(Ordered_container auto& s); \n```", "```\nvoid sort(sortable auto& s);   // better \n```", "```\nvector<string> v{ \"abc\", \"xyz\" };\nauto& x = v.front();        // bad\nString auto& s = v.front(); // good (String is a GSL concept) \n```", "```\ntemplate<typename T>       // Correct but verbose: \"The parameter is\n    requires sortable<T>   // of type T which is the name of a type\nvoid sort(T&);             // that is sortable\"\n\ntemplate<sortable T>       // Better: \"The parameter is of type T\nvoid sort(T&);             // which is Sortable\"\n\nvoid sort(sortable auto&); // Best: \"The parameter is Sortable\" \n```", "```\ntemplate<typename T>\n// bad; insufficient\nconcept Addable = requires(T a, T b) { a + b; };\n\ntemplate<Addable N>\nauto algo(const N& a, const N& b) // use two numbers\n{\n    // ...\n    return a + b;\n}\n\nint x = 7;\nint y = 9;\nauto z = algo(x, y);   // z = 16\n\nstring xx = \"7\";\nstring yy = \"9\";\nauto zz = algo(xx, yy);   // zz = \"79\" \n```", "```\ntemplate<typename T>\n// The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules\nconcept Number = requires(T a, T b) { a + b; a - b; a * b; a / b; };\n\ntemplate<Number N>\nauto algo(const N& a, const N& b)\n{\n    // ...\n    return a + b;\n}\n\nint x = 7;\nint y = 9;\nauto z = algo(x, y);   // z = 16\n\nstring xx = \"7\";\nstring yy = \"9\";\nauto zz = algo(xx, yy);   // error: string is not a Number \n```", "```\ntemplate<typename T> concept Subtractable = requires(T a, T b) { a - b; }; \n```", "```\nclass Minimal {\n    // ...\n};\n\nbool operator==(const Minimal&, const Minimal&);\nbool operator<(const Minimal&, const Minimal&);\n\nMinimal operator+(const Minimal&, const Minimal&);\n// no other operators\n\nvoid f(const Minimal& x, const Minimal& y)\n{\n    if (!(x == y)) { /* ... */ }    // OK\n    if (x != y) { /* ... */ }       // surprise! error\n\n    while (!(x < y)) { /* ... */ }  // OK\n    while (x >= y) { /* ... */ }    // surprise! error\n\n    x = x + y;          // OK\n    x += y;             // surprise! error\n} \n```", "```\nclass Convenient {\n    // ...\n};\n\nbool operator==(const Convenient&, const Convenient&);\nbool operator<(const Convenient&, const Convenient&);\n// ... and the other comparison operators ...\n\nConvenient operator+(const Convenient&, const Convenient&);\n// ... and the other arithmetic operators ...\n\nvoid f(const Convenient& x, const Convenient& y)\n{\n    if (!(x == y)) { /* ... */ }    // OK\n    if (x != y) { /* ... */ }       // OK\n\n    while (!(x < y)) { /* ... */ }  // OK\n    while (x >= y) { /* ... */ }    // OK\n\n    x = x + y;     // OK\n    x += y;        // OK\n} \n```", "```\ntemplate<typename T>\n    // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules\n    // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }\n    concept Number = requires(T a, T b) {\n        { a + b } -> convertible_to<T>;\n        { a - b } -> convertible_to<T>;\n        { a * b } -> convertible_to<T>;\n        { a / b } -> convertible_to<T>;\n    }; \n```", "```\n// balancer for a generic binary tree\ntemplate<typename Node> concept Balancer = requires(Node* p) {\n    add_fixup(p);\n    touch(p);\n    detach(p);\n}; \n```", "```\ntemplate<typename I>\n// Note: input_iterator is defined in <iterator>\nconcept Input_iter = requires(I iter) { ++iter; };\n\ntemplate<typename I>\n// Note: forward_iterator is defined in <iterator>\nconcept Fwd_iter = Input_iter<I> && requires(I iter) { iter++; }; \n```", "```\ntemplate<typename I>    // iterator providing random access\n// Note: random_access_iterator is defined in <iterator>\nconcept RA_iter = ...;\n\ntemplate<typename I>    // iterator providing random access to contiguous data\n// Note: contiguous_iterator is defined in <iterator>\nconcept Contiguous_iter =\n    RA_iter<I> && is_contiguous_v<I>;  // using is_contiguous trait \n```", "```\ntemplate<typename I> concept Contiguous = is_contiguous_v<I>;\n\ntemplate<typename I>\nconcept Contiguous_iter = RA_iter<I> && Contiguous<I>; \n```", "```\ntemplate<typename T>\n    requires !C<T>    // bad\nvoid f();\n\ntemplate<typename T>\n    requires C<T>\nvoid f(); \n```", "```\ntemplate<typename T>   // general template\n    void f();\n\ntemplate<typename T>   // specialization by concept\n    requires C<T>\nvoid f(); \n```", "```\ntemplate<typename T>\nvoid f() = delete; \n```", "```\ntemplate<typename T>\nenable_if<!C<T>, void>   // bad\nf();\n\ntemplate<typename T>\nenable_if<C<T>, void>\nf(); \n```", "```\nC1<T> && C2<T>\n!C1<T> && C2<T>\nC1<T> && !C2<T>\n!C1<T> && !C2<T> \n```", "```\ntemplate<typename T> concept Equality = has_equal<T> && has_not_equal<T>; \n```", "```\ntemplate<typename T> concept Equality = requires(T a, T b) {\n    { a == b } -> std::convertible_to<bool>;\n    { a != b } -> std::convertible_to<bool>;\n    // axiom { !(a == b) == (a != b) }\n    // axiom { a = b; => a == b }  // => means \"implies\"\n}; \n```", "```\nbool greater(double x, double y) { return x > y; }\nsort(v, greater);                                    // pointer to function: potentially slow\nsort(v, [](double x, double y) { return x > y; });   // function object\nsort(v, std::greater{});                             // function object\n\nbool greater_than_7(double x) { return x > 7; }\nauto x = find_if(v, greater_than_7);                 // pointer to function: inflexible\nauto y = find_if(v, [](double x) { return x > 7; }); // function object: carries the needed data\nauto z = find_if(v, Greater_than<double>(7));        // function object: carries the needed data \n```", "```\nauto y1 = find_if(v, [](totally_ordered auto x) { return x > 7; }); // require an ordered type\nauto z1 = find_if(v, [](auto x) { return x > 7; });                 // hope that the type has a > \n```", "```\nvoid sort(sortable auto& s)  // sort sequence s\n{\n    if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";\n    // ...\n    if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";\n} \n```", "```\ntemplate<sortable S>\n    requires Streamable<S>\nvoid sort(S& s)  // sort sequence s\n{\n    if (debug) cerr << \"enter sort( \" << s <<  \")\\n\";\n    // ...\n    if (debug) cerr << \"exit sort( \" << s <<  \")\\n\";\n} \n```", "```\ntemplate<typename T, size_t N>\nclass Matrix {\n    // ...\n    using Iterator = typename std::vector<T>::iterator;\n    // ...\n}; \n```", "```\ntemplate<typename T>\nvoid user(T& c)\n{\n    // ...\n    typename container_traits<T>::value_type x; // bad, verbose\n    // ...\n}\n\ntemplate<typename T>\nusing Value_type = typename container_traits<T>::value_type; \n```", "```\ntemplate<typename T>\nvoid user2(T& c)\n{\n    // ...\n    Value_type<T> x;\n    // ...\n} \n```", "```\ntypedef int (*PFI)(int);   // OK, but convoluted\n\nusing PFI2 = int (*)(int);   // OK, preferred\n\ntemplate<typename T>\ntypedef int (*PFT)(T);      // error\n\ntemplate<typename T>\nusing PFT2 = int (*)(T);   // OK \n```", "```\ntuple<int, string, double> t1 = {1, \"Hamlet\", 3.14};   // explicit type\nauto t2 = make_tuple(1, \"Ophelia\"s, 3.14);         // better; deduced type \n```", "```\nvector<double> v = { 1, 2, 3, 7.9, 15.99 };\nlist<Record*> lst; \n```", "```\ntuple t1 = {1, \"Hamlet\"s, 3.14}; // deduced: tuple<int, string, double> \n```", "```\nclass X {\npublic:\n    explicit X(int);\n    X(const X&);            // copy\n    X operator=(const X&);\n    X(X&&) noexcept;        // move\n    X& operator=(X&&) noexcept;\n    ~X();\n    // ... no more constructors ...\n};\n\nX x {1};              // fine\nX y = x;              // fine\nstd::vector<X> v(10); // error: no default constructor \n```", "```\nnamespace Bad {\n    struct S { int m; };\n    template<typename T1, typename T2>\n    bool operator==(T1, T2) { cout << \"Bad\\n\"; return true; }\n}\n\nnamespace T0 {\n    bool operator==(int, Bad::S) { cout << \"T0\\n\"; return true; }  // compare to int\n\n    void test()\n    {\n        Bad::S bad{ 1 };\n        vector<int> v(10);\n        bool b = 1 == bad;\n        bool b2 = v.size() == bad;\n    }\n} \n```", "```\ntemplate<typename T>\nenable_if_t<is_integral_v<T>>\nf(T v)\n{\n    // ...\n}\n\n// Equivalent to:\ntemplate<Integral T>\nvoid f(T v)\n{\n    // ...\n} \n```", "```\n??? \n```", "```\ntemplate<typename C>\nvoid sort(C& c)\n{\n    std::sort(begin(c), end(c)); // necessary and useful dependency\n}\n\ntemplate<typename Iter>\nIter algo(Iter first, Iter last)\n{\n    for (; first != last; ++first) {\n        auto x = sqrt(*first); // potentially surprising dependency: which sqrt()?\n        helper(first, x);      // potentially surprising dependency:\n                               // helper is chosen based on first and x\n        TT var = 7;            // potentially surprising dependency: which TT?\n    }\n} \n```", "```\ntemplate<typename T, typename A = std::allocator<T>>\n    // requires Regular<T> && Allocator<A>\nclass List {\npublic:\n    struct Link {   // does not depend on A\n        T elem;\n        Link* pre;\n        Link* suc;\n    };\n\n    using iterator = Link*;\n\n    iterator first() const { return head; }\n\n    // ...\nprivate:\n    Link* head;\n};\n\nList<int> lst1;\nList<int, My_allocator> lst2; \n```", "```\ntemplate<typename T>\nstruct Link {\n    T elem;\n    Link* pre;\n    Link* suc;\n};\n\ntemplate<typename T, typename A = std::allocator<T>>\n    // requires Regular<T> && Allocator<A>\nclass List2 {\npublic:\n    using iterator = Link<T>*;\n\n    iterator first() const { return head; }\n\n    // ...\nprivate:\n    Link<T>* head;\n};\n\nList2<int> lst1;\nList2<int, My_allocator> lst2; \n```", "```\ntemplate<typename T>\nclass Foo {\npublic:\n    enum { v1, v2 };\n    // ...\n}; \n```", "```\nstruct Foo_base {\n    enum { v1, v2 };\n    // ...\n};\n\ntemplate<typename T>\nclass Foo : public Foo_base {\npublic:\n    // ...\n}; \n```", "```\n??? string specialization (==)\n\n??? representation specialization ? \n```", "```\nstruct trivially_copyable_tag {};\nstruct non_trivially_copyable_tag {};\n\n// T is not trivially copyable\ntemplate<class T> struct copy_trait { using tag = non_trivially_copyable_tag; };\n// int is trivially copyable\ntemplate<> struct copy_trait<int> { using tag = trivially_copyable_tag; };\n\ntemplate<class Iter>\nOut copy_helper(Iter first, Iter last, Iter out, trivially_copyable_tag)\n{\n    // use memmove\n}\n\ntemplate<class Iter>\nOut copy_helper(Iter first, Iter last, Iter out, non_trivially_copyable_tag)\n{\n    // use loop calling copy constructors\n}\n\ntemplate<class Iter>\nOut copy(Iter first, Iter last, Iter out)\n{\n    using tag_type = typename copy_trait<std::iter_value_t<Iter>>::tag;\n    return copy_helper(first, last, out, tag_type{})\n}\n\nvoid use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, vector<string>& vs2)\n{\n    copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove\n    copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors\n} \n```", "```\ntemplate<class Iter>\n    requires std::is_trivially_copyable_v<std::iter_value_t<Iter>>\nOut copy_helper(In, first, In last, Out out)\n{\n    // use memmove\n}\n\ntemplate<class Iter>\nOut copy_helper(In, first, In last, Out out)\n{\n    // use loop calling copy constructors\n} \n```", "```\n??? \n```", "```\ntemplate<typename T, typename U>\nvoid f(T t, U u)\n{\n    T v1(T(u));    // mistake: oops, v1 is a function, not a variable\n    T v2{u};       // clear:   obviously a variable\n    auto x = T(u); // unclear: construction or cast?\n}\n\nf(1, \"asdf\"); // bad: cast from const char* to int \n```", "```\ntemplate<class T>\n    // Call a member function\nvoid test1(T t)\n{\n    t.f();    // require T to provide f()\n}\n\ntemplate<class T>\nvoid test2(T t)\n    // Call a non-member function without qualification\n{\n    f(t);     // require f(/*T*/) be available in caller's scope or in T's namespace\n}\n\ntemplate<class T>\nvoid test3(T t)\n    // Invoke a \"trait\"\n{\n    test_traits<T>::f(t); // require customizing test_traits<>\n                          // to get non-default functions/types\n} \n```", "```\ntemplate<typename T>\nstruct Container {         // an interface\n    virtual T* get(int i);\n    virtual T* first();\n    virtual T* next();\n    virtual void sort();\n};\n\ntemplate<typename T>\nclass Vector : public Container<T> {\npublic:\n    // ...\n};\n\nVector<int> vi;\nVector<string> vs; \n```", "```\nvoid maul(Fruit* p)\n{\n    *p = Pear{};     // put a Pear into *p\n    p[1] = Pear{};   // put a Pear into p[1]\n}\n\nApple aa [] = { an_apple, another_apple };   // aa contains Apples (obviously!)\n\nmaul(aa);\nApple& a0 = &aa[0];   // a Pear?\nApple& a1 = &aa[1];   // a Pear? \n```", "```\nvoid maul2(Fruit* p)\n{\n    *p = Pear{};   // put a Pear into *p\n}\n\nvector<Apple> va = { an_apple, another_apple };   // va contains Apples (obviously!)\n\nmaul2(va);       // error: cannot convert a vector<Apple> to a Fruit*\nmaul2(&va[0]);   // you asked for it\n\nApple& a0 = &va[0];   // a Pear? \n```", "```\n??? \n```", "```\nclass Shape {\n    // ...\n    template<class T>\n    virtual bool intersect(T* p);   // error: template cannot be virtual\n}; \n```", "```\nstruct Link_base {   // stable\n    Link_base* suc;\n    Link_base* pre;\n};\n\ntemplate<typename T>   // templated wrapper to add type safety\nstruct Link : Link_base {\n    T val;\n};\n\nstruct List_base {\n    Link_base* first;   // first element (if any)\n    int sz;             // number of elements\n    void add_front(Link_base* p);\n    // ...\n};\n\ntemplate<typename T>\nclass List : List_base {\npublic:\n    void put_front(const T& e) { add_front(new Link<T>{e}); }   // implicit cast to Link_base\n    T& front() { return static_cast<Link<T>*>(first)->val; }   // explicit cast back to Link<T>\n    // ...\n};\n\nList<int> li;\nList<string> ls; \n```", "```\n??? printf \n```", "```\n??? beware of move-only and reference arguments \n```", "```\n??? forwarding, type checking, references \n```", "```\n??? \n```", "```\n??? \n```", "```\nenable_if \n```", "```\n??? good \n```", "```\ntemplate<typename Iter>\n    /*requires*/ enable_if<random_access_iterator<Iter>, void>\nadvance(Iter p, int n) { p += n; }\n\ntemplate<typename Iter>\n    /*requires*/ enable_if<forward_iterator<Iter>, void>\nadvance(Iter p, int n) { assert(n >= 0); while (n--) ++p;} \n```", "```\nvoid advance(random_access_iterator auto p, int n) { p += n; }\n\nvoid advance(forward_iterator auto p, int n) { assert(n >= 0); while (n--) ++p;} \n```", "```\n??? big object / small object optimization \n```", "```\ntemplate<typename T>\n    // requires Number<T>\nconstexpr T pow(T v, int n)   // power/exponential\n{\n    T res = 1;\n    while (n--) res *= v;\n    return res;\n}\n\nconstexpr auto f7 = pow(pi, 7); \n```", "```\n??? \n```", "```\n??? \n```", "```\n??? \n```", "```\nfor (auto i = first; i < last; ++i) {   // less generic\n    // ...\n}\n\nfor (auto i = first; i != last; ++i) {   // good; more generic\n    // ...\n} \n```", "```\nclass Base {\npublic:\n    Bar f();\n    Bar g();\n};\n\nclass Derived1 : public Base {\npublic:\n    Bar h();\n};\n\nclass Derived2 : public Base {\npublic:\n    Bar j();\n};\n\n// bad, unless there is a specific reason for limiting to Derived1 objects only\nvoid my_func(Derived1& param)\n{\n    use(param.f());\n    use(param.g());\n}\n\n// good, uses only Base interface so only commit to that\nvoid my_func(Base& param)\n{\n    use(param.f());\n    use(param.g());\n} \n```", "```\n??? \n```", "```\nclass X {\npublic:\n    X() = delete;\n    X(const X&) = default;\n    X(X&&) = default;\n    X& operator=(const X&) = default;\n    // ...\n}; \n```", "```\nstatic_assert(Default_constructible<X>);    // error: X has no default constructor\nstatic_assert(Copyable<X>);                 // error: we forgot to define X's move constructor \n```", "```\nchar ch = 7;\nvoid* pv = &ch;\nint* pi = pv;   // not C++\n*pi = 999;      // overwrite sizeof(int) bytes near &ch \n```", "```\nint* p1 = malloc(10 * sizeof(int));                      // not C++\nint* p2 = static_cast<int*>(malloc(10 * sizeof(int)));   // not C, C-style C++\nint* p3 = new int[10];                                   // not C\nint* p4 = (int*) malloc(10 * sizeof(int));               // both C and C++ \n```", "```\n// in C:\ndouble sqrt(double);\n\n// in C++:\nextern \"C\" double sqrt(double);\n\nsqrt(2); \n```", "```\n// in C:\nX call_f(struct Y*, int);\n\n// in C++:\nextern \"C\" X call_f(Y* p, int i)\n{\n    return p->f(i);   // possibly a virtual function call\n} \n```", "```\n// file.h:\nnamespace Foo {\n    int x = 7;\n    int xx() { return x+x; }\n}\n\n// file1.cpp:\n#include <file.h>\n// ... more ...\n\n // file2.cpp:\n#include <file.h>\n// ... more ... \n```", "```\n// bar.cpp:\nvoid bar() { cout << \"bar\\n\"; }\n\n// foo.cpp:\nextern void bar();\nvoid foo() { bar(); } \n```", "```\n#include <vector>\n#include <algorithm>\n#include <string>\n\n// ... my code here ... \n```", "```\n#include <vector>\n\n// ... my code here ...\n\n#include <algorithm>\n#include <string> \n```", "```\n// foo.h:\nvoid foo(int);\nint bar(long);\nint foobar(int);\n\n// foo.cpp:\nvoid foo(int) { /* ... */ }\nint bar(double) { /* ... */ }\ndouble foobar(int); \n```", "```\n// foo.h:\nvoid foo(int);\nint bar(long);\nint foobar(int);\n\n// foo.cpp:\n#include \"foo.h\"\n\nvoid foo(int) { /* ... */ }\nint bar(double) { /* ... */ }\ndouble foobar(int);   // error: wrong return type \n```", "```\n#include <string>\n#include <vector>\n#include <iostream>\n#include <memory>\n#include <algorithm>\n\nusing namespace std;\n\n// ... \n```", "```\n#include <cmath>\nusing namespace std;\n\nint g(int x)\n{\n    int sqrt = 7;\n    // ...\n    return sqrt(x); // error\n} \n```", "```\n// bad.h\n#include <iostream>\nusing namespace std; // bad\n\n// user.cpp\n#include \"bad.h\"\n\nbool copy(/*... some parameters ...*/);    // some function that happens to be named copy\n\nint main()\n{\n    copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous\n} \n```", "```\n// file foobar.h:\n#ifndef LIBRARY_FOOBAR_H\n#define LIBRARY_FOOBAR_H\n// ... declarations ...\n#endif // LIBRARY_FOOBAR_H \n```", "```\n// file1.h:\n#include \"file2.h\"\n\n// file2.h:\n#include \"file3.h\"\n\n// file3.h:\n#include \"file1.h\" \n```", "```\n#include <iostream>\nusing namespace std;\n\nvoid use()\n{\n    string s;\n    cin >> s;               // fine\n    getline(cin, s);        // error: getline() not defined\n    if (s == \"surprise\") {  // error == not defined\n        // ...\n    }\n} \n```", "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid use()\n{\n    string s;\n    cin >> s;               // fine\n    getline(cin, s);        // fine\n    if (s == \"surprise\") {  // fine\n        // ...\n    }\n} \n```", "```\n// basic_std_lib.h:\n\n#include <string>\n#include <map>\n#include <iostream>\n#include <random>\n#include <vector> \n```", "```\n#include \"basic_std_lib.h\" \n```", "```\n#include \"helpers.h\"\n// helpers.h depends on std::string and includes <string> \n```", "```\n// foo.cpp:\n#include <string>                // From the standard library, requires the <> form\n#include <some_library/common.h> // A file that is not locally relative, included from another library; use the <> form\n#include \"foo.h\"                 // A file locally relative to foo.cpp in the same project, use the \"\" form\n#include \"util/util.h\"           // A file locally relative to foo.cpp in the same project, use the \"\" form\n#include <component_b/bar.h>     // A file in the same project located via a search path, use the <> form \n```", "```\n// good examples\n#include <vector>\n#include <string>\n#include \"util/util.h\"\n\n// bad examples\n#include <VECTOR>        // bad: the standard library defines a header identified as <vector>, not <VECTOR>\n#include <String>        // bad: the standard library defines a header identified as <string>, not <String>\n#include \"Util/Util.H\"   // bad: the header file exists on the file system as \"util/util.h\"\n#include \"util\\util.h\"   // bad: may not work if the implementation interprets `\\u` as an escape sequence, or where '\\' is not a valid path separator \n```", "```\n??? \n```", "```\n// file foo.h:\nnamespace\n{\n    const double x = 1.234;  // bad\n\n    double foo(double y)     // bad\n    {\n        return y + x;\n    }\n}\n\nnamespace Foo\n{\n    const double x = 1.234; // good\n\n    inline double foo(double y)        // good\n    {\n        return y + x;\n    }\n} \n```", "```\nstatic int f();\nint g();\nstatic bool h();\nint k(); \n```", "```\nnamespace {\n    int f();\n    bool h();\n}\nint g();\nint k(); \n```", "```\n??? \n```", "```\nnamespace std { // BAD: violates standard\n\nclass My_vector {\n    //     . . .\n};\n\n}\n\nnamespace Foo { // GOOD: user namespace is allowed\n\nclass My_vector {\n    //     . . .\n};\n\n} \n```", "```\nint v[SIZE];                        // BAD\n\nstd::array<int, SIZE> w;            // ok \n```", "```\nint* v = new int[initial_size];     // BAD, owning raw pointer\ndelete[] v;                         // BAD, manual delete\n\nstd::vector<int> w(initial_size);   // ok \n```", "```\nvector<int> v1(20);  // v1 has 20 elements with the value 0 (vector<int>{})\nvector<int> v2 {20}; // v2 has 1 element with the value 20 \n```", "```\nvoid f()\n{\n    array<int, 10> a, b;\n    memset(a.data(), 0, 10);         // BAD, and contains a length error (length = 10 * sizeof(int))\n    memcmp(a.data(), b.data(), 10);  // BAD, and contains a length error (length = 10 * sizeof(int))\n} \n```", "```\nvoid f()\n{\n    array<int, 10> a, b, c{};       // c is initialized to zero\n    a.fill(0);\n    fill(b.begin(), b.end(), 0);    // std::fill()\n    fill(b, 0);                     // std::ranges::fill()\n\n    if ( a == b ) {\n      // ...\n    }\n} \n```", "```\nvoid f(std::vector<int>& v, std::array<int, 12> a, int i)\n{\n    v[0] = a[0];        // BAD\n    v.at(0) = a[0];     // OK (alternative 1)\n    at(v, 0) = a[0];    // OK (alternative 2)\n\n    v.at(0) = a[i];     // BAD\n    v.at(0) = a.at(i);  // OK (alternative 1)\n    v.at(0) = at(a, i); // OK (alternative 2)\n} \n```", "```\nstruct base {\n    virtual void update() = 0;\n};\n\nstruct derived : public base {\n    void update() override {}\n};\n\nvoid f(derived& a, derived& b) // goodbye v-tables\n{\n    memset(&a, 0, sizeof(derived));\n    memcpy(&a, &b, sizeof(derived));\n    memcmp(&a, &b, sizeof(derived));\n} \n```", "```\nvoid g(derived& a, derived& b)\n{\n    a = {};    // default initialize\n    b = a;     // copy\n    if (a == b) do_something(a, b);\n} \n```", "```\nvector<string> read_until(const string& terminator)\n{\n    vector<string> res;\n    for (string s; cin >> s && s != terminator; ) // read a word\n        res.push_back(s);\n    return res;\n} \n```", "```\nvector<string> read_until(string_view terminator)   // C++17\n{\n    vector<string> res;\n    for (string s; cin >> s && s != terminator; ) // read a word\n        res.push_back(s);\n    return res;\n} \n```", "```\nchar* cat(const char* s1, const char* s2)   // beware!\n    // return s1 + '.' + s2\n{\n    int l1 = strlen(s1);\n    int l2 = strlen(s2);\n    char* p = (char*) malloc(l1 + l2 + 2);\n    strcpy(p, s1, l1);\n    p[l1] = '.';\n    strcpy(p + l1 + 1, s2, l2);\n    p[l1 + l2 + 1] = 0;\n    return p;\n} \n```", "```\nvector<string> read_until(string_view terminator);\n\nvoid user(zstring p, const string& s, string_view ss)\n{\n    auto v1 = read_until(p);\n    auto v2 = read_until(s);\n    auto v3 = read_until(ss);\n    // ...\n} \n```", "```\nvoid f1(const char* s); // s is probably a string \n```", "```\nvoid f1(zstring s);     // s is a C-style string or the nullptr\nvoid f1(czstring s);    // s is a C-style string constant or the nullptr\nvoid f1(std::byte* s);  // s is a pointer to a byte (C++17) \n```", "```\nchar arr[] = {'a', 'b', 'c'};\n\nvoid print(const char* p)\n{\n    cout << p << '\\n';\n}\n\nvoid use()\n{\n    print(arr);   // run-time error; potentially very bad\n} \n```", "```\n??? \n```", "```\n??? \n```", "```\nauto pp1 = make_pair(\"Tokyo\", 9.00);         // {C-style string,double} intended?\npair<string, double> pp2 = {\"Tokyo\", 9.00};  // a bit verbose\nauto pp3 = make_pair(\"Tokyo\"s, 9.00);        // {std::string,double}    // C++14\npair pp4 = {\"Tokyo\"s, 9.00};                 // {std::string,double}    // C++17 \n```", "```\nchar c;\nchar buf[128];\nint i = 0;\nwhile (cin.get(c) && !isspace(c) && i < 128)\n    buf[i++] = c;\nif (i == 128) {\n    // ... handle too long string ....\n} \n```", "```\nstring s;\ns.reserve(128);\ncin >> s; \n```", "```\n??? \n```", "```\n// write a complex number:\ncomplex<double> z{ 3, 4 };\ncout << z << '\\n'; \n```", "```\n// read a file of complex numbers:\nfor (complex<double> z; cin >> z; )\n    v.push_back(z); \n```", "```\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    // ... use iostreams ...\n} \n```", "```\ncout << \"Hello, World!\" << endl;    // two output operations and a flush\ncout << \"Hello, World!\\n\";          // one output operation and no flush \n```", "```\n??? \n```", "```\nint use(int x)\n{\n    int i;\n    char c;\n    double d;\n\n    // ... some stuff ...\n\n    if (x < i) {\n        // ...\n        i = f(x, d);\n    }\n    if (i < x) {\n        // ...\n        i = g(x, c);\n    }\n    return i;\n} \n```", "```\ntemplate<class T>\n//  requires Number<T>\nstring sign(T x)\n{\n    if (x < 0)\n        return \"negative\";\n    if (x > 0)\n        return \"positive\";\n    return \"zero\";\n} \n```", "```\ntemplate<class T>\n//  requires Number<T>\nstring sign(T x)        // bad\n{\n    string res;\n    if (x < 0)\n        res = \"negative\";\n    else if (x > 0)\n        res = \"positive\";\n    else\n        res = \"zero\";\n    return res;\n} \n```", "```\nint index(const char* p)\n{\n    if (!p) return -1;  // error indicator: alternatively \"throw nullptr_error{}\"\n    // ... do a lookup to find the index for p\n    return i;\n} \n```", "```\nint index2(const char* p)\n{\n    int i;\n    if (!p)\n        i = -1;  // error indicator\n    else {\n        // ... do a lookup to find the index for p\n    }\n    return i;\n} \n```", "```\n??? \n```", "```\n??? \n```", "```\n// Old conventional style: many problems\n\nclass Picture\n{\n    int mx;\n    int my;\n    int * data;\npublic:\n    // main problem: constructor does not fully construct\n    Picture(int x, int y)\n    {\n        mx = x;         // also bad: assignment in constructor body\n                        // rather than in member initializer\n        my = y;\n        data = nullptr; // also bad: constant initialization in constructor\n                        // rather than in member initializer\n    }\n\n    ~Picture()\n    {\n        Cleanup();\n    }\n\n    // ...\n\n    // bad: two-phase initialization\n    bool Init()\n    {\n        // invariant checks\n        if (mx <= 0 || my <= 0) {\n            return false;\n        }\n        if (data) {\n            return false;\n        }\n        data = (int*) malloc(mx*my*sizeof(int));   // also bad: owning raw * and malloc\n        return data != nullptr;\n    }\n\n    // also bad: no reason to make cleanup a separate function\n    void Cleanup()\n    {\n        if (data) free(data);\n        data = nullptr;\n    }\n};\n\nPicture picture(100, 0); // not ready-to-use picture here\n// this will fail..\nif (!picture.Init()) {\n    puts(\"Error, invalid picture\");\n}\n// now have an invalid picture object instance. \n```", "```\nclass Picture\n{\n    int mx;\n    int my;\n    vector<int> data;\n\n    static int check_size(int size)\n    {\n        // invariant check\n        Expects(size > 0);\n        return size;\n    }\n\npublic:\n    // even better would be a class for a 2D Size as one single parameter\n    Picture(int x, int y)\n        : mx(check_size(x))\n        , my(check_size(y))\n        // now we know x and y have a valid size\n        , data(mx * my) // will throw std::bad_alloc on error\n    {\n        // picture is ready-to-use\n    }\n\n    // compiler generated dtor does the job. (also see C.21)\n\n    // ...\n};\n\nPicture picture1(100, 100);\n// picture1 is ready-to-use here...\n\n// not a valid size for y,\n// default contract violation behavior will call std::terminate then\nPicture picture2(100, 0);\n// not reach here... \n```", "```\nvoid do_something(int n)\n{\n    if (n < 100) goto exit;\n    // ...\n    int* p = (int*) malloc(n);\n    // ...\n    if (some_error) goto exit;\n    // ...\nexit:\n    free(p);\n} \n```", "```\n??? \n```", "```\n[[suppress(\"bounds\")]] char* raw_find(char* p, int n, char x)    // find x in p[0]..p[n - 1]\n{\n    // ...\n} \n```", "```\nauto x = m * v1 + vv;   // multiply m with v1 and add the result to vv \n```", "```\nvoid stable_sort(Sortable& c)\n    // sort c in the order determined by <, keep equal elements (as defined by ==) in\n    // their original relative order\n{\n    // ... quite a few lines of non-trivial code ...\n} \n```", "```\nint i;\nfor (i = 0; i < max; ++i); // bug waiting to happen\nif (i == j)\n    return i; \n```", "```\nif (i < 0) error(\"negative argument\");\n\nif (i < 0)\n    error(\"negative argument\"); \n```", "```\nvoid print_int(int i);\nvoid print_string(const char*);\n\nprint_int(1);          // repetitive, manual type matching\nprint_string(\"xyzzy\"); // repetitive, manual type matching \n```", "```\nvoid print(int i);\nvoid print(string_view);    // also works on any string-like sequence\n\nprint(1);              // clear, automatic type matching\nprint(\"xyzzy\");        // clear, automatic type matching \n```", "```\nprintS  // print a std::string\nprints  // print a C-style string\nprinti  // print an int \n```", "```\nauto p = new User();\nauto p = make_unique<User>();\n// note: \"p\" is not being used to say \"raw pointer to type User,\"\n//       just generally to say \"this is an indirection\"\n\nauto cntHits = calc_total_of_hits(/*...*/);\n// note: \"cnt\" is not being used to encode a type,\n//       just generally to say \"this is a count of something\" \n```", "```\nstruct S {\n    int m_;\n    S(int m) : m_{abs(m)} { }\n}; \n```", "```\ntypename<typename T>\nclass HashTable {   // maps string to T\n    // ...\n};\n\nHashTable<int> index; \n```", "```\ndouble sqrt(double x);   // return the square root of x; x must be non-negative\n\nint length(const char* p);  // return the number of characters in a zero-terminated C-style string\n\nint length_of_string(const char zero_terminated_array_of_char[])    // bad: verbose\n\nint g;      // bad: global variable with a cryptic name\n\nint open;   // bad: global variable with a short, popular name \n```", "```\nint mtbf {12};\nint mean_time_between_failures {12}; // make up your mind \n```", "```\nvoid f()\n{\n    const int SIZE{1000};  // Bad, use 'size' instead\n    int v[SIZE];\n} \n```", "```\nenum bad { BAD, WORSE, HORRIBLE }; // BAD \n```", "```\nauto c = 299'792'458; // m/s2\nauto q2 = 0b0000'1111'0000'0000;\nauto ss_number = 123'456'7890; \n```", "```\nauto hello = \"Hello!\"s; // a std::string\nauto world = \"world\";   // a C-style string\nauto interval = 100ms;  // using <chrono> \n```", "```\n#include < map >\n\nint main(int argc, char * argv [ ])\n{\n    // ...\n} \n```", "```\n#include <map>\n\nint main(int argc, char* argv[])\n{\n    // ...\n} \n```", "```\nclass X {\npublic:\n    // interface\nprotected:\n    // unchecked function for use by derived class implementations\nprivate:\n    // implementation details\n}; \n```", "```\nclass X {\npublic:\n    // interface\nprotected:\n    // unchecked function for use by derived class implementations\nprivate:\n    // implementation details (types, functions, and data)\n}; \n```", "```\nclass X {   // bad\npublic:\n    void f();\npublic:\n    int g();\n    // ...\n}; \n```", "```\nstruct Cable {\n    int x;\n    // ...\n};\n\ndouble foo(int x)\n{\n    if (0 < x) {\n        // ...\n    }\n\n    switch (x) {\n    case 0:\n        // ...\n        break;\n    case amazing:\n        // ...\n        break;\n    default:\n        // ...\n        break;\n    }\n\n    if (0 < x)\n        ++x;\n\n    if (x < 0)\n        something();\n    else\n        something_else();\n\n    return some_value;\n} \n```", "```\nT& operator[](size_t);   // OK\nT &operator[](size_t);   // just strange\nT & operator[](size_t);   // undecided \n```", "```\nint oO01lL = 6; // bad\n\nint splunk = 7;\nint splonk = 8; // bad: splunk and splonk are easily confused \n```", "```\nint x = 7; char* p = 29;    // don't\nint x = 7; f(x);  ++x;      // don't \n```", "```\nvoid f(void);   // bad\n\nvoid g();       // better \n```", "```\nint f();\nf(1, 2, \"weird but valid C89\");   // hope that f() is defined int f(a, b, c) char* c; { /* ... */ } \n```", "```\nconst int x = 7;    // OK\nint const y = 9;    // bad\n\nconst int *const p = nullptr;   // OK, constant pointer to constant int\nint const *const p = nullptr;   // bad, constant pointer to constant int \n```", "```\n// foo.h:\nextern int a;   // a declaration\nextern void foo();\n\n// foo.cpp:\nint a;   // a definition\nvoid foo() { ++a; } \n```", "```\n// foo.h:\nint a;   // a definition\nvoid foo() { ++a; } \n```", "```\nclass Employee {\n    string email, first, last;\npublic:\n    Employee(const char* firstName, const char* lastName);\n    // ...\n};\n\nEmployee::Employee(const char* firstName, const char* lastName)\n  : first(firstName),\n    last(lastName),\n    // BAD: first and last not yet constructed\n    email(first + \".\" + last + \"@acme.com\")\n{} \n```", "```\nclass B {\npublic:\n    B()\n    {\n        /* ... */\n        f(); // BAD: C.82: Don't call virtual functions in constructors and destructors\n        /* ... */\n    }\n\n    virtual void f() = 0;\n};\n\nclass B {\nprotected:\n    class Token {};\n\npublic:\n    // constructor needs to be public so that make_shared can access it.\n    // protected access level is gained by requiring a Token.\n    explicit B(Token) { /* ... */ }  // create an imperfectly initialized object\n    virtual void f() = 0;\n\n    template<class T>\n    static shared_ptr<T> create()    // interface for creating shared objects\n    {\n        auto p = make_shared<T>(typename T::Token{});\n        p->post_initialize();\n        return p;\n    }\n\nprotected:\n    virtual void post_initialize()   // called right after construction\n        { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe\n    }\n};\n\nclass D : public B {                 // some derived class\nprotected:\n    class Token {};\n\npublic:\n    // constructor needs to be public so that make_shared can access it.\n    // protected access level is gained by requiring a Token.\n    explicit D(Token) : B{ B::Token{} } {}\n    void f() override { /* ...  */ };\n\nprotected:\n    template<class T>\n    friend shared_ptr<T> B::create();\n};\n\nshared_ptr<D> p = D::create<D>();    // creating a D object \n```", "```\nclass Base {\npublic:\n    ~Base();                   // BAD, not virtual\n    virtual ~Base();           // GOOD\n    // ...\n};\n\nclass Derived : public Base { /* ... */ };\n\n{\n    unique_ptr<Base> pb = make_unique<Derived>();\n    // ...\n} // ~pb invokes correct destructor only when ~Base is virtual \n```", "```\nclass My_policy {\npublic:\n    virtual ~My_policy();      // BAD, public and virtual\nprotected:\n    ~My_policy();              // GOOD\n    // ...\n};\n\ntemplate<class Policy>\nclass customizable : Policy { /* ... */ }; // note: private inheritance \n```", "```\nclass Nefarious {\npublic:\n    Nefarious() { /* code that could throw */ }    // ok\n    ~Nefarious() { /* code that could throw */ }   // BAD, should not throw\n    // ...\n}; \n```", "```\n     void test(string& s)\n     {\n         Nefarious n;          // trouble brewing\n         string copy = s;      // copy the string\n     } // destroy copy and then n \n    ```", "```\n     class Innocent_bystander {\n         Nefarious member;     // oops, poisons the enclosing class's destructor\n         // ...\n     };\n\n     void test(string& s)\n     {\n         Innocent_bystander i;  // more trouble brewing\n         string copy2 = s;      // copy the string\n     } // destroy copy and then i \n    ```", "```\n     static Nefarious n;       // oops, any destructor exception can't be caught \n    ```", "```\n     void test()\n     {\n         std::array<Nefarious, 10> arr; // this line can std::terminate()\n     } \n    ```", "```\n     std::vector<Nefarious> vec(10);   // this line can std::terminate() \n    ```", "```\nT& T::operator=(const T& other)\n{\n    auto temp = other;\n    swap(temp);\n    return *this;\n} \n```", "```\nclass X {\npublic:\n    X(const X&) { /* stuff */ }\n\n    // BAD: failed to also define a copy assignment operator\n\n    X(x&&) noexcept { /* stuff */ }\n\n    // BAD: failed to also define a move assignment operator\n\n    // ...\n};\n\nX x1;\nX x2 = x1; // ok\nx2 = x1;   // pitfall: either fails to compile, or does something suspicious \n```", "```\nclass X {\n    HANDLE hnd;\n    // ...\npublic:\n    ~X() { /* custom stuff, such as closing hnd */ }\n    // suspicious: no mention of copying or moving -- what happens to hnd?\n};\n\nX x1;\nX x2 = x1; // pitfall: either fails to compile, or does something suspicious\nx2 = x1;   // pitfall: either fails to compile, or does something suspicious \n```", "```\nclass X {\n    string s; // defines more efficient move operations\n    // ... other data members ...\npublic:\n    X(const X&) { /* stuff */ }\n    X& operator=(const X&) { /* stuff */ }\n\n    // BAD: failed to also define a move construction and move assignment\n    // (why wasn't the custom \"stuff\" repeated here?)\n};\n\nX test()\n{\n    X local;\n    // ...\n    return local;  // pitfall: will be inefficient and/or do the wrong thing\n} \n```", "```\ntemplate<class T>\nclass Vector {\nprivate:\n    T* elem;   // sz elements on the free store, owned by the class object\n    int sz;\n    // ...\n}; \n```", "```\n??? \"odd\" non-memory resource ??? \n```", "```\nvoid f(int i)\n{\n    FILE* f = fopen(\"a file\", \"r\");\n    ifstream is { \"another file\" };\n    // ...\n    if (i == 0) return;\n    // ...\n    fclose(f);\n} \n```", "```\nvoid f(int i)\n{\n    unique_ptr<FILE, int(*)(FILE*)> f(fopen(\"a file\", \"r\"), fclose);\n    // ...\n    if (i == 0) return;\n    // ...\n} \n```", "```\nvoid f(int i)\n{\n    ifstream input {\"a file\"};\n    // ...\n    if (i == 0) return;\n    // ...\n} \n```", "```\nstring* bad()   // really bad\n{\n    vector<string> v = { \"This\", \"will\", \"cause\", \"trouble\", \"!\" };\n    // leaking a pointer into a destroyed member of a destroyed object (v)\n    return &v[0];\n}\n\nvoid use()\n{\n    string* p = bad();\n    vector<int> xx = {7, 8, 9};\n    // undefined behavior: x might not be the string \"This\"\n    string x = *p;\n    // undefined behavior: we don't know what (if anything) is allocated a location p\n    *p = \"Evil!\";\n} \n```", "```\ntemplate<typename T> class Vector {\n    // ...\n    T* elem;   // point to sz elements of type T\n    int sz;\n}; \n```", "```\nvector<int> get_large_vector()\n{\n    return ...;\n}\n\nauto v = get_large_vector(); //  return by value is ok, most modern compilers will do copy elision \n```", "```\n??? Messing with pointers \n```", "```\ntemplate<typename T> struct Named {\n    string name;\n    T value;\n}; \n```", "```\ntemplate<typename T> class Vector {\npublic:\n    Vector(std::initializer_list<T>);\n    // ...\n};\n\nVector<string> vs { \"Nygaard\", \"Ritchie\" }; \n```", "```\n     void bad()\n      {\n          int* p = new int[700];\n          int* q = &p[7];\n          delete p;\n\n          vector<int> v(700);\n          int* q2 = &v[7];\n          v.resize(900);\n\n          // ... use q and q2 ...\n      } \n    ```"]