["```cpp\n const bool skip_transaction = is_already_logged_transaction(thd);\n  if (gtid_next_list == nullptr) {\n    if (skip_transaction) {\n      skip_statement(thd);\n      return GTID_STATEMENT_SKIP;\n    }     \n    return GTID_STATEMENT_EXECUTE;\n  } else { \n```", "```cpp\n while (!io_slave_killed(thd, mi)) {\n        ulong event_len;\n        ...\n        THD_STAGE_INFO(thd, stage_waiting_for_source_to_send_event);\n        event_len = read_event(mysql, &rpl, mi, &suppress_warnings);\n        ...\n        THD_STAGE_INFO(thd, stage_queueing_source_event_to_the_relay_log);\n        event_buf = (const char *)mysql->net.read_pos + 1;\n        ...\n        if (RUN_HOOK(binlog_relay_io, after_read_event,\n                     (thd, mi, (const char *)mysql->net.read_pos + 1, event_len,\n                      &event_buf, &event_len))) {\n          mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,\n                     ER_THD(thd, ER_REPLICA_FATAL_ERROR),\n                     \"Failed to run 'after_read_event' hook\");\n          goto err;\n        }\n        ...\n        QUEUE_EVENT_RESULT queue_res = queue_event(mi, event_buf, event_len);\n        if (queue_res == QUEUE_EVENT_ERROR_QUEUING) {\n          mi->report(ERROR_LEVEL, ER_REPLICA_RELAY_LOG_WRITE_FAILURE,\n                     ER_THD(thd, ER_REPLICA_RELAY_LOG_WRITE_FAILURE),\n                     \"could not queue event from source\");\n          goto err;\n        }\n        ...\n        if (RUN_HOOK(binlog_relay_io, after_queue_event,\n                     (thd, mi, event_buf, event_len, synced))) {\n          mi->report(ERROR_LEVEL, ER_REPLICA_FATAL_ERROR,\n                     ER_THD(thd, ER_REPLICA_FATAL_ERROR),\n                     \"Failed to run 'after_queue_event' hook\");\n          goto err;  \n        } \n        ...\n        thd->mem_root->ClearForReuse();\n      } \n```", "```cpp\n // possible WQ overfill\n  while (worker->running_status == Slave_worker::RUNNING && !thd->killed &&\n         (ret = worker->jobs.en_queue(job_item)) ==\n             Slave_jobs_queue::error_result) {\n    thd->ENTER_COND(&worker->jobs_cond, &worker->jobs_lock,\n                    &stage_replica_waiting_worker_queue, &old_stage);\n    worker->jobs.overfill = true;\n    worker->jobs.waited_overfill++;\n    rli->mts_wq_overfill_cnt++;\n    // wait if worker queue is full\n    mysql_cond_wait(&worker->jobs_cond, &worker->jobs_lock);\n    mysql_mutex_unlock(&worker->jobs_lock);\n    thd->EXIT_COND(&old_stage);\n    mysql_mutex_lock(&worker->jobs_lock);\n  } \n```", "```cpp\nbool Mts_submode_logical_clock::wait_for_last_committed_trx(\n    Relay_log_info *rli, longlong last_committed_arg) {\n  THD *thd = rli->info_thd;\n  ...\n  if ((!rli->info_thd->killed && !is_error) &&\n      !clock_leq(last_committed_arg, get_lwm_timestamp(rli, true))) {\n    PSI_stage_info old_stage;\n    struct timespec ts[2];\n    set_timespec_nsec(&ts[0], 0);\n    assert(rli->gaq->get_length() >= 2);  // there's someone to wait\n    thd->ENTER_COND(&rli->logical_clock_cond, &rli->mts_gaq_LOCK,\n                    &stage_worker_waiting_for_commit_parent, &old_stage);\n    do {\n      // wait if LWM is less than last committed\n      mysql_cond_wait(&rli->logical_clock_cond, &rli->mts_gaq_LOCK);\n    } while ((!rli->info_thd->killed && !is_error) &&\n             !clock_leq(last_committed_arg, estimate_lwm_timestamp()));\n    min_waited_timestamp.store(SEQ_UNINIT);  // reset waiting flag\n    mysql_mutex_unlock(&rli->mts_gaq_LOCK);\n    thd->EXIT_COND(&old_stage);\n    set_timespec_nsec(&ts[1], 0);\n    rli->mts_total_wait_overlap += diff_timespec(&ts[1], &ts[0]);\n  } else {\n    min_waited_timestamp.store(SEQ_UNINIT);\n    mysql_mutex_unlock(&rli->mts_gaq_LOCK);\n  }\n  return rli->info_thd->killed || is_error;\n} \n```", "```cpp\nset global debug= 'd:T:t:i:o,/tmp/mysql.trace'; \n```"]