["```cpp\n[](#cb1-1)struct HeapItem {\n[](#cb1-2)    uint64_t val = 0;\n[](#cb1-3)    size_t *ref = NULL;\n[](#cb1-4)};\n[](#cb1-5)\n[](#cb1-6)// the structure for the key\n[](#cb1-7)struct Entry {\n[](#cb1-8)    struct HNode node;\n[](#cb1-9)    std::string  key;\n[](#cb1-10)    std::string  val;\n[](#cb1-11)    uint32_t type = 0;\n[](#cb1-12)    ZSet *zset = NULL;\n[](#cb1-13)    // for TTLs\n[](#cb1-14)    size_t heap_idx = -1;\n[](#cb1-15)};\n```", "```cpp\n[](#cb2-1)static size_t heap_parent(size_t i) {\n[](#cb2-2)    return (i + 1) / 2 - 1;\n[](#cb2-3)}\n[](#cb2-4)\n[](#cb2-5)static size_t heap_left(size_t i) {\n[](#cb2-6)    return i * 2 + 1;\n[](#cb2-7)}\n[](#cb2-8)\n[](#cb2-9)static size_t heap_right(size_t i) {\n[](#cb2-10)    return i * 2 + 2;\n[](#cb2-11)}\n```", "```cpp\n[](#cb3-1)static void heap_up(HeapItem *a, size_t pos) {\n[](#cb3-2)    HeapItem t = a[pos];\n[](#cb3-3)    while (pos > 0 && a[heap_parent(pos)].val > t.val) {\n[](#cb3-4)        // swap with the parent\n[](#cb3-5)        a[pos] = a[heap_parent(pos)];\n[](#cb3-6)        *a[pos].ref = pos;\n[](#cb3-7)        pos = heap_parent(pos);\n[](#cb3-8)    }\n[](#cb3-9)    a[pos] = t;\n[](#cb3-10)    *a[pos].ref = pos;\n[](#cb3-11)}\n```", "```cpp\n[](#cb4-1)static void heap_down(HeapItem *a, size_t pos, size_t len) {\n[](#cb4-2)    HeapItem t = a[pos];\n[](#cb4-3)    while (true) {\n[](#cb4-4)        // find the smallest one among the parent and their kids\n[](#cb4-5)        size_t l = heap_left(pos);\n[](#cb4-6)        size_t r = heap_right(pos);\n[](#cb4-7)        size_t min_pos = -1;\n[](#cb4-8)        size_t min_val = t.val;\n[](#cb4-9)        if (l < len && a[l].val < min_val) {\n[](#cb4-10)            min_pos = l;\n[](#cb4-11)            min_val = a[l].val;\n[](#cb4-12)        }\n[](#cb4-13)        if (r < len && a[r].val < min_val) {\n[](#cb4-14)            min_pos = r;\n[](#cb4-15)        }\n[](#cb4-16)        if (min_pos == (size_t)-1) {\n[](#cb4-17)            break;\n[](#cb4-18)        }\n[](#cb4-19)        // swap with the kid\n[](#cb4-20)        a[pos] = a[min_pos];\n[](#cb4-21)        *a[pos].ref = pos;\n[](#cb4-22)        pos = min_pos;\n[](#cb4-23)    }\n[](#cb4-24)    a[pos] = t;\n[](#cb4-25)    *a[pos].ref = pos;\n[](#cb4-26)}\n```", "```cpp\n[](#cb5-1)void heap_update(HeapItem *a, size_t pos, size_t len) {\n[](#cb5-2)    if (pos > 0 && a[heap_parent(pos)].val > a[pos].val) {\n[](#cb5-3)        heap_up(a, pos);\n[](#cb5-4)    } else {\n[](#cb5-5)        heap_down(a, pos, len);\n[](#cb5-6)    }\n[](#cb5-7)}\n```", "```cpp\n[](#cb6-1)// global variables\n[](#cb6-2)static struct {\n[](#cb6-3)    HMap db;\n[](#cb6-4)    // a map of all client connections, keyed by fd\n[](#cb6-5)    std::vector<Conn *> fd2conn;\n[](#cb6-6)    // timers for idle connections\n[](#cb6-7)    DList idle_list;\n[](#cb6-8)    // timers for TTLs\n[](#cb6-9)    std::vector<HeapItem> heap;\n[](#cb6-10)} g_data;\n```", "```cpp\n[](#cb7-1)// set or remove the TTL\n[](#cb7-2)static void entry_set_ttl(Entry *ent, int64_t ttl_ms) {\n[](#cb7-3)    if (ttl_ms < 0 && ent->heap_idx != (size_t)-1) {\n[](#cb7-4)        // erase an item from the heap\n[](#cb7-5)        // by replacing it with the last item in the array.\n[](#cb7-6)        size_t pos = ent->heap_idx;\n[](#cb7-7)        g_data.heap[pos] = g_data.heap.back();\n[](#cb7-8)        g_data.heap.pop_back();\n[](#cb7-9)        if (pos < g_data.heap.size()) {\n[](#cb7-10)            heap_update(g_data.heap.data(), pos, g_data.heap.size());\n[](#cb7-11)        }\n[](#cb7-12)        ent->heap_idx = -1;\n[](#cb7-13)    } else if (ttl_ms >= 0) {\n[](#cb7-14)        size_t pos = ent->heap_idx;\n[](#cb7-15)        if (pos == (size_t)-1) {\n[](#cb7-16)            // add an new item to the heap\n[](#cb7-17)            HeapItem item;\n[](#cb7-18)            item.ref = &ent->heap_idx;\n[](#cb7-19)            g_data.heap.push_back(item);\n[](#cb7-20)            pos = g_data.heap.size() - 1;\n[](#cb7-21)        }\n[](#cb7-22)        g_data.heap[pos].val = get_monotonic_usec() + (uint64_t)ttl_ms * 1000;\n[](#cb7-23)        heap_update(g_data.heap.data(), pos, g_data.heap.size());\n[](#cb7-24)    }\n[](#cb7-25)}\n```", "```cpp\n[](#cb8-1)static void entry_del(Entry *ent) {\n[](#cb8-2)    switch (ent->type) {\n[](#cb8-3)    case T_ZSET:\n[](#cb8-4)        zset_dispose(ent->zset);\n[](#cb8-5)        delete ent->zset;\n[](#cb8-6)        break;\n[](#cb8-7)    }\n[](#cb8-8)    entry_set_ttl(ent, -1);\n[](#cb8-9)    delete ent;\n[](#cb8-10)}\n```", "```cpp\n[](#cb9-1)static uint32_t next_timer_ms() {\n[](#cb9-2)    uint64_t now_us = get_monotonic_usec();\n[](#cb9-3)    uint64_t next_us = (uint64_t)-1;\n[](#cb9-4)\n[](#cb9-5)    // idle timers\n[](#cb9-6)    if (!dlist_empty(&g_data.idle_list)) {\n[](#cb9-7)        Conn *next = container_of(g_data.idle_list.next, Conn, idle_list);\n[](#cb9-8)        next_us = next->idle_start + k_idle_timeout_ms * 1000;\n[](#cb9-9)    }\n[](#cb9-10)\n[](#cb9-11)    // ttl timers\n[](#cb9-12)    if (!g_data.heap.empty() && g_data.heap[0].val < next_us) {\n[](#cb9-13)        next_us = g_data.heap[0].val;\n[](#cb9-14)    }\n[](#cb9-15)\n[](#cb9-16)    if (next_us == (uint64_t)-1) {\n[](#cb9-17)        return 10000;   // no timer, the value doesn't matter\n[](#cb9-18)    }\n[](#cb9-19)\n[](#cb9-20)    if (next_us <= now_us) {\n[](#cb9-21)        // missed?\n[](#cb9-22)        return 0;\n[](#cb9-23)    }\n[](#cb9-24)    return (uint32_t)((next_us - now_us) / 1000);\n[](#cb9-25)}\n```", "```cpp\n[](#cb10-1)static void process_timers() {\n[](#cb10-2)    // the extra 1000us is for the ms resolution of poll()\n[](#cb10-3)    uint64_t now_us = get_monotonic_usec() + 1000;\n[](#cb10-4)\n[](#cb10-5)    // idle timers\n[](#cb10-6)    while (!dlist_empty(&g_data.idle_list)) {\n[](#cb10-7)        // code omitted...\n[](#cb10-8)    }\n[](#cb10-9)\n[](#cb10-10)    // TTL timers\n[](#cb10-11)    const size_t k_max_works = 2000;\n[](#cb10-12)    size_t nworks = 0;\n[](#cb10-13)    while (!g_data.heap.empty() && g_data.heap[0].val < now_us) {\n[](#cb10-14)        Entry *ent = container_of(g_data.heap[0].ref, Entry, heap_idx);\n[](#cb10-15)        HNode *node = hm_pop(&g_data.db, &ent->node, &hnode_same);\n[](#cb10-16)        assert(node == &ent->node);\n[](#cb10-17)        entry_del(ent);\n[](#cb10-18)        if (nworks++ >= k_max_works) {\n[](#cb10-19)            // don't stall the server if too many keys are expiring at once\n[](#cb10-20)            break;\n[](#cb10-21)        }\n[](#cb10-22)    }\n[](#cb10-23)}\n```", "```cpp\n[](#cb11-1)static void do_expire(std::vector<std::string> &cmd, std::string &out) {\n[](#cb11-2)    int64_t ttl_ms = 0;\n[](#cb11-3)    if (!str2int(cmd[2], ttl_ms)) {\n[](#cb11-4)        return out_err(out, ERR_ARG, \"expect int64\");\n[](#cb11-5)    }\n[](#cb11-6)\n[](#cb11-7)    Entry key;\n[](#cb11-8)    key.key.swap(cmd[1]);\n[](#cb11-9)    key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());\n[](#cb11-10)\n[](#cb11-11)    HNode *node = hm_lookup(&g_data.db, &key.node, &entry_eq);\n[](#cb11-12)    if (node) {\n[](#cb11-13)        Entry *ent = container_of(node, Entry, node);\n[](#cb11-14)        entry_set_ttl(ent, ttl_ms);\n[](#cb11-15)    }\n[](#cb11-16)    return out_int(out, node ? 1: 0);\n[](#cb11-17)}\n```", "```cpp\n[](#cb12-1)static void do_ttl(std::vector<std::string> &cmd, std::string &out) {\n[](#cb12-2)    Entry key;\n[](#cb12-3)    key.key.swap(cmd[1]);\n[](#cb12-4)    key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());\n[](#cb12-5)\n[](#cb12-6)    HNode *node = hm_lookup(&g_data.db, &key.node, &entry_eq);\n[](#cb12-7)    if (!node) {\n[](#cb12-8)        return out_int(out, -2);\n[](#cb12-9)    }\n[](#cb12-10)\n[](#cb12-11)    Entry *ent = container_of(node, Entry, node);\n[](#cb12-12)    if (ent->heap_idx == (size_t)-1) {\n[](#cb12-13)        return out_int(out, -1);\n[](#cb12-14)    }\n[](#cb12-15)\n[](#cb12-16)    uint64_t expire_at = g_data.heap[ent->heap_idx].val;\n[](#cb12-17)    uint64_t now_us = get_monotonic_usec();\n[](#cb12-18)    return out_int(out, expire_at > now_us ? (expire_at - now_us) / 1000 : 0);\n[](#cb12-19)}\n```"]