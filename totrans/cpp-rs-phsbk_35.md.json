["```rs\n#include <iostream>\n\nint process(int n) {\n  std::cout << n << std::endl;\n  return 2 * n;\n}\n\nint main() {\n  auto f = process;\n  // or with type annotation\n  // int (*f)(int) = process;\n\n  std::cout << f(42) << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n\nint main() {\n  int (*f)(int) = [](int n) {\n    std::cout << n << std::endl;\n    return 2 * n;\n  };\n\n  std::cout << f(42) << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"hi\");\n  auto f = [x = std::move(x)]() mutable {\n    return std::move(x);\n  };\n\n  std::cout << f() << std::endl;\n  // compiles, but the captured value has been\n  // moved\n  std::cout << f() << std::endl; // prints \"\"\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <string>\n\nint main() {\n  std::string x(\"\");\n  auto f = [x = std::move(x)]() mutable {\n    x.push_back('!');\n    return x.size();\n  };\n\n  std::cout << f() << std::endl; // prints \"1\"\n  std::cout << f() << std::endl; // prints \"2\"\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"\");\n  auto f = [&x]() {\n    x.push_back('!');\n    return x.size();\n  };\n\n  std::cout << f() << std::endl; // prints \"1\"\n  std::cout << f() << std::endl; // prints \"2\"\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"\");\n  auto f = [&x]() { return x.size(); };\n\n  std::cout << f() << std::endl; // prints \"0\"\n  std::cout << f() << std::endl; // prints \"0\"\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <sstream>\n#include <string>\n\nint main() {\n  std::string greeting = \"hello\";\n  // Can't write the type of the closure\n  auto sayHelloTo = [&](std::string &who) {\n    std::ostringstream out;\n    out << greeting << \" \" << who;\n    return out.str();\n  };\n\n  std::string world(\"world\");\n  std::string moon(\"moon\");\n\n  std::cout << sayHelloTo(world) << std::endl;\n  std::cout << sayHelloTo(moon) << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <functional>\n#include <iostream>\n#include <sstream>\n#include <string>\n\nint main() {\n  std::string greeting = \"hello\";\n  // Can't write the type of the closure\n  std::function<std::string(std::string &)>\n      sayHelloTo([&](std::string &who) {\n        std::ostringstream out;\n        out << greeting << \" \" << who;\n        return out.str();\n      });\n\n  std::string world(\"world\");\n  std::string moon(\"moon\");\n\n  std::cout << sayHelloTo(world) << std::endl;\n  std::cout << sayHelloTo(moon) << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <memory>\n#include <string>\n\n// The common interface\nstruct Debug {\n  virtual std::ostream &\n  emit(std::ostream &out) const = 0;\n};\n\nstd::ostream &operator<<(std::ostream &out,\n                         const Debug &d) {\n  d.emit(out);\n  return out;\n}\n\n// Two things that implement the interface\nstruct A : public Debug {\n  std::ostream &\n  emit(std::ostream &out) const override {\n    out << \"A\";\n    return out;\n  }\n};\n\nstruct B : public Debug {\n  std::ostream &\n  emit(std::ostream &out) const override {\n    out << \"B\";\n    return out;\n  }\n};\n\nint main() {\n  // Without the return-type annotation,\n  // std::unique_ptr<A> would be inferred.\n  auto f = [](std::unique_ptr<A> a,\n              std::unique_ptr<B> b)\n      -> std::unique_ptr<Debug> { return a; };\n  std::cout << *f(std::make_unique<A>(),\n                  std::make_unique<B>())\n            << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"hello world\");\n  std::string y(\"goodnight moon\");\n\n  auto f = [&]() {\n    std::cout << x << std::endl;\n    std::cout << y << std::endl;\n  };\n\n  // x and y borrowed by f, but still available\n  std::cout << x << std::endl;\n  std::cout << y << std::endl;\n\n  f();\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"hello world\");\n  std::string y(\"goodnight moon\");\n\n  auto f = [&]() {\n    x.push_back('!');\n    y.push_back('!');\n  };\n\n  // x and y borrowed by mutably f, but still\n  // available anyway\n  std::cout << x << std::endl;\n  std::cout << y << std::endl;\n\n  f();\n\n  std::cout << x << std::endl;\n  std::cout << y << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"hello world\");\n  std::string y(\"goodnight moon\");\n\n  auto f = [=]() mutable {\n    x.push_back('!');\n    y.push_back('!');\n  };\n\n  // copies of x and y owned by f, originals\n  // still available\n  std::cout << x << std::endl;\n  std::cout << y << std::endl;\n\n  f();\n\n  // still don't have the !, since the copies\n  // were modified not the originals\n  std::cout << x << std::endl;\n  std::cout << y << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"hello world\");\n  std::string y(\"goodnight moon\");\n\n  auto f = [x = std::move(x),\n            y = std::move(y)]() {\n    std::cout << x << std::endl;\n    std::cout << y << std::endl;\n  };\n\n  // x and y moved into f,\n  // empty strings left behind.\n  std::cout << x << std::endl;\n  std::cout << y << std::endl;\n\n  f();\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string x(\"hello world\");\n  std::string y(\"goodnight moon\");\n\n  auto f = [x = std::move(x), &y]() mutable {\n    x.push_back('!');\n    std::cout << x << std::endl;\n    std::cout << y << std::endl;\n  };\n\n  // x moved into f, y borrowed by f\n  std::cout << x << std::endl;\n  std::cout << y << std::endl;\n\n  f();\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cstddef>\n#include <iostream>\n#include <string>\n\nstruct MyClosure {\n  std::string msg;\n\n  std::size_t operator()() {\n    std::cout << msg << std::endl;\n    return msg.size();\n  }\n};\n\nint main() {\n  MyClosure myClosure{\"hello world\"};\n  myClosure();\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cassert>\n#include <functional>\n#include <iostream>\n\nstruct Interface {\n  virtual void showVirtual() = 0;\n};\n\nstruct A : public Interface {\n  void show() {\n    std::cout << \"A\" << std::endl;\n  }\n\n  void showVirtual() override {\n    std::cout << \"A\" << std::endl;\n  }\n};\n\nstruct B : public Interface {\n  void showVirtual() override {\n    std::cout << \"B\" << std::endl;\n  }\n\n  void show() {\n    std::cout << \"B\" << std::endl;\n  }\n};\n\nint main() {\n  auto showV = &Interface::showVirtual;\n  auto showA = &A::show;\n  auto showB = &B::show;\n\n  A a;\n  B b;\n\n  (a.*showV)(); // prints A\n  (b.*showV)(); // prints B\n\n  (a.*showA)(); // prints A\n  (b.*showB)(); // prints B\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n\nint apply_to_0(auto f) {\n  return f(0);\n}\n\nint main() {\n  int x = 1;\n  auto f([=](int n) { return n + x; });\n  std::cout << apply_to_0(f) << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <functional>\n#include <iostream>\n\nint apply_to_0(std::function<int(int)> f) {\n  return f(0);\n}\n\nint main() {\n  int x = 1;\n  // closure is on heap\n  auto f(std::function(\n      [=](int n) { return n + x; }));\n  std::cout << apply_to_0(f) << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <iostream>\n\ndecltype(auto) makeConst(int n) {\n  return [n]() { return n; };\n}\n\nint main() {\n  auto f = makeConst(42);\n  std::cout << f() << std::endl;\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\n\n```", "```rs\ndecltype(auto) makeClosure(int n) {\n  return [n]() { return [n]() { return n; }; };\n} \n```", "```rs\n// Does not compile: not yet supported\nfn make_closure(\n    n: i32,\n) -> impl Fn() -> impl Fn() -> i32 {\n    move || move || n\n}\n```", "```rs\n#include <string>\n\nint main() {\n  int n = 0;\n\n  auto idCounter = [&]<typename T>(T x) {\n    n++;\n    return x;\n  };\n\n  int y = idCounter(5);\n  std::string z =\n      idCounter.template operator()<std::string>(std::string(\"hi\"));\n} \n```", "```rs\n#include <string>\n\nint main() {\n  auto id = []<typename T>(T x) { return x; };\n  int y = id(5);\n  std::string z = id(std::string(\"hi\"));\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\n#include <cassert>\n#include <functional>\n\nint add(int x, int y) {\n  return x + y;\n}\n\nint main() {\n  using namespace std::placeholders;\n\n  auto addTen = std::bind(add, 10, _1);\n  assert(42 == addTen(32));\n} \n```", "```rs\n\n```", "```rs\n\n```", "```rs\nuse partial_application::*;\n\nfn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nfn main() {\n    let add_ten = partial!(move add => 10, _);\n\n    assert_eq!(42, add_ten(32));\n}\n```", "```rs\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string msg(\"hello world\");\n  auto f = [=]() -> const std::string & {\n    return msg;\n  };\n  std::cout << f() << std::endl;\n} \n```", "```rs\nfn main() {\n    let msg = String::from(\"hello world\");\n    // fails to compile!\n    let f = move || &msg;\n\n    println!(\"{}\", f());\n}\n```", "```rs\n\n```", "```rs\n\n```", "```rs\nfn main() {\n    let greeting = \"hello \".to_string();\n\n    // Can't write the type of the closure\n    let say_hello_to = move |who: &str| {\n        greeting + who\n    };\n\n    println!(\"{}\", say_hello_to(\"world\"));\n    println!(\"{}\", say_hello_to(\"moon\"));\n}\n```", "```rs\nerror[E0382]: use of moved value: `say_hello_to`\n --> example.rs:9:20\n  |\n8 |     println!(\"{}\", say_hello_to(\"world\"));\n  |                    --------------------- `say_hello_to` moved due to this call\n9 |     println!(\"{}\", say_hello_to(\"moon\"));\n  |                    ^^^^^^^^^^^^ value used here after move\n  |\nnote: closure cannot be invoked more than once because it moves the variable `greeting` out of its environment\n --> example.rs:6:26\n  |\n6 |         move |who: &str| greeting + who;\n  |                          ^^^^^^^^\nnote: this value implements `FnOnce`, which causes it to be moved when called\n --> example.rs:8:20\n  |\n8 |     println!(\"{}\", say_hello_to(\"world\"));\n  | \n```", "```rs\n\n```", "```rs\n\n```"]