- en: Lambdas, closures, and function objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/closures.html](https://cel.cs.brown.edu/crp/idioms/closures.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Function pointers](#function-pointers)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both C++ and Rust permit the use of functions as values. In both, the values
    can have [function pointer types](https://doc.rust-lang.org/std/primitive.fn.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'fn process(n: i32) -> i32 {'
  prefs: []
  type: TYPE_NORMAL
- en: println!("{}", n);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2 * n
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let f = process;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // or with type annotation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// let f: fn(i32) -> i32 = process;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f(42));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Non-capturing closures are also convertible function pointers in both C++ and
    Rust. In the following example the type could be inferred in both C++ and Rust,
    but the type is explicitly given to demonstrate that in both cases the closure
    has a function pointer type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let f = |n: i32| {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", n);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 2 * n
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // or with type annotation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// let f: fn(i32) -> i32 = process;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f(42));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in C++, in Rust functions can be defined within other functions. This
    has the same meaning as defining the functions outside of the function (i.e.,
    the function is not a capturing closure and so cannot capture variables defined
    in the outer function), but the name of the function is only available within
    the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'fn process(n: i32) -> i32 {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", n);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 2 * n
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", process(42));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Rust''s call operator traits](#rusts-call-operator-traits)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, any class can implement the call operator method `operator()` and be
    a function object. Closures defined by lambdas do so automatically. In Rust the
    equivalent are the call operator traits.
  prefs: []
  type: TYPE_NORMAL
- en: '| Trait | Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`FnOnce<Args>`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html) | `fn
    call_once(self, args: Args) -> Self::Output` | Can be called at most once |'
  prefs: []
  type: TYPE_TB
- en: '| [`FnMut<Args>`](https://doc.rust-lang.org/std/ops/trait.FnMut.html) | `fn
    call_mut(&mut self, args: Args) -> Self::Output` | Can be called multiple times
    and may mutate captures (like the `mutable` specifier in C++) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Fn<Args>`](https://doc.rust-lang.org/std/ops/trait.Fn.html) | `fn call(&self,
    args: Args) -> Self::Output` | Can be called multiple times and do not mutate
    captures |'
  prefs: []
  type: TYPE_TB
- en: Rust function pointers implement all three traits. Other closures implement
    the traits depending on how they use the captured variables.
  prefs: []
  type: TYPE_NORMAL
- en: <details><summary>Closure implementing only `FnOnce`</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let f = {
  prefs: []
  type: TYPE_NORMAL
- en: let x = String::from("hi");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// f : FnOnce()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: move || x
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // f() is equivalent to f.call_once()
  prefs: []
  type: TYPE_NORMAL
- en: println!("{}", f()); // prints "hi"
  prefs: []
  type: TYPE_NORMAL
- en: // Won't compile--call_once consumes f.
  prefs: []
  type: TYPE_NORMAL
- en: // println!("{}", f());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]</details>  <details><summary>Closure implementing `FnMut` and taking
    ownership of the capture</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut f = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut x = String::from("");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '// f : FnMut() -> usize'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: move || {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: x.push('!');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: x.len()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f()); // prints "1"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f()); // prints "2"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]</details>  <details><summary>Closure implementing `FnMut` and capturing
    by mutable reference</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `x` has to be alive as long as the closure might be used, since
    the closure borrows `x`. Therefore, `x` can't be declared in a block with the
    lambda like in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut x = String::from("");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// g : FnMut() -> usize'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut f = || {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x.push('!');
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: x.len()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f()); // prints "1"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f()); // prints "2"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]</details>  <details><summary>Closure implementing `Fn`</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: Whether `x` is `mut` or not doesn't affect whether the closure implements `Fn`
    or `FnMut`. What matters is how `x` is used by the closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let f = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let x = String::from("");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '// g : Fn() -> usize'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: move || x.len()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f()); // prints "0"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f()); // prints "0"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lambdas and closures](#lambdas-and-closures)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In neither C++ nor Rust can the concrete type of a capturing closure be written.
    In both languages, for local variables this means that the type must be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let greeting = "hello";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Can't write the type of the closure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let say_hello_to = |who: &str| {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: format!("{} {}", greeting, who)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say_hello_to("world"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say_hello_to("moon"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In both C++ and Rust if the closure is heap-allocated a type can be given. In
    C++ this is done using `std::function` while in Rust it again is done with the
    call operator traits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let greeting = "hello";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Can't write the type of the closure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let say_hello_to: Box<'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dyn Fn(&str) -> String,
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '= Box::new(|who: &str| {'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: format!("{} {}", greeting, who)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say_hello_to("world"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say_hello_to("moon"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Since `std::function` can be empty the above example isn't strictly equivalent.
    However, since `std::function` is often used with the side condition that the
    value not be empty, the `Box` without an `Option` wrapper for representing the
    empty case is the more practical translation.
  prefs: []
  type: TYPE_NORMAL
- en: A type can also be given in terms of one of the function operator traits for
    references to closures in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let greeting = "hello";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Can't write the type of the closure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let say_hello_to = |who: &str| {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: format!("{} {}", greeting, who)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let say: &dyn Fn(&str) -> String = &say_hello_to;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say("world"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say("moon"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, in both C++ and Rust, the return type of the closure can be annotated
    as part of the lambda expression. This is useful when the return type either cannot
    be inferred or should be less specific than what would be inferred. In the following
    example this is used to return a value in terms of an interface it implements
    instead of the concrete type that would otherwise be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: // The common interface
  prefs: []
  type: TYPE_NORMAL
- en: use std::fmt::Debug;
  prefs: []
  type: TYPE_NORMAL
- en: // Two things that implement the interface
  prefs: []
  type: TYPE_NORMAL
- en: '#[derive(Debug)]'
  prefs: []
  type: TYPE_NORMAL
- en: struct A;
  prefs: []
  type: TYPE_NORMAL
- en: '#[derive(Debug)]'
  prefs: []
  type: TYPE_NORMAL
- en: struct B;
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Without the return type annotation,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Box<A> would be inferred.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let f = move |a: Box<A>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b: Box<B>|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> Box<dyn Debug> { a };
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{:?}", f(Box::new(A), Box::new(B)));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[Capturing variables](#capturing-variables)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, capture specifiers are used to indicate whether a variable should be
    captured by reference, by copy, or by move. The capture specifiers can be given
    for all of the variables at once, for each variable, or given as a default along
    with specific choices for each variable.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, the variables are captured either all by reference (by default) or
    all by move (using a `move` specifier). In order to express other capture strategies,
    the references and copies need to be explicitly defined and the closure needs
    to capture those variables instead.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing the pattern of explicitly making copies or taking references leverages
    the fact that in Rust blocks are expressions. In the examples that need to do
    that, notice the lack of a semicolon in the last statement of the block that is
    being assigned to the variable to hold the closure.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples show examples of different patterns of capturing variables
    in C++ and their analogs in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: <details><summary>Capture `x` and `y` by reference</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let x = String::from("hello world");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let y = String::from("goodnight moon");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let f = || {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", x);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // x and y borrowed by f, but still available
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", x);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]</details>  <details><summary>Capture `x` and `y` by mutable reference</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: The C++ version is same as when capturing by mutable reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut x = String::from("hello world");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut y = String::from("goodnight moon");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // f needs to be mut because it mutates
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // its captured variables
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut f = || {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x.push('!');
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: y.push('!');
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // x and y borrowed mutably by f, and so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // can't be used here
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // println!("{}", x);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // println!("{}", y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", x);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]</details>  <details><summary>Copy `x` and `y` to capture by value</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: In C++ this requires that the lambda have the `mutable` specifier. In Rust this
    requires
  prefs: []
  type: TYPE_NORMAL
- en: making a copy of the values for the closure to capture,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: marking those copy as mutable with `mut`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: marking the closure itself as mutable with `mut`, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using the `move` specifier to move ownership of the copies into the closure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types that indicate they are [trivially copyable by implementing the `Copy`
    trait](constructors/copy_and_move_constructors.html#trivially-copyable-types)
    do not need to be explicitly cloned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let x = String::from("hello world");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let y = String::from("goodnight moon");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut f = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Shadow outer variables with copies.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // This needs to happen outside of the
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // closure expression.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut x = x.clone();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut y = y.clone();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: move || {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: x.push('!');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: y.push('!');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // clones of x and y owned by f, originals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // still available
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", x);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // still don't have the !, since the copies
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // were modified not the originals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", x);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]</details>  <details><summary>Move `x` and `y` to capture by value</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let x = String::from("hello world");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let y = String::from("goodnight moon");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // captures x and y by value
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let f = move || {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", x);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // x and y moved into f,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // original variables cannot be used
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // println!("{}", x);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // println!("{}", y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]</details>  <details><summary>Move `x` to capture by value, capture
    `y` by reference</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let mut x = String::from("hello world");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let y = String::from("goodnight moon");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut f = {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let y = &y;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // Actually captures both x and y by
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // value, but y is a reference
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: move || {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: x.push('!');
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", x);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // x moved into f, y borrowed by f
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // println!("{}", x);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Function objects](#function-objects)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike in C++, in Rust only functions and closures implement the function call
    operator traits. The ability to directly implement the traits is [not yet part
    of stable Rust](https://github.com/rust-lang/rust/issues/29625).
  prefs: []
  type: TYPE_NORMAL
- en: Instead, one can implement a [conversion function](./user-defined_conversions.html).
    The standard conversion traits `From` and `Into` cannot be implemented for this
    purpose, however, because the `impl Trait` syntax cannot be used in trait implementations.^([1](#footnote-impl-trait-impl))
    Instead a separate method must be defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: struct MyClosure {
  prefs: []
  type: TYPE_NORMAL
- en: 'msg: String,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl MyClosure {
  prefs: []
  type: TYPE_NORMAL
- en: fn as_fn(&self) -> impl Fn() -> usize {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: move || {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", self.msg);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.msg.len()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let my_closure = MyClosure {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'msg: String::from("hello world"),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let f = my_closure.as_fn();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In Rust editions earlier than 2024, the above example requires a precise capturing
    annotation using the [`use<'a>` syntax](https://doc.rust-lang.org/std/keyword.use.html#precise-capturing)
    to specify that the returned closure borrows from the parameters, since otherwise
    a lifetime bound is not inferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[Member functions as function pointers](#member-functions-as-function-pointers)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, pointers to member functions can be invoked with the `.*` operator or
    can be converted to `std::function` values using `std::mem_fn`, enabling them
    to be used in the same way as other `std::function` values. When called on a derived
    class, whether the method whose address was taken or the overriding method in
    the derived class is called depends on whether the method is defined as virtual.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust pointers to member functions are normal function pointers. For example,
    a method on a type `T` with a `&self` parameter is a function whose first argument
    has type `&T`. When the method is named via a trait, then the first argument of
    the function has type `&dyn T` with a lifetime bound. Determining whether vtables
    are involved in the use of a pointer to a member function is determined at the
    time that the method is referenced, rather than when the method is defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: trait Interface {
  prefs: []
  type: TYPE_NORMAL
- en: fn show(&self);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: struct A;
  prefs: []
  type: TYPE_NORMAL
- en: impl Interface for A {
  prefs: []
  type: TYPE_NORMAL
- en: fn show(&self) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("A");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: struct B;
  prefs: []
  type: TYPE_NORMAL
- en: impl Interface for B {
  prefs: []
  type: TYPE_NORMAL
- en: fn show(&self) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("B");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: // types could be inferred, but given to show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // that they are just a function pointers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let show_a: fn(&A) = A::show;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let show_b: fn(&B) = B::show;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let show_v: fn(&(dyn Interface + ''static)) ='
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Interface::show;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: show_a(&A); // prints A
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: show_b(&B); // prints B
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: show_v(&A); // prints A
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: show_v(&B); // prints B
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[Closures as parameters](#closures-as-parameters)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In both C++ and Rust, unboxed closures can be accepted as parameters. Just as
    using `auto` as the type of a parameter in C++ makes the function actually a function
    template, using `impl Trait` as the type of a parameter in Rust makes the function
    generic. [The resulting generic function is checked statically, just like it would
    be if the type parameter and bound were given explicitly.](data_modeling/concepts.html#templates-vs-generic-functions)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'fn apply_to_0(f: impl FnOnce(i32) -> i32) -> i32 {'
  prefs: []
  type: TYPE_NORMAL
- en: f(0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let x = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let f = move |n: i32| x + n;'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", apply_to_0(&f));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When accepting closures as type parameters in Rust, it is best practice to specify
    the type as the the least restrictive interface required for how the closure will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using `FnOnce` as the bound is the least restrictive, and so should be used
    so that the function accepting a closure as a parameter is as compatible with
    as many closures as possible . `FnOnce` works with `Fn` and `FnMut` because there
    are `FnOnce` trait implementations for `&Fn` and `&FnMut`. The `FnMut` trait is
    the next most restrictive, followed by `Fn`, and then actual function pointers,
    whose types are written with a lowercase `fn`.
  prefs: []
  type: TYPE_NORMAL
- en: In both C++ and Rust, it is also possible to pass references or pointers to
    closures. In the following example, the closure is in dynamically allocated storage
    in both C++ and in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'fn apply_to_0(f: Box<dyn FnOnce(i32) -> i32>) -> i32 {'
  prefs: []
  type: TYPE_NORMAL
- en: f(0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let x = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let f = Box::new(move |n: i32| x + n);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", apply_to_0(f));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`FnOnce` can be called when in a `Box`, because the box owns the trait object,
    but not when in a reference which doesn''t. `Fn` and `FnMut` do not have the same
    restriction.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Returning closures](#returning-closures)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, `auto` or `decltype(auto)` can be used as the return type for a function
    returning a closure. In Rust, once again the `impl Trait` syntax can be used.
    Just as how in C++ using `auto` in this way does not denote an abbreviated function
    template, it does not denote a generic function in Rust. Instead the type is inferred,
    and must satisfy the trait.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'fn make_const(n: i32) -> impl Fn() -> i32 {'
  prefs: []
  type: TYPE_NORMAL
- en: move || n
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let f = make_const(42);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In places in C++ where `decltype` is used to name the closure, e.g., when returning
    a closure in a template class, in Rust the `impl Trait` syntax is used. If a type
    needs to be given in a let binding, then an underscore `_` can be used to indicate
    that the part of the type that is the closure's type should be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: struct Wrapper<T>(T);
  prefs: []
  type: TYPE_NORMAL
- en: fn make_closure() -> Wrapper<impl Fn(i32) -> i32>
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: let x = 1;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Wrapper(move |n: i32| x + n)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'let w: Wrapper<_> = make_closure();'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: w.0(0);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There are several other places where `decltype` works but `impl Trait` does
    not yet, such as [the output type for `Fn` traits](https://github.com/rust-lang/rust/issues/99697).
    This means that one can define closures that return closures in Rust, but cannot
    give them a type, and therefore cannot return them from functions. The following
    compiles in C++ but fails to compile in Rust for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[Template lambdas](#template-lambdas)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust does not support generic closures. Thus, the following has no equivalent
    in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: However, if the lambda doesn't capture anything, it is possible to write the
    following equivalent in Rust, by using an inner function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: 'fn id<T>(x: T) -> T {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id(5);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id(String::from("hi"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[Partial application and `std::bind`](#partial-application-and-stdbind)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no equivalent to the C++ template `std::bind` in the Rust standard
    library. The idiomatic way to express partial application in Rust is to write
    out the lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'fn add(x: i32, y: i32) -> i32 {'
  prefs: []
  type: TYPE_NORMAL
- en: x + y
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let add_ten = move |y| add(10, y);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert_eq!(42, add_ten(32));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The third-party crate [partial_application](https://docs.rs/partial_application/latest/partial_application/)
    provides something akin to `std::bind` using Rust macros.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[Returning references to captured variables](#returning-references-to-captured-variables)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rust it is not possible to have a closure return a reference to a captured
    variable. This is due to a limitation with how the `Fn` family of traits are defined:
    `Fn::Output` does not have a way to express a lifetime bound.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The workarounds to this limitation in Rust involve either heap-allocating and
    using a shared pointer `Rc`, or defining a new trait instead of using one of the
    `Fn` traits. The following example shows a trait that uses [generic associated
    types](https://doc.rust-lang.org/reference/items/associated-items.html#r-items.associated.type.generic)
    to define a generalized `Fn` trait. In practice, however, it is usually better
    either to define a custom trait for each use case or to elide the trait entirely
    if a single struct is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: trait Closure<Args> {
  prefs: []
  type: TYPE_NORMAL
- en: // The lifetime parameter enables expressing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // the bound.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type Output<'a>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Self: ''a;'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // The bound from self can then be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // provided to Output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fn call<'a>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&''a self,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'args: Args,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Self::Output<'a>;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: struct MyClosure {
  prefs: []
  type: TYPE_NORMAL
- en: 'msg: String,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Closure<()> for MyClosure {
  prefs: []
  type: TYPE_NORMAL
- en: type Output<'a> = &'a str;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fn call(&self, _: ()) -> &str {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&self.msg'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let f = MyClosure {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'msg: String::from("hello world"),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", f.call(()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[Closures, ownership, and `FnOnce`](#closures-ownership-and-fnonce)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closures are a part of Rust where the borrow checker is likely to cause frustration
    for a C++ programmer. This is usually not because of lifetimes, which have to
    be similarly considered in C++, but rather because C++ defaults to copy semantics
    while Rust defaults to move semantics. For example, this small adjustment to one
    of the earlier examples fails to compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This fails to compile because the `+` operator takes ownership of `greeting`,
    which makes it no longer accessible for later invocations. Because of this, the
    closure only implements `FnOnce`, not `Fn`, and therefore can only be called once,
    because the call takes ownership of the closure itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In many cases like this, the answer is to clone the value so that the copy owned
    by the closure can be retained for future invocations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let greeting = "hello ".to_string();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Can't write the type of the closure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let say_hello_to = move |who: &str| {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: greeting.clone() + who
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say_hello_to("world"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: println!("{}", say_hello_to("moon"));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: If cloning isn't desired because it is too expensive, then the closure needs
    to be redesigned to avoid giving away ownership of its captured variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[Documentation best practices](#documentation-best-practices)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ often recommended to explicitly list captures in a lambda expression, especially
    in situations where a closure will outlive its context. The purpose of this is
    to assist in reasoning about the lifetimes of the captures to ensure that the
    closure does not outlive any of the objects it has captured.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, the same decisions about captures with respect to lifetimes have to
    be made, but the compiler tracks them instead of having to do the reasoning manually.
    That is, in spite of the type of the closure not being expressible, it does still
    include the lifetimes of variables captured by reference, and so is checked the
    same way that any other structure would be.
  prefs: []
  type: TYPE_NORMAL
- en: This results in the best practices for documenting closures in Rust not including
    enumerating captures, even in situations where one would do so in C++.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true about the destructibility of the content of the captures in
    a closure. The example involving `FnOnce` functions in [the previous section](#closures-ownership-and-fnonce)
    may be a point of frustration initially, but the behavior has the benefit of reducing
    the documentation and reasoning burdens.
  prefs: []
  type: TYPE_NORMAL
- en: <link rel="stylesheet" type="text/css" href="../quiz/style.css">
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: That is, one can write neither `impl From<&MyClosure> for impl Fn() -> usize
    {...}` nor `impl Into<impl Fn() -> usize> for &MyClosure {...}`. [↩](#fr-impl-trait-impl-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Click here to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Lambdas,
    closures, and function objects)'
  prefs: []
  type: TYPE_NORMAL
