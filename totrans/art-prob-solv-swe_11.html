<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better</h1>
<blockquote>原文：<a href="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/Chapter7.html">https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/Chapter7.html</a></blockquote>
      
      
      

      <h1 id="chapter-7-key-improvements-of-mysql-80-over-mysql-57">Chapter 7: Key Improvements of MySQL 8.0 Over MySQL 5.7</h1>

<p>MySQL 8.0 has introduced substantial improvements over MySQL 5.7. It not only enhances functionality and adds support for hash joins in execution plans but, more importantly, greatly improves scalability. These advancements lay a solid foundation for future improvements.</p>

<h2 id="71-scaling-up-innodb-improvements">7.1 Scaling Up: InnoDB Improvements</h2>

<p>Early open-source DBMS code often used a coarse-grained latch for the entire kernel. In contrast, InnoDB has adopted a more refined approach, employing separate latches for different kernel components, such as the lock manager and buffer pool [19].</p>

<p>MySQL 8.0 introduced additional improvements to enhance the scalability of the InnoDB storage engine. Here are the related improvements:</p>

<ol>
  <li><strong>Redo Log Optimization:</strong> Enhancements to the redo log have facilitated subsequent performance improvements.</li>
  <li><strong>Lock-sys Latch Sharding:</strong> The lock-sys latch has been sharded, akin to read-write locks, to improve transactional locking.</li>
  <li><strong>Trx-sys Latch Splitting and Sharding:</strong> While contention for latches persists, optimizations in trx-sys lay a strong foundation for future improvements in MVCC ReadView.</li>
</ol>

<p>These significant scalability improvements will be discussed in detail below.</p>

<h3 id="711-redo-log-optimization">7.1.1 Redo Log Optimization</h3>

<p>Write-ahead logging is a fundamental, omnipresent component in ARIES-style concurrency and recovery, and it represents a significant potential bottleneck, especially in OLTP workloads making frequent small changes to data. Two logging-related impediments to database system scalability are identified, each challenging different levels of the software architecture [3]:</p>

<ol>
  <li>The high volume of small-sized I/O requests may saturate the disk.</li>
  <li>Contention arises as transactions serialize access to in-memory log data structures.</li>
</ol>

<p>The above potential bottlenecks are reflected in MySQL 5.7. Detailed information on redo log optimization can be found in “<em>MySQL 8.0: New Lock-Free, Scalable WAL Design</em>”, where the complexity lies in how the sequential order of Log Sequence Numbers (LSN) is ensured in the new design. The article also highlights the following improvements [27]:</p>

<p><em>We have introduced dedicated threads for particular tasks related to the redo log writes. User threads no longer do writes to the redo files themselves. They simply wait when they need redo flushed to disk and it is not flushed yet.</em></p>

<p>This improvement completely changed the previous mechanism and laid a solid foundation for scalability. The following git log details the specific optimizations made to the redo log.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">commit</span> <span class="mi">6</span><span class="n">be2fa0bdbbadc52cc8478b52b69db02b0eaff40</span>
<span class="n">Author</span><span class="o">:</span> <span class="n">Pawe</span><span class="err">ł</span> <span class="n">Olchawa</span> <span class="o">&lt;</span><span class="n">pawel</span><span class="p">.</span><span class="n">olchawa</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="o">:</span>   <span class="n">Wed</span> <span class="n">Feb</span> <span class="mi">14</span> <span class="mi">09</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span><span class="mi">42</span> <span class="mi">2018</span> <span class="o">+</span><span class="mo">0100</span>

    <span class="n">WL</span><span class="err">#</span><span class="mi">10310</span> <span class="n">Redo</span> <span class="n">log</span> <span class="n">optimization</span><span class="o">:</span> <span class="n">dedicated</span> <span class="n">threads</span> <span class="n">and</span> <span class="n">concurrent</span> <span class="n">log</span> <span class="n">buffer</span><span class="p">.</span>

    <span class="mf">0.</span> <span class="n">Log</span> <span class="n">buffer</span> <span class="n">became</span> <span class="n">a</span> <span class="n">ring</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">data</span> <span class="n">inside</span> <span class="n">is</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">shifted</span><span class="p">.</span>
    <span class="mf">1.</span> <span class="n">User</span> <span class="n">threads</span> <span class="n">are</span> <span class="n">able</span> <span class="n">to</span> <span class="n">write</span> <span class="n">concurrently</span> <span class="n">to</span> <span class="n">log</span> <span class="n">buffer</span><span class="p">.</span> 
    <span class="mf">2.</span> <span class="n">Relaxed</span> <span class="n">order</span> <span class="n">of</span> <span class="n">dirty</span> <span class="n">pages</span> <span class="n">in</span> <span class="n">flush</span> <span class="n">lists</span> <span class="o">-</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">synchronize</span>
       <span class="n">the</span> <span class="n">order</span> <span class="n">in</span> <span class="n">which</span> <span class="n">dirty</span> <span class="n">pages</span> <span class="n">are</span> <span class="n">added</span> <span class="n">to</span> <span class="n">flush</span> <span class="n">lists</span><span class="p">.</span>
    <span class="mf">3.</span> <span class="n">Concurrent</span> <span class="n">MTR</span> <span class="n">commits</span> <span class="n">can</span> <span class="n">interleave</span> <span class="n">on</span> <span class="n">different</span> <span class="n">stages</span> <span class="n">of</span> <span class="n">commits</span><span class="p">.</span>
    <span class="mf">4.</span> <span class="n">Introduced</span> <span class="n">dedicated</span> <span class="n">log</span> <span class="n">threads</span> <span class="n">which</span> <span class="n">keep</span> <span class="n">writing</span> <span class="n">log</span> <span class="n">buffer</span><span class="o">:</span> 
        <span class="o">*</span> <span class="n">log_writer</span><span class="o">:</span> <span class="n">writes</span> <span class="n">log</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">system</span> <span class="n">buffers</span><span class="p">,</span>
        <span class="o">*</span> <span class="n">log_flusher</span><span class="o">:</span> <span class="n">flushes</span> <span class="n">system</span> <span class="n">buffers</span> <span class="n">to</span> <span class="n">disk</span><span class="p">.</span>
       <span class="n">As</span> <span class="n">soon</span> <span class="n">as</span> <span class="n">they</span> <span class="n">finished</span> <span class="n">writing</span> <span class="p">(</span><span class="n">flushing</span><span class="p">)</span> <span class="n">and</span> <span class="n">there</span> <span class="n">is</span> <span class="k">new</span> <span class="n">data</span> <span class="n">to</span> 
       <span class="n">write</span> <span class="p">(</span><span class="n">flush</span><span class="p">),</span> <span class="n">they</span> <span class="n">start</span> <span class="n">next</span> <span class="n">write</span> <span class="p">(</span><span class="n">flush</span><span class="p">).</span>
    <span class="mf">5.</span> <span class="n">User</span> <span class="n">threads</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">write</span> <span class="o">/</span> <span class="n">flush</span> <span class="n">log</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">disk</span><span class="p">,</span> <span class="n">they</span> <span class="n">only</span>
       <span class="n">wait</span> <span class="n">by</span> <span class="n">spinning</span> <span class="n">or</span> <span class="n">on</span> <span class="n">event</span> <span class="k">for</span> <span class="n">notification</span><span class="p">.</span> <span class="n">They</span> <span class="k">do</span> <span class="n">not</span> <span class="n">have</span> <span class="n">to</span> 
       <span class="n">compete</span> <span class="k">for</span> <span class="n">the</span> <span class="n">responsibility</span> <span class="n">of</span> <span class="n">writing</span> <span class="o">/</span> <span class="n">flushing</span><span class="p">.</span>
    <span class="mf">6.</span> <span class="n">Introduced</span> <span class="n">a</span> <span class="n">ring</span> <span class="n">buffer</span> <span class="n">of</span> <span class="n">events</span> <span class="p">(</span><span class="n">one</span> <span class="n">per</span> <span class="n">log</span><span class="o">-</span><span class="n">block</span><span class="p">)</span> <span class="n">which</span> <span class="n">are</span> <span class="n">used</span>
       <span class="n">by</span> <span class="n">user</span> <span class="n">threads</span> <span class="n">to</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">written</span><span class="o">/</span><span class="n">flushed</span> <span class="n">redo</span> <span class="n">log</span> <span class="n">to</span> <span class="n">avoid</span><span class="o">:</span>
        <span class="o">*</span> <span class="n">contention</span> <span class="n">on</span> <span class="n">single</span> <span class="n">event</span>
        <span class="o">*</span> <span class="nb">false</span> <span class="n">wake</span><span class="o">-</span><span class="n">ups</span> <span class="n">of</span> <span class="n">all</span> <span class="n">waiting</span> <span class="n">threads</span> <span class="n">whenever</span> <span class="n">some</span> <span class="n">write</span><span class="o">/</span><span class="n">flush</span>
          <span class="n">has</span> <span class="n">finished</span> <span class="p">(</span><span class="n">we</span> <span class="n">can</span> <span class="n">wake</span><span class="o">-</span><span class="n">up</span> <span class="n">only</span> <span class="n">those</span> <span class="n">waiting</span> <span class="n">in</span> <span class="n">related</span> <span class="n">blocks</span><span class="p">)</span>
    <span class="mf">7.</span> <span class="n">Introduced</span> <span class="n">dedicated</span> <span class="n">notifier</span> <span class="n">threads</span> <span class="n">not</span> <span class="n">to</span> <span class="n">delay</span> <span class="n">next</span> <span class="n">writes</span><span class="o">/</span><span class="n">fsyncs</span><span class="o">:</span>
        <span class="o">*</span> <span class="n">log_write_notifier</span><span class="o">:</span> <span class="n">notifies</span> <span class="n">user</span> <span class="n">threads</span> <span class="n">about</span> <span class="n">written</span> <span class="n">redo</span><span class="p">,</span>
        <span class="o">*</span> <span class="n">log_flush_notifier</span><span class="o">:</span> <span class="n">notifies</span> <span class="n">user</span> <span class="n">threads</span> <span class="n">about</span> <span class="n">flushed</span> <span class="n">redo</span><span class="p">.</span>
    <span class="mf">8.</span> <span class="n">Master</span> <span class="kr">thread</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">has</span> <span class="n">to</span> <span class="n">flush</span> <span class="n">log</span> <span class="n">buffer</span><span class="p">.</span>
    <span class="p">...</span>
    <span class="mf">30.</span> <span class="n">Mysql</span> <span class="n">test</span> <span class="n">runner</span> <span class="n">received</span> <span class="n">a</span> <span class="k">new</span> <span class="n">feature</span> <span class="p">(</span><span class="n">thanks</span> <span class="n">to</span> <span class="n">Marcin</span><span class="p">)</span><span class="o">:</span>
        <span class="o">--</span><span class="n">exec_in_background</span><span class="p">.</span>
    <span class="n">Review</span><span class="o">:</span> <span class="n">RB</span><span class="err">#</span><span class="mi">15134</span>
    <span class="n">Reviewers</span><span class="o">:</span>
        <span class="o">-</span> <span class="n">Marcin</span> <span class="n">Babij</span> <span class="o">&lt;</span><span class="n">marcin</span><span class="p">.</span><span class="n">babij</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="o">-</span> <span class="n">Debarun</span> <span class="n">Banerjee</span> <span class="o">&lt;</span><span class="n">debarun</span><span class="p">.</span><span class="n">banerjee</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">.</span>
    <span class="n">Performance</span> <span class="n">tests</span><span class="o">:</span>
        <span class="o">-</span> <span class="n">Dimitri</span> <span class="n">Kravtchuk</span> <span class="o">&lt;</span><span class="n">dimitri</span><span class="p">.</span><span class="n">kravtchuk</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="o">-</span> <span class="n">Daniel</span> <span class="n">Blanchard</span> <span class="o">&lt;</span><span class="n">daniel</span><span class="p">.</span><span class="n">blanchard</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="o">-</span> <span class="n">Amrendra</span> <span class="n">Kumar</span> <span class="o">&lt;</span><span class="n">amrendra</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">kumar</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">.</span>
    <span class="n">QA</span> <span class="n">and</span> <span class="n">MTR</span> <span class="n">tests</span><span class="o">:</span>
        <span class="o">-</span> <span class="n">Vinay</span> <span class="n">Fisrekar</span> <span class="o">&lt;</span><span class="n">vinay</span><span class="p">.</span><span class="n">fisrekar</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span><span class="p">.</span>
</code></pre></div></div>

<p>The new mechanism employs dedicated threads to flush redo log files, supports concurrent writes to the log buffer, removes global latches in the code, and introduces latch-free processing, significantly enhancing scalability.</p>

<p>A test comparing TPC-C throughput with different levels of concurrency before and after optimization was conducted. Specific details are shown in the following figure:</p>

<p><img src="../Images/d7f66e43157014e054a21f9e87f38918.png" alt="image-20240829094221268" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829094221268.png"/></p>

<p>Figure 7-1. Impact of redo log optimization under different concurrency levels.</p>

<p>The results in the figure show a significant improvement in throughput at a concurrency level of 100 but a decrease at high concurrency levels. This decrease can be attributed to two potential reasons:</p>

<ol>
  <li><strong>Unsolved Foundational Flaws:</strong> During the transformation process, foundational problems may not have been fully addressed.</li>
  <li><strong>Interference from Multiple Queue Bottlenecks:</strong> Problems similar to multi-queue bottlenecks interfering with each other may arise. Although performance in some areas has improved, other bottlenecks have worsened under high concurrency.</li>
</ol>

<p>Extensive research suggests that the optimization should theoretically enhance throughput. The redo log optimization uses a group commit-like mechanism to reduce I/O overhead. Instead of immediately flushing redo log contents, user threads write to a log buffer and wait, while a dedicated thread batches and flushes the log to disk, notifying user threads when the process is complete. This approach is expected to significantly decrease I/O operations under high concurrency. Therefore, the most likely cause of performance problems is exacerbated bottlenecks in other queues.</p>

<p>Implementing redo log optimization is highly challenging, and without it, achieving throughput levels in the millions of tpmC would be nearly impossible.</p>

<p>Extensive testing revealed that the optimizations performed well under low concurrency conditions and significantly accelerated the TPC-C data loading process. Specific details are shown in the following figure:</p>

<p><img src="../Images/075bced720bbbdf5c2a4e2331c6f2079.png" alt="image-20240829095452552" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829095452552.png"/></p>

<p>Figure 7-2. Impact of redo log optimization for TPC-C data loading time.</p>

<p>The TPC-C data loading process involves large transactions of up to 100MB. Previously, loading 1000 warehouses took 77 minutes, but with the optimization, it now takes only 16 minutes. This demonstrates that redo log optimization is highly effective for handling large transactions.</p>

<p>To assess the true value of this optimization, scalability enhancements were applied to MySQL 5.7.36. This process involved first applying the trx-sys patch, followed by the lock-sys patch, to evaluate the extent of throughput improvement. Specific details are shown in the following figure:</p>

<p><img src="../Images/df038ca81523ec4f6d21b7b7763c1a57.png" alt="image-20240829100209917" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829100209917.png"/></p>

<p>Figure 7-3. Indirect impact of redo log optimization.</p>

<p>From the figure, it can be seen that after applying the trx-sys and lock-sys scalability patches, MySQL 5.7.36 experienced an improvement in throughput. However, it did not fundamentally solve scalability problems, especially when compared to the improved MySQL 8.0.27 version. The gap remains significant. To identify the bottleneck at 250 concurrency, the following screenshot from the <em>perf</em> tool can be examined.</p>

<p><img src="../Images/4990fe18db5d697cf145e29c175acd0c.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/739df2baa4dbff3a74a4cdc6d1d651e7.png"/></p>

<p>Figure 7-4. Screenshot from the <em>perf</em> tool at 250 concurrency.</p>

<p>From the figure, it is evident that the bottleneck is <strong>prepare_write</strong>, which precisely corresponds to the bottleneck of writing redo log buffer in MySQL 5.7.36 version.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Prepare to write the mini-transaction log to the redo log buffer.
@return number of bytes to write in finish_write() */</span>
<span class="n">ulint</span> <span class="n">mtr_t</span><span class="o">::</span><span class="n">Command</span><span class="o">::</span><span class="n">prepare_write</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">m_impl</span><span class="o">-&gt;</span><span class="n">m_log_mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">MTR_LOG_SHORT_INSERTS</span><span class="p">:</span>
      <span class="n">ut_d</span><span class="p">(</span><span class="n">ut_error</span><span class="p">);</span>
      <span class="cm">/* fall through (write no redo log) */</span>
      <span class="p">[[</span><span class="n">fallthrough</span><span class="p">]];</span>
    <span class="k">case</span> <span class="n">MTR_LOG_NO_REDO</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">MTR_LOG_NONE</span><span class="p">:</span>
      <span class="n">ut_ad</span><span class="p">(</span><span class="n">m_impl</span><span class="o">-&gt;</span><span class="n">m_log</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">MTR_LOG_ALL</span><span class="p">:</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="n">ut_d</span><span class="p">(</span><span class="n">ut_error</span><span class="p">);</span>
      <span class="n">ut_o</span><span class="p">(</span><span class="k">return</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
</code></pre></div></div>

<p>Let’s analyze this function by examining its call stack relationship.</p>

<p><img src="../Images/5eabfef4a07c9d88d726c35feff2c693.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/f558d2899635882ec517e2b1da5a0a8f.png"/></p>

<p>Figure 7-5. Call stack relationship revealing bottleneck in redo log writing.</p>

<p>The figure clearly shows that the bottleneck lies in redo log writing. Without the redo log optimization patch, the scalability problems in MySQL 5.7.36 cannot be fundamentally solved, underscoring the significant impact of redo log optimization.</p>

<p>Does redo log optimization currently have any side effects? Test data indicates that under low concurrency conditions, the number of flush operations increases significantly. Using SysBench read-write tests, the relationship between the average number of I/O flushes per transaction and concurrency was statistically analyzed. Specific details are shown in the following figure:</p>

<p><img src="../Images/95ab89db6fe71f566fc5987d2c79171b.png" alt="image-20240829100245272" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829100245272.png"/></p>

<p>Figure 7-6. Side effects of redo log optimization at low concurrency: more I/O flushes.</p>

<p>From the figure, it can be observed that with 3 concurrent read-write operations, each transaction averages over 9 flushes, while at 200 concurrency, it decreases to around 1 flush per transaction. These average flush counts can be further optimized, but it requires finding a balance: timely flushing activates user threads more quickly but incurs higher I/O overhead, whereas delaying flushing reduces I/O costs but may increase user response times.</p>

<p>It is important to note that the Redo log improvements are primarily focused on enhancing overall performance in high-concurrency environments, but they perform poorly in scenarios with fewer than 50 concurrent connections. Many users have complained that MySQL 8.0’s performance falls short of expectations, and this is one of the fundamental reasons.</p>

<h3 id="712-optimizing-lock-sys-through-latch-sharding">7.1.2 Optimizing Lock-Sys Through Latch Sharding</h3>

<p>In MySQL 5.7, the lock system experienced significant latch contention problems, which severely impacted throughput under high concurrency. During transaction execution, frequent locking and unlocking operations require acquiring a global latch. When many user threads compete for this global latch, MySQL’s scalability becomes a major concern.</p>

<p>Lock-sys optimization is the second major improvement made in MySQL 8.0. The following git log describes the specific details of the lock-sys optimization.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">commit</span> <span class="mi">1</span><span class="n">d259b87a63defa814e19a7534380cb43ee23c48</span>
<span class="n">Author</span><span class="o">:</span> <span class="n">Jakub</span> <span class="err">Ł</span><span class="n">opusza</span><span class="err">ń</span><span class="n">ski</span> <span class="o">&lt;</span><span class="n">jakub</span><span class="p">.</span><span class="n">lopuszanski</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="o">:</span>   <span class="n">Wed</span> <span class="n">Feb</span> <span class="mi">5</span> <span class="mi">14</span><span class="o">:</span><span class="mi">12</span><span class="o">:</span><span class="mi">22</span> <span class="mi">2020</span> <span class="o">+</span><span class="mo">0100</span>

    <span class="n">WL</span><span class="err">#</span><span class="mi">10314</span> <span class="o">-</span> <span class="n">InnoDB</span><span class="o">:</span> <span class="n">Lock</span><span class="o">-</span><span class="n">sys</span> <span class="n">optimization</span><span class="o">:</span> <span class="n">sharded</span> <span class="n">lock_sys</span> <span class="n">mutex</span>

    <span class="n">The</span> <span class="n">Lock</span><span class="o">-</span><span class="n">sys</span> <span class="n">orchestrates</span> <span class="n">access</span> <span class="n">to</span> <span class="n">tables</span> <span class="n">and</span> <span class="n">rows</span><span class="p">.</span> <span class="n">Each</span> <span class="n">table</span><span class="p">,</span> <span class="n">and</span> <span class="n">each</span> <span class="n">row</span><span class="p">,</span>
    <span class="n">can</span> <span class="n">be</span> <span class="n">thought</span> <span class="n">of</span> <span class="n">as</span> <span class="n">a</span> <span class="n">resource</span><span class="p">,</span> <span class="n">and</span> <span class="n">a</span> <span class="n">transaction</span> <span class="n">may</span> <span class="n">request</span> <span class="n">access</span> <span class="n">right</span> <span class="k">for</span>
    <span class="n">a</span> <span class="n">resource</span><span class="p">.</span> <span class="n">As</span> <span class="n">two</span> <span class="n">transactions</span> <span class="n">operating</span> <span class="n">on</span> <span class="n">a</span> <span class="n">single</span> <span class="n">resource</span> <span class="n">can</span> <span class="n">lead</span> <span class="n">to</span>
    <span class="n">problems</span> <span class="k">if</span> <span class="n">the</span> <span class="n">two</span> <span class="n">operations</span> <span class="n">conflict</span> <span class="n">with</span> <span class="n">each</span> <span class="n">other</span><span class="p">,</span> <span class="n">Lock</span><span class="o">-</span><span class="n">sys</span> <span class="n">remembers</span>
    <span class="n">lists</span> <span class="n">of</span> <span class="n">already</span> <span class="n">GRANTED</span> <span class="n">lock</span> <span class="n">requests</span> <span class="n">and</span> <span class="n">checks</span> <span class="k">new</span> <span class="n">requests</span> <span class="k">for</span> <span class="n">conflicts</span> <span class="n">in</span>
    <span class="n">which</span> <span class="k">case</span> <span class="n">they</span> <span class="n">have</span> <span class="n">to</span> <span class="n">start</span> <span class="n">WAITING</span> <span class="k">for</span> <span class="n">their</span> <span class="n">turn</span><span class="p">.</span>

    <span class="n">Lock</span><span class="o">-</span><span class="n">sys</span> <span class="n">stores</span> <span class="n">both</span> <span class="n">GRANTED</span> <span class="n">and</span> <span class="n">WAITING</span> <span class="n">lock</span> <span class="n">requests</span> <span class="n">in</span> <span class="n">lists</span> <span class="n">known</span> <span class="n">as</span> <span class="n">queues</span><span class="p">.</span>
    <span class="n">To</span> <span class="n">allow</span> <span class="n">concurrent</span> <span class="n">operations</span> <span class="n">on</span> <span class="n">these</span> <span class="n">queues</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">a</span> <span class="n">mechanism</span> <span class="n">to</span> <span class="n">latch</span>
    <span class="n">these</span> <span class="n">queues</span> <span class="n">in</span> <span class="n">safe</span> <span class="n">and</span> <span class="n">quick</span> <span class="n">fashion</span><span class="p">.</span>

    <span class="n">In</span> <span class="n">the</span> <span class="n">past</span> <span class="n">a</span> <span class="n">single</span> <span class="n">latch</span> <span class="k">protected</span> <span class="n">access</span> <span class="n">to</span> <span class="n">all</span> <span class="n">of</span> <span class="n">these</span> <span class="n">queues</span><span class="p">.</span>
    <span class="n">This</span> <span class="n">scaled</span> <span class="n">poorly</span><span class="p">,</span> <span class="n">and</span> <span class="n">the</span> <span class="n">managment</span> <span class="n">of</span> <span class="n">queues</span> <span class="n">become</span> <span class="n">a</span> <span class="n">bottleneck</span><span class="p">.</span>
    <span class="n">In</span> <span class="k">this</span> <span class="n">WL</span><span class="p">,</span> <span class="n">we</span> <span class="n">introduce</span> <span class="n">a</span> <span class="n">more</span> <span class="n">granular</span> <span class="n">approach</span> <span class="n">to</span> <span class="n">latching</span><span class="p">.</span>

    <span class="n">Reviewed</span><span class="o">-</span><span class="n">by</span><span class="p">:</span> <span class="n">Pawel</span> <span class="n">Olchawa</span> <span class="o">&lt;</span><span class="n">pawel</span><span class="p">.</span><span class="n">olchawa</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
    <span class="n">Reviewed</span><span class="o">-</span><span class="n">by</span><span class="o">:</span> <span class="n">Debarun</span> <span class="n">Banerjee</span> <span class="o">&lt;</span><span class="n">debarun</span><span class="p">.</span><span class="n">banerjee</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
      <span class="n">RB</span><span class="o">:</span><span class="mi">23836</span>
</code></pre></div></div>

<p>Sharding the global latch theoretically can significantly improve scalability under high concurrency situations. Based on the program before and after optimizing with lock-sys, using BenchmarkSQL to compare TPC-C throughput with concurrency, the specific results are as shown in the following figure:</p>

<p><img src="../Images/3c0335016408372c44248e78157f2f26.png" alt="image-20240829100432417" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829100432417.png"/></p>

<p>Figure 7-7. Impact of lock-sys optimization under different concurrency levels.</p>

<p>From the figure, it can be seen that optimizing lock-sys significantly improves throughput under high concurrency conditions, while the effect is less pronounced under low concurrency due to fewer conflicts.</p>

<h3 id="713-latch-splitting-in-trx-sys">7.1.3 Latch Splitting in trx-sys</h3>

<p>The trx-sys subsystem in MySQL, closely related to MVCC, primarily involves read operations. Improvements to redo log and lock-sys are mainly associated with write operations.</p>

<p>MySQL 5.7 utilized a global latch to synchronize various operations within trx-sys. To enhance read capabilities, it was crucial to address this latch bottleneck. However, the intertwined logic made modification challenging.</p>

<p>In MySQL 8.0, the global latch was initially split. A new latch was introduced for the <em>serialization_list</em>, allowing bypass of the global latch and reducing the contention pressure on it. The following git log describes the specific details of these optimizations.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">commit</span> <span class="n">e66d48b0c73d5fec278f81784bd5697502990263</span>
<span class="n">Author</span><span class="o">:</span> <span class="n">Pawe</span><span class="err">ł</span> <span class="n">Olchawa</span> <span class="o">&lt;</span><span class="n">pawel</span><span class="p">.</span><span class="n">olchawa</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="o">:</span>   <span class="n">Mon</span> <span class="n">Mar</span> <span class="mi">1</span> <span class="mi">15</span><span class="o">:</span><span class="mi">52</span><span class="o">:</span><span class="mi">30</span> <span class="mi">2021</span> <span class="o">+</span><span class="mo">0100</span>

    <span class="n">BUG</span><span class="err">#</span><span class="mi">27933068</span> <span class="n">USE</span> <span class="n">DIFFERENT</span> <span class="n">MUTEX</span> <span class="n">TO</span> <span class="n">PROTECT</span> <span class="n">TRX_SYS</span><span class="o">-&gt;</span><span class="n">SERIALISATION_LIST</span>

    <span class="n">This</span> <span class="n">is</span> <span class="n">an</span> <span class="n">optimization</span> <span class="n">patch</span><span class="p">,</span> <span class="n">which</span> <span class="n">reduces</span> <span class="n">contention</span> <span class="n">on</span> <span class="n">the</span> <span class="n">trx_sys_t</span><span class="o">::</span><span class="n">mutex</span>
    <span class="n">by</span> <span class="n">introducing</span> <span class="n">a</span> <span class="k">new</span> <span class="n">mutex</span> <span class="o">-</span> <span class="n">the</span> <span class="n">trx_sys_t</span><span class="o">::</span><span class="n">serialisation_mutex</span><span class="p">.</span>

    <span class="n">The</span> <span class="k">new</span> <span class="n">mutex</span> <span class="n">protects</span> <span class="n">the</span> <span class="n">trx_sys_t</span><span class="o">::</span><span class="n">serialisation_list</span> <span class="n">and</span> <span class="n">replaces</span> <span class="n">the</span>
    <span class="n">trx_sys_t</span><span class="o">::</span><span class="n">mutex</span> <span class="n">when</span> <span class="n">trx</span><span class="o">-&gt;</span><span class="n">no</span> <span class="n">is</span> <span class="n">being</span> <span class="n">assigned</span><span class="p">.</span>

    <span class="n">This</span> <span class="n">is</span> <span class="n">a</span> <span class="n">modified</span> <span class="n">version</span> <span class="n">of</span> <span class="n">the</span> <span class="n">contribution</span> <span class="n">patch</span> <span class="n">which</span> <span class="n">was</span> <span class="n">created</span> <span class="n">by</span> <span class="n">Zhai</span> <span class="n">Weixiang</span><span class="p">.</span>
    <span class="n">Modifications</span><span class="o">:</span>
    <span class="mf">1.</span> <span class="n">Periodical</span> <span class="n">write</span> <span class="n">of</span> <span class="n">max_trx_id</span> <span class="n">to</span> <span class="n">the</span> <span class="n">transaction</span> <span class="n">system</span> <span class="n">header</span> <span class="n">page</span> <span class="n">is</span> <span class="n">modified</span><span class="p">.</span>
    <span class="mf">2.</span> <span class="n">The</span> <span class="n">trx_get_serial_no</span><span class="p">()</span> <span class="n">is</span> <span class="n">called</span> <span class="n">when</span> <span class="n">we</span> <span class="k">do</span> <span class="n">not</span> <span class="n">hold</span> <span class="n">trx_sys_t</span><span class="o">::</span><span class="n">mutex</span><span class="p">.</span>
    <span class="mf">3.</span> <span class="n">Members</span> <span class="n">in</span> <span class="n">trx_sys_t</span> <span class="n">are</span> <span class="n">rearranged</span><span class="p">,</span> <span class="n">so</span> <span class="n">they</span> <span class="n">are</span> <span class="n">grouped</span> <span class="n">by</span> <span class="n">mutex</span> <span class="n">that</span> <span class="n">protects</span> <span class="n">them</span><span class="p">.</span>
    <span class="mf">4.</span> <span class="n">The</span> <span class="k">new</span> <span class="n">mutex</span> <span class="n">received</span> <span class="n">its</span> <span class="n">own</span> <span class="n">latch_id</span><span class="p">.</span>
    <span class="mf">5.</span> <span class="n">InnoDB</span> <span class="n">relies</span> <span class="n">on</span> <span class="n">rw_trx_max_id</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">max_trx_id</span> <span class="n">in</span> <span class="n">few</span> <span class="n">places</span><span class="p">.</span>
    <span class="mf">6.</span> <span class="n">The</span> <span class="n">min_active_id</span> <span class="n">is</span> <span class="n">updated</span> <span class="n">only</span> <span class="n">when</span> <span class="n">it</span> <span class="n">really</span> <span class="n">changes</span><span class="p">.</span>

    <span class="n">RB</span><span class="o">:</span> <span class="mi">19712</span>
    <span class="n">Reviewed</span><span class="o">-</span><span class="n">by</span><span class="o">:</span> <span class="n">Debarun</span> <span class="n">Banerjee</span> <span class="n">debarun</span><span class="p">.</span><span class="n">banerjee</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span>
</code></pre></div></div>

<p>Based on this optimization before and after, using BenchmarkSQL to compare TPC-C throughput with concurrency, the specific results are shown in the following figure:</p>

<p><img src="../Images/54b11e2a4a28e3dfd6fc6cc426074998.png" alt="image-20240829100937477" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829100937477.png"/></p>

<p>Figure 7-8. Impact of latch splitting in trx-sys under different concurrency levels.</p>

<p>From the figure, it can be seen that the optimization is effective at 150 concurrency. However, beyond 200 concurrency, throughput not only fails to increase but actually decreases. This decline at high concurrency levels is primarily due to interference from other queue bottlenecks.</p>

<h3 id="714-latch-sharding-for-trx-sys">7.1.4 Latch Sharding for trx-sys</h3>

<p>In MySQL 8.0, further scalability improvements are made to the trx-sys subsystem. The <em>rw_trx_set</em> has been divided into shards, each with its own latch. This significantly reduces global latch contention for read operations. The following git log describes the specific details of these optimizations.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">commit</span> <span class="n">bc95476c0156070fd5cedcfd354fa68ce3c95bdb</span>
<span class="n">Author</span><span class="o">:</span> <span class="n">Pawe</span><span class="err">ł</span> <span class="n">Olchawa</span> <span class="o">&lt;</span><span class="n">pawel</span><span class="p">.</span><span class="n">olchawa</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="o">:</span>   <span class="n">Tue</span> <span class="n">May</span> <span class="mi">25</span> <span class="mi">18</span><span class="o">:</span><span class="mi">12</span><span class="o">:</span><span class="mi">20</span> <span class="mi">2021</span> <span class="o">+</span><span class="mo">0200</span>

    <span class="n">BUG</span><span class="err">#</span><span class="mi">32832196</span> <span class="n">SINGLE</span> <span class="n">RW_TRX_SET</span> <span class="n">LEADS</span> <span class="n">TO</span> <span class="n">CONTENTION</span> <span class="n">ON</span> <span class="n">TRX_SYS</span> <span class="n">MUTEX</span>

    <span class="mf">1.</span> <span class="n">Introduced</span> <span class="n">shards</span><span class="p">,</span> <span class="n">each</span> <span class="n">with</span> <span class="n">rw_trx_set</span> <span class="n">and</span> <span class="n">dedicated</span> <span class="n">mutex</span><span class="p">.</span>
    <span class="mf">2.</span> <span class="n">Extracted</span> <span class="n">modifications</span> <span class="n">to</span> <span class="n">rw_trx_set</span> <span class="n">outside</span> <span class="n">its</span> <span class="n">original</span> <span class="n">critical</span> <span class="n">sections</span>
       <span class="p">(</span><span class="n">removal</span> <span class="n">had</span> <span class="n">to</span> <span class="n">be</span> <span class="n">extracted</span> <span class="n">outside</span> <span class="n">trx_erase_lists</span><span class="p">).</span>
    <span class="mf">3.</span> <span class="n">Eliminated</span> <span class="n">allocation</span> <span class="n">on</span> <span class="n">heap</span> <span class="n">inside</span> <span class="n">TrxUndoRsegs</span><span class="p">.</span>
    <span class="mf">4.</span> <span class="p">[</span><span class="n">BUG</span><span class="o">-</span><span class="n">FIX</span><span class="p">]</span> <span class="n">The</span> <span class="n">trx</span><span class="o">-&gt;</span><span class="n">state</span> <span class="n">and</span> <span class="n">trx</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="n">became</span> <span class="n">converted</span> <span class="n">to</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;&gt;</span>
       <span class="n">fields</span> <span class="n">to</span> <span class="n">avoid</span> <span class="n">risk</span> <span class="n">of</span> <span class="n">torn</span> <span class="n">reads</span> <span class="n">on</span> <span class="n">egzotic</span> <span class="n">platforms</span><span class="p">.</span>
    <span class="mf">5.</span> <span class="n">Added</span> <span class="n">assertions</span> <span class="n">which</span> <span class="n">ensure</span> <span class="n">that</span> <span class="kr">thread</span> <span class="n">operating</span> <span class="n">on</span> <span class="n">transaction</span> <span class="n">has</span> <span class="n">rights</span>
       <span class="n">to</span> <span class="k">do</span> <span class="n">so</span> <span class="p">(</span><span class="n">to</span> <span class="n">show</span> <span class="n">there</span> <span class="n">is</span> <span class="n">no</span> <span class="n">possible</span> <span class="n">race</span> <span class="n">condition</span><span class="p">).</span>

    <span class="n">RB</span><span class="o">:</span> <span class="mi">26314</span>
    <span class="n">Reviewed</span><span class="o">-</span><span class="n">by</span><span class="o">:</span> <span class="n">Jakub</span> <span class="err">Ł</span><span class="n">opusza</span><span class="err">ń</span><span class="n">ski</span> <span class="n">jakub</span><span class="p">.</span><span class="n">lopuszanski</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span>
</code></pre></div></div>

<p>Based on these optimizations before and after, using BenchmarkSQL to compare TPC-C throughput with concurrency, the specific results are as shown in the following figure:</p>

<p><img src="../Images/ea3541b32aff0ad79f8cb9fa1ee9d0e2.png" alt="image-20240829101111288" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101111288.png"/></p>

<p>Figure 7-9. Impact of latch sharding in trx-sys under different concurrency levels.</p>

<p>From the figure, it can be seen that this improvement significantly enhances TPC-C throughput, reaching its peak at 200 concurrency. It is worth noting that the impact diminishes at 300 concurrency, primarily due to ongoing scalability problems in the trx-sys subsystem related to MVCC ReadView. This problem will be discussed further in the next chapter.</p>

<h3 id="715-summary">7.1.5 Summary</h3>

<p>The series of scalability improvements mentioned above have laid a solid foundation for achieving high throughput in MySQL. Without these changes, subsequent improvements would lose their significance. Therefore, MySQL 8.0 has made significant advancements in scalability.</p>

<h2 id="72-evaluating-performance-gains-in-mysql-lock-scheduling-algorithms">7.2 Evaluating Performance Gains in MySQL Lock Scheduling Algorithms</h2>

<p>Scheduling is crucial in computer system design. The right policy can significantly reduce mean response time without needing faster machines, effectively improving performance for free. Scheduling also optimizes other metrics, such as user fairness and differentiated service levels, ensuring some job classes have lower mean delays than others [24].</p>

<p>MySQL 8.0 uses the Contention-Aware Transaction Scheduling (CATS) algorithm to prioritize transactions waiting for locks. When multiple transactions compete for the same lock, CATS determines the priority based on scheduling weight, calculated by the number of transactions a given transaction blocks. The transaction blocking the most others gets higher priority; if weights are equal, the longest waiting transaction goes first.</p>

<p>A deadlock occurs when multiple transactions cannot proceed because each holds a lock needed by another, causing all involved to wait indefinitely without releasing their locks.</p>

<p>After understanding the MySQL lock scheduling algorithm, let’s examine how this algorithm affects throughput. Before testing, it is necessary to understand the previous FIFO algorithm and how to restore it. For relevant details, refer to the git log explanations provided below.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">This</span> <span class="n">WL</span> <span class="n">improves</span> <span class="n">the</span> <span class="n">implementation</span> <span class="n">of</span> <span class="n">CATS</span> <span class="n">to</span> <span class="n">the</span> <span class="n">point</span> <span class="n">where</span> <span class="n">the</span> <span class="n">FCFS</span> <span class="n">will</span> <span class="n">be</span> <span class="n">redundant</span> <span class="p">(</span><span class="n">as</span> <span class="n">often</span> <span class="n">slower</span><span class="p">,</span> <span class="n">and</span> <span class="n">easy</span> <span class="n">to</span> <span class="s">"emulate"</span> <span class="n">by</span> <span class="n">setting</span> <span class="n">equal</span> <span class="n">schedule</span> <span class="n">weights</span> <span class="n">in</span> <span class="n">CATS</span><span class="p">),</span> <span class="n">so</span> <span class="n">it</span> <span class="n">removes</span> <span class="n">FCFS</span> <span class="n">from</span> <span class="n">the</span> <span class="n">code</span><span class="p">,</span> <span class="n">further</span> <span class="n">simplifying</span> <span class="n">the</span> <span class="n">lock_sys</span><span class="err">'</span><span class="n">s</span> <span class="n">logic</span><span class="p">.</span>
</code></pre></div></div>

<p>Based on the above prompt, restoring the FIFO lock scheduling algorithm in MySQL is straightforward. Subsequently, throughput was tested using SysBench Pareto distribution scenarios with varying concurrency levels in the improved MySQL 8.0.32. Details are provided in the following figure.</p>

<p><img src="../Images/e2bbab0a50484c4512cada95e23cd4b0.png" alt="image-20240829101222447" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101222447.png"/></p>

<p>Figure 7-10. Impact of CATS on throughput at various concurrency levels.</p>

<p>From the figure, it can be seen that the throughput of the CATS algorithm significantly exceeds that of the FIFO algorithm. To compare these two algorithms in terms of user response time, refer to the following figure.</p>

<p><img src="../Images/3a5c4d81f6a6083c92db92ad1a70f122.png" alt="image-20240829101254601" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101254601.png"/></p>

<p>Figure 7-11. Impact of CATS on response time at various concurrency levels.</p>

<p>From the figure, it can be seen that the CATS algorithm provides significantly better user response times.</p>

<p>Furthermore, comparing deadlock error statistics during the Pareto distribution test process, details can be found in the following figure.</p>

<p><img src="../Images/b52da62952ddc961d2ce63deb40ef462.png" alt="image-20240829101332034" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101332034.png"/></p>

<p>Figure 7-12. Impact of CATS on ignored errors at various concurrency levels.</p>

<p>Comparative analysis shows that the CATS algorithm significantly reduces deadlocks. This reduction in deadlocks likely plays a key role in improving performance. The theoretical basis for this correlation is as follows [8]:</p>

<p><em>Under a high-contention setting, the throughput of the target system will be determined by the concurrency control mechanism of the target system: systems which can release locks earlier or reduce the number of aborts will have advantages in such a setting.</em></p>

<p>The above test results align closely with MySQL’s official findings. The following two figures, based on official tests [57], demonstrate the significant effectiveness of the CATS algorithm.</p>

<p><img src="../Images/b310997cccf5a47e469129246583f04c.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/853d21533f748c1c56a4151869a82a27.gif"/></p>

<p>Figure 7-13. Comparison of CATS and FIFO in TPS and mean latency: insights from the MySQL blog.</p>

<p>Additionally, MySQL’s official requirements for implementing the CATS algorithm are stringent. Specific details are provided in the following figure:</p>

<p><img src="../Images/0ead65693f0a60f349e4ef7d6a9651e3.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/4f0ea97ad117848a71148849705e311e.png"/></p>

<p>Figure 7-14. Requirements of the official worklog for CATS.</p>

<p>Therefore, with the adoption of the CATS algorithm, performance degradation should be absent in all scenarios. It seems like things end here, but the summary in the CATS algorithm’s paper [24] raises some doubts. Details are provided in the following figure:</p>

<p><img src="../Images/bba749fc0c5101cc3cf32f0d089bf3ae.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/4cc389ee95fbae485f1e014aad393aa8.gif"/></p>

<p>Figure 7-15. Doubts about the CATS paper.</p>

<p>From the information above, it can be inferred that either the industry has overlooked potential flaws in FIFO, or the paper’s assessment is flawed, and FIFO does not have the serious problems suggested. This contradiction highlights a critical problem: one of these conclusions must be flawed; both cannot be correct.</p>

<p>Contradictions often present valuable opportunities for in-depth problem analysis and resolution. They highlight areas where existing understanding may be challenged or where new insights can be gained.</p>

<p>This time, testing on the improved MySQL 8.0.27 revealed a large number of error logs in the MySQL error log file. Below is a partial screenshot:</p>

<p><img src="../Images/f5362a8c9da0af6746edab7bd9ab8ac0.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/4ca52ffeebc49306e76c74ed9062257d.png"/></p>

<p>Figure 7-16. Partial screenshot of numerous error logs.</p>

<p>Continuing the analysis of the corresponding code, the specifics are as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Deadlock_notifier</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span><span class="k">const</span> <span class="n">ut</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">trx_t</span> <span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">trxs_on_cycle</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">trx_t</span> <span class="o">*</span><span class="n">victim_trx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ut_ad</span><span class="p">(</span><span class="n">locksys</span><span class="o">::</span><span class="n">owns_exclusive_global_latch</span><span class="p">());</span>
  <span class="n">start_print</span><span class="p">();</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">trxs_on_cycle</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">trx_t</span> <span class="o">*</span><span class="n">trx</span> <span class="o">=</span> <span class="n">trxs_on_cycle</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">trx_t</span> <span class="o">*</span><span class="n">blocked_trx</span> <span class="o">=</span> <span class="n">trxs_on_cycle</span><span class="p">[</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">lock_t</span> <span class="o">*</span><span class="n">blocking_lock</span> <span class="o">=</span>
        <span class="n">lock_has_to_wait_in_queue</span><span class="p">(</span><span class="n">blocked_trx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">wait_lock</span><span class="p">,</span> <span class="n">trx</span><span class="p">);</span>
    <span class="n">ut_a</span><span class="p">(</span><span class="n">blocking_lock</span><span class="p">);</span>
    <span class="n">print_title</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">"TRANSACTION"</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="n">trx</span><span class="p">,</span> <span class="mi">3000</span><span class="p">);</span>
    <span class="n">print_title</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">"HOLDS THE LOCK(S)"</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="n">blocking_lock</span><span class="p">);</span>
    <span class="n">print_title</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">"WAITING FOR THIS LOCK TO BE GRANTED"</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="n">trx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">.</span><span class="n">wait_lock</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">victim_it</span> <span class="o">=</span>
      <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">trxs_on_cycle</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">trxs_on_cycle</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">victim_trx</span><span class="p">);</span>
  <span class="n">ut_ad</span><span class="p">(</span><span class="n">victim_it</span> <span class="o">!=</span> <span class="n">trxs_on_cycle</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">victim_pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">trxs_on_cycle</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">victim_it</span><span class="p">);</span>
  <span class="n">ut</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">buff</span><span class="p">;</span>
  <span class="n">buff</span> <span class="o">&lt;&lt;</span> <span class="s">"*** WE ROLL BACK TRANSACTION ("</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">victim_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">")</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">buff</span><span class="p">.</span><span class="n">str</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
  <span class="n">DBUG_PRINT</span><span class="p">(</span><span class="s">"ib_lock"</span><span class="p">,</span> <span class="p">(</span><span class="s">"deadlock detected"</span><span class="p">));</span>
  <span class="p">...</span>
  <span class="n">lock_deadlock_found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From the code analysis, it’s clear that deadlocks lead to a substantial amount of log output. The ignored errors observed during testing are connected to these deadlocks. The CATS algorithm helps reduce the number of ignored errors, resulting in fewer log outputs. This problem can be consistently reproduced.</p>

<p>Given this context, several considerations emerge:</p>

<ol>
  <li><strong>Impact on Performance Testing:</strong> The extensive error logs and the resulting disruptions could potentially skew the performance evaluation, leading to inaccurate assessments of the system’s capabilities.</li>
  <li><strong>Effectiveness of the CATS Algorithm:</strong> The performance improvement of the CATS algorithm may need re-evaluation. If the extensive output of error logs significantly impacts performance, its actual effectiveness may not be as high as initially believed.</li>
</ol>

<p>Set <code class="language-plaintext highlighter-rouge">innodb_print_all_deadlocks=OFF</code> or remove all logging from the <code class="language-plaintext highlighter-rouge">Deadlock_notifier::notify</code> function, recompile MySQL, and run SysBench read-write tests with a Pareto distribution. Details are provided in the following figure:</p>

<p><img src="../Images/a5a0464e2d8f6cff94fc7cd6f711f19d.png" alt="image-20240829101534550" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101534550.png"/></p>

<p>Figure 7-17. Impact of CATS on throughput at various concurrency levels for improved MySQL 8.0.27 after eliminating interference.</p>

<p>From the figure, it is evident that there has been a significant change in throughput comparison. In scenarios with severe conflicts, the CATS algorithm slightly outperforms the FIFO algorithm, but the difference is minimal and much less pronounced than in previous tests. Note that these tests were conducted on the improved MySQL 8.0.27.</p>

<p>Let’s conduct performance comparison tests on the improved MySQL 8.0.32, with deadlock log interference removed, using Pareto distribution.</p>

<p><img src="../Images/1fc0c4040379dabf2ad2a13add5c5b75.png" alt="image-20240829101612063" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101612063.png"/></p>

<p>Figure 7-18. Impact of CATS on throughput at various concurrency levels for improved MySQL 8.0.32 after eliminating interference.</p>

<p>From the figure, it is evident that removing the interference results in only a slight performance difference. This small variation makes it understandable why the severity of FIFO scheduling problems may be difficult to notice. The perceived bias from the CATS author and MySQL officials is likely due to interference from extensive deadlock log output.</p>

<p>Using the same 32 warehouses as in the CATS algorithm paper, TPC-C tests were conducted at various concurrency levels. MySQL was based on the improved MySQL 8.0.27, and BenchmarkSQL was modified to support 100 concurrent transactions per warehouse.</p>

<p><img src="../Images/9fb06ba2573f47a3467fcdcbbadabde2.png" alt="image-20240829101632142" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101632142.png"/></p>

<p>Figure 7-19. Impact of CATS on throughput at different concurrency levels under NUMA after eliminating interference, according to the CATS paper.</p>

<p>From the figure, it’s evident that the CATS algorithm performs worse than the FIFO algorithm. To avoid NUMA-related interference, MySQL was bound to NUMA node 0 for a new round of throughput versus concurrency tests.</p>

<p><img src="../Images/1e3bff5182c8fa0e7e51cc41ad13514c.png" alt="image-20240829101650730" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101650730.png"/></p>

<p>Figure 7-20. Impact of CATS on throughput at different concurrency levels under SMP after eliminating interference, according to the CATS paper.</p>

<p>In this round of testing, the FIFO algorithm continued to outperform the CATS algorithm. The decline in performance of the CATS algorithm in BenchmarkSQL TPC-C testing compared to improvements in SysBench Pareto testing can be attributed to the following reasons:</p>

<ol>
  <li><strong>Additional Overhead</strong>: The CATS algorithm inherently introduces some extra overhead.</li>
  <li><strong>NUMA Environment Problems</strong>: The CATS algorithm may not perform optimally in NUMA environments.</li>
  <li><strong>Conflict Severity</strong>: The conflict severity in TPC-C testing is less pronounced than in SysBench Pareto testing.</li>
  <li><strong>Different Concurrency Scenarios</strong>: SysBench creates concurrency scenarios that differ significantly from those in BenchmarkSQL.</li>
</ol>

<p>Finally, standard TPC-C testing was performed again with 1000 warehouses at varying concurrency levels. Specific details are shown in the following figure:</p>

<p><img src="../Images/07d1e1ce7058308849d128242880cc42.png" alt="image-20240829101712694" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101712694.png"/></p>

<p>Figure 7-21. Impact of CATS on BenchmarkSQL throughput after eliminating interference.</p>

<p>From the figure, it is evident that there is little difference between the two algorithms in low-conflict scenarios. In other words, the CATS algorithm does not offer significant benefits in situations with fewer conflicts.</p>

<p>Overall, while CATS shows some improvement in Pareto testing, it is less pronounced than expected. The CATS algorithm significantly reduces transaction deadlocks, potentially resulting in less performance degradation than the FIFO algorithm. When deadlock logs are suppressed, the difference between these algorithms is minimal, clarifying the confusion surrounding the CATS algorithm’s performance.</p>

<p>Database performance testing is inherently complex and error-prone [9]. It cannot be judged by data alone and requires thorough investigation to ensure logical consistency.</p>

<h2 id="73-enhancements-in-mysql-execution-plans">7.3 Enhancements in MySQL Execution Plans</h2>

<h3 id="731-hash-join-implementation-in-mysql">7.3.1 Hash Join Implementation in MySQL</h3>

<p>As the name suggests, hashing is central to the hash join algorithm. It builds a hash table from one input table and then processes the other table row by row, using the hash table for lookups.</p>

<p>Hash joins are typically faster and are preferred over the block nested loop algorithm used in earlier MySQL versions. The benefits are substantial, as demonstrated by the practical case below.</p>

<p>In MySQL 5.7, which lacks hash join support, the SQL query relies on traditional join methods, resulting in a longer execution time of 3.82 seconds.</p>

<p><img src="../Images/ed154c5e7e4a64453b3fb80f1b81b841.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/47b077e25be1755b8c698aea97f51f7f.png"/></p>

<p>Figure 7-22. Non-hash join performance in MySQL 5.7.</p>

<p>MySQL 8.0 introduced hash join. For the same SQL query, using hash join with hints reduced the execution time to 1.22 seconds, a significant improvement over the 3.82 seconds with traditional methods.</p>

<p><img src="../Images/81e30c9f88dac4a4f7c0447c16d9c2ec.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/12c296b6f5d91c71b24391af9c293363.png"/></p>

<p>Figure 7-23. Hash join performance in MySQL 8.0.</p>

<p>Notably, hash join in MySQL 8.0 enhances join performance under the following conditions [13]:</p>

<ol>
  <li>No index is available</li>
  <li>The query is I/O-bound</li>
  <li>A large portion of a table is accessed</li>
  <li>There are selective conditions across multiple tables</li>
  <li>Increasing join_buffer_size can further improve performance</li>
</ol>

<p>The introduction of hash join is a significant feature in MySQL 8.0, offering a promising solution for reducing response times.</p>

<h3 id="732-introduction-of-hypergraph-algorithm-in-mysql">7.3.2 Introduction of Hypergraph Algorithm in MySQL</h3>

<p>The hypergraph algorithm was introduced in MySQL 8.0 but is currently only available in debug mode. The following git log provides specific implementation details of the hypergraph algorithm.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">commit</span> <span class="n">b9be77784bf690173522d8db015acf0e72f28f84</span>
<span class="n">Author</span><span class="o">:</span> <span class="n">Steinar</span> <span class="n">H</span><span class="p">.</span> <span class="n">Gunderson</span> <span class="o">&lt;</span><span class="n">steinar</span><span class="p">.</span><span class="n">gunderson</span><span class="err">@</span><span class="n">oracle</span><span class="p">.</span><span class="n">com</span><span class="o">&gt;</span>
<span class="n">Date</span><span class="o">:</span>   <span class="n">Wed</span> <span class="n">May</span> <span class="mi">6</span> <span class="mi">16</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mi">13</span> <span class="mi">2020</span> <span class="o">+</span><span class="mo">0200</span>

    <span class="n">WL</span> <span class="err">#</span><span class="mi">14070</span><span class="o">:</span> <span class="n">Hypergraph</span> <span class="n">partitioning</span> <span class="n">algorithm</span>

    <span class="n">Implement</span> <span class="n">DPhyp</span> <span class="k">for</span> <span class="n">hypergraph</span> <span class="n">partitioning</span><span class="p">,</span> <span class="n">a</span> <span class="n">central</span> <span class="n">component</span> <span class="n">of</span> <span class="n">the</span> <span class="n">join</span>
    <span class="n">optimizer</span><span class="p">.</span> <span class="n">The</span> <span class="n">algorithm</span> <span class="n">enumerates</span> <span class="n">all</span> <span class="n">possible</span> <span class="n">connected</span> <span class="n">sub</span><span class="o">-</span><span class="n">hypergraphs</span>
    <span class="n">of</span> <span class="n">the</span> <span class="n">larger</span> <span class="n">join</span> <span class="n">graph</span><span class="p">,</span> <span class="n">in</span> <span class="n">a</span> <span class="n">bottom</span><span class="o">-</span><span class="n">up</span> <span class="n">fashion</span><span class="p">.</span> <span class="p">(</span><span class="n">That</span> <span class="n">is</span><span class="p">,</span> <span class="k">for</span> <span class="n">a</span> <span class="n">given</span> <span class="n">graph</span> <span class="n">G</span>
    <span class="n">with</span> <span class="n">a</span> <span class="n">subgraphs</span> <span class="n">A</span> <span class="n">and</span> <span class="n">B</span> <span class="n">than</span> <span class="n">can</span> <span class="n">further</span> <span class="n">be</span> <span class="n">partitioned</span> <span class="n">respectively</span> <span class="n">into</span> <span class="n">A1</span><span class="o">/</span><span class="n">A2</span>
    <span class="n">and</span> <span class="n">B1</span><span class="o">/</span><span class="n">B2</span><span class="p">,</span> <span class="n">A1</span> <span class="n">and</span> <span class="n">A2</span> <span class="n">will</span> <span class="n">both</span> <span class="n">be</span> <span class="n">seen</span> <span class="n">before</span> <span class="n">A</span><span class="p">,</span> <span class="n">which</span> <span class="n">will</span> <span class="n">in</span> <span class="n">turn</span> <span class="n">be</span> <span class="n">seen</span>
    <span class="n">before</span> <span class="n">S</span><span class="p">.</span> <span class="n">However</span><span class="p">,</span> <span class="n">there</span> <span class="n">is</span> <span class="n">no</span> <span class="n">guarantee</span> <span class="n">that</span> <span class="n">B1</span> <span class="n">or</span> <span class="n">B2</span> <span class="n">is</span> <span class="n">seen</span> <span class="n">before</span> <span class="n">A</span><span class="p">.)</span>

    <span class="n">The</span> <span class="n">algorithm</span> <span class="n">is</span> <span class="n">described</span> <span class="n">in</span> <span class="n">the</span> <span class="n">paper</span> <span class="s">"Dynamic Programming Strikes Back"</span> <span class="n">by</span>
    <span class="n">Neumann</span> <span class="n">and</span> <span class="n">Moerkotte</span><span class="p">.</span> <span class="n">There</span> <span class="n">is</span> <span class="n">a</span> <span class="n">somewhat</span> <span class="n">extended</span> <span class="n">version</span> <span class="n">of</span> <span class="n">the</span> <span class="n">paper</span>
    <span class="p">(</span><span class="n">that</span> <span class="n">also</span> <span class="n">contains</span> <span class="n">a</span> <span class="n">few</span> <span class="n">corrections</span><span class="p">)</span> <span class="n">in</span> <span class="n">Moerkotte</span><span class="err">'</span><span class="n">s</span> <span class="n">treatise</span> <span class="s">"Building Query</span><span class="err">
</span><span class="s">    Compilers"</span><span class="p">.</span> <span class="n">Some</span> <span class="n">critical</span> <span class="n">details</span> <span class="n">are</span> <span class="n">still</span> <span class="n">missing</span><span class="p">,</span> <span class="n">which</span> <span class="n">we</span><span class="err">'</span><span class="n">ve</span> <span class="n">had</span> <span class="n">to</span> <span class="n">fill</span> <span class="n">in</span>
    <span class="n">ourselves</span><span class="p">.</span> <span class="n">We</span> <span class="n">don</span><span class="err">'</span><span class="n">t</span> <span class="n">currently</span> <span class="n">implement</span> <span class="n">the</span> <span class="n">extension</span> <span class="n">to</span> <span class="n">generalized</span>
    <span class="n">hypergraphs</span><span class="p">,</span> <span class="n">but</span> <span class="n">it</span> <span class="n">should</span> <span class="n">be</span> <span class="n">fairly</span> <span class="n">straightforward</span> <span class="n">to</span> <span class="k">do</span> <span class="n">later</span><span class="p">.</span>

    <span class="n">Since</span> <span class="n">our</span> <span class="n">graphs</span> <span class="n">can</span> <span class="n">never</span> <span class="n">have</span> <span class="n">more</span> <span class="n">than</span> <span class="mi">61</span> <span class="n">tables</span><span class="p">,</span> <span class="n">node</span> <span class="n">sets</span> <span class="n">and</span> <span class="n">edge</span> <span class="n">lists</span>
    <span class="n">are</span> <span class="n">implemented</span> <span class="k">using</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span> <span class="n">bit</span> <span class="n">sets</span><span class="p">.</span> <span class="n">This</span> <span class="n">allows</span> <span class="k">for</span> <span class="n">a</span> <span class="n">compact</span> <span class="n">representation</span>
    <span class="n">and</span> <span class="n">very</span> <span class="n">fast</span> <span class="n">set</span> <span class="n">manipulation</span><span class="p">;</span> <span class="n">the</span> <span class="n">algorithm</span> <span class="n">does</span> <span class="n">a</span> <span class="n">fair</span> <span class="n">amount</span> <span class="n">of</span>
    <span class="n">intersections</span> <span class="n">and</span> <span class="n">unions</span><span class="p">.</span> <span class="n">If</span> <span class="n">we</span> <span class="n">should</span> <span class="n">need</span> <span class="n">extensions</span> <span class="n">to</span> <span class="n">larger</span> <span class="n">graphs</span> <span class="n">later</span>
    <span class="p">(</span><span class="k">this</span> <span class="n">will</span> <span class="n">require</span> <span class="n">additional</span> <span class="n">heuristics</span> <span class="k">for</span> <span class="n">reducing</span> <span class="n">the</span> <span class="n">search</span> <span class="n">space</span><span class="p">),</span> <span class="n">we</span> <span class="n">can</span>
    <span class="n">use</span> <span class="n">dynamic</span> <span class="n">bit</span> <span class="n">sets</span><span class="p">,</span> <span class="n">although</span> <span class="n">at</span> <span class="n">a</span> <span class="n">performance</span> <span class="n">cost</span><span class="p">.</span>

    <span class="n">This</span> <span class="n">is</span> <span class="n">implemented</span> <span class="n">entirely</span> <span class="n">independently</span> <span class="n">of</span> <span class="n">the</span> <span class="n">server</span><span class="p">;</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">MySQL</span>
    <span class="n">dependencies</span><span class="p">,</span> <span class="kt">short</span> <span class="n">of</span> <span class="n">some</span> <span class="n">shared</span> <span class="n">header</span> <span class="n">files</span> <span class="k">for</span> <span class="n">bit</span> <span class="n">manipulations</span><span class="p">.</span> <span class="n">It</span> <span class="n">is</span>
    <span class="n">tested</span> <span class="k">using</span> <span class="n">unit</span> <span class="n">tests</span> <span class="n">and</span> <span class="n">microbenchmarks</span><span class="p">.</span>

    <span class="n">Change</span><span class="o">-</span><span class="n">Id</span><span class="o">:</span> <span class="n">I7912c09ab69a17e607ee3b8fb2af2bd7602e54ec</span>
</code></pre></div></div>

<p>From the above, it can be seen that the theoretical foundation for the hypergraph algorithm’s implementation is detailed in the paper “Dynamic Programming Strikes Back” [35]. This highlights the high level of complexity involved in its implementation.</p>

<p>A cost-based query optimizer is crucial for the overall performance of a database management system, particularly in finding the optimal join order. Building on the efficient <em>DPccp</em> algorithm, which uses dynamic programming, a new algorithm, <em>DPhyp</em>, is introduced to handle complex join predicates effectively. By modeling the query graph as a hypergraph and analyzing its connected subgraphs, <em>DPhyp</em> improves the optimization of non-inner joins, offering substantial performance gains over previous methods.</p>

<p>With advances in hardware, high-complexity algorithms are becoming practical. Even though some algorithms may not run in polynomial time, modern computers can handle large NP-complete problems efficiently. Dynamic programming techniques, while still exponential, are increasingly viable for moderate instance sizes, often achieving time complexities of O(2^n).</p>

<p>Nevertheless, when using the hypergraph algorithm, the number of tables involved in joins should be kept within reasonable limits to avoid potential performance problems. Performance comparisons were conducted for complex join operations in TPC-C, with and without hypergraph optimization enabled. Detailed results are shown in the following figure:</p>

<p><img src="../Images/479d19e7baca5f40961422c966334bcb.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/363e8bb8f055a7611cb80e0c62b2fa2a.png"/></p>

<p>Figure 7-24. Effects of hypergraph algorithms on typical TPC-C SQL workloads.</p>

<p>From the figure, it is evident that enabling the hypergraph algorithm results in an execution time of 0.88 seconds, whereas disabling it reduces the time to 0.03 seconds. This demonstrates the significant performance impact of using the hypergraph algorithm. In many cases, the overhead of the hypergraph can be substantial. If MySQL’s default execution plan leads to slow performance, the hypergraph algorithm might offer valuable improvements.</p>

<p>Let’s further analyze the performance of the hypergraph algorithm by examining the <em>perf</em> flame graph in the following figure.</p>

<p><img src="../Images/016861ff478ed8cbf861ab045a71f3fb.png" alt="" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/6b03a6feb6dee8e562c0970cb5417d6b.png"/></p>

<p>Figure 7-25. A typical flame graph of hypergraph algorithm.</p>

<p>From the figure, it is evident that the hypergraph algorithm (hypergraph*) consumes a significant amount of computation. Currently operating in single-threaded mode, there is substantial potential for optimizing the hypergraph algorithm.</p>

<p>Due to MySQL’s absence of query plan caching, constructing optimal execution plans with the hypergraph algorithm is time-consuming, posing challenges for its effective use in production environments.</p>

<p>Notably, AI can also be utilized for optimizing execution plans, as discussed in section 5.20.2.</p>

<h2 id="74-cost-savings-with-binlog-compression">7.4 Cost Savings with Binlog Compression</h2>

<p>Starting with MySQL 8.0.20, binlog compression is supported but disabled by default. It can be enabled with the <em>binlog_transaction_compression</em> parameter, and the <em>zstd</em> compression level can be adjusted using the <em>binlog_transaction_compression_level_zstd</em> parameter, with a default level of 3.</p>

<p>Using a Group Replication cluster within the same data center, the impact of binlog compression on TPC-C throughput and concurrency was examined using BenchmarkSQL. Both primary and secondary nodes were configured with the <em>binlog_transaction_compression</em> parameter. Specific test results are shown in the following figure:</p>

<p><img src="../Images/3f5357ee2ff758a709d1e16c5a40f1a7.png" alt="image-20240829101915930" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101915930.png"/></p>

<p>Figure 7-26. Impact of binlog compression on BenchmarkSQL performance.</p>

<p>From the figure, it is evident that enabling binlog compression significantly affects throughput, with noticeable fluctuations.</p>

<p>The next step is to compare binlog sizes before and after compression. Specific details are shown in the following figure:</p>

<p><img src="../Images/61ff7db622e36ed0918e0509e044333e.png" alt="image-20240829101936734" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101936734.png"/></p>

<p>Figure 7-27. Effects of binlog compression after BenchmarkSQL testing.</p>

<p>From the figure, it is evident that binlog compression has a notable positive effect on TPC-C testing. It’s worth noting that setting <em>binlog_row_image=minimal</em> can significantly reduce binlog size, but it has less impact on performance. Specific details are shown in the following figure:</p>

<p><img src="../Images/cd7718f0c275f3cde86b00d06d4b0b1e.png" alt="image-20240829101956608" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829101956608.png"/></p>

<p>Figure 7-28. Impact of <em>binlog_row_image=minimal</em> on BenchmarkSQL performance.</p>

<p>Finally, let’s examine the comparison of binlog sizes between <em>binlog_row_image=minimal</em> and <em>binlog_row_image=full</em>. Specific details are shown in the following figure:</p>

<p><img src="../Images/d64733af5ac5decd5731b014911e152b.png" alt="image-20240829102020166" style="zoom:150%;" data-original-src="https://enhancedformysql.github.io/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/media/image-20240829102020166.png"/></p>

<p>Figure 7-29. Effects of <em>binlog_row_image=minimal</em> after BenchmarkSQL testing.</p>

<p>From the figure, it can be seen that setting <em>binlog_row_image=minimal</em> can also significantly reduce the size of binlogs.</p>

<p>Overall, MySQL 8.0 offers effective solutions to address the problem of binlogs consuming substantial I/O space. Users can leverage binlog compression and, where feasible, further reduce binlog size by using <em>binlog_row_image=minimal</em> to save on storage costs. It’s important to note that the compression ratio can vary across different applications.</p>

<p><a href="/The-Art-of-Problem-Solving-in-Software-Engineering_How-to-Make-MySQL-Better/Chapter8.html">Next</a></p>


      
        
</body>
</html>