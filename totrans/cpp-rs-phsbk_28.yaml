- en: Errors indicating bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html](https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In C++, exceptions are sometimes used to indicate an error that is due to a
    programming bug. In many situations no exception is produced, and instead the
    invalid use of an API is simply undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, `panic!` is used for these kinds of errors, often via an [`expect`](https://doc.rust-lang.org/std/result/enum.Result.html#method.expect)
    or [`unwrap`](https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap)
    method on `Result` or `Option` or via [assertions like `assert!`](#assertions).
    While a panic in Rust may unwind the stack or abort a program, it is never undefined
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let v = vec![1,2,3];
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // panics!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let x = v[4];
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Converting `Result` or `Option` to `panic!`](#converting-result-or-option-to-panic)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is easier to convert from a `Result` or `Option` to a panic than to go the
    other way around. Therefore, many libraries in Rust are written to return `Result`
    or `Option` and allow the caller to determine whether a `None` result indicates
    a bug by using `unwrap` or `expect` to extract the value, panicking if there isn't
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: /// Returns `None` if the number cannot be divided evenly.
  prefs: []
  type: TYPE_NORMAL
- en: 'fn divide_exact(dividend: i32, divisor: i32) -> Option<i32> {'
  prefs: []
  type: TYPE_NORMAL
- en: let quotient = dividend / divisor;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if quotient * divisor == dividend {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(quotient)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Returns `None` if the number cannot be divided by 2
  prefs: []
  type: TYPE_NORMAL
- en: 'fn divide_by_two_exact(dividend: i32) -> Option<i32> {'
  prefs: []
  type: TYPE_NORMAL
- en: // divide_exact returning None here isn't a bug
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: divide_exact(dividend, 2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let res = divide_exact(10, 3); // Oops, a bug!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let x = res.unwrap();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When designing an API, if only one of a `Result`-based (or `Option`-based) or
    panicking interface is going to be offered, it is generally better to offer the
    `Result`-based interface. That way that the caller can choose to omit the pre-condition
    checks and handle the error instead or to panic because pre-conditions should
    have been met.
  prefs: []
  type: TYPE_NORMAL
- en: '[Assertions](#assertions)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rust, panics are also generated by assertions. Unlike `assert` in C++, The
    [`assert!`](https://doc.rust-lang.org/std/macro.assert.html) family of macros
    in Rust cannot be disabled. They are therefore appropriate for asserting invariants
    when creating safe wrappers for unsafe code, in addition to checking for logical
    invariants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { use std::convert::TryFrom;'
  prefs: []
  type: TYPE_NORMAL
- en: pub struct Widget<T> {
  prefs: []
  type: TYPE_NORMAL
- en: 'parts: *const T,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'part_count: usize,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'impl<T: Copy> Widget<T> {'
  prefs: []
  type: TYPE_NORMAL
- en: // ... constructor methods ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// Panics if n is greater than the number of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// parts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'pub fn get_part(&self, n: usize) -> T {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// SAFETY: Widget maintians invariant of'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // at least part_count parts, so if n is
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // less than the part count then we can
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // use it access a part.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: assert!(
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: n < self.part_count,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"index {} exceeds part count {}",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: n,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.part_count
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: );
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let idx = isize::try_from(n).expect(
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"can''t convert index to offset"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: );
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: unsafe { self.parts.offset(idx).read() }
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Rust [`debug_assert!` macro](https://doc.rust-lang.org/std/macro.debug_assert.html)
    is more like `assert!` in C++, in that it can be turned off by a compilation configuration
    option, and so is useful for encoding logical invariants that should be checked
    during development and testing, but are too expensive to check in production.
  prefs: []
  type: TYPE_NORMAL
- en: '[Other assertion macros](#other-assertion-macros)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust has several other convenience assertion macros. The macros [`assert_eq!`](https://doc.rust-lang.org/std/macro.assert_eq.html)
    and [`assert_ne!`](https://doc.rust-lang.org/std/macro.assert_ne.html) will print
    their arguments on assertion failure using the `Debug` trait implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The [`unreachable!`](https://doc.rust-lang.org/std/macro.unreachable.html) macro
    is for asserting that when matching on an enum certain cases are expected to not
    be possible. It is essentially `panic!` with a fixed error message, but better
    communicates intent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Static assertions](#static-assertions)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ also has `static_assert`, which is guaranteed to be evaluated at compile
    time, other than when used in templates. When used in templates, it is guaranteed
    to be evaluated at compile time if the template is instantiated. In Rust the same
    thing can achieved by calling `assert!` in a const block or some other [constant
    context](https://doc.rust-lang.org/reference/const_eval.html#const-context). The
    convenience macros `assert_eq!` and `assert_ne!` cannot (yet) be used in const
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: The following example fails to compile in both Rust and C++ with the message
    from the static assertion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: const {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert!(false, "static requirement");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Like with C++ `static_assert`, a Rust assertion in a const block in a generic
    definition is only evaluated when the generic arguments are known. Both the C++
    and the Rust versions of the following example only fail to compile if the `first`
    function is called on an array with a size less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { fn first<const N: usize>(arr: [i32; N]) -> i32
    {'
  prefs: []
  type: TYPE_NORMAL
- en: const {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert!(
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: N >= 1,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"array needs to have at last size 1!"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arr[0]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In C++, `static_assert` can also be used at namespace scope. To achieve an equivalent
    thing in Rust requires defining an unnamed constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'const _: () = assert!(true, "top-level assert true");'
  prefs: []
  type: TYPE_NORMAL
- en: 'const _: () = assert!(false, "top-level assert false");'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Assertions and the optimizer](#assertions-and-the-optimizer)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assertions do affect how the Rust compiler optimizes code (e.g., by enabling
    the optimizer to eliminate subsequent redundant checks) but the specific effects
    are not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Panics in embedded systems](#panics-in-embedded-systems)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When programming in Rust for embedded systems using `#![no_std]`, there is no
    default panic handler. Instead one must be specified using the `#[panic_handler]`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The Embedded Rust Book [chapter on handling panics](https://docs.rust-embedded.org/book/start/panicking.html)
    has more details on implementing panic handlers for in `no_std` programs.
  prefs: []
  type: TYPE_NORMAL
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Errors
    indicating bugs)
  prefs: []
  type: TYPE_NORMAL
