<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Pre-allocated buffers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Pre-allocated buffers</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/out_params/pre-allocated_buffers.html">https://cel.cs.brown.edu/crp/idioms/out_params/pre-allocated_buffers.html</a></blockquote>
                        
<p>There are situations where large quantities of data need to be returned from a
function that will be called repeatedly, so that incurring the copies involved
in returning by value or repeated heap allocations would be cost prohibitive.
Some of these situations include:</p>
<ul>
<li>performing file or network IO,</li>
<li>communicating with graphics hardware,</li>
<li>communicating with hardware on embedded systems, or</li>
<li>implementing cryptography algorithms.</li>
</ul>
<p>In these situations, C++ programs tend to pre-allocate buffers that are reused
for all calls. This also usually enables allocating the buffer on the stack,
rather than having to use dynamic storage.</p>
<p>The following example pre-allocates a buffer and reads a large file into it
within a loop.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;fstream&gt;

int main() {
  std::ifstream file("/path/to/file");
  if (!file.is_open()) {
    return -1;
  }

  byte buf[1024];
  while (file.good()) {
    file.read(buf, sizeof buf);
    std::streamsize count = file.gcount();

    // use data in buf
  }

  return 0;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs::File;
use std::io::{BufReader, Read};

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let mut f = BufReader::new(File::open(
        "/path/to/file",
    )?);

    let mut buf = [0u8; 1024];

    loop {
        let count = f.read(&amp;mut buf)?;
        if count == 0 {
            break;
        }

        // use data in buf
    }

    Ok(())
}</code></pre></pre>
</div>
<p>The major difference between the C++ program and the Rust program is that in the
Rust program the buffer must be initialized before it can be used. In most
cases, this one-time initialization cost is not significant. When it is, unsafe
Rust is required to avoid the initialization.</p>
<p>The technique for avoiding initialization makes use of
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>std::mem::MaybeUninit</code></a>.
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#examples">Examples of safe usage of
<code>MaybeUninit</code></a>
are given in the API documentation for the type.</p>
<p>The IO API in stable Rust does not include support for <code>MaybeUninit</code>. Instead,
there is a <a href="#upcoming-changes-and-borrowedbuf">new safe API being developed</a>
that will enable avoiding initialization without requiring unsafe Rust in code
that uses the API.</p>
<p>If the callee might need to grow the provided buffer and dynamic allocation is
allowed, then a <code>&amp;mut Vec&lt;T&gt;</code> can be used instead of <code>&amp;mut [T]</code>. This is similar
to providing a <code>std::vector&lt;T&gt;&amp;</code> in C++. To avoid unnecessary reallocation, the
vector can be created using <code>Vec::&lt;T&gt;::with_capacity(n)</code>.</p>
<h2 id="a-note-on-reading-files"><a class="header" href="#a-note-on-reading-files">A note on reading files</a></h2>
<p>While the examples here use IO to demonstrate re-using pre-allocated buffers,
there are higher-level interfaces available for reading from <code>File</code>s, both from
the <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> and
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> traits, and
from convenience functions in
<a href="https://doc.rust-lang.org/std/io/index.html#functions-1"><code>std::io</code></a> and in
<a href="https://doc.rust-lang.org/std/fs/index.html#functions-1"><code>std::fs</code></a>.</p>
<p>The techniques described here are useful, however, in other situations where a
reusable buffer is required, such as when interacting with hardware APIs, when
using existing C or C++ libraries, or when implementing algorithms that produce
larges amount of data in chunks, such as cryptography algorithms.</p>
<h2 id="upcoming-changes-and-borrowedbuf"><a class="header" href="#upcoming-changes-and-borrowedbuf">Upcoming changes and <code>BorrowedBuf</code></a></h2>
<p>The Rust community is refining approaches to working with uninitialized buffers.
On the nightly branch of Rust, one can use
<a href="https://doc.rust-lang.org/std/io/struct.BorrowedBuf.html"><code>BorrowedBuf</code></a> to
achieve the same results as when using slices of <code>MaybeUninit</code>, but without
having to write any unsafe code. The IO APIs for avoiding unnecessary
initialization use <code>BorrowedBuf</code> instead of slices of <code>MaybeUninit</code>.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;pre-allocated_buffers&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;5b23f54f-b4a2-46f5-87b4-5551a2c93be8&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nlet mut buf = [0u8; 1024];\n\nwhile let Some(count) = fetch(&amp;mut buf) {\n    // use data in buf\n}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nlet mut buf;\n\nwhile let Some(count) = fetch(&amp;mut buf) {\n    // use data in buf\n}\n```\n&quot;,&quot;```rust\nloop {\n    let mut buf = [0u8; 1024];\n    let Some(count) = fetch(&amp;mut buf) else {\n        break;\n    };\n    // use data in buf\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following is the most idiomatic way in Rust to use the following\nfunction?\n\n```rust\n/// Fetches data into the given buffer. Returns the number of bytes populated,\n/// or `None` when the end of the data is reached. The contents of `buf` will\n/// not be read.\nfn fetch(buf: &amp;mut [u8]) -&gt; Option&lt;usize&gt;\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Pre-allocated buffers">Click here to leave us feedback about this page.</a>
                        
</body>
</html>