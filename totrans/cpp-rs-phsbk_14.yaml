- en: Template classes, functions, and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/data_modeling/templates.html](https://cel.cs.brown.edu/crp/idioms/data_modeling/templates.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The most common uses of templates in C++ are to define classes, methods, or
    functions that work for any type (or at least for any type that provides certain
    methods). This use case is common in the STL for container classes (such as `<vector>`)
    and for the algorithms library (`<algorithm>`).
  prefs: []
  type: TYPE_NORMAL
- en: The following example defines a template for a directed graph represented as
    an adjacency list, where the graph is generic in the type of the labels on the
    nodes. Though the example shows a template class, the same comparisons with Rust
    apply to template methods and template functions.
  prefs: []
  type: TYPE_NORMAL
- en: The same kind of reusable code can be created in Rust using generic types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'adjacencies: Vec<Vec<usize>>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'node_labels: Vec<Label>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl<Label> DirectedGraph<Label> {
  prefs: []
  type: TYPE_NORMAL
- en: pub fn new() -> Self {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DirectedGraph {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'adjacencies: Vec::new(),'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'node_labels: Vec::new(),'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pub fn add_node(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&mut self,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'label: Label,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> usize {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.adjacencies.push(Vec::new());
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.node_labels.push(label);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.num_nodes() - 1
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pub fn add_edge(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '&mut self,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'from: usize,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'to: usize,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> Result<(), &str> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let num_nodes = self.num_nodes();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if from >= num_nodes || to >= num_nodes {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Err("Node index out of range.")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.adjacencies[from].push(to);
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ok(())
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pub fn num_nodes(&self) -> usize {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.node_labels.len()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the use case demonstrated in the above example, there are few practical differences
    between using C++ template to define a class and using and Rust's generics to
    define a struct. Whenever one would use a template that takes a `typename` or
    `class` parameter in C++, one can instead take a type parameter in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '[Operations on the parameterized type](#operations-on-the-parameterized-type)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The differences become more apparent when one attempts to perform operations
    on the values. The following code listing adds a method to get the smallest node
    in the graph to both the Rust and the C++ examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'adjacencies: Vec<Vec<usize>>, node_labels: Vec<Label>, }   impl<Label> DirectedGraph<Label>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'pub fn new() -> Self { DirectedGraph { adjacencies: Vec::new(), node_labels:
    Vec::new(), } }   pub fn add_node( &mut self, label: Label, ) -> usize { self.adjacencies.push(Vec::new());
    self.node_labels.push(label); self.num_nodes() - 1 }   pub fn num_nodes(&self)
    -> usize { self.node_labels.len() }   pub fn add_edge( &mut self, from: usize,
    to: usize, ) -> Result<(), &str> { if from > self.num_nodes() || to > self.num_nodes()
    { Err("Node not in graph.") } else { self.adjacencies[from].push(to); Ok(()) }
    }    pub fn smallest_node(&self) -> Option<usize>'
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Label: Ord,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Matches the C++, but is not the idomatic
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // implementation!
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if self.node_labels.is_empty() {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: None
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut least = &self.node_labels[0];
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let mut index = 0;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: for i in 1..self.node_labels.len() {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if *least > self.node_labels[i] {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: least = &self.node_labels[i];
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: index = i;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some(index)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The major difference between these implementations is that in the C++ version
    the `>` operator or `operator>` method is used on the values without knowing whether
    the either is defined for the type. In the Rust version, there is a constraint
    requiring that the `Label` type implement the `Ord` trait. (See the chapter on
    [concepts, interfaces, and static dispatch](./concepts.html) for more details
    on Rust traits and how they relate to C++ concepts.)
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C++ templates, generic definitions in Rust are type checked at the point
    of definition rather than at the point of use. This means that for operations
    to be used on values with the type of a type parameter, the parameter has to be
    constrained to types that implement some trait. As can be seen in the above example,
    much like with C++ concepts and `requires`, the constraint can be required for
    individual methods rather than for the whole generic class.
  prefs: []
  type: TYPE_NORMAL
- en: It is best practice in Rust to put the trait bounds on the specific things that
    require the bounds, in order to make the overall use of the types more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, a more idiomatic implementation of `smallest_node` makes use of
    Rust's iterators. This style of implementation may take some getting used to for
    programmers more accustomed to implementations in the style used in the earlier
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
  prefs: []
  type: TYPE_NORMAL
- en: 'adjacencies: Vec<Vec<usize>>, node_labels: Vec<Label>, }   impl<Label> DirectedGraph<Label>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'pub fn new() -> Self { DirectedGraph { adjacencies: Vec::new(), node_labels:
    Vec::new(), } }   pub fn add_node( &mut self, label: Label, ) -> usize { self.adjacencies.push(Vec::new());
    self.node_labels.push(label); self.num_nodes() - 1 }   pub fn num_nodes(&self)
    -> usize { self.node_labels.len() }   pub fn add_edge( &mut self, from: usize,
    to: usize, ) -> Result<(), &str> { if from > self.num_nodes() || to > self.num_nodes()
    { Err("Node not in graph.") } else { self.adjacencies[from].push(to); Ok(()) }
    }    pub fn smallest_node(&self) -> Option<usize>'
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Label: Ord,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.node_labels
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .iter()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .enumerate()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|(i, l)| (l, i))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .min()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(|(_, i)| i)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An even more idiomatic implementation would make use of the [itertools crate](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.position_min).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[`constexpr` template parameters](#constexpr-template-parameters)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust also supports the equivalent of constexpr template parameters. For example,
    one can define a generic function that returns an array of consecutive integers
    starting from a specific value and whose size is determined at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#![allow(unused)] fn main() { fn make_sequential_array<const N: usize>('
  prefs: []
  type: TYPE_NORMAL
- en: 'start: i32,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ) -> [i32; N] {
  prefs: []
  type: TYPE_NORMAL
- en: std::array::from_fn(|i| start + i as i32)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding idiomatic Rust function uses the helper `std::array::from_fn`
    to construct the array. `from_fn` itself takes as type parameters the element
    type and the constant. Those arguments are elided because Rust can infer them,
    because both are part of the type of the produced array.
  prefs: []
  type: TYPE_NORMAL
- en: '[Rust''s `Self` type](#rusts-self-type)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within a Rust struct defintion, `impl` block, or `impl` trait block, there is
    a `Self` type that is in scope. The `Self` type is the type of the class being
    defined with all of the generic type parameters filled in. It can be useful to
    refer to this type especially in cases where there are many parameters that would
    otherwise have to be listed out.
  prefs: []
  type: TYPE_NORMAL
- en: The `Self` type is necessary when defining generic traits to refer to the concrete
    implementing type. Because Rust does not have inheritance between concrete types
    and does not have method overriding, this is sufficient to avoid the need to pass
    the implementing type as a type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: For examples of this, see the chapter on the [curiously reoccurring template
    pattern](../../patterns/crtp.html#method-chaining).
  prefs: []
  type: TYPE_NORMAL
- en: '[A note on type checking and type errors](#a-note-on-type-checking-and-type-errors)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The checking of generic types at the point of definition rather than at the
    point of template expansion impacts when errors are detected and how they are
    reported. Some of this difference cannot be achieved by consistently using C++
    concepts to declare the operations required.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one might accidentally make the `nodeLabels` member a vector of
    `size_t` instead of a vector of the label parameter. If all of the test cases
    for the graph used label types that were convertible to integers, the error would
    not be detected.
  prefs: []
  type: TYPE_NORMAL
- en: A similar Rust program fails to compile, even without a function that instantiates
    the generic structure with a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Despite the error, the C++ example compiles and passes the tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Even without test cases, the Rust example fails to compile and produces a message
    useful for identifying the error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Lifetimes parameters](#lifetimes-parameters)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust's generics are also used for classes, methods, traits, and functions that
    are generic in the lifetimes of the references they manipulate. Unlike other type
    parameters, using a function with different lifetimes does not cause additional
    copies of the function to be generated in the compiled code, because lifetimes
    do not impact the runtime representation.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter on concepts includes [examples of how lifetimes interact with Rust's
    generics](./concepts.html#generics-and-lifetimes).
  prefs: []
  type: TYPE_NORMAL
- en: '[Conditional compilation](#conditional-compilation)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One significant difference between C++ templates and Rust generics is that C++
    templates are actually a more general purpose macro language, supporting things
    like conditional compilation (e.g., when used in conjunction with `if constexpr`,
    `requires`, or `std::enable_if`). Rust supports these use cases with its macro
    system, which differs significantly from C++. The most common use of the macro
    system, conditional compilation, is provided by [the `cfg` attribute and `cfg!`
    macro](https://doc.rust-lang.org/rust-by-example/attribute/cfg.html).
  prefs: []
  type: TYPE_NORMAL
- en: The separation of conditional compilation from generics in Rust involves similar
    design considerations as the omission of [template specialization](./template_specialization.html)
    from Rust.
  prefs: []
  type: TYPE_NORMAL
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Template
    classes, functions, and methods)
  prefs: []
  type: TYPE_NORMAL
