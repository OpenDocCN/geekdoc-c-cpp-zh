- en: <main class="calibre3">
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: Chapter 6. Virtual Memory
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章 虚拟内存
- en: </main>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 1 What Virtual Memory *isn't*
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 虚拟内存*不是什么*
- en: Virtual memory is often naively discussed as a way to extended your RAM by using
    the hard drive as extra, slower, system memory. That is, once your system runs
    out of memory, it flows over onto the hard drive which is used as "virtual" memory.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存通常被天真地讨论为通过使用硬盘作为额外的、较慢的系统内存来扩展你的RAM。也就是说，一旦你的系统内存不足，它就会流到硬盘上，硬盘被用作“虚拟”内存。
- en: In modern operating systems, this is commonly referred to as *swap space*, because
    unused parts of memory as swapped out to disk to free up main memory (remember,
    programs can only execute from main memory).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代操作系统中，这通常被称为*交换空间*，因为未使用的内存部分被交换到磁盘上以释放主内存（记住，程序只能从主内存中执行）。
- en: Indeed, the ability to swap out memory to disk is an important capability, but
    as you will see it is not the purpose of virtual memory, but rather a very useful
    side effect!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，将内存交换到磁盘的能力是一个重要的功能，但正如你将看到的，这并不是虚拟内存的目的，而是一个非常有用的副作用！
- en: </main>
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 2 What virtual memory *is*
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 虚拟内存*是什么*
- en: Virtual memory is all about making use of *address space*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存全部关于利用*地址空间*。
- en: The address space of a processor refers the range of possible addresses that
    it can use when loading and storing to memory. The address space is limited by
    the width of the registers, since as we know to load an address we need to issue
    a `load` instruction with the address to load from stored in a register. For example,
    registers that are 32 bits wide can hold addresses in a register range from `0x00000000`
    to `0xFFFFFFF`. 2^^(32) is equal to 4GB, so a 32 bit processor can load or store
    to up to 4GB of memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的地址空间指的是它在加载和存储到内存时可以使用的可能地址的范围。地址空间受寄存器宽度的限制，因为我们知道要加载一个地址，我们需要发出一个带有要加载地址的`load`指令，该地址存储在寄存器中。例如，32位宽的寄存器可以存储从`0x00000000`到`0xFFFFFFF`的地址。2^^(32)等于4GB，所以32位处理器可以加载或存储多达4GB的内存。
- en: 2.1 64 bit computing
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 64位计算
- en: 'New processors are generally all 64-bit processors, which as the name suggests
    has registers 64 bits wide. As an exercise, you should work out the address space
    available to these processors (hint: it is big!).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 新处理器通常是64位处理器，正如其名称所暗示的，具有64位宽的寄存器。作为一个练习，你应该计算出这些处理器可用的地址空间（提示：它很大！）。
- en: 64-bit computing does have some trade-offs against using smaller bit-width processors.
    Every program compiled in 64-bit mode requires 8-byte pointers, which can increase
    code and data size, and hence impact both instruction and data cache performance.
    However, 64-bit processors tend to have more registers, which means less need
    to save temporary variables to memory when the compiler is under register pressure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 64位计算与使用较小位宽处理器相比有一些权衡。在64位模式下编译的每个程序都需要8字节的指针，这可能会增加代码和数据的大小，从而影响指令和数据缓存性能。然而，64位处理器通常具有更多的寄存器，这意味着当编译器处于寄存器压力之下时，不需要将临时变量保存到内存中。
- en: 2.1.1 Canonical Addresses
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1 规范地址
- en: While 64-bit processors have 64-bit wide registers, systems generally do not
    implement all 64-bits for addressing — it is not actually possible to do `load`
    or `store` to all 16 exabytes of theoretical physical memory!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然64位处理器具有64位宽的寄存器，但系统通常不会实现所有64位用于寻址——实际上不可能对理论上的16艾字节物理内存的所有16艾字节进行`load`或`store`操作！
- en: Thus most architectures define an *unimplemented* region of the address space
    which the processor will consider invalid for use. x86-64 and Itanium both define
    the most-significant valid bit of an address, which must then be sign-extended
    (see [Section 2.3.1.3.1, Sign-extension](csbu-print_split_009.html#sign_extension))
    to create a valid address. The result of this is that the total address space
    is effectively divided into two parts, an upper and a lower portion, with the
    addresses in-between considered invalid. This is illustrated in [Figure 2.1.1.1,
    Illustration of canonical addresses](#canonical_address). Valid addresses are
    termed *canonical addresses* (invalid addresses being *non*-canonical).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数架构定义了一个*未实现*的地址空间区域，处理器将认为该区域无效且不可用。x86-64和Itanium都定义了地址的最重要有效位，然后必须对其进行符号扩展（见[第2.3.1.3.1节，符号扩展](csbu-print_split_009.html#sign_extension)）以创建一个有效的地址。结果是，整个地址空间实际上被分为两部分，一个上部分和一个下部分，中间的地址被认为是无效的。这如图2.1.1.1所示，有效地址被称为*规范地址*（无效地址被称为*非规范*地址）。
- en: <picture>![By defining a most-significant bit that must be sign-extended to
    create a full address, the address-space is effectively partitioned into upper
    and lower portions, with intermediate addresses considered invalid by the processor.](canonical.svg)</picture>Figure 2.1.1.1 Illustration
    of canonical addresses
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![通过定义一个必须进行符号扩展以创建完整地址的最高有效位，地址空间实际上被划分为上部分和下部分，中间地址被处理器视为无效。](canonical.svg)</picture>图2.1.1.1
    标准地址的说明
- en: The exact most-significant bit value for the processor can usually be found
    by querying the processor itself using its informational instructions. Although
    the exact value is implementation dependent, a typical value would be 48; providing
    2^(48) = 256 TiB of usable address-space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的确切最高有效位值通常可以通过使用其信息指令查询处理器本身来找到。尽管确切值取决于实现，但典型值可能是48；提供2^(48) = 256 TiB的可用地址空间。
- en: Reducing the possible address-space like this means that significant savings
    can be made with all parts of the addressing logic in the processor and related
    components, as they know they will not need to deal with full 64-bit addresses.
    Since the implementation defines the upper-bits as being signed-extended, this
    prevents portable operating systems using these bits to store or flag additional
    information and ensuring compatibility if the implementation wishes to implement
    more address-space in the future.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式减少可能的地址空间意味着处理器和相关组件的地址逻辑部分可以节省大量空间，因为它们知道它们不需要处理完整的64位地址。由于实现定义了高位为有符号扩展，这防止了可移植操作系统使用这些位来存储或标记附加信息，并确保如果实现希望在将来实现更多地址空间时保持兼容性。
- en: 2.2 Using the address space
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 使用地址空间
- en: As with most components of the operating system, virtual memory acts as an abstraction
    between the address space and the physical memory available in the system. This
    means that when a program uses an address that address does not refer to the bits
    in an actual physical location in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作系统的许多组件一样，虚拟内存充当了地址空间和系统可用物理内存之间的抽象。这意味着当一个程序使用一个地址时，该地址并不指向内存中实际物理位置的位。
- en: So to this end, we say that all addresses a program uses are *virtual*. The
    operating system keeps track of virtual addresses and how they are allocated to
    *physical* addresses. When a program does a load or store from an address, the
    processor and operating system work together to convert this virtual address to
    the actual address in the system memory chips.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这个意义上说，我们说程序使用的所有地址都是*虚拟*的。操作系统跟踪虚拟地址以及它们如何分配到*物理*地址。当程序从一个地址进行加载或存储时，处理器和操作系统一起工作，将这个虚拟地址转换为系统内存芯片中的实际地址。
- en: </main>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 3 Pages
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 页面
- en: The total address-space is divided into individual *pages*. Pages can be many
    different sizes; generally they are around 4 KiB, but this is not a hard and fast
    rule and they can be much larger but generally not any smaller. The page is the
    smallest unit of memory that the operating system and hardware can deal with.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总地址空间被划分为单独的*页面*。页面可以有不同的大小；通常它们大约是4 KiB，但这并不是一个固定的规则，它们可以更大，但通常不会更小。页面是操作系统和硬件可以处理的最小内存单位。
- en: Additionally, each page has a number of attributes set by the operating system.
    Generally, these include read, write and execute permissions for the current page.
    For example, the operating system can generally mark the code pages of a process
    with an executable flag and the processor can choose to not execute any code from
    pages without this bit set.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个页面都有操作系统设置的若干属性。通常，这些包括当前页面的读取、写入和执行权限。例如，操作系统通常会给进程的代码页面标记一个可执行标志，处理器可以选择不执行没有设置此位的任何代码页面。
- en: <picture>![Pages](page.svg)</picture>Figure 3.1 Virtual memory pages
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![Pages](page.svg)</picture>图3.1 虚拟内存页面
- en: Programmers may at this point be thinking that they can easily allocate small
    amounts of memory, much smaller than 4 KiB, using `malloc` or similar calls. This
    *heap* memory is actually backed by page-size allocations, which the `malloc`
    implementation divides up and manages for you in an efficient manner.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可能会在这个时候认为他们可以轻松地分配少量内存，远小于4 KiB，使用`malloc`或类似的调用。这种*堆*内存实际上是由页面大小的分配支持的，`malloc`实现会以高效的方式为您分割和管理这些分配。
- en: </main>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 4 Physical Memory
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 物理内存
- en: Just as the operating system divides the possible address space up into pages,
    it divides the available physical memory up into *frames*. A frame is just the
    conventional name for a hunk of physical memory the same size as the system page
    size.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如操作系统将可能的地址空间划分为页面一样，它也将可用的物理内存划分为*帧*。帧只是与系统页面大小相同的物理内存块的传统名称。
- en: The operating system keeps a *frame-table* which is a list of all possible pages
    of physical memory and if they are free (available for allocation) or not. When
    memory is allocated to a process, it is marked as used in the frame-table. In
    this way, the operating-system keeps track of all memory allocations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统维护一个*帧表*，这是一个所有可能的物理内存页面的列表，以及它们是否空闲（可用于分配）。当内存分配给一个进程时，它在帧表中标记为已使用。这样，操作系统就能跟踪所有内存分配。
- en: How does the operating system know what memory is available? This information
    about where memory is located, how much, attributes and so forth is passed to
    the operating system by the BIOS during initialisation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统如何知道哪些内存可用？有关内存位置、多少、属性等信息是在初始化过程中由BIOS传递给操作系统的。
- en: </main>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 5 Pages + Frames = Page Tables
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 页面 + 帧数 = 页面表
- en: It is the job of the operating system is to keep track of which of virtual-page
    points to which physical frame. This information is kept in a *page-table* which,
    in its simplest form, could simply be a table where each row contains its associated
    frame — this is termed a *linear page-table*. If you were to use this simple system,
    with a 32 bit address-space and 4 KiB pages there would be 1048576 possible pages
    to keep track of in the page table (2^(32) ÷ 4096); hence the table would be 1048576
    entries long to ensure we can always map a virtual page to a physical page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的任务是跟踪哪个虚拟页面指向哪个物理帧。这些信息保存在一个*页面表*中，在其最简单形式下，可以是一个表格，其中每一行包含其关联的帧——这被称为*线性页面表*。如果您使用这个简单的系统，在32位地址空间和4
    KiB页面的情况下，页面表中需要跟踪的可能页面有1048576个（2^(32) ÷ 4096）；因此，表格将包含1048576个条目以确保我们总能将虚拟页面映射到物理页面。
- en: Page tables can have many different structures and are highly optimised, as
    the process of finding a page in the page table can be a lengthy process. We will
    examine page-tables in more depth later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 页面表可以有多种不同的结构，并且高度优化，因为查找页面表中的页面可能是一个耗时的过程。我们将在稍后更深入地研究页面表。
- en: The page-table for a process is under the exclusive control of the operating
    system. When a process requests memory, the operating system finds it a free page
    of physical memory and records the virtual-to-physical translation in the processes
    page-table. Conversely, when the process gives up memory, the virtual-to-physical
    record is removed and the underlying frame becomes free for allocation to another
    process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的页面表完全由操作系统控制。当进程请求内存时，操作系统找到一个空闲的物理内存页面，并在进程的页面表中记录虚拟到物理的转换。相反，当进程释放内存时，虚拟到物理的记录被移除，底层帧变为空闲，可供其他进程分配。
- en: </main>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 6 Virtual Addresses
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 虚拟地址
- en: When a program accesses memory, it does not know or care where the physical
    memory backing the address is stored. It knows it is up to the operating system
    and hardware to work together to map locate the right physical address and thus
    provide access to the data it wants. Thus we term the address a program is using
    to access memory a *virtual address*. A virtual address consists of two parts;
    the page and an offset into that page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序访问内存时，它不知道或关心支持该地址的物理内存存储在哪里。它知道这取决于操作系统和硬件共同工作以定位正确的物理地址，从而提供对所需数据的访问。因此，我们将程序用于访问内存的地址称为*虚拟地址*。虚拟地址由两部分组成；页面和该页面的偏移量。
- en: 6.1 Page
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1 页面
- en: Since the entire possible address space is divided up into regular sized pages,
    every possible address resides within a page. The page component of the virtual
    address acts as an index into the page table. Since the page is the smallest unit
    of memory allocation within the system there is a trade-off between making pages
    very small, and thus having very many pages for the operating-system to manage,
    and making pages larger but potentially wasting memory
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个可能的地址空间被划分为固定大小的页面，每个可能的地址都位于一个页面内。虚拟地址的页面部分充当页面表的索引。由于页面是系统内内存分配的最小单元，因此存在在使页面非常小、从而为操作系统管理提供非常多的页面，以及使页面更大但可能浪费内存之间的权衡。
- en: 6.2 Offset
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2 偏移量
- en: The last bits of the virtual address are called the *offset* which is the location
    difference between the byte address you want and the start of the page. You require
    enough bits in the offset to be able to get to any byte in the page. For a 4K
    page you require (4K == (4 * 1024) == 4096 == 2^(12) ==) 12 bits of offset. Remember
    that the smallest amount of memory that the operating system or hardware deals
    with is a page, so each of these 4096 bytes reside within a single page and are
    dealt with as "one".
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址的最后几位称为*偏移量*，它是你想要的字节地址与页面起始位置之间的位置差异。你需要足够的偏移量位来能够到达页面中的任何字节。对于一个4K页面，你需要（4K
    == (4 * 1024) == 4096 == 2^(12) ==) 12位的偏移量。记住，操作系统或硬件处理的最小内存单位是一个页面，因此这些4096个字节都位于单个页面内，并被当作“一个”来处理。
- en: 6.3 Virtual Address Translation
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3 虚拟地址转换
- en: Virtual address translation refers to the process of finding out which physical
    page maps to which virtual page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址转换是指找出哪个物理页面映射到哪个虚拟页面的过程。
- en: When translating a virtual-address to a physical-address we only deal with the
    *page number* . The essence of the procedure is to take the page number of the
    given address and look it up in the *page-table* to find a pointer to a physical
    address, to which the offset from the virtual address is added, giving the actual
    location in system memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在将虚拟地址转换为物理地址时，我们只处理*页面号*。这个过程的核心是取给定地址的页面号，在*页表*中查找以找到指向物理地址的指针，然后加上虚拟地址的偏移量，给出系统内存中的实际位置。
- en: Since the page-tables are under the control of the operating system, if the
    virtual-address doesn't exist in the page-table then the operating-system knows
    the process is trying to access memory that has not been allocated to it and the
    access will not be allowed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页表受操作系统的控制，如果虚拟地址不在页表中，则操作系统知道进程正在尝试访问未分配给它的内存，访问将不被允许。
- en: <picture>![Converting a virtual address to a physical address](virtaddress.svg)</picture>Figure 6.3.1 Virtual
    Address Translation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![将虚拟地址转换为物理地址](virtaddress.svg)</picture>图 6.3.1 虚拟地址转换
- en: We can follow this through for our previous example of a simple *linear* page-table.
    We calculated that a 32-bit address-space would require a table of 1048576 entries
    when using 4KiB pages. Thus to map a theoretical address of 0x80001234, the first
    step would be to remove the offset bits. In this case, with 4KiB pages, we know
    we have 12-bits (2^(12) == 4096) of offset. So we would right-shift out 12-bits
    of the virtual address, leaving us with 0x80001\. Thus (in decimal) the value
    in row 524289 of the linear page table would be the physical frame corresponding
    to this page.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照我们之前的简单*线性*页表示例来跟踪这个过程。我们计算出使用4KiB页面时，32位地址空间需要一个包含1048576个条目的表。因此，要将理论地址0x80001234映射，第一步是移除偏移量位。在这种情况下，使用4KiB页面，我们知道我们有12位（2^(12)
    == 4096）的偏移量。所以我们会将虚拟地址右移12位，留下0x80001。因此（以十进制表示），线性页表第524289行的值将是与此页面对应的物理帧。
- en: 'You might see a problem with a linear page-table: since every page must be
    accounted for, whether in use or not, a physically linear page-table is completely
    impractical with a 64-bit address space. Consider a 64-bit address space divided
    into 64 KiB pages creates 2^(64)/2^(16) = 2^(52) pages to be managed; assuming
    each page requires an 8-byte pointer to a physical location a total of 2^(52)*2³
    = 2^(55) or 32 PiB of contiguous memory would be required just for the page table!
    There are ways to split addressing up that avoid this which we will discuss later.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到线性页表的问题：由于每个页面都必须被考虑，无论是否使用，在64位地址空间中使用物理线性页表是完全不切实际的。考虑一个64位地址空间被分成64
    KiB页面，这将创建2^(64)/2^(16) = 2^(52)个页面需要管理；假设每个页面需要一个指向物理位置的8字节指针，总共需要2^(52)*2³ =
    2^(55)或32 PiB的连续内存仅用于页表！有方法可以分割地址来避免这种情况，我们将在后面讨论。
- en: </main>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 7 Consequences of virtual addresses, pages and page tables
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 虚拟地址、页面和页表的影响
- en: Virtual addressing, pages and page-tables are the basis of every modern operating
    system. It under-pins most of the things we use our systems for.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址、页面和页表是每个现代操作系统的基石。它们支撑着我们使用系统的大部分功能。
- en: 7.1 Individual address spaces
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 单独的地址空间
- en: By giving each process its own page table, every process can pretend that it
    has access to the entire address space available from the processor. It doesn't
    matter that two processes might use the same address, since different page-tables
    for each process will map it to a different frame of physical memory. Every modern
    operating system provides each process with its own address space like this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个进程提供它自己的页表，每个进程都可以假装它有权访问处理器提供的整个地址空间。两个进程可能使用相同的地址无关紧要，因为每个进程的不同页表会将其映射到物理内存的不同帧。每个现代操作系统都以这种方式为每个进程提供自己的地址空间。
- en: Over time, physical memory becomes *fragmented*, meaning that there are "holes"
    of free space in the physical memory. Having to work around these holes would
    be at best annoying and would become a serious limit to programmers. For example,
    if you `malloc` 8 KiB of memory; requiring the backing of two 4 KiB frames, it
    would be a huge unconvinced if those frames had to be contiguous (i.e., physically
    next to each other). Using virtual-addresses it does not matter; as far as the
    process is concerned it has 8 KiB of contiguous memory, even if those pages are
    backed by frames very far apart. By assigning a virtual address space to each
    process the programmer can leave working around fragmentation up to the operating
    system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，物理内存会变得*碎片化*，这意味着物理内存中会有“空洞”的空闲空间。不得不绕过这些空洞最多是令人烦恼的，并且会成为程序员的严重限制。例如，如果你`malloc`
    8 KiB的内存，需要两个4 KiB的帧作为后盾，如果这些帧必须连续（即，在物理上相邻），那将是非常令人怀疑的。使用虚拟地址则无关紧要；对于进程来说，它拥有8
    KiB的连续内存，即使这些页面由相隔很远的帧支持。通过为每个进程分配一个虚拟地址空间，程序员可以将处理碎片化的问题留给操作系统。
- en: 7.2 Protection
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 保护
- en: We previously mentioned that the virtual mode of the 386 processor is called
    protected mode, and this name arises from the protection that virtual memory can
    offer to processes running on it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，386处理器的虚拟模式被称为保护模式，这个名字来源于虚拟内存可以为运行在其上的进程提供的保护。
- en: In a system without virtual memory, every process has complete access to all
    of system memory. This means that there is nothing stopping one process from overwriting
    another processes memory, causing it to crash (or perhaps worse, return incorrect
    values, especially if that program is managing your bank account!)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有虚拟内存的系统里，每个进程都可以完全访问整个系统内存。这意味着没有任何东西可以阻止一个进程覆盖另一个进程的内存，导致它崩溃（或者更糟，返回错误值，尤其是如果那个程序正在管理你的银行账户！）
- en: This level of protection is provided because the operating system is now the
    layer of abstraction between the process and memory access. If a process gives
    a virtual address that is not covered by its page-table, then the operating system
    knows that that process is doing something wrong and can inform the process it
    has stepped out of its bounds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种级别的保护是因为操作系统现在是进程和内存访问之间的抽象层。如果一个进程提供了一个不在其页表覆盖范围内的虚拟地址，那么操作系统就知道该进程正在做错事，并且可以通知该进程它已经越界。
- en: Since each page has extra attributes, a page can be set read only, write only
    or have any number of other interesting properties. When the process tries to
    access the page, the operating system can check if it has sufficient permissions
    and stop it if it does not (writing to a read only page, for example).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个页面都有额外的属性，页面可以被设置为只读、只写或者具有任何数量的其他有趣属性。当进程尝试访问页面时，操作系统可以检查它是否有足够的权限，如果没有则阻止它（例如，向只读页面写入）。
- en: Systems that use virtual memory are inherently more stable because, assuming
    the perfect operating system, a process can only crash itself and not the entire
    system (of course, humans write operating systems and we inevitably overlook bugs
    that can still cause entire systems to crash).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟内存的系统本质上更稳定，因为，假设操作系统是完美的，一个进程只能崩溃自己，而不能崩溃整个系统（当然，人类编写操作系统，我们不可避免地会忽略仍然可能导致整个系统崩溃的bug）。
- en: 7.3 Swap
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 交换
- en: We can also now see how the swap memory is implemented. If instead of pointing
    to an area of system memory the page pointer can be changed to point to a location
    on a disk.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也可以看到交换内存是如何实现的。如果页指针不是指向系统内存的一个区域，而是可以改变指向磁盘上的一个位置。
- en: When this page is referenced, the operating system needs to move it from the
    disk back into system memory (remember, program code can only execute from system
    memory). If system memory is full, then *another* page needs to be kicked out
    of system memory and put into the swap disk before the required page can be put
    in memory. If another process wants that page that was just kicked out back again,
    the process repeats.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用这个页面时，操作系统需要将其从磁盘移动回系统内存（记住，程序代码只能从系统内存中执行）。如果系统内存已满，那么就需要将 *另一个* 页面从系统内存中移出并放入交换磁盘，然后才能将所需的页面放入内存。如果另一个进程想要那个刚刚被移出的页面，这个过程会重复。
- en: This can be a major issue for swap memory. Loading from the hard disk is very
    slow (compared to operations done in memory) and most people will be familiar
    with sitting in front of the computer whilst the hard disk churns and churns whilst
    the system remains unresponsive.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于交换内存来说可能是一个大问题。从硬盘加载非常慢（与内存中的操作相比），大多数人都会熟悉坐在电脑前，硬盘不停地旋转，而系统却无响应的情况。
- en: 7.3.1 mmap
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1 mmap
- en: A different but related process is the memory map, or `mmap` (from the system
    call name). If instead of the page table pointing to physical memory or swap the
    page table points to a file, on disk, we say the file is `mmap`ed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不同但相关的过程是内存映射，或称为 `mmap`（来自系统调用名称）。如果页表不是指向物理内存或交换空间，而是指向磁盘上的文件，我们说这个文件被 `mmap`
    了。
- en: Normally, you need to `open` a file on disk to obtain a file descriptor, and
    then `read` and `write` it in a sequential form. When a file is mmaped it can
    be accessed just like system RAM.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要 `打开` 磁盘上的一个文件来获取文件描述符，然后以顺序形式 `读取` 和 `写入` 它。当一个文件被 mmap 时，它可以像系统 RAM
    一样访问。
- en: 7.4 Sharing memory
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 内存共享
- en: Usually, each process gets its own page table, so any address it uses is mapped
    to a unique frame in physical memory. But what if the operating system points
    two page table-entries to the same frame? This means that this frame will be shared;
    and any changes that one process makes will be visible to the other.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个进程都有自己的页表，所以它使用的任何地址都会映射到物理内存中的一个唯一帧。但如果操作系统将两个页表条目指向同一个帧呢？这意味着这个帧将被共享；并且一个进程所做的任何更改都将对另一个进程可见。
- en: You can see now how threads are implemented. In [Section 4.3.1, `clone`](csbu-print_split_024.html#linux_clone)
    we said that the Linux `clone()` function could share as much or as little of
    a new process with the old process as it required. If a process calls `clone()`
    to create a new process, but requests that the two processes share the same page
    table, then you effectively have a *thread* as both processes see the same underlying
    physical memory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到线程是如何实现的。在 [第 4.3.1 节，`clone`](csbu-print_split_024.html#linux_clone)
    中，我们提到 Linux 的 `clone()` 函数可以根据需要与旧进程共享新进程的尽可能多或尽可能少的资源。如果一个进程调用 `clone()` 来创建新进程，但请求两个进程共享相同的页表，那么实际上就有一个
    *线程*，因为两个进程都看到相同的底层物理内存。
- en: You can also see now how copy on write is done. If you set the permissions of
    a page to be read-only, when a process tries to write to the page the operating
    system will be notified. If it knows that this page is a copy-on-write page, then
    it needs to make a new copy of the page in system memory and point the page in
    the page table to this new page. This can then have its attributes updated to
    have write permissions and the process has its own unique copy of the page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在也可以看到写时复制的实现方式。如果你将页面的权限设置为只读，当进程尝试写入页面时，操作系统会收到通知。如果它知道这个页面是写时复制页面，那么它需要在系统内存中创建页面的新副本，并将页表中的页面指向这个新页面。然后可以更新其属性以具有写权限，进程就有页面的唯一副本。
- en: 7.5 Disk Cache
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 磁盘缓存
- en: In a modern system, it is often the case that rather than having too little
    memory and having to swap memory out, there is more memory available than the
    system is currently using.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代系统中，通常不是内存不足需要交换内存，而是系统当前使用的内存比可用的内存多。
- en: The memory hierarchy tells us that disk access is much slower than memory access,
    so it makes sense to move as much data from disk into system memory if possible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 内存层次结构告诉我们，磁盘访问比内存访问慢得多，所以尽可能将数据从磁盘移动到系统内存是有意义的。
- en: Linux, and many other systems, will copy data from files on disk into memory
    when they are used. Even if a program only initially requests a small part of
    the file, it is highly likely that as it continues processing it will want to
    access the rest of file. When the operating system has to read or write to a file,
    it first checks if the file is in its memory cache.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Linux以及许多其他系统，在它们使用文件时，会将磁盘上的数据复制到内存中。即使一个程序最初只请求文件的一小部分，它很可能在继续处理时还需要访问文件的其余部分。当操作系统需要读取或写入文件时，它首先检查文件是否在其内存缓存中。
- en: These pages should be the first to be removed as memory pressure in the system
    increases.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统内存压力增加时，这些页面应该是首先被移除的。
- en: 7.5.1 Page Cache
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1 页缓存
- en: A term you might hear when discussing the kernel is the *page cache*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论内核时可能会听到的一个术语是*页缓存*。
- en: 'The *page cache* refers to a list of pages the kernel keeps that refer to files
    on disk. From above, swap page, mmaped pages and disk cache pages all fall into
    this category. The kernel keeps this list because it needs to be able to look
    them up quickly in response to read and write requests XXX: this bit doesn''t
    file?'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*页缓存*指的是内核保持的页面列表，这些页面指向磁盘上的文件。从上面来看，交换页、mmap页和磁盘缓存页都属于这一类。内核保持这个列表是因为它需要能够快速查找它们以响应读写请求
    XXX：这部分内容似乎不适用？'
- en: </main>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 8 Hardware Support
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 硬件支持
- en: So far, we have only mentioned that hardware works with the operating system
    to implement virtual memory. However we have glossed over the details of exactly
    how this happens.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只提到硬件与操作系统合作以实现虚拟内存。然而，我们忽略了具体是如何发生的细节。
- en: Virtual memory is necessarily quite dependent on the hardware architecture,
    and each architecture has its own subtleties. However, there are are a few universal
    elements to virtual memory in hardware.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存必然非常依赖于硬件架构，每种架构都有其自己的细微差别。然而，硬件中的虚拟内存有一些普遍的元素。
- en: 8.1 Physical v Virtual Mode
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 物理模式与虚拟模式
- en: All processors have some concept of either operating in *physical* or *virtual*
    mode. In physical mode, the hardware expects that any address will refer to an
    address in actual system memory. In virtual mode, the hardware knows that addresses
    will need to be translated to find their physical address.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有处理器都有在*物理*或*虚拟*模式下运行的概念。在物理模式下，硬件期望任何地址都将指向实际系统内存中的地址。在虚拟模式下，硬件知道地址需要被转换以找到它们的物理地址。
- en: In many processors, this two modes are simply referred to as physical and virtual
    mode. Itanium is one such example. The most common processor, the x86, has a lot
    of baggage from days before virtual memory and so the two modes are referred to
    as *real* and *protected* mode. The first processor to implement protected mode
    was the 386, and even the most modern processors in the x86 family line can still
    do real mode, though it is not used. In real mode the processor implements a form
    of memory organisation called segmentation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多处理器中，这两种模式简单地被称为物理模式和虚拟模式。安腾（Itanium）就是这样一个例子。最常见的处理器x86有很多来自虚拟内存之前的遗留问题，因此这两种模式被称为*实*模式和*保护*模式。第一个实现保护模式的处理器是386，即使是x86家族中最现代的处理器仍然可以执行实模式，尽管它不再使用。在实模式下，处理器实现了一种称为分段的内存组织形式。
- en: 8.1.1 Issues with segmentation
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1 分段问题
- en: Segmentation is really only interesting as a historical note, since virtual
    memory has made it less relevant. Segmentation has a number of drawbacks, not
    the least of which it is very confusing for inexperienced programmers, which virtual
    memory systems were largely invented to get around.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 分段实际上只作为一个历史性的注释而有趣，因为虚拟内存使其变得不那么相关。分段有几个缺点，其中最不重要的是它对经验不足的程序员来说非常复杂，而虚拟内存系统在很大程度上是为了绕过这些缺点而发明的。
- en: In segmentation there are a number of registers which hold an address that is
    the start of a segment. The only way to get to an address in memory is to specify
    it as an offset from one of these segment registers. The size of the segment (and
    hence the maximum offset you can specify) is determined by the number of bits
    available to offset from segment base register. In the x86, the maximum offset
    is 16 bits, or only 64KImagine that the maximum offset was 32 bits; in this case
    the entire address space could be accessed as an offset from a segment at `0x00000000`
    and you would essentially have a flat layout -- but it still isn't as good as
    virtual memory as you will see. In fact, the only reason it is 16 bits is because
    the original Intel processors were limited to this, and the chips maintain backwards
    compatibility. . This causes all sorts of havoc if one wants to use an address
    that is more than 64K away, which as memory grew into the megabytes (and now gigabytes)
    became more than a slight inconvenience to a complete failure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在分段中，有一些寄存器持有地址，这个地址是段的起始点。到达内存中的地址的唯一方法是将它指定为从这些段寄存器之一的一个偏移量。段的大小（因此你可以指定的最大偏移量）由可用于从段基寄存器偏移的位数决定。在x86中，最大偏移量是16位，或者只有64K。想象一下最大偏移量是32位；在这种情况下，整个地址空间都可以作为一个从`0x00000000`段偏移的偏移量来访问，你将基本上有一个平坦的布局--但它仍然不如虚拟内存好，你将看到。事实上，它之所以是16位，仅仅是因为原始的英特尔处理器被限制在这个范围内，芯片保持了向后兼容性。这如果在想要使用超过64K的地址时会导致各种混乱。随着内存增长到兆字节（现在甚至是吉字节），这变成了一个严重的不便，甚至可能导致完全失败。
- en: <picture>![A segmentation problem. You only have three segment registers, and
    can only offset a short distance from each segment. How do you get to another
    address? You need to manually reorganise the segment registers, which quickly
    becomes a bottleneck.](segmentation.svg)</picture>Figure 8.1.1.1 Segmentation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![一个分段问题。你只有三个段寄存器，并且只能从每个段偏移一个短距离。你怎么到达另一个地址？你需要手动重新组织段寄存器，这很快就会变成一个瓶颈。](segmentation.svg)</picture>图 8.1.1.1
    分段
- en: In the above figure, there are three segment registers which are all pointing
    to segments. The maximum offset (constrained by the number of bits available)
    is shown by shading. If the program wants an address outside this range, the segment
    registers must be reconfigured. This quickly becomes a major annoyance. Virtual
    memory, on the other hand, allows the program to specify any address and the operating
    system and hardware do the hard work of translating to a physical address.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图中，有三个段寄存器，它们都指向段。最大偏移量（由可用的位数限制）通过阴影显示。如果程序想要这个范围之外的地址，段寄存器必须重新配置。这很快就会变成一个主要的不便。另一方面，虚拟内存允许程序指定任何地址，操作系统和硬件则负责将这个地址转换成物理地址。
- en: 8.2 The TLB
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2 TLB
- en: The *Translation Lookaside Buffer* (or TLB for short) is the main component
    of the processor responsible for virtual-memory. It is a cache of virtual-page
    to physical-frame translations inside the processor. The operating system and
    hardware work together to manage the TLB as the system runs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换查找缓冲区*（或简称TLB）是处理器负责虚拟内存的主要组件。它是在处理器内部的一个虚拟页到物理帧转换的缓存。操作系统和硬件在系统运行时共同管理TLB。'
- en: 8.2.1 Page Faults
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1 页面错误
- en: When a virtual address is requested of the hardware — say via a `load` instruction
    requesting to get some data — the processor looks for the virtual-address to physical-address
    translation in its TLB. If it has a valid translation it can then combine this
    with the offset portion to go straight to the physical address and complete the
    load.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当硬件请求一个虚拟地址时--比如通过一个`load`指令请求获取一些数据--处理器会在其TLB中查找虚拟地址到物理地址的转换。如果它有一个有效的转换，它就可以将这个转换与偏移部分结合起来，直接访问物理地址并完成加载。
- en: However, if the processor can *not* find a translation in the TLB, the processor
    must raise a *page fault*. This is similar to an interrupt (as discussed before)
    which the operating system must handle.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果处理器在TLB中找不到翻译，它必须引发一个*页面错误*。这类似于之前讨论过的中断，操作系统必须处理它。
- en: When the operating system gets a page fault, it needs to go through its page-table
    to find the correct translation and insert it into the TLB.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统接收到页面错误时，它需要通过其页表来查找正确的翻译并将其插入到TLB中。
- en: In the case that the operating system can not find a translation in the page
    table, or alternatively if the operating system checks the permissions of the
    page in question and the process is not authorised to access it, the operating
    system must kill the process. If you have ever seen a segmentation fault (or a
    segfault) this is the operating system killing a process that has overstepped
    its bounds.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统在页面表中找不到翻译，或者如果操作系统检查了相关页面的权限，并且进程未被授权访问，操作系统必须终止该进程。如果你曾经见过段错误（或segfault），这就是操作系统终止越界进程的情况。
- en: Should the translation be found, and the TLB currently be full, then one translation
    needs to be removed before another can be inserted. It does not make sense to
    remove a translation that is likely to be used in the future, as you will incur
    the cost of finding the entry in the page-tables all over again. TLBs usually
    use something like a *Least Recently Used* or LRU algorithm, where the oldest
    translation that has not been used is ejected in favour of the new one.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了翻译，并且当前TLB已满，那么在插入另一个翻译之前需要移除一个翻译。移除将来可能被使用的翻译没有意义，因为这会导致你再次在页面表中查找条目的成本。TLBs通常使用类似*最近最少使用*（LRU）的算法，其中最老的未使用翻译将被新的翻译替换。
- en: The access can then be tried again, and, all going well, should be found in
    the TLB and translated correctly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以再次尝试访问，如果一切顺利，应该会在TLB中找到并正确翻译。
- en: 8.2.1.1 Finding the page table
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 8.2.1.1 查找页面表
- en: When we say that the operating system finds the translation in the page table,
    it is logical to ask how the operating system finds the memory that has the page
    table.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说操作系统在页面表中找到翻译时，逻辑上会问操作系统是如何找到包含页面表的内存的。
- en: The base of the page table will be kept in a register associated with each process.
    This is usually called the page-table base-register or similar. By taking the
    address in this register and adding the page number to it, the correct entry can
    be located.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 页面表的基址将被保存在与每个进程关联的寄存器中。这通常被称为页面表基址寄存器或类似名称。通过取该寄存器中的地址并加上页面号，可以找到正确的条目。
- en: 8.2.2 Other page related faults
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2 其他页面相关错误
- en: There are two other important faults that the TLB can generally generate which
    help to mange accessed and dirty pages. Each page generally contains an attribute
    in the form of a single bit which flags if the page has been accessed or is dirty.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: TLB通常可以生成两种其他重要的错误，这些错误有助于管理访问和脏页面。每个页面通常包含一个表示页面是否被访问或是否为脏的单比特属性。
- en: An accessed page is simply any page that has been accessed. When a page translation
    is initially loaded into the TLB the page can be marked as having been accessed
    (else why were you loading it in?Actually, if you were loading it in without a
    pending access this would be called *speculation*, which is where you do something
    with the expectation that it will pay off. For example, if code was reading along
    memory linearly putting the next page translation in the TLB might save time and
    give a performance improvement.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 被访问的页面简单地是指任何被访问过的页面。当页面翻译最初被加载到TLB中时，页面可以被标记为已访问（否则你为什么要加载它？实际上，如果你在没有待访问的情况下加载它，这将被称为*推测*，这是你期望它能带来回报时采取的行动。例如，如果代码线性地读取内存，将下一个页面翻译放入TLB可能会节省时间并提高性能。）
- en: The operating system can periodically go through *all* the pages and clear the
    accessed bit to get an idea of what pages are currently in use. When system memory
    becomes full and it comes time for the operating system to choose pages to be
    swapped out to disk, obviously those pages whose accessed bit has not been reset
    are the best candidates for removal, because they have not been used the longest.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统可以定期遍历**所有**页面并清除访问位，以了解当前哪些页面正在使用。当系统内存满时，操作系统需要选择将页面交换到磁盘，显然那些访问位未被重置的页面是移除的最佳候选者，因为它们未被使用的时间最长。
- en: A dirty page is one that has data written to it, and so does not match any data
    already on disk. For example, if a page is loaded in from swap and then written
    to by a process, before it can be moved out of swap it needs to have its on disk
    copy updated. A page that is clean has had no changes, so we do not need the overhead
    of copying the page back to disk.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 脏页面是指写入数据的页面，因此与磁盘上的任何数据都不匹配。例如，如果页面从交换区加载并由进程写入，在它可以从交换区移出之前，需要更新其磁盘上的副本。干净的页面没有变化，所以我们不需要将页面复制回磁盘的开销。
- en: Both are similar in that they help the operating system to manage pages. The
    general concept is that a page has two extra bits; the dirty bit and the accessed
    bit. When the page is put into the TLB, these bits are set to indicate that the
    CPU should raise a fault .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者在帮助操作系统管理页面方面是相似的。一般概念是页面有两个额外的位；脏位和访问位。当页面被放入TLB时，这些位被设置为指示CPU应该引发故障。
- en: When a process tries to reference memory, the hardware does the usual translation
    process. However, it also does an extra check to see if the accessed flag is *not*
    set. If so, it raises a fault to the operating system, which should set the bit
    and allow the process to continue. Similarly if the hardware detects that it is
    writing to a page that does not have the dirty bit set, it will raise a fault
    for the operating system to mark the page as dirty.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程尝试引用内存时，硬件会执行常规的转换过程。然而，它还会进行额外的检查，以查看访问标志是否*未*设置。如果是这样，它会向操作系统发出故障，操作系统应该设置该位并允许进程继续。同样，如果硬件检测到它正在写入一个没有设置脏位（dirty
    bit）的页面，它将向操作系统发出故障，以标记该页面为脏。
- en: 8.3 TLB Management
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3 TLB管理
- en: We can say that the TLB used by the hardware but managed by software. It is
    up to the operating system to load the TLB with correct entries and remove old
    entries.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说硬件使用的TLB由软件管理。操作系统负责将正确的条目加载到TLB中并删除旧条目。
- en: 8.3.1 Flushing the TLB
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1 刷新TLB
- en: The process of removing entries from the TLB is called *flushing*. Updating
    the TLB is a crucial part of maintaining separate address spaces for processes;
    since each process can be using the same virtual address not updating the TLB
    would mean a process might end up overwriting another processes memory (conversely,
    in the case of *threads* sharing the address-space is what you want, thus the
    TLB is *not* flushed when switching between threads in the same process).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从TLB中删除条目的过程称为*刷新*。更新TLB是维护进程独立地址空间的关键部分；因为每个进程都可能使用相同的虚拟地址，如果不更新TLB，则意味着一个进程可能会覆盖另一个进程的内存（相反，在*线程*共享地址空间的情况下，这是你所希望的，因此当在同一个进程之间切换线程时，TLB不会被刷新）。
- en: On some processors, every time there is a context switch the entire TLB is flushed.
    This can be quite expensive, since this means the new process will have to go
    through the whole process of taking a page fault, finding the page in the page
    tables and inserting the translation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些处理器中，每次进行上下文切换时，整个TLB都会被刷新。这可能会相当昂贵，因为这意味着新进程将不得不经历整个页面故障、在页面表中查找页面并插入转换的过程。
- en: Other processors implement an extra *address space ID* (ASID) which is added
    to each TLB translation to make it unique. This means each address space (usually
    each process, but remember threads want to share the same address space) gets
    its own ID which is stored along with any translations in the TLB. Thus on a context
    switch the TLB does *not* need to be flushed, since the next process will have
    a different address space ID and even if it asks for the same virtual address,
    the address space ID will differ and so the translation to physical page will
    be different. This scheme reduces flushing and increases overall system performance,
    but requires more TLB hardware to hold the ASID bits.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其他处理器实现了一个额外的*地址空间标识符*（ASID），它被添加到每个TLB转换中，使其唯一。这意味着每个地址空间（通常是每个进程，但请记住线程想要共享相同的地址空间）都获得自己的ID，该ID与TLB中的任何转换一起存储。因此，在上下文切换时，TLB不需要被刷新，因为下一个进程将具有不同的地址空间ID，即使它请求相同的虚拟地址，地址空间ID也会不同，因此物理页面的转换也会不同。这种方案减少了刷新并提高了整体系统性能，但需要更多的TLB硬件来存储ASID位。
- en: Generally, this is implemented by having an additional register as part of the
    process state that includes the ASID. When performing a virtual-to-physical translation,
    the TLB consults this register and will only match those entries that have the
    same ASID as the currently running process. Of course the width of this register
    determines the number of ASID's available and thus has performance implications.
    For an example of ASID's in a processor architecture see [Section 10.2.1, Address
    spaces](csbu-print_split_039.html#itanium_address_spaces).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是通过在进程状态中包含ASID（地址空间标识符）的额外寄存器来实现的。在执行虚拟到物理转换时，TLB会咨询这个寄存器，并且只会匹配具有与当前运行进程相同ASID的条目。当然，这个寄存器的宽度决定了可用的ASID数量，从而具有性能影响。有关处理器架构中ASID的示例，请参阅[第10.2.1节，地址空间](csbu-print_split_039.html#itanium_address_spaces)。
- en: 8.3.2 Hardware v Software loaded TLB
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2 硬件和软件加载的TLB
- en: While the control of what ends up in the TLB is the domain of the operating
    system; it is not the whole story. The process described in [Section 8.2.1, Page
    Faults](#page_faults) describes a page-fault being raised to the operating system,
    which traverses the page-table to find the virtual-to-physical translation and
    installs it in the TLB. This would be termed a *software-loaded TLB* — but there
    is another alternative; the *hardware-loaded TLB*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对 TLB 的控制是操作系统的领域；但这并不是全部。在 [第 8.2.1 节，页面错误](#page_faults) 中描述的过程描述了一个页面错误被提交给操作系统，它遍历页面表以找到虚拟到物理的转换并将其安装到
    TLB 中。这被称为 *软件加载的 TLB* — 但还有另一种选择；*硬件加载的 TLB*。
- en: In a hardware loaded TLB, the processor architecture defines a particular layout
    of page-table information ([Section 5, Pages + Frames = Page Tables](csbu-print_split_034.html#page_tables)
    which must be followed for virtual address translation to proceed. In response
    to access to a virtual-address that is not present in the TLB, the processor will
    automatically walk the page-tables to load the correct translation entry. Only
    if the translation entry does not exist will the processor raise an exception
    to be handled by the operating system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个硬件加载的 TLB 中，处理器架构定义了页面表信息的特定布局（[第 5 节，页面 + 帧等于页面表](csbu-print_split_034.html#page_tables)，这是进行虚拟地址转换必须遵循的。对于
    TLB 中不存在的虚拟地址的访问，处理器将自动遍历页面表以加载正确的转换条目。只有当转换条目不存在时，处理器才会引发异常，由操作系统处理。
- en: Implementing the page-table traversal in specialised hardware gives speed advantages
    when finding translations, but removes flexibility from operating-systems implementors
    who might like to implement alternative schemes for page-tables.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在专用硬件中实现页面表遍历在查找转换时提供了速度优势，但减少了操作系统实现者实现页面表替代方案的灵活性。
- en: All architectures can be broadly categorised into these two methodologies. Later,
    we will examine some common architectures and their virtual-memory support.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有架构都可以广泛地分为这两种方法。稍后，我们将检查一些常见的架构及其虚拟内存支持。
- en: </main>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 9 Linux Specifics
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9 Linux 特性
- en: Although the basic concepts of virtual memory remain constant, the specifics
    of implementations are highly dependent on the operating system and hardware.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然虚拟内存的基本概念保持不变，但实现的具体细节高度依赖于操作系统和硬件。
- en: 9.1 Address Space Layout
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 地址空间布局
- en: Linux divides the available address space up into a shared kernel component
    and private user space addresses. This means that addresses in the kernel port
    of the address space map to the same physical memory for each process, whilst
    user-space addresses are private to the process. On Linux, the shared kernel space
    is at the very top of the available address space. On the most common processor,
    the 32 bit x86, this split happens at the 3GB point. As 32 bits can map a maximum
    of 4GB, this leaves the top 1GB for the shared kernel regionThis is unfortunately
    an over-simplification, because many machines wanted to support more than 4GB
    per process. *High memory* support allows processors to get access to a full 4GB
    via special extensions..
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 将可用的地址空间划分为共享内核组件和私有用户空间地址。这意味着地址空间内核端口的地址映射到每个进程相同的物理内存，而用户空间地址对进程是私有的。在
    Linux 中，共享内核空间位于可用地址空间的顶部。在最常见的处理器 32 位 x86 上，这种划分发生在 3GB 处。由于 32 位可以映射最大 4GB，这为共享内核区域留下了顶部
    1GB。这不幸是一个过于简化的说法，因为许多机器希望支持每个进程超过 4GB。*高内存*支持允许处理器通过特殊扩展访问完整的 4GB。
- en: <picture>![The Linux address space layout. Note that pages in the user-space
    address space are private, whilst the kernel pages are shared.](linux-layout.svg)</picture>Figure 9.1.1 Linux
    address space layout
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![Linux 地址空间布局。注意，用户空间地址空间中的页面是私有的，而内核页面是共享的。](linux-layout.svg)</picture>图
    9.1.1 Linux 地址空间布局
- en: 9.2 Three Level Page Table
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2 三级页面表
- en: There are many different ways for an operating system to organise the page tables
    but Linux chooses to use a *hierarchical* system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统有许多不同的方式来组织页面表，但 Linux 选择使用 *分层*系统。
- en: As the page tables use a hierarchy that is three levels deep, the Linux scheme
    is most commonly referred to as the *three level page table*. The three level
    page table has proven to be robust choice, although it is not without its criticism.
    The details of the virtual memory implementation of each processor vary Whitley
    meaning that the generic page table Linux chooses must be portable and relatively
    generic.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面表使用的是深度为三级的层次结构，Linux 方案通常被称为*三级页面表*。三级页面表已被证明是一个稳健的选择，尽管它并非没有批评。每个处理器的虚拟内存实现细节各不相同，Whitley
    意味着 Linux 选择的通用页面表必须是可移植的和相对通用的。
- en: The concept of the three level page table is not difficult. We already know
    that a virtual address consists of a page number and an offset in the physical
    memory page. In a three level page table, the virtual address is further split
    up into a number *levels*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 三级页面表的概念并不复杂。我们已经知道虚拟地址由页面号和物理内存页面中的偏移量组成。在三级页面表中，虚拟地址进一步分为*级别*数。
- en: Each level is a page table of its own right; i.e. it maps a page number of a
    physical page. In a single level page table the "level 1" entry would directly
    map to the physical frame. In the multilevel version each of the upper levels
    gives the address of the physical memory frame holding the next lower levels page
    table.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每一级都是它自己的页面表；即它映射一个物理页面的页面号。在单级页面表中，“级别1”的条目会直接映射到物理框架。在多级版本中，每一级上级都给出包含下一级页面表的物理内存框架的地址。
- en: <picture>![A three level page table](threelevel.svg)</picture>Figure 9.2.1 Linux
    Three Level Page Table
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![三级页面表](threelevel.svg)</picture>图9.2.1 Linux 三级页面表
- en: So a sample reference involves going to the top level page table, finding the
    physical frame that the next level address is on, reading that levels table and
    finding the physical frame that the next levels page table lives on, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个示例引用涉及前往顶级页面表，找到包含下一级地址的物理框架，读取该级别的表，并找到包含下一级页面表的物理框架，依此类推。
- en: At first, this model seems to be needlessly complex. The main reason this model
    is implemented is for size considerations. Imagine the theoretical situation of
    a process with only one single page mapped right near the end of its virtual address
    space. We said before that the page table entry is found as an offset from the
    page table base register, so the page table needs to be a contiguous array in
    memory. So the single page near the end of the address space requires the entire
    array, which might take up considerable space (many, many physical pages of memory).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个模型看起来过于复杂。这个模型实施的主要原因是为了考虑大小。想象一下这样一个理论情况：一个进程只有一个页面映射在其虚拟地址空间的末尾。我们之前说过，页面表条目是作为页面表基寄存器的偏移量来找到的，所以页面表需要在内存中是一个连续的数组。因此，地址空间末尾的单一页面需要整个数组，这可能会占用相当大的空间（许多许多物理页面的内存）。
- en: In a three level system, the first level is only one physical frame of memory.
    This maps to a second level, which is again only a single frame of memory, and
    again with the third. Consequently, the three level system reduces the number
    of pages required to only a fraction of those required for the single level system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个三级系统中，第一级仅是一个物理内存框架。这映射到第二级，它同样只是一个内存框架，再映射到第三级。因此，三级系统将所需的页面数量减少到单级系统所需数量的一个分数。
- en: There are obvious disadvantages to the system. Looking up a single address takes
    more references, which can be expensive. Linux understands that this system may
    not be appropriate on many different types of processor, so each architecture
    can *collapse* the page table to have less levels easily (for example, the most
    common architecture, the x86, only uses a two level system in its implementation).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统有明显的缺点。查找单个地址需要更多的引用，这可能会很昂贵。Linux 理解这个系统可能不适合许多不同类型的处理器，因此每个架构都可以轻松地将页面表*折叠*以减少级别（例如，最常用的架构
    x86 在其实现中只使用两级系统）。
- en: </main>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 10 Hardware support for virtual memory
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10 虚拟内存的硬件支持
- en: As covered in [Section 8.2, The TLB](csbu-print_split_037.html#the_tlb), the
    processor hardware provides a lookup-table that links virtual addresses to physical
    addresses. Each processor architecture defines different ways to manage the TLB
    with various advantages and disadvantages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第8.2节，转换后备缓冲区（TLB）](csbu-print_split_037.html#the_tlb)所述，处理器硬件提供了一个查找表，将虚拟地址链接到物理地址。每个处理器架构定义了不同的方式来管理
    TLB，具有各种优点和缺点。
- en: The part of the processor that deals with virtual memory is generally referred
    to as the *Memory Management Unit* or MMU
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器中处理虚拟内存的部分通常被称为*内存管理单元*或MMU
- en: 10.1 x86-64
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1 x86-64
- en: XXX
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: XXX
- en: 10.2 Itanium
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2 Itanium
- en: The Itanium MMU provides many interesting features for the operating system
    to work with virtual memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Itanium MMU为操作系统提供了许多与虚拟内存一起工作的有趣功能。
- en: 10.2.1 Address spaces
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1 地址空间
- en: '[Section 8.3.1, Flushing the TLB](csbu-print_split_037.html#flushing_tlb) introduced
    the concept of the *address-space ID* to reduce the overheads of flushing the
    TLB when context switching. However, programmers often use *threads* to allow
    execution contexts to share an address space. Each thread has the same ASID and
    hence shares TLB entries, leading to increased performance. However, a single
    ASID prevents the TLB from enforcing protection; sharing becomes an "all or nothing"
    approach. To share even a few bytes, threads must forgo all protection from each
    other (see also [Section 7.2, Protection](csbu-print_split_036.html#protection)).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8.3.1节，刷新TLB](csbu-print_split_037.html#flushing_tlb)介绍了*地址空间ID*的概念，以减少在上下文切换时刷新TLB的开销。然而，程序员经常使用*线程*来允许执行上下文共享地址空间。每个线程都有相同的ASID，因此共享TLB条目，从而提高了性能。然而，单个ASID阻止TLB执行保护；共享变成了一种“全有或全无”的方法。为了共享几个字节，线程必须放弃彼此之间的所有保护（参见[第7.2节，保护](csbu-print_split_036.html#protection)）。'
- en: <picture>![Itanium regions and protection keys. In this example the processes
    alias region 1\. Each process has a private mapping and they share a key for another.](ia64-regions-keys.svg)</picture>Figure 10.2.1.1 Illustration
    Itanium regions and protection keys
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![Itanium区域和保护键。在这个例子中，进程别名区域1。每个进程都有一个私有映射，并共享另一个的密钥。](ia64-regions-keys.svg)</picture>图10.2.1.1
    Itanium区域和保护键示意图
- en: The Itanium MMU considers these problems and provides the ability to share an
    address space (and hence translation entries) at a much lower granularity whilst
    still maintaining protection within the hardware. The Itanium divides the 64-bit
    address space up into 8 *regions*, as illustrated in [Figure 10.2.1.1, Illustration
    Itanium regions and protection keys](#ia64_regions_keys). Each process has eight
    24-bit *region registers* as part of its state, which each hold a *region ID*
    (RID) for each of the eight regions of the process address space. TLB translations
    are tagged with the RID and thus will only match if the process also holds this
    RID, as illustrated in [Figure 10.2.1.2, Illustration of Itanium TLB translation](#ia64_tlb_translation).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Itanium MMU考虑了这些问题，并提供了在硬件中保持保护的同时，以更细粒度共享地址空间（以及相应的转换条目）的能力。Itanium将64位地址空间划分为8个*区域*，如图[图10.2.1.1，Itanium区域和保护键示意图](#ia64_regions_keys)所示。每个进程作为其状态的一部分拥有八个24位的*区域寄存器*，每个寄存器为进程地址空间的八个区域中的每一个保存一个*区域ID*（RID）。TLB转换被标记为RID，因此只有当进程也持有此RID时才会匹配，如图[图10.2.1.2，Itanium
    TLB转换示意图](#ia64_tlb_translation)所示。
- en: <picture>![Illustration of the Itanium translation process (Mosberger).](ia64-tlb-translation.svg)</picture>Figure 10.2.1.2 Illustration
    of Itanium TLB translation
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![Itanium转换过程示意图（Mosberger）](ia64-tlb-translation.svg)</picture>图10.2.1.2
    Itanium TLB转换示意图
- en: Further to this, the top three bits (the region bits) are not considered in
    virtual address translation. Therefore, if two processes share a RID (i.e., hold
    the same value in one of their region registers) then they have an aliased view
    of that region. For example, if process-A holds RID `0x100` in region-register
    3 and process-B holds the same RID `0x100` in region-register 5 then process-A,
    region 3 is aliased to process-B, region 5. This limited sharing means both processes
    receive the benefits of shared TLB entries without having to grant access to their
    entire address space.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最高三位（区域位）在虚拟地址转换中不被考虑。因此，如果两个进程共享一个RID（即，在它们的区域寄存器中持有相同的值），那么它们对该区域有一个别名视图。例如，如果进程-A在区域寄存器3中持有RID
    `0x100`，而进程-B在区域寄存器5中也持有相同的RID `0x100`，那么进程-A的区域3被别名映射到进程-B的区域5。这种有限的共享意味着两个进程都能从共享的TLB条目中获得好处，而无需授予对它们整个地址空间的访问权限。
- en: 10.2.1.1 Protection Keys
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.1.1 保护键
- en: To allow for even finer grained sharing, each TLB entry on the Itanium is also
    tagged with a *protection key*. Each process has an additional number of *protection
    key registers* under operating-system control.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许更细粒度的共享，Itanium上的每个TLB条目也被标记为*保护键*。每个进程在操作系统控制下有额外的*保护键寄存器*数量。
- en: When a series of pages is to be shared (e.g., code for a shared system library),
    each page is tagged with a unique key and the OS grants any processes allowed
    to access the pages that key. When a page is referenced the TLB will check the
    key associated with the translation entry against the keys the process holds in
    its protection key registers, allowing the access if the key is present or otherwise
    raising a *protection* fault to the operating system.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当一系列页面需要共享（例如，共享系统库的代码）时，每个页面都会被标记上唯一的关键字，操作系统授予允许访问页面的任何进程该关键字。当引用页面时，TLB将检查与翻译条目关联的关键字与进程在其保护关键字寄存器中持有的关键字进行比对，如果存在关键字则允许访问，否则向操作系统引发*保护*故障。
- en: The key can also enforce permissions; for example, one process may have a key
    which grants write permissions and another may have a read-only key. This allows
    for sharing of translation entries in a much wider range of situations with granularity
    right down to a single-page level, leading to large potential improvements in
    TLB performance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字还可以强制执行权限；例如，一个进程可能有一个授予写权限的关键字，而另一个可能有一个只读关键字。这允许在更广泛的场景中共享翻译条目，粒度可以细到单页级别，从而带来TLB性能的巨大潜在改进。
- en: 10.2.2 Itanium Hardware Page-Table Walker
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2 Itanium 硬件页表遍历器
- en: Switching context to the OS when resolving a TLB miss adds significant overhead
    to the fault processing path. To combat this, Itanium allows the option of using
    built-in hardware to read the page-table and automatically load virtual-to-physical
    translations into the TLB. The hardware page-table walker (HPW) avoids the expensive
    transition to the OS, but requires translations to be in a fixed format suitable
    for the hardware to understand.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决TLB缺失时切换上下文到操作系统会增加故障处理路径的显著开销。为了解决这个问题，Itanium允许使用内置硬件读取页表并自动将虚拟到物理的转换加载到TLB中。硬件页表遍历器（HPW）避免了昂贵的操作系统转换，但需要转换以固定格式存在，以便硬件理解。
- en: The Itanium HPW is referred to in Intel's documentation as the *virtually hashed
    page-table walker* or VHPT walker, for reasons which should become clear. Itanium
    gives developers the option of two mutually exclusive HPW implementations; one
    based on a virtual linear page-table and the other based on a hash table.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在英特尔文档中，Itanium HPW被称为*虚拟哈希页表遍历器*或VHPT遍历器，原因将在下面变得清晰。Itanium为开发者提供了两种互斥的HPW实现选项；一种基于虚拟线性页表，另一种基于哈希表。
- en: It should be noted it is possible to operate with no hardware page-table walker;
    in this case each TLB miss is resolved by the OS and the processor becomes a software-loaded
    architecture. However, the performance impact of disabling the HPW is so considerable
    it is very unlikely any benefit could be gained from doing so
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，可以不使用硬件页表遍历器进行操作；在这种情况下，每个TLB缺失都由操作系统解决，处理器变成一个软件加载的架构。然而，禁用HPW的性能影响如此之大，因此不太可能从中获得任何好处。
- en: 10.2.2.1 Virtual Linear Page-Table
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.2.1 虚拟线性页表
- en: The virtual linear page-table implementation is referred to in documentation
    as the *short format virtually hashed page-table* (SF-VHPT). It is the default
    HPW model used by Linux on Itanium.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中，虚拟线性页表实现被称为*短格式虚拟哈希页表*（SF-VHPT）。它是Linux在Itanium上使用的默认HPW模型。
- en: The usual solution is a multi-level or hierarchical page-table, where the bits
    comprising the virtual page number are used as an index into intermediate levels
    of the page-table (see [Section 9.2, Three Level Page Table](csbu-print_split_038.html#three_level_page_table)).
    Empty regions of the virtual address space simply do not exist in the hierarchical
    page-table. Compared to a linear page-table, for the (realistic) case of a tightly-clustered
    and sparsely-filled address space, relatively little space is wasted in overheads.
    The major disadvantage is the multiple memory references required for lookup.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的解决方案是多级或分层页表，其中虚拟页号组成的位被用作页表中间级别的索引（参见[第9.2节，三级页表](csbu-print_split_038.html#three_level_page_table)）。虚拟地址空间的空区域在分层页表中根本不存在。与线性页表相比，对于（现实中的）紧密簇集和稀疏填充的地址空间，开销相对较小。主要的缺点是需要多次内存引用进行查找。
- en: <picture>![The hierarchical page-table](hierarchical-pt.svg)</picture>Figure 10.2.2.1.1 Illustration
    of a hierarchical page-table
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![分层页表](hierarchical-pt.svg)图10.2.2.1.1 分层页表的示意图'
- en: With a 64-bit address space, even a 512~GiB linear table identified in [Section 6.3,
    Virtual Address Translation](csbu-print_split_035.html#virtual_address_translation)
    takes only 0.003% of the 16-exabytes available. Thus a *virtual linear page-table*
    (VLPT) can be created in a contiguous area of *virtual* address space.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位地址空间中，即使在[第6.3节，虚拟地址转换](csbu-print_split_035.html#virtual_address_translation)中标识的512~GiB线性表也只占用16艾字节可用空间的0.003%。因此，可以在虚拟地址空间的连续区域创建一个*虚拟线性页表*（VLPT）。
- en: Just as for a physically linear page-table, on a TLB miss the hardware uses
    the virtual page number to offset from the page-table base. If this entry is valid,
    the translation is read and inserted directly into the TLB. However, with a VLPT
    the address of the translation entry is itself a virtual address and thus there
    is the possibility that the virtual page which it resides in is not present in
    the TLB. In this case a *nested fault* is raised to the operating system. The
    software must then correct this fault by mapping the page holding the translation
    entry into the VLPT.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如物理线性页表一样，在TLB缺失时，硬件使用虚拟页号从页表基址偏移。如果此条目有效，则读取转换并将其直接插入到TLB中。然而，对于VLPT，转换条目的地址本身就是一个虚拟地址，因此存在这样一个可能性，即它所在的虚拟页不在TLB中。在这种情况下，会向操作系统引发一个*嵌套故障*。然后，软件必须通过将包含转换条目的页面映射到VLPT来纠正这个故障。
- en: <picture>![Operation of the Itanium short-format VHPT](ia64-short-format.svg)</picture>Figure 10.2.2.1.2 Itanium
    short-format VHPT implementation
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![Itanium短格式VHPT的操作](ia64-short-format.svg)图10.2.2.1.2 Itanium短格式VHPT实现'
- en: This process can be made quite straight forward if the operating system keeps
    a hierarchical page-table. The leaf page of a hierarchical page-table holds translation
    entries for a virtually contiguous region of addresses and can thus be mapped
    by the TLB to create the VLPT as described in [Figure 10.2.2.1.2, Itanium short-format
    VHPT implementation](#ia64_short_format).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统保持一个分层页表，这个过程可以变得相当简单。分层页表的叶子页包含对地址连续区域的转换条目，因此可以通过TLB映射，如[图10.2.2.1.2，Itanium短格式VHPT实现](#ia64_short_format)中所述来创建虚拟线性页表（VLPT）。
- en: <picture>![Itanium PTE entry formats](ia64-ptes.svg)</picture>Figure 10.2.2.1.3 Itanium
    PTE entry formats
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![Itanium PTE条目格式](ia64-ptes.svg)图10.2.2.1.3 Itanium PTE条目格式'
- en: The major advantage of a VLPT occurs when an application makes repeated or contiguous
    accesses to memory. Consider that for a walk of virtually contiguous memory, the
    first fault will map a page full of translation entries into the virtual linear
    page-table. A subsequent access to the next virtual page will require the next
    translation entry to be loaded into the TLB, which is now available in the VLPT
    and thus loaded very quickly and without invoking the operating system. Overall,
    this will be an advantage if the cost of the initial nested fault is amortised
    over subsequent HPW hits.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: VLPT的主要优势在于当应用程序对内存进行重复或连续访问时。考虑一下，对于虚拟连续内存的遍历，第一次故障会将一个包含转换条目的页面映射到虚拟线性页表中。对下一个虚拟页的后续访问将需要将下一个转换条目加载到TLB中，该条目现在在VLPT中可用，因此可以非常快速地加载，而不需要调用操作系统。总体而言，如果初始嵌套故障的成本在后续HPW命中中得到摊销，这将是一个优势。
- en: The major drawback is that the VLPT now requires TLB entries which causes an
    increase on TLB pressure. Since each address space requires its own page table
    the overheads become greater as the system becomes more active. However, any increase
    in TLB capacity misses should be more than regained in lower refill costs from
    the efficient hardware walker. Note that a pathological case could skip over `page_size`
    ÷ `translation_size` entries, causing repeated nested faults, but this is a very
    unlikely access pattern.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 主要缺点是VLPT现在需要TLB条目，这导致TLB压力增加。由于每个地址空间都需要自己的页表，当系统变得更加活跃时，开销变得更大。然而，任何TLB容量缺失的增加都应该通过高效的硬件遍历器的较低填充成本得到补偿。请注意，一个病态的情况可能会跳过`page_size`
    ÷ `translation_size`条目，导致重复的嵌套故障，但这是一个非常不可能的访问模式。
- en: The hardware walker expects translation entries in a specific format as illustrated
    on the left of [Figure 10.2.2.1.3, Itanium PTE entry formats](#ia64_ptes). The
    VLPT requires translations in the so-called 8-byte *short format*. If the operating
    system is to use its page-table as backing for the VLPT (as in [Figure 10.2.2.1.2,
    Itanium short-format VHPT implementation](#ia64_short_format)) it must use this
    translation format. The architecture describes a limited number of bits in this
    format as ignored and thus available for use by software, but significant modification
    is not possible.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件页表期望以特定格式进行翻译条目，如[图10.2.2.1.3，Itanium PTE条目格式](#ia64_ptes)左侧所示。VLPT需要所谓的8字节*短格式*的翻译。如果操作系统要将其页表用作VLPT的后备（如在[图10.2.2.1.2，Itanium短格式VHPT实现](#ia64_short_format)中所示），则必须使用此翻译格式。该架构描述了在此格式中有限数量的位被忽略，因此可供软件使用，但无法进行重大修改。
- en: A linear page-table is premised on the idea of a fixed page size. Multiple page-size
    support is problematic since it means the translation for a given virtual page
    is no longer at a constant offset. To combat this, each of the 8-regions of the
    address space ([Figure 10.2.1.1, Illustration Itanium regions and protection keys](#ia64_regions_keys))
    has a separate VLPT which only maps addresses for that region. A default page-size
    can be given for each region (indeed, with Linux HugeTLB, discussed below, one
    region is dedicated to larger pages). However, page sizes can not be mixed within
    a region.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 线性页表基于固定页面大小的想法。由于这意味着给定虚拟页的翻译不再位于一个常数偏移量，因此支持多个页面大小是有问题的。为了解决这个问题，地址空间的8个区域（[图10.2.1.1，Itanium区域和保护键说明](#ia64_regions_keys)）中的每个区域都有一个单独的VLPT，它只为该区域映射地址。可以为每个区域指定默认页面大小（实际上，在下面讨论的Linux
    HugeTLB中，一个区域被专门用于更大的页面）。然而，一个区域内的页面大小不能混合。
- en: 10.2.2.2 Virtual Hash Table
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 10.2.2.2 虚拟哈希表
- en: Using TLB entries in an effort to reduce TLB refill costs, as done with the
    SF-VHPT, may or may not be an effective trade-off. Itanium also implements a *hashed
    page-table* with the potential to lower TLB overheads. In this scheme, the processor
    *hashes* a virtual address to find an offset into a contiguous table.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TLB条目以降低TLB填充成本，就像SF-VHPT所做的那样，可能或可能不是一种有效的权衡。Itanium还实现了一个具有降低TLB开销潜力的*哈希页表*。在此方案中，处理器将虚拟地址*哈希*以找到连续表中的偏移量。
- en: The previously described physically linear page-table can be considered a hash
    page-table with a *perfect* hash function which will never produce a collision.
    However, as explained, this requires an impractical trade-off of huge areas of
    contiguous physical memory. However, constraining the memory requirements of the
    page table raises the possibility of collisions when two virtual addresses hash
    to the same offset. Colliding translations require a *chain* pointer to build
    a linked-list of alternative possible entries. To distinguish which entry in the
    linked-list is the correct one requires a *tag* derived from the incoming virtual
    address.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的物理线性页表可以被视为具有*完美*哈希函数的哈希页表，该函数永远不会产生冲突。然而，正如解释的那样，这需要巨大的连续物理内存区域的不切实际的权衡。然而，限制页表的内存需求提高了当两个虚拟地址哈希到相同的偏移时发生冲突的可能性。冲突的翻译需要一个*链*指针来构建一个包含替代可能条目的链表。要区分链表中的哪个条目是正确的，需要一个从传入的虚拟地址派生的*标签*。
- en: The extra information required for each translation entry gives rise to the
    moniker *long-format*~VHPT (LF-VHPT). Translation entries grow to 32-bytes as
    illustrated on the right hand side of [Figure 10.2.2.1.3, Itanium PTE entry formats](#ia64_ptes).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个翻译条目所需额外信息导致出现了*长格式*~VHPT（LF-VHPT）的别称。翻译条目增长到32字节，如[图10.2.2.1.3，Itanium PTE条目格式](#ia64_ptes)右侧所示。
- en: The main advantage of this approach is the global hash table can be pinned with
    a single TLB entry. Since all processes share the table it should scale better
    than the SF-VHPT, where each process requires increasing numbers of TLB entries
    for VLPT pages. However, the larger entries are less cache friendly; consider
    we can fit four 8-byte short-format entries for every 32-byte long-format entry.
    The very large caches on the Itanium processor may help mitigate this impact,
    however.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的主要优势是全局哈希表可以通过单个TLB条目固定。由于所有进程共享该表，因此其扩展性应优于SF-VHPT，在SF-VHPT中，每个进程需要越来越多的TLB条目来处理VLPT页面。然而，较大的条目对缓存不太友好；考虑我们可以在每个32字节的长期格式条目中放入四个8字节的短格式条目。Itanium处理器上非常大的缓存可能有助于减轻这种影响。
- en: One advantage of the SF-VHPT is that the operating system can keep translations
    in a hierarchical page-table and, as long as the hardware translation format is
    maintained, can map leaf pages directly to the VLPT. With the LF-VHPT the OS must
    either use the hash table as the primary source of translation entries or otherwise
    keep the hash table as a cache of its own translation information. Keeping the
    LF-VHPT hash table as a cache is somewhat sub-optimal because of increased overheads
    on time critical fault paths, however advantages are gained from the table requiring
    only a single TLB entry.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: SF-VHPT的一个优点是操作系统可以将转换存储在分层页表中，并且只要硬件转换格式保持不变，就可以直接将叶页映射到VLPT。使用LF-VHPT时，操作系统必须要么使用哈希表作为转换条目的主要来源，要么将哈希表作为其转换信息的缓存。将LF-VHPT的哈希表作为缓存存在一些次优性，因为会增加时间关键故障路径上的开销，然而，由于表格只需要一个TLB条目，因此也获得了一些优势。
- en: </main>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
