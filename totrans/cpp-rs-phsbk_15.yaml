- en: Template specialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板特化
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/data_modeling/template_specialization.html](https://cel.cs.brown.edu/crp/idioms/data_modeling/template_specialization.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cel.cs.brown.edu/crp/idioms/data_modeling/template_specialization.html](https://cel.cs.brown.edu/crp/idioms/data_modeling/template_specialization.html)
- en: Template specialization in C++ makes it possible for a template entity to have
    different implementations for different parameters. Most STL implementations make
    use of this to, for example, provide a [space-efficient representation of `std::vector<bool>`](https://en.cppreference.com/w/cpp/container/vector_bool).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的模板特化使得模板实体可以为不同的参数有不同的实现。大多数 STL 实现都利用这一点，例如，提供 `[std::vector<bool>` 的空间高效表示](https://en.cppreference.com/w/cpp/container/vector_bool)。
- en: Because of the possibility of template specialization, when a C++ function operates
    on values of a template class like `std::vector`, the function is essentially
    defined in terms of the interface provided by the template class, rather than
    for a specific implementation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板特化的可能性，当一个 C++ 函数操作 `std::vector` 这样的模板类值时，该函数本质上是在模板类提供的接口的术语下定义的，而不是针对特定实现。
- en: To accomplish the same thing in Rust requires defining the function in terms
    of a trait for the interface against which it operates. This enables clients to
    select their choice of representation for data by using any concrete type that
    implements the interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Rust 中实现相同的功能，需要根据它操作的接口特质来定义函数。这使得客户端可以通过使用实现该接口的任何具体类型来选择他们选择的数据表示。
- en: This is more practical to do in Rust than in C++, because generics not being
    a general metaprogramming facility means that [generic entities can be type checked
    locally](./templates.html#a-note-on-type-checking-and-type-errors), making them
    easier to define. It is more common to do in Rust than in C++ because Rust does
    not have [implementation inheritance](./inheritance_and_reuse.html), so there
    is a sharper line between interface and implementation than there is in C++.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中这样做比在 C++ 中更实用，因为泛型不是一种通用的元编程设施意味着[泛型实体可以在本地进行类型检查](./templates.html#a-note-on-type-checking-and-type-errors)，这使得它们更容易定义。在
    Rust 中比在 C++ 中更常见，因为 Rust 没有[实现继承](./inheritance_and_reuse.html)，因此在接口和实现之间存在比
    C++ 中更清晰的界限。
- en: The following example shows how a Rust function can be implemented so that different
    concrete representations can be selected by a client. For a compact bit vector
    representation, the example uses the [`BitVec`](https://docs.rs/bitvec/latest/bitvec/vec/struct.BitVec.html)
    type from the [bitvec crate](https://docs.rs/bitvec/latest/bitvec/). `BitVec`
    is intended intended to provide an API similar to `Vec<bool>` or `std::vector<bool>`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何实现 Rust 函数，以便客户端可以选择不同的具体表示。对于紧凑的位向量表示，示例使用了来自 [bitvec crate](https://docs.rs/bitvec/latest/bitvec/)
    的 `BitVec` 类型。`BitVec` 的目的是提供类似于 `Vec<bool>` 或 `std::vector<bool>` 的 API。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Trade-offs between generics and templates](#trade-offs-between-generics-and-templates)'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[泛型和模板之间的权衡](#泛型和模板之间的权衡)'
- en: Because generic functions can only interact with generic values in ways defined
    by the trait bounds, it is easier to test generic implementations. In particular,
    code testing a generic implementation only has to consider the possible behaviors
    of the given trait.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于泛型函数只能以特质界限定义的方式与泛型值交互，因此测试泛型实现更容易。特别是，测试泛型实现的代码只需要考虑给定特质可能的行为。
- en: For a comparison, consider the following programs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，考虑以下程序。
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#![allow(unused)] fn main() { fn max<''a, T: Ord>(x: &''a T, y: &''a T) ->
    &''a T {'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { fn max<''a, T: Ord>(x: &''a T, y: &''a T) ->
    &''a T {'
- en: if x > y {
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if x > y {
- en: x
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: x
- en: '} else {'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: y
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: y
- en: '}'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the Rust program, *parametricity* means that (assuming safe Rust) from the
    type alone one can tell that if the function returns, it must return exactly one
    of `x` or `y`. This is because the trait bound `Ord` doesn't give any way to construct
    new values of type `T`, and the use of references doesn't give any way for the
    function to store one of `x` or `y` from an earlier call to return in a later
    call.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 程序中，*参数化*意味着（假设是安全的 Rust）仅从类型本身就可以判断，如果函数返回，它必须返回 `x` 或 `y` 中的一个。这是因为特质界限
    `Ord` 不提供任何构造类型 `T` 的新值的方法，而引用的使用也不提供函数从早期调用中存储 `x` 或 `y` 以在后续调用中返回的方法。
- en: In the C++ program, a call to `max` with `int` as the template parameter will
    give a distinctly different result than with any other parameter because of the
    template specialization enabling the behavior of the function to vary based on
    the type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 程序中，使用 `int` 作为模板参数调用 `max` 函数将产生与任何其他参数明显不同的结果，这是因为模板特化使得函数的行为可以根据类型而变化。
- en: The trade-off is that in Rust specialized implementations are harder to use
    because they must have different names, but that they are easier to write because
    it is easier to write generic code while being confident about its correctness.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代价是，在 Rust 中，特化的实现更难使用，因为它们必须有不同的名称，但它们更容易编写，因为在编写泛型代码的同时可以更有信心地保证其正确性。
- en: '[Niche optimization](#niche-optimization)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[利基优化](#niche-optimization)'
- en: There are several cases where the Rust compiler will perform optimizations to
    achieve more efficient representations. Those situations are all ones where the
    efficiency gains do not otherwise change the observable behavior of the code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Rust 编译器将执行优化以实现更有效的表示。这些情况都是那些效率提升不会改变代码可观察行为的情况。
- en: '[The most common case is with the `Option` type](https://doc.rust-lang.org/std/option/index.html#representation).
    When `Option` is used with a type where the compiler can tell that there are unused
    values, one of those unused values will be used to represent the `None` case,
    so that `Option<T>` will not require an extra word of memory to indicate the discriminant
    of the enum.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[最常见的案例是使用 `Option` 类型](https://doc.rust-lang.org/std/option/index.html#representation)。当
    `Option` 与编译器可以确定存在未使用值的类型一起使用时，其中一个未使用的值将被用来表示 `None` 情况，这样 `Option<T>` 就不需要额外的内存字来指示枚举的区分符。'
- en: This optimization is applied to reference types (`&` and `&mut`), since references
    cannot be null. It is also applied to `NonNull<T>`, which represents a non-null
    pointer to a value of type `T`, and to `NonZeroU8` and other non-zero integral
    types. The optimization for the reference case is what makes `Option<&T>` and
    `Option<&mut T>` safer equivalents to using non-owning observation pointers in
    C++.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化应用于引用类型（`&` 和 `&mut`），因为引用不能为空。它也应用于 `NonNull<T>`，它表示指向类型 `T` 值的非空指针，以及
    `NonZeroU8` 和其他非零整型。针对引用情况的优化使得 `Option<&T>` 和 `Option<&mut T>` 成为使用 C++ 中的非拥有观察指针的更安全等价物。
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Template
    specialization)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [点击此处给我们关于此页面的反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Template
    specialization)
