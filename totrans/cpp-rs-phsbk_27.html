<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Expected errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Expected errors</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/exceptions/expected_errors.html">https://cel.cs.brown.edu/crp/idioms/exceptions/expected_errors.html</a></blockquote>
                        
<p>In C++, <code>throw</code> both produces an error (the thrown exception) and initiates
non-local control flow (unwinding to the nearest <code>catch</code> block). In Rust, error
values (<code>Option::None</code> or <code>Result::Err</code>) are returned as normal values from a
function. Rust's <code>return</code> statement can be used to return early from a function.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;

double divide(double dividend, double divisor) {
  if (divisor == 0.0) {
    throw std::domain_error("zero divisor");
  }

  return dividend / divisor;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(
    dividend: f64,
    divisor: f64,
) -&gt; Option&lt;f64&gt; {
    if divisor == 0.0 {
        return None;
    }

    Some(dividend / divisor)
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The requirement to have the return type indicate that an error is possible means
that callbacks that are permitted to have errors need to be given an <code>Option</code> or
<code>Result</code> return type. Omitting that is like requiring callbacks to be <code>noexcept</code>
in C++. Functions that do not need to indicate errors but that will be used as
callbacks where errors are permitted will need to wrap their results in
<code>Option::Some</code> or <code>Result::Ok</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;

int produce_42() {
  return 42;
}

int fail() {
  throw std::runtime_error("oops");
}

int useCallback(int (*func)(void)) {
  return func();
}

int main() {
  try {
    int x = useCallback(produce_42);
    int y = useCallback(fail);

    // use x and y
  } catch (std::runtime_error &amp;e) {
    // handle error
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn produce_42() -&gt; i32 {
    42
}

fn fail() -&gt; Option&lt;i32&gt; {
    None
}

fn use_callback(
    f: impl Fn() -&gt; Option&lt;i32&gt;,
) -&gt; Option&lt;i32&gt; {
    f()
}

fn main() {
    // need to wrap produce_42 to match the
    // expected type
    let Some(x) =
        use_callback(|| Some(produce_42()))
    else {
        // handle error
        return;
    };
    let Some(y) = use_callback(fail) else {
        // handle error
        return;
    };
    // use x and y
}</code></pre></pre>
</div>
<h2 id="handling-errors"><a class="header" href="#handling-errors">Handling errors</a></h2>
<p>In C++, the only way to handle exceptions is <code>catch</code>. In Rust, all of the
features for dealing with <a href="../data_modeling/tagged_unions.html">tagged
unions</a> can be used with <code>Result</code> and
<code>Option</code>. The most approach depends on the intention of the program.</p>
<p>The basic way of handling an error indicated by a <code>Result</code> in Rust is by using
<code>match</code>.</p>
<p>Using <code>match</code> is the most general approach, because it enables handling
additional cases explicitly and can be used as an expression. <code>match</code> connotes
equal importance of all branches.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;stdexcept&gt;

int main() {
    std::vector&lt;int&gt; v;
    // ... populate v ...
    try {
        auto x = v.at(0);
        // use x
    } catch (std::out_of_range &amp;e) {
        // handle error
    }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    // ... populate v ...
    match v.get(0) {
        Some(x) =&gt; {
            // use x
        }
        None =&gt; {
            // handle error
        }
    }
}</code></pre></pre>
</div>
<p>Because handling only a single variant of a Rust enum is so common, the <code>if let</code>
syntax support that use case. The syntax both makes it clear that only the one
case is important and reduces the levels of indentation.</p>
<p><code>if let</code> is less general than <code>match</code>. It can also be used as an expression, but
can only distinguish one case from the rest. <code>if let</code> connotes that the <code>else</code>
case is not the normal case, but that some default handling will occur or some
default value will be produced.</p>
<p>Note that with <code>Result</code>, <code>if let</code> does not enable accessing the error value.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    // ... populate v ...
    if let Some(x) = v.get(0) {
        // use x
    } else {
        // handle error
    }
}</code></pre></pre>
<p>When the error handling involves some kind of control flow operation, like
<code>break</code> or <code>return</code>, the <code>let else</code> syntax is even more concise.</p>
<p>Much like normal <code>let</code> statements, <code>let else</code> statements can only be used where
statements are expected. <code>let else</code> statements also connote that the else case
is not the normal case, and that no further (normal) processing will occur.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    // ... populate v ...
    let Some(x) = v.get(0) else {
        // handle error
        return;
    };
    // use x
}</code></pre></pre>
<p><code>Result</code> and <code>Option</code> also have some helper methods for handling errors.
These methods resemble the methods on <code>std::expected</code> in C++.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;expected&gt;
#include &lt;string&gt;

int main() {
  std::expected&lt;int, std::string&gt; res(42);
  auto x(res.transform([](int n) { return n * 2; }));
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let res: Result&lt;i32, String&gt; = Ok(42);
    let x = res.map(|n| n * 2);
}</code></pre></pre>
</div>
<p>These helper methods and others are described in detail in the documentation for
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#implementations"><code>Option</code></a>
and
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#implementations"><code>Result</code></a>.</p>
<h2 id="borrowed-results"><a class="header" href="#borrowed-results">Borrowed results</a></h2>
<p>In the above examples, the successful results are borrowed from the vector. It
common to need to clone or copy the result into an owned copy, and to want to do
so without having to match on and reconstruct the value. <code>Result</code> and <code>Option</code>
have helper methods for these purposes.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = Vec::&lt;i32&gt;::new();
    v.push(42);
    let x: Option&lt;&amp;i32&gt; = v.get(0);
    let y: Option&lt;i32&gt; = v.get(0).copied();

    let mut w = Vec::&lt;String&gt;::new();
    w.push("hello".to_string());
    let s: Option&lt;&amp;String&gt; = w.get(0);
    let r: Option&lt;String&gt; = w.get(0).cloned();
}</code></pre></pre>
<h2 id="propagating-errors"><a class="header" href="#propagating-errors">Propagating errors</a></h2>
<p>In C++, exceptions propagate automatically. In Rust, errors indicated by
<code>Result</code> or <code>Option</code> must be explicitly propagated. The <code>?</code> operator is a
convenience for this. There are also several methods for manipulating <code>Result</code>
and <code>Option</code> that have a similar effect to propagating the error.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;vector&gt;

int accessValue(std::vector&lt;std::size_t&gt; indices,
                 std::vector&lt;int&gt; values,
                 std::size_t i) {
  // vector::at throws
  size_t idx(indices.at(i));
  // vector::at throws
  return values.at(idx);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn access_value(
    indices: Vec&lt;usize&gt;,
    values: Vec&lt;i32&gt;,
    i: usize,
) -&gt; Option&lt;i32&gt; {
    // * dereferences the &amp;i32 to copy it
    // ? propagates the None
    let idx = *indices.get(i)?;
    // returns the Option directly
    values.get(idx).copied()
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The above Rust example is equivalent to the following, which does not use the
<code>?</code> operator. The version using <code>?</code> is more idiomatic.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn access_value(
    indices: Vec&lt;usize&gt;,
    values: Vec&lt;i32&gt;,
    i: usize,
) -&gt; Option&lt;i32&gt; {
    // matching through the &amp; makes a copy of the i32
    let Some(&amp;idx) = indices.get(i) else {
        return None;
    };
    // still returns the Option directly
    values.get(idx).copied()
}
<span class="boring">}</span></code></pre></pre>
<p>The following example is also equivalent. It is not idiomatic (using <code>?</code> here is
more readable), but does demonstrate one of the helper methods.
<code>Option::and_then</code> is similar to <a href="https://en.cppreference.com/w/cpp/utility/optional/and_then"><code>std::optional::and_then</code> in
C++23</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn access_value(
    indices: Vec&lt;usize&gt;,
    values: Vec&lt;i32&gt;,
    i: usize,
) -&gt; Option&lt;i32&gt; {
    // matching through the &amp; makes a copy of the i32
    indices
        .get(i)
        .and_then(|idx| values.get(*idx))
        .copied()
}
<span class="boring">}</span></code></pre></pre>
<p>These helper methods and others are described in detail in the documentation for
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#implementations"><code>Option</code></a>
and
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#implementations"><code>Result</code></a>.</p>
<h2 id="uncaught-exceptions-in-main"><a class="header" href="#uncaught-exceptions-in-main">Uncaught exceptions in <code>main</code></a></h2>
<p>In C++ when an exception is uncaught, it terminates the program with a non-zero
exit code and an error message. To achieve a similar result using <code>Result</code> in
Rust, <code>main</code> can be given a return type of <code>Result</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;stdexcept&gt;

int main() {
  throw std::runtime_error("oops");
}
</code></pre>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;(), &amp;'static str&gt; {
    Err("oops")
}</code></pre>
</div>
<p>In Rust, the <code>main</code> function can return any type that implements the <a href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>Termination</code>
trait</a>, such as
<code>()</code>, <code>Result</code>, and <a href="https://doc.rust-lang.org/std/process/struct.ExitCode.html"><code>ExitCode</code></a>.
For example, <code>main</code> can return a result whose error type implements the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code>
trait</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run">#[derive(Debug)]
struct InterestingError {
    message: &amp;'static str,
    other_interesting_value: i32,
}

fn main() -&gt; Result&lt;(), InterestingError&gt; {
    Err(InterestingError {
        message: "oops",
        other_interesting_value: 9001,
    })
}</code></pre></pre>
<p>Running this program produces the output <code>Error: InterestingError { message: "oops", other_interesting_value: 9001 }</code> with an exit code of <code>1</code>.</p>
<h2 id="limitations-to-forcing-error-handling-with-result"><a class="header" href="#limitations-to-forcing-error-handling-with-result">Limitations to forcing error handling with <code>Result</code></a></h2>
<p>Returning <code>Result</code> or <code>Option</code> does not give the usual benefits when used with
APIs that pass pre-allocated buffers by mutable reference. This is because the
buffer is accessible outside of the <code>Result</code> or <code>Option</code>, and so the compiler
cannot force handling of the error case.</p>
<p>For example, in the following example the result of <code>read_line</code> can be ignored,
resulting in logic errors in the program. However, since the buffer is required
to be initialized, it will not result in memory safety violations or undefined
behavior.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut buffer = String::with_capacity(1024);
    std::io::stdin().read_line(&amp;mut buffer);
    // use buffer
}</code></pre></pre>
<p>Rust will produce a warning in this case, because of the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute"><code>#[must_use]</code>
attribute</a>
on <code>Result</code>.</p>
<pre><code class="language-text">warning: unused `Result` that must be used
 --&gt; example.rs:3:5
  |
3 |     std::io::stdin().read_line(&amp;mut buffer);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this `Result` may be an `Err` variant, which should be handled
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
3 |     let _ = std::io::stdin().read_line(&amp;mut buffer);
  |     +++++++
</code></pre>
<p><code>Option</code> does not have a <code>#[must_use]</code> attribute, so functions that return an
<code>Option</code> that must be handled (due to the <code>None</code> case indicating an error)
should be annotated with the <code>#[must_use]</code> attribute. For example, the <code>get</code>
method on slices returns <code>Option</code> and is <a href="https://doc.rust-lang.org/src/core/slice/mod.rs.html#592-595">annotated as
<code>#[must_use]</code></a>.</p>
<h2 id="designing-and-implementing-error-types"><a class="header" href="#designing-and-implementing-error-types">Designing and implementing error types</a></h2>
<p>One challenge to handling errors in Rust compared to C++ is that because error
propagation in Rust is explicit, error values from different subsystems need to
be combined into a single type in order to be propagated further up the stack.
With C++ exceptions, this requires no special effort.</p>
<p>The following example shows how such an error type is implemented manually.
Later examples show how the
<a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> and
<a href="https://docs.rs/anyhow/latest/anyhow/">anyhow</a> crates can be used to reduce the
verbosity of the implementation.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;

struct ErrorA : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowA() {}

struct ErrorB : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowB() {}

void process() {
  mightThrowA();
  mightThrowB();
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;
use std::fmt::Display;
use std::fmt::Formatter;

#[derive(Debug)]
struct ErrorA;

impl Display for ErrorA {
    fn fmt(
        &amp;self,
        fmt: &amp;mut Formatter&lt;'_&gt;,
    ) -&gt; Result&lt;(), std::fmt::Error&gt; {
        write!(fmt, "ErrorA produced")
    }
}

impl Error for ErrorA {}

fn might_throw_A() -&gt; Result&lt;(), ErrorA&gt; {
    Ok(())
}

#[derive(Debug)]
struct ErrorB;

impl Display for ErrorB {
    fn fmt(
        &amp;self,
        fmt: &amp;mut Formatter&lt;'_&gt;,
    ) -&gt; Result&lt;(), std::fmt::Error&gt; {
        write!(fmt, "ErrorB produced")
    }
}

impl Error for ErrorB {}

fn might_throw_B() -&gt; Result&lt;(), ErrorB&gt; {
    Ok(())
}

// This extra structure is needed to combine the errors
#[derive(Debug)]
enum ErrorAOrB {
    ErrorA(ErrorA),
    ErrorB(ErrorB),
}

impl Display for ErrorAOrB {
    fn fmt(
        &amp;self,
        fmt: &amp;mut Formatter&lt;'_&gt;,
    ) -&gt; Result&lt;(), std::fmt::Error&gt; {
        match self {
            Self::ErrorA(err) =&gt; err.fmt(fmt),
            Self::ErrorB(err) =&gt; err.fmt(fmt),
        }
    }
}

impl Error for ErrorAOrB {}

impl From&lt;ErrorA&gt; for ErrorAOrB {
    fn from(err: ErrorA) -&gt; Self {
        Self::ErrorA(err)
    }
}

impl From&lt;ErrorB&gt; for ErrorAOrB {
    fn from(err: ErrorB) -&gt; Self {
        Self::ErrorB(err)
    }
}

fn process() -&gt; Result&lt;(), ErrorAOrB&gt; {
    // the ? operator uses the From instance
    might_throw_A()?;
    might_throw_B()?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>The following example uses the
<a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> crate to implement the
same thing as in the above example. The C++ version shown for comparison is the
same as in the previous example.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;

struct ErrorA : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowA() {}

struct ErrorB : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowB() {}

void process() {
  mightThrowA();
  mightThrowB();
}
</code></pre>
<pre><code class="language-rust ignore">use thiserror::Error;

#[derive(Debug, Error)]
#[error("ErrorA was produced")]
struct ErrorA;

fn might_throw_A() -&gt; Result&lt;(), ErrorA&gt; {
    Ok(())
}

#[derive(Debug, Error)]
#[error("ErrorB was produced")]
struct ErrorB;

fn might_throw_B() -&gt; Result&lt;(), ErrorB&gt; {
    Ok(())
}

#[derive(Debug, Error)]
enum ErrorAOrB {
    #[error("error from source A")]
    ErrorA(#[from] ErrorA),
    #[error("error from source B")]
    ErrorB(#[from] ErrorB),
}

fn process() -&gt; Result&lt;(), ErrorAOrB&gt; {
    might_throw_A()?;
    might_throw_B()?;
    Ok(())
}</code></pre>
</div>
<h2 id="error-types-for-applications"><a class="header" href="#error-types-for-applications">Error types for applications</a></h2>
<p>When implementing an application (as opposed to a library), it is often the case
that the specific type of error isn't as significant as the ability to easily
propagate them without the verbosity of the above example. For those cases, the
<a href="https://crates.io/crates/anyhow">anyhow</a> crate provides mechanisms for
combining errors into a single error type, as well as the ability to produce
one-off errors. Since the errors types used in conjunction with anyhow still
need to implement the <code>std::error::Error</code> trait, anyhow is often used in
conjunction with thiserror.</p>
<p>Discriminating based on the type of the error, as one would do with <code>catch</code> in
C++, can be done with one of the <a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast"><code>downcast</code>
methods</a>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;exception&gt;

struct ErrorA : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowA() {}

struct ErrorB : public std::exception {
  const char *msg = "ErrorA was produced";
  const char *what() const noexcept override {
    return msg;
  }
};

void mightThrowB() {}

void process() {
  mightThrowA();
  mightThrowB();
}

int main() {
  try {
    process();
  } catch (ErrorA &amp;err) {
    // handle ErrorA
  } catch (ErrorB &amp;err) {
    // handle ErrorB
  }
}
</code></pre>
<pre><code class="language-rust ignore">use thiserror::Error;

#[derive(Debug, Error)]
#[error("ErrorA was produced")]
struct ErrorA;

fn might_throw_A() -&gt; Result&lt;(), ErrorA&gt; {
    Ok(())
}

#[derive(Debug, Error)]
#[error("ErrorB was produced")]
struct ErrorB;

fn might_throw_B() -&gt; Result&lt;(), ErrorB&gt; {
    Ok(())
}

fn process() -&gt; anyhow::Result&lt;()&gt; {
    might_throw_A()?;
    might_throw_B()?;
    Ok(())
}

fn main() {
    if let Err(err) = process() {
        if let Some(errA) =
            err.downcast_ref::&lt;ErrorA&gt;()
        {
            // handle ErrorA
        } else if let Some(errB) =
            err.downcast_ref::&lt;ErrorB&gt;()
        {
            // handle ErrorB
        }
    }
}</code></pre>
</div>
<h2 id="backtraces"><a class="header" href="#backtraces">Backtraces</a></h2>
<p>Backtraces can be manually included with errors by defining a field with the
type <a href="https://doc.rust-lang.org/std/backtrace/index.html"><code>Backtrace</code></a>. The
backtrace can be captured using the <a href="https://doc.rust-lang.org/std/backtrace/struct.Backtrace.html#method.capture"><code>Backtrace::capture</code>
method</a>.
The <a href="https://doc.rust-lang.org/std/backtrace/index.html">module documentation</a>
describes the configuration required to enable backtraces.</p>
<p>Both <a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> and
<a href="https://docs.rs/anyhow/latest/anyhow/">anyhow</a> have support for conveniently
adding backtrace information to errors. Instructions for including backtraces
are given on the main documentation page for each crate.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;expected_errors&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Errors that are expected (such as might arise from handling user input) should\nbe represented with `Result` or `Option`, rather than panics, so that they can\nbe handled.\n\nSince there are multiple kinds of errors that might be produced, `Result` should\nbe used instead of `Option` so that the errors can be distinguished, in order\nto, e.g., provide different error messages for the user.\n&quot;,&quot;id&quot;:&quot;5654c1c0-b526-4248-8684-64e55b26e715&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nuse thiserror::Error;\n\n#[derive(Clone, Copy, Debug, Error)]\nenum ProcessError {\n    #[error(\&quot;the vector is empty\&quot;)]\n    EmptyVec,\n    #[error(\&quot;the vector is too big\&quot;)]\n    TooBigVec,\n}\n\n/// Returns `Err(EmptyVec)` if the given vector is empty,\n/// or `Err(TooBigVec)` if the given vector is too big.\nfn process(userInput: Vec&lt;i32&gt;) -&gt; Result&lt;(), ProcessError&gt;;\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n/// # Panics\n///\n/// Panics if the given vector is empty or too big.\nfn process(userInput: Vec&lt;i32&gt;);\n```\n&quot;,&quot;```rust\n/// Returns `None` if the given vector is empty or too big.\nfn process(userInput: Vec&lt;i32&gt;) -&gt; Option&lt;int&gt;;\n```\n&quot;],&quot;prompt&quot;:&quot;Which Rust signature the most idiomatic to use for a translation of the\nfollowing C++ function?\n\n```cpp\n#include &lt;stdexcept&gt;\n#include &lt;vector&gt;\n\n/**\n * @exception bad_domain If the given vector is\n * empty.\n */\nvoid process(std::vector&lt;int&gt; userInput) {\n  if (userInput.empty()) {\n    throw std::domain_error(\&quot;Non-empty vector required\&quot;);\n  }\n  if (userInput.size() &gt; 100) {\n    throw std::domain_error(\&quot;Vector is too big\&quot;);\n  }\n\n  // process elements of v\n}\n```\n&quot;}},{&quot;context&quot;:&quot;The `?` operator returns early, so that the rest of the function is not\nexecuted.\n\nThe program using `match` call `f` on both `0` and `1`, while the others return\nearly and so do not call `f` on `1`.\n&quot;,&quot;id&quot;:&quot;08e6862a-31a2-4554-bfbf-bdf13cd4d8c0&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    if let Some(x) = f(0)\n        &amp;&amp; let Some(y) = f(1)\n    {\n        return Some((x, y));\n    }\n    None\n}\n```\n&quot;,&quot;```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    let Some(x) = f(0) else {\n        return None;\n    };\n    let Some(y) = f(1) else {\n        return None;\n    };\n    Some((x, y))\n}\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    match (f(0), f(1)) {\n        (Some(x), Some(y)) =&gt; Some((x, y)),\n        _ =&gt; None,\n    }\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Assume `f` is some function\n\n```rust\nfn f(i32) -&gt; Option&lt;i32&gt; {\n   // ...\n}\n```\n\nWhich programs have equivalent behavior to the following program?\n\n```rust\nfn go() -&gt; Option&lt;(i32, i32)&gt; {\n    let x = f(0)?;\n    let y = f(1)?;\n    Some((x, y))\n}\n```\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Expected errors">Click here to leave us feedback about this page.</a>
                        
</body>
</html>