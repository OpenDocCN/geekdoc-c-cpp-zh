<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Constructors</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/constructors.html">https://cel.cs.brown.edu/crp/idioms/constructors.html</a></blockquote>
                        
<p>In C++, constructors initialize objects. At the point when a constructor is executed, storage for the object has been
allocated and the constructor is only performing initialization.</p>
<p>Rust does not have constructors in the same way as C++. In Rust, there is a
single fundamental way to create an object, which is to initialize all of its
members at once. The term "constructor" or "constructor method" in Rust refers
to something more like a factory: a static method associated with a type (i.e.,
a method that does not have a <code>self</code> parameter), which returns a value of the
type.</p>
<div class="comparison">
<pre><code class="language-cpp"><span class="boring">#include &lt;thread&gt;
</span><span class="boring">unsigned int cpu_count() {
</span><span class="boring">    return std::thread::hardware_concurrency();
</span><span class="boring">}
</span><span class="boring">
</span>class ThreadPool {
  unsigned int num_threads;

public:
  ThreadPool() : num_threads(cpu_count()) {}
  ThreadPool(unsigned int nt) : num_threads(nt) {}
};

int main() {
  ThreadPool p1;
  ThreadPool p2(4);
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn cpu_count() -&gt; usize {
</span><span class="boring">    std::thread::available_parallelism().unwrap().get()
</span><span class="boring">}
</span><span class="boring">
</span>struct ThreadPool {
  num_threads: usize
}

impl ThreadPool {
    fn new() -&gt; Self {
        Self { num_threads: cpu_count() }
    }

    fn with_threads(nt: usize) -&gt; Self {
        Self { num_threads: nt }
    }
}

fn main() {
    let p1 = ThreadPool::new();
    let p2 = ThreadPool::with_threads(4);
}</code></pre></pre>
</div>
<p>In Rust, typically the primary constructor for a type is named <code>new</code>, especially if it
takes no arguments. (See the chapter on <a href="./constructors/default_constructors.html">default
constructors</a>.) Constructors based on
some specific property of the value are usually named <code>with_&lt;something&gt;</code>, e.g.,
<code>ThreadPool::with_threads</code>. See the <a href="https://rust-lang.github.io/api-guidelines/naming.html">naming
guidelines</a> for the
conventions on how to name constructor methods in Rust.</p>
<p>If the fields to be initialized are visible, there is a reasonable default
value, and the value does not manage a resource, then it is also common to use
record update syntax to initialize a value based on some default value.</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
    z: i32,
}

impl Point {
    const fn zero() -&gt; Self {
        Self { x: 0, y: 0, z: 0 }
    }
}

fn main() {
    let x_unit = Point {
        x: 1,
        ..Point::zero()
    };
}</code></pre></pre>
<p>Despite the name, "record update syntax" does not modify a record but instead
creates a new value based on another one, taking ownership of it in order to do
so.</p>
<h2 id="storage-allocation-vs-initialization"><a class="header" href="#storage-allocation-vs-initialization">Storage allocation vs initialization</a></h2>
<p>In Rust, the actual construction of a structure or enum value occurs where the
structure construction syntax (e.g., <code>ThreadPool { ... }</code>) is, after the
evaluation of the expressions for the fields (e.g., <code>cpu_count()</code>).</p>
<p>A significant implication of this difference is that storage is not allocated
for a struct in Rust at the point where the constructor method (such as
<code>ThreadPool::with_threads</code>) is called, and in fact is not allocated until after the
values of the fields of a struct have been computed (in terms of the semantics
of the language — the optimizer may still avoid the copy). Therefore there is no
straightforward way in Rust to translate patterns such as a class which stores a pointer to
itself upon construction (in Rust, this requires tools like <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a> and <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>).</p>
<h2 id="fallible-constructors"><a class="header" href="#fallible-constructors">Fallible constructors</a></h2>
<p>In C++, the primary way constructors can indicate failure is by throwing
exceptions. In Rust, because constructors are normal static methods, fallible
constructors can instead return <code>Result</code> (akin to <code>std::expected</code>) or <code>Option</code>
(akin to <code>std::optional</code>).<sup class="footnote-reference" id="fr-NonZero-1"><a href="#footnote-NonZero">1</a></sup></p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

class ThreadPool {
  unsigned int num_threads;

public:
  ThreadPool(unsigned int nt) : num_threads(nt) {
    if (num_threads == 0) {
      throw std::domain_error(
          "Cannot have zero threads");
    }
  }
};

int main() {
  try {
    ThreadPool p(0);
    // use p here
  } catch (const std::domain_error &amp;e) {
    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">struct ThreadPool {
    num_threads: usize,
}

#[derive(Debug)]
enum ThreadPoolError {
    ZeroThreads,
}

impl ThreadPool {
    fn with_threads(
        nt: usize,
    ) -&gt; Result&lt;Self, ThreadPoolError&gt; {
        if nt == 0 {
            Err(ThreadPoolError::ZeroThreads)
        } else {
            Ok(Self { num_threads: nt })
        }
    }
}

fn main() {
    match ThreadPool::with_threads(0) {
        Err(err) =&gt; println!("{:?}", err),
        Ok(p) =&gt; {
            // use p here
        }
    }
}</code></pre></pre>
</div>
<p>See <a href="./exceptions.html">the chapter on exceptions</a> for more information on
how C++ exceptions and exception handling translate to Rust.</p>
<hr/>
<ol class="footnote-definition"><li id="footnote-NonZero">
<p>An alternative approach here would be to use <code>NonZero&lt;usize&gt;</code> as the
type so that the error case wasn't possible in the first place. <a href="#fr-NonZero-1">↩</a></p>
</li>
</ol>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Constructors">Click here to leave us feedback about this page.</a>
                        
</body>
</html>