- en: Abstract classes, interfaces, and dynamic dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/data_modeling/abstract_classes.html](https://cel.cs.brown.edu/crp/idioms/data_modeling/abstract_classes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In C++ when an interface will be used with dynamic dispatch to resolve invoked
    methods, the interface is defined using an abstract class. Types that implement
    the interface inherit from the abstract class. In Rust the interface is given
    by a *trait*, which is then implemented for the types that support that trait.
    Programs can then be written over *trait objects* that use that trait as their
    base type.
  prefs: []
  type: TYPE_NORMAL
- en: The following example defines an interface, two implementations of that interface,
    and a function that takes an argument that satisfies the interface. In C++ the
    interface is defined with an abstract class with pure virtual methods, and in
    Rust the interface is defined with a trait. In both languages, the function (`printArea`
    in C++ and `print_area` in Rust) invokes a method using dynamic dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: // Define an interface
  prefs: []
  type: TYPE_NORMAL
- en: trait Shape {
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: struct Triangle {
  prefs: []
  type: TYPE_NORMAL
- en: 'base: f64,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: f64,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Implement the interface for a concrete type
  prefs: []
  type: TYPE_NORMAL
- en: impl Shape for Triangle {
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64 {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0.5 * self.base * self.height
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: struct Rectangle {
  prefs: []
  type: TYPE_NORMAL
- en: 'width: f64,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: f64,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Implement the interface for a concrete type
  prefs: []
  type: TYPE_NORMAL
- en: impl Shape for Rectangle {
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64 {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.width * self.height
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Use a value via a reference to the interface
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_area(shape: &dyn Shape) {'
  prefs: []
  type: TYPE_NORMAL
- en: println!("{}", shape.area());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let triangle = Triangle {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'base: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_area(&triangle);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Use a value via an owned pointer to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // interface
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let shape: Box<dyn Shape> = if true {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Box::new(Rectangle {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'width: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '})'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Box::new(triangle)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Convert to a reference to the interface
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_area(shape.as_ref());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are several places where the Rust implementation differs slightly from
    the C++ implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, a trait's methods are always visible whenever the trait itself is visible.
    Additionally, the fact that a type implements a trait is always visible whenever
    both the trait and the type are visible. These properties of Rust explain the
    lack of visibility declarations in places where one might find them in C++.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, to associate methods with a type rather than value of that type, you
    use the `static` keyword. In Rust, non-static methods take an explicit `self`
    parameter. This syntactic choice makes it possible to indicate (in way similar
    to other parameters) whether the method mutates the object (by taking `&mut self`
    instead of `&self`) and whether it takes ownership of the object (by taking `self`
    instead of `&self`).
  prefs: []
  type: TYPE_NORMAL
- en: Rust methods do not need to be declared as virtual. Because of differences in
    vtable representation, all methods for a type are available for dynamic dispatch.
    Types of values that use vtables are indicated with the `dyn` keyword. This is
    further described [below](#vtables-and-rust-trait-object-types).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Rust does not have an equivalent for the virtual destructor declaration
    because in Rust every vtable includes the drop behavior (whether given by a user
    defined `Drop` implementation or not) required for the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Vtables and Rust trait object types](#vtables-and-rust-trait-object-types)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ and Rust both requires some kind of indirection to perform dynamic dispatch
    against an interface. In C++ this indirection takes the form of a pointer to the
    abstract class (instead of the derived concrete class), making use of a vtable
    to resolve the virtual method.
  prefs: []
  type: TYPE_NORMAL
- en: In the above Rust example, the type `dyn Shape` is the type of a trait object
    for the `Shape` trait. A trait object includes a vtable along with the underlying
    value.
  prefs: []
  type: TYPE_NORMAL
- en: In C++ all objects whose class inherits from a class with a virtual method have
    a vtable in their representation, whether dynamic dispatch is used or not. Pointers
    or references to objects are the same size as pointers to objects without virtual
    methods, but every object includes its vtable.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, vtables are present only when values are represented as trait objects.
    The reference to the trait object is twice the size of a normal reference since
    it includes both the pointer to the value and the pointer to the vtable. In the
    Rust example above, the local variable `triangle` in `main` does not have a vtable
    in its representation, but when the reference to it is converted to a reference
    to a trait object (so that it can be passed to `print_area`), that does include
    a pointer to the vtable.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, just as abstract classes in C++ cannot be used as the type of
    a local variable, the type of a parameter of a function, or the type of a return
    value of a function, trait object types in Rust cannot be used in corresponding
    contexts. In Rust, this is enforced by the type `dyn Shape` not implementing the
    `Sized` marker trait, preventing it from being used in contexts that require knowing
    the size of a type statically.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows some places where a trait object type can and cannot
    be used due to not implementing `Sized`. The uses forbidden in Rust would also
    be forbidden in C++ because `Shape` is an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: trait Shape {
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64; }   struct Triangle {
  prefs: []
  type: TYPE_NORMAL
- en: 'base: f64, height: f64, }   impl Shape for Triangle {'
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64 { 0.5 * self.base * self.height } }   fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: // Local variables must have a known size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// let v: dyn Shape = Triangle { base: 1.0, height: 1.0 };'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // References always have a known size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let shape: &dyn Shape = &Triangle {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'base: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Boxes also always have a known size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'let boxed_shape: Box<dyn Shape> = Box::new(Triangle {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'base: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // Types like Option<T> include the value of type T directly, and so also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // need to know the size of T.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '// let v: Option<dyn Shape> = Some(Triangle { base: 1.0, height: 1.0 });'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Parameter types must have a known size.
  prefs: []
  type: TYPE_NORMAL
- en: '// fn print_area(shape: dyn Shape) { }'
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_area(shape: &dyn Shape) {}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The decision to include the vtable in the reference instead of in the value
    is one part of what makes it reasonable to use traits both for polymorphism via
    dynamic dispatch and for [polymorphism via static dispatch, where one would use
    concepts in C++](./concepts.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[Limitations of trait objects in Rust](#limitations-of-trait-objects-in-rust)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rust, not all traits can be used as the base trait for trait objects. The
    most commonly encountered restriction is that traits that require knowledge of
    the object's size via a `Sized` supertrait are not `dyn`-compatible. There are
    [additional restrictions](https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: '[Trait objects and lifetimes](#trait-objects-and-lifetimes)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects which are used with dynamic dispatch may contain pointers or references
    to other objects. In C++ the lifetimes of those references must be tracked manually
    by the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Rust checks the bounds on the lifetimes of references that the trait objects
    may contain. If the bounds are not given explicitly, they are determined according
    to the [lifetime elision rules](https://doc.rust-lang.org/reference/lifetime-elision.html#r-lifetime-elision.trait-object).
    The bound is part of the type of the trait object.
  prefs: []
  type: TYPE_NORMAL
- en: Usually the elision rules pick the correct lifetime bound. Sometimes, the rules
    result in surprising error messages from the compiler. In those situations or
    when the compiler cannot determine which lifetime bound to assign, the bound may
    be given manually. The following example shows explicitly what the inferred lifetimes
    are for a structure storing a trait object and for the `print_area` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: trait Shape {
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64; }   struct Triangle {
  prefs: []
  type: TYPE_NORMAL
- en: 'base: f64, height: f64, }   impl Shape for Triangle {'
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64 { 0.5 * self.base * self.height } }   struct Scaled {
  prefs: []
  type: TYPE_NORMAL
- en: 'scale: f64,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // 'static is the lifetime that would be inferred by the lifetime elision
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // rule [lifetime-elision.trait-object.default].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'shape: Box<dyn Shape + ''static>,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: impl Shape for Scaled {
  prefs: []
  type: TYPE_NORMAL
- en: fn area(&self) -> f64 {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.scale * self.shape.area()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // These are the lifetimes that would be inferred by the lifetime elision rule
  prefs: []
  type: TYPE_NORMAL
- en: // [lifetime-elision.function.implicit-lifetime-parameters] for the reference
  prefs: []
  type: TYPE_NORMAL
- en: // and [lifetime-elision.trait-object.containing-type-unique] for the trait
  prefs: []
  type: TYPE_NORMAL
- en: // bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'fn print_area<''a>(shape: &''a (dyn Shape + ''a)) {'
  prefs: []
  type: TYPE_NORMAL
- en: println!("{}", shape.area());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: fn main() {
  prefs: []
  type: TYPE_NORMAL
- en: let triangle = Triangle {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'base: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'height: 1.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_area(&triangle);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let scaled_triangle = Scaled {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'scale: 2.0,'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'shape: Box::new(triangle),'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_area(&scaled_triangle);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Abstract
    classes, interfaces, and dynamic dispatch)
  prefs: []
  type: TYPE_NORMAL
