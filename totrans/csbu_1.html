<html><head></head><body>
<main class="calibre3">
<div id="chapter01" class="author">
<header class="calibre6">
<h2 id="calibre_toc_3" class="calibre7"><span class="first-last">Chapter<span class="first-last"> </span></span><span class="first-last">2<span class="first-last">. </span></span>Binary and Number Representation</h2></header></div></main>

<main class="calibre3">
<div id="chapter01" class="author">
<section id="binary"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_10"><span class="first-last">1<span class="first-last"> </span></span>Binary — the basis of computing</h2></header><section id="binary_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last"> </span></span>Binary Theory</h3></header><section id="binary_s1_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>Introduction</h4></header><p class="releaseinfo">Binary is a base-2 number system that uses two mutually
	exclusive states to represent information.  A binary number is
	made up of elements called <em class="calibre5">bits</em> where
	each bit can be in one of the two possible states.  Generally,
	we represent them with the numerals
	<code class="computeroutput1">1</code> and
	<code class="computeroutput1">0</code>.  We also talk about them
	being true and false.  Electrically, the two states might be
	represented by high and low voltages or some form of switch
	turned on or off.</p><p class="releaseinfo">We build binary numbers the same way we build numbers in
	our traditional base 10 system.  However, instead of a one's
	column, a 10's column, a 100's column (and so on) we have a
	one's column, a two's columns, a four's column, an eight's
	column, and so on, as illustrated below.
	</p><figure id="binary_s1_s1_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>1<span>.</span>1<span> </span></span>Binary</div></header><table class="calibre14"><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">2<sup class="calibre22">...</sup></td><td class="calibre19">2<sup class="calibre22">6</sup></td><td class="calibre19">2<sup class="calibre22">5</sup></td><td class="calibre19">2<sup class="calibre22">4</sup></td><td class="calibre19">2<sup class="calibre22">3</sup></td><td class="calibre19">2<sup class="calibre22">2</sup></td><td class="calibre19">2<sup class="calibre22">1</sup></td><td class="calibre19">2<sup class="calibre22">0</sup></td></tr><tr class="calibre16"><td class="calibre19">...</td><td class="calibre19">64</td><td class="calibre19">32</td><td class="calibre19">16</td><td class="calibre19">8</td><td class="calibre19">4</td><td class="calibre19">2</td><td class="calibre19">1</td></tr></tbody></table></figure><p class="releaseinfo">For example, to represent the number 203 in base 10, we
	know we place a <code class="computeroutput1">3</code> in the
	<code class="computeroutput1">1's</code> column, a
	<code class="computeroutput1">0</code> in the
	<code class="computeroutput1">10's</code> column and a
	<code class="computeroutput1">2</code> in the
	<code class="computeroutput1">100's</code> column.  This is
	expressed with exponents in the table below.</p><figure id="binary_s1_s1_tab2"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>1<span>.</span>2<span> </span></span>203 in base 10</div></header><table class="calibre14"><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">10<sup class="calibre22">2</sup></td><td class="calibre19">10<sup class="calibre22">1</sup></td><td class="calibre19">10<sup class="calibre22">0</sup></td></tr><tr class="calibre16"><td class="calibre19">2</td><td class="calibre19">0</td><td class="calibre19">3</td></tr></tbody></table></figure><p class="releaseinfo">Or, in other words, 2 ×
	10<sup class="calibre22">2</sup> + 3 ×
	10<sup class="calibre22">0</sup> = 200 + 3 =
	203.  To represent the same thing in binary, we would have the
	following table.</p><figure id="binary_s1_s1_tab3"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>1<span>.</span>3<span> </span></span>203 in base 2</div></header><table class="calibre14"><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">2<sup class="calibre22">7</sup></td><td class="calibre19">2<sup class="calibre22">6</sup></td><td class="calibre19">2<sup class="calibre22">5</sup></td><td class="calibre19">2<sup class="calibre22">4</sup></td><td class="calibre19">2<sup class="calibre22">3</sup></td><td class="calibre19">2<sup class="calibre22">2</sup></td><td class="calibre19">2<sup class="calibre22">1</sup></td><td class="calibre19">2<sup class="calibre22">0</sup></td></tr><tr class="calibre16"><td class="calibre19">1</td><td class="calibre19">1</td><td class="calibre19">0</td><td class="calibre19">0</td><td class="calibre19">1</td><td class="calibre19">0</td><td class="calibre19">1</td><td class="calibre19">1</td></tr></tbody></table></figure><p class="releaseinfo">That equates to 2<sup class="calibre22">7</sup> +
	2<sup class="calibre22">6</sup> +
	2<sup class="calibre22">3</sup>+2<sup class="calibre22">1</sup>
	+ 2<sup class="calibre22">0</sup> = 128 + 64
	+ 8 + 2 + 1 = 203.</p></section><section id="binary_s1_s2"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>2<span class="first-last"> </span></span>The basis of computing</h4></header><p class="releaseinfo">You may be wondering how a simple number is the basis of
        all the amazing things a computer can do.  Believe it or not,
        it is!  The processor in your computer has a complex but
        ultimately limited set of <em class="calibre5">instructions</em> it
        can perform on values such as addition, multiplication, etc.
        Essentially, each of these instructions is assigned a number
        so that an entire program (add this to that, multiply by that,
        divide by this and so on) can be represented by a just a
        stream of numbers.  For example, if the processor knows
        operation <code class="computeroutput1">2</code> is addition, then
        <code class="computeroutput1">252</code> could mean "add 5 and 2
        and store the output somewhere".  The reality is of course
        much more complicated (see <a href="csbu-print_split_009.html#chapter02" class="xref pcalibre"><span><span>Chapter<span class="sep"> </span></span><span>3, </span><span>Computer Architecture</span></span></a>) but,
        in a nutshell, this is what a computer is.
        </p><p class="releaseinfo">In the days of punch-cards, one could see with their
          eye the one's and zero's that make up the program stream by
          looking at the holes present on the card.  Of course this
          moved to being stored via the polarity of small magnetic
          particles rather quickly (tapes, disks) and onto the point
          today that we can carry unimaginable amounts of data in our
          pocket.</p><p class="releaseinfo">Translating these numbers to something useful to humans
        is what makes a computer so useful.  For example, screens are
        made up of millions of discrete <em class="calibre5">pixels</em>,
        each too small for the human eye to distinguish but combining
        to make a complete image.  Generally each pixel has a certain
        red, green and blue component that makes up its display
        color.  Of course, these values can be represented by numbers,
        which of course can be represented by binary!  Thus any image
        can be broken up into millions of individual dots, each dot
        represented by a <em class="calibre5">tuple</em> of three values
        representing the red, green and blue values for the pixel.
        Thus given a long string of such numbers, formatted correctly,
        the video hardware in your computer can convert those numbers
        to electrical signals to turn on and off individual pixels and
        hence display an image.
        </p><p class="releaseinfo">As you read on, we will build up the entire modern
            computing environment from this basic building block;
            <em class="calibre5">from the bottom-up</em> if you
            will!</p></section><section id="binary_s1_s3"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last"> </span></span>Bits and Bytes</h4></header><p class="releaseinfo">As discussed above, we can essentially choose to
	represent anything by a number, which can be converted to
	binary and operated on by the computer.  For example, to
	represent all the letters of the alphabet we would need at
	least enough different combinations to represent all the lower
	case letters, the upper case letters, numbers and punctuation,
	plus a few extras.  Adding this up means we need probably
	around 80 different combinations.</p><p class="releaseinfo">If we have two bits, we can represent four possible
	unique combinations (<code class="computeroutput1">00 01 10
	11</code>).  If we have three bits, we can represent
	8 different combinations.  In general, with
	<code class="computeroutput1">n</code> bits we can represent
	<code class="computeroutput1">2<sup class="calibre23">n</sup></code>
	unique combinations.</p><p class="releaseinfo">8 bits gives us
	<code class="computeroutput1">2<sup class="calibre23">8</sup> =
	256</code> unique representations, more than enough
	for our alphabet combinations.  We call a group of 8 bits a
	<em class="calibre5">byte</em>.  Guess how big a C
	<code class="computeroutput1">char</code> variable is?  One
	byte.</p><section id="binary_s1_s3_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last"> </span></span>ASCII</h5></header><p class="releaseinfo">Given that a byte can represent any of the values 0
	  through 255, anyone could arbitrarily make up a mapping
	  between characters and numbers.  For example, a video card
	  manufacturer could decide that
	  <code class="computeroutput1">1</code> represents
	  <code class="computeroutput1">A</code>, so when value
	  <code class="computeroutput1">1</code> is sent to the video card
	  it displays a capital 'A' on the screen.  A printer
	  manufacturer might decide for some obscure reason that
	  <code class="computeroutput1">1</code> represented a lower-case
	  'z', meaning that complex conversions would be required to
	  display and print the same thing.</p><p class="releaseinfo">To avoid this happening, the <em class="calibre5">American
	  Standard Code for Information Interchange</em> or
	  ASCII was invented.  This is a <em class="calibre5">7-bit</em>
	  code, meaning there are 2<sup class="calibre22">7</sup> or
	  128 available codes.</p><p class="releaseinfo">The range of codes is divided up into two major parts;
	  the non-printable and the printable.  Printable characters
	  are things like characters (upper and lower case), numbers
	  and punctuation.  Non-printable codes are for control, and
	  do things like make a carriage-return, ring the terminal
	  bell or the special <code class="computeroutput1">NULL</code>
	  code which represents nothing at all.</p><p class="releaseinfo">127 unique characters is sufficient for American
	  English, but becomes very restrictive when one wants to
	  represent characters common in other languages, especially
	  Asian languages which can have many thousands of unique
	  characters.</p><p class="releaseinfo">To alleviate this, modern systems are moving away from
	  ASCII to <em class="calibre5">Unicode</em>, which can use up to 4
	  bytes to represent a character, giving
	  <em class="calibre5">much</em> more room!</p></section><section id="binary_s1_s3_s2"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last"> </span></span>Parity</h5></header><p class="releaseinfo">ASCII, being only a 7-bit code, leaves one bit of the
	  byte spare.  This can be used to implement
	  <em class="calibre5">parity</em> which is a simple form of error
	  checking.  Consider a computer using punch-cards for input,
	  where a hole represents 1 and no hole represents 0.  Any
	  inadvertent covering of a hole will cause an incorrect value
	  to be read, causing undefined behaviour.</p><p class="releaseinfo">Parity allows a simple check of the bits of a byte to
	  ensure they were read correctly.  We can implement either
	  <em class="calibre5">odd</em> or <em class="calibre5">even</em> parity
	  by using the extra bit as a <em class="calibre5">parity
	  bit</em>.</p><p class="releaseinfo">In odd parity, if the number of 1's in the 7 bits of
	  information is odd, the parity bit is set, otherwise it is
	  not set.  Even parity is the opposite; if the number of 1's
	  is even the parity bit is set to 1.</p><p class="releaseinfo">In this way, the flipping of one bit will case a
	  parity error, which can be detected.</p><p class="releaseinfo">XXX more about error correcting</p></section><section id="binary_s1_s3_s3"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last">.</span>3<span class="first-last"> </span></span>16, 32 and 64 bit computers</h5></header><p class="releaseinfo">Numbers do not fit into bytes; hopefully your bank
          balance in dollars will need more range than can fit into
          one byte!  All most all general-purpose architectures are at
          least <em class="calibre5">32 bit</em> computers.  This means
          that their internal registers are 32-bits (or 4-bytes) wide,
          and that operations generally work on 32-bit values.  We
          refer to 4 bytes as a <em class="calibre5">word</em>; this is
          analogous to language where letters (bits) make up words in
          a sentence, except in computing every word has the same
          size!  The size of a C <code class="computeroutput1">int</code>
          variable is 32 bits.  Modern architectures are 64 bits,
          which doubles the size the processor works with to 8
          bytes.</p></section><section id="binary_s1_s3_s4"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last">.</span>4<span class="first-last"> </span></span>Kilo, Mega and Giga Bytes</h5></header><p class="releaseinfo">Computers deal with a lot of bytes; that's what makes
          them so powerful!  We need a way to talk about large numbers
          of bytes, and a natural way is to use the "International
          System of Units" (SI) prefixes as used in most other
          scientific areas.  So for example, kilo refers to
          10<sup class="calibre22">3</sup> or 1000 units, as in a
          kilogram has 1000 grams.</p><p class="releaseinfo">1000 is a nice round number in base 10, but in binary
          it is <code class="computeroutput1">1111101000</code> which is
          not a particularly "round" number.  However, 1024 (or
          2<sup class="calibre22">10</sup>) is a round number —
          (<code class="computeroutput1">10000000000</code> — and
          happens to be quite close to the base 10 meaning value of
          "kilo" (1000 as opposed to 1024).  Thus 1024 bytes naturally
          became known as a <em class="calibre5">kilobyte</em>.  The next
          SI unit is "mega" for
          <code class="computeroutput1">10<sup class="calibre23">6</sup></code>
          and the prefixes continue upwards by
          10<sup class="calibre22">3</sup> (corresponding to the usual
          grouping of three digits when writing large numbers).  As it
          happens,
          <code class="computeroutput1">2<sup class="calibre23">20</sup></code>
          is again close to the SI base 10 definition for mega;
          1048576 as opposed to 1000000.  Increasing the base 2 units
          by powers of 10 remains functionally close to the SI base 10
          value, although each increasing factor diverges slightly
          further from the base SI meaning.  Thus the SI base-10 units
          are "close enough" and have become the commonly used for
          base 2 values.</p><figure id="binary_s1_s3_s4_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>3<span>.</span>4<span>.</span>1<span> </span></span>Base 2 and 10 factors related to bytes</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Name</th><th class="calibre17">Base 2 Factor</th><th class="calibre17">Bytes</th><th class="calibre17">Close Base 10 Factor</th><th class="calibre17">Base 10 bytes</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">1 Kilobyte</td><td class="calibre19">2<sup class="calibre22">10</sup></td><td class="calibre19">1,024</td><td class="calibre19">10<sup class="calibre22">3</sup></td><td class="calibre19">1,000</td></tr><tr class="calibre16"><td class="calibre19">1 Megabyte</td><td class="calibre19">2<sup class="calibre22">20</sup></td><td class="calibre19">1,048,576</td><td class="calibre19">10<sup class="calibre22">6</sup></td><td class="calibre19">1,000,000</td></tr><tr class="calibre16"><td class="calibre19">1 Gigabyte</td><td class="calibre19">2<sup class="calibre22">30</sup></td><td class="calibre19">1,073,741,824</td><td class="calibre19">10<sup class="calibre22">9</sup></td><td class="calibre19">1,000,000,000</td></tr><tr class="calibre16"><td class="calibre19">1 Terabyte</td><td class="calibre19">2<sup class="calibre22">40</sup></td><td class="calibre19">1,099,511,627,776</td><td class="calibre19">10<sup class="calibre22">12</sup></td><td class="calibre19">1,000,000,000,000</td></tr><tr class="calibre16"><td class="calibre19">1 Petabyte</td><td class="calibre19">2<sup class="calibre22">50</sup></td><td class="calibre19">1,125,899,906,842,624</td><td class="calibre19">10<sup class="calibre22">15</sup></td><td class="calibre19">1,000,000,000,000,000</td></tr><tr class="calibre16"><td class="calibre19">1 Exabyte</td><td class="calibre19">2<sup class="calibre22">60</sup></td><td class="calibre19">1,152,921,504,606,846,976</td><td class="calibre19">10<sup class="calibre22">18</sup></td><td class="calibre19">1,000,000,000,000,000,000</td></tr></tbody></table></figure><p class="releaseinfo">It can be very useful to commit the base 2 factors to
          memory as an aid to quickly correlate the relationship
          between number-of-bits and "human" sizes.  For example, we
          can quickly calculate that a 32 bit computer can address up
          to four gigabytes of memory by noting that
          <code class="computeroutput1">2<sup class="calibre23">32</sup></code>
          can recombine to <code class="computeroutput1">2<sup class="calibre23">(2 +
          30)</sup></code> or
          <code class="computeroutput1">2<sup class="calibre23">2</sup> ×
          2<sup class="calibre23">30</sup></code>, which is
          just <code class="computeroutput1">4 ×
          2<sup class="calibre23">30</sup></code>, where we
          know
          <code class="computeroutput1">2<sup class="calibre23">30</sup></code>
          is a gigabyte.  A 64-bit value could similarly address up to
          16 exabytes (<code class="computeroutput1">2<sup class="calibre23">4</sup>
          × 2<sup class="calibre23">60</sup></code>); you
          might be interested in working out just how big a number
          this is.  To get a feel for how big that number is,
          calculate how long it would take to count to
          <code class="computeroutput1">2<sup class="calibre23">64</sup></code>
          if you incremented once per second.</p></section><section id="binary_s1_s3_s5"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last">.</span>5<span class="first-last"> </span></span>Kilo, Mega and Giga Bits</h5></header><p class="releaseinfo">Apart from the confusion related to the overloading of
          SI units between binary and base 10, capacities will often
          be quoted in terms of <em class="calibre5">bits</em> rather than
          bytes.  Generally this happens when talking about networking
          or storage devices; you may have noticed that your ADSL
          connection is described as something like 1500
          kilobits/second.  The calculation is simple; multiply by
          1000 (for the kilo), divide by 8 to get bytes and then 1024
          to get kilobytes (so 1500 kilobits/s=183 kilobytes per
          second).</p><p class="releaseinfo">The SI standardisation body has recognised these dual
          uses and has specified unique prefixes for binary usage.
          Under the standard 1024 bytes is a
          <code class="computeroutput1">kibibyte</code>, short for
          <em class="calibre5">kilo binary</em> byte (shortened to KiB).
          The other prefixes have a similar prefix (Mebibyte, MiB, for
          example).  Tradition largely prevents use of these terms,
          but you may seem them in some literature.</p></section><section id="binary_s1_s3_s6"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last">.</span>6<span class="first-last"> </span></span>Conversion</h5></header><p class="releaseinfo">The easiest way to convert between bases is to use a
	  computer, after all, that's what they're good at!  However,
	  it is often useful to know how to do conversions by
	  hand.</p><p class="releaseinfo">The easiest method to convert between bases is
	  <em class="calibre5">repeated division</em>.  To convert,
	  repeatedly divide the quotient by the base, until the
	  quotient is zero, making note of the remainders at each
	  step.  Then, write the remainders in reverse, starting at
	  the bottom and appending to the right each time.  An example
	  should illustrate; since we are converting to binary we use
	  a base of 2.</p><figure id="binary_s1_s3_s6_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>3<span>.</span>6<span>.</span>1<span> </span></span>Convert 203 to binary</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Quotient</th><th class="calibre17"/><th class="calibre17">Remainder</th><th class="calibre17"/></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">203<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">101</td><td class="calibre19">1</td><td class="calibre19"/></tr><tr class="calibre16"><td class="calibre19">101<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">50</td><td class="calibre19">1</td><td class="calibre19">↑</td></tr><tr class="calibre16"><td class="calibre19">50<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">25</td><td class="calibre19">0</td><td class="calibre19">↑</td></tr><tr class="calibre16"><td class="calibre19">25<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">12</td><td class="calibre19">1</td><td class="calibre19">↑</td></tr><tr class="calibre16"><td class="calibre19">12<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">6</td><td class="calibre19">0</td><td class="calibre19">↑</td></tr><tr class="calibre16"><td class="calibre19">6<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">3</td><td class="calibre19">0</td><td class="calibre19">↑</td></tr><tr class="calibre16"><td class="calibre19">3<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">1</td><td class="calibre19">1</td><td class="calibre19">↑</td></tr><tr class="calibre16"><td class="calibre19">1<sub class="calibre25">10</sub> ÷ 2 =</td><td class="calibre19">0</td><td class="calibre19">1</td><td class="calibre19">↑</td></tr></tbody></table></figure><p class="releaseinfo">Reading from the bottom and appending to the right
	  each time gives <code class="computeroutput1">11001011</code>,
	  which we saw from the previous example was 203.</p></section></section><section id="binary_s1_s4"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>4<span class="first-last"> </span></span>Boolean Operations</h4></header><p class="releaseinfo">George Boole was a mathematician who discovered a whole
	area of mathematics called <em class="calibre5">Boolean
	Algebra</em>.  Whilst he made his discoveries in the mid
	1800's, his mathematics are the fundamentals of all computer
	science.  Boolean algebra is a wide ranging topic, we present
	here only the bare minimum to get you started.</p><p class="releaseinfo">Boolean operations simply take a particular input and
	produce a particular output following a rule.  For example,
	the simplest boolean operation,
	<code class="computeroutput1">not</code> simply inverts the value
	of the input operand.  Other operands usually take two inputs,
	and produce a single output.</p><p class="releaseinfo">The fundamental Boolean operations used in computer
	science are easy to remember and listed below. We represent
	them below with <em class="calibre5">truth tables</em>; they simply
	show all possible inputs and outputs.  The term
	<em class="calibre5">true</em> simply reflects
	<code class="computeroutput1">1</code> in binary.</p><section id="binary_s1_s4_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>4<span class="first-last">.</span>1<span class="first-last"> </span></span>Not</h5></header><p class="releaseinfo">Usually represented by
	  <code class="computeroutput1">!</code>,
	  <code class="computeroutput1">not</code> simply inverts the
	  value, so <code class="computeroutput1">0</code> becomes
	  <code class="computeroutput1">1</code> and
	  <code class="computeroutput1">1</code> becomes
	  <code class="computeroutput1">0</code></p><figure id="binary_s1_s4_s1_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>4<span>.</span>1<span>.</span>1<span> </span></span>Truth table for <em class="calibre5">not</em></div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Input</th><th class="calibre17">Output</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td></tr></tbody></table></figure></section><section id="binary_s1_s4_s2"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>4<span class="first-last">.</span>2<span class="first-last"> </span></span>And</h5></header><p class="releaseinfo">To remember how the and operation
	  works think of it as "if one input <em class="calibre5">and</em>
	  the other are true, result is true</p><figure id="binary_s1_s4_s2_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>4<span>.</span>2<span>.</span>1<span> </span></span>Truth table for <em class="calibre5">and</em></div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Input 1</th><th class="calibre17">Input 2</th><th class="calibre17">Output</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td></tr></tbody></table></figure></section><section id="binary_s1_s4_s3"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>4<span class="first-last">.</span>3<span class="first-last"> </span></span>Or</h5></header><p class="releaseinfo">To remember how the
	  <code class="computeroutput1">or</code> operation works think of
	  it as "if one input <em class="calibre5">or</em> the other input
	  is true, the result is true</p><figure id="binary_s1_s4_s3_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>4<span>.</span>3<span>.</span>1<span> </span></span>Truth table for <em class="calibre5">or</em></div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Input 1</th><th class="calibre17">Input 2</th><th class="calibre17">Output</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td></tr></tbody></table></figure></section><section id="binary_s1_s4_s4"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>4<span class="first-last">.</span>4<span class="first-last"> </span></span>Exclusive Or (xor)</h5></header><p class="releaseinfo">Exclusive or, written as
	  <code class="computeroutput1">xor</code> is a special case of
	  <code class="computeroutput1">or</code> where the output is true
	  if one, and <em class="calibre5">only</em> one, of the inputs is
	  true.  This operation can surprisingly do many interesting
	  tricks, but you will not see a lot of it in the
	  kernel.</p><figure id="binary_s1_s4_s4_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>4<span>.</span>4<span>.</span>1<span> </span></span>Truth table for <em class="calibre5">xor</em></div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Input 1</th><th class="calibre17">Input 2</th><th class="calibre17">Output</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td></tr><tr class="calibre16"><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">1</code>
                  </td><td class="calibre19">
                    <code class="computeroutput1">0</code>
                  </td></tr></tbody></table></figure></section></section><section id="binary_s1_s5"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>5<span class="first-last"> </span></span>How computers use boolean operations</h4></header><p class="releaseinfo">Believe it or not, essentially everything your computer
	does comes back to the above operations.  For example, the
	half adder is a type of circuit made up from boolean
	operations that can add bits together (it is called a half
	adder because it does not handle carry bits).  Put more half
	adders together, and you will start to build something that
	can add together long binary numbers.  Add some external
	memory, and you have a computer.
	</p><p class="releaseinfo">Electronically, the boolean operations are implemented
	in <em class="calibre5">gates</em> made by
	<em class="calibre5">transistors</em>.  This is why you might have
	heard about transistor counts and things like Moore's Law.  The
	more transistors, the more gates, the more things you can add
	together.  To create the modern computer, there are an awful
	lot of gates, and an awful lot of transistors.  Some of the
	latest Itanium processors have around 460 million
	transistors.</p></section><section id="binary_s1_s6"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>1<span class="first-last">.</span>6<span class="first-last"> </span></span>Working with binary in C</h4></header><p class="releaseinfo">In C we have a direct interface to all of the above
	operations.  The following table describes the
	operators</p><figure id="binary_s1_s6_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>1<span>.</span>6<span>.</span>1<span> </span></span>Boolean operations in C</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Operation</th><th class="calibre17">Usage in C</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">not</code>
                </td><td class="calibre19">
                  <code class="computeroutput1">!</code>
                </td></tr><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">and</code>
                </td><td class="calibre19">
                  <code class="computeroutput1">&amp;</code>
                </td></tr><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">or</code>
                </td><td class="calibre19">
                  <code class="computeroutput1">|</code>
                </td></tr><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">xor</code>
                </td><td class="calibre19">
                  <code class="computeroutput1">^</code>
                </td></tr></tbody></table></figure><p class="releaseinfo">We use these operations on variables to modify the bits
	within the variable.  Before we see examples of this, first we
	must divert to describe hexadecimal notation.</p></section></section><section id="binary_s2"><header class="calibre8"><h3 class="calibre2"><span class="first-last">1<span class="first-last">.</span>2<span class="first-last"> </span></span>Hexadecimal</h3></header><p class="releaseinfo">Hexadecimal refers to a base 16 number system.  We use
      this in computer science for only one reason, it makes it easy
      for humans to think about binary numbers.  Computers only ever
      deal in binary and hexadecimal is simply a shortcut for us
      humans trying to work with the computer.</p><p class="releaseinfo">So why base 16?  Well, the most natural choice is base 10,
      since we are used to thinking in base 10 from our every day
      number system.  But base 10 does not work well with binary -- to
      represent 10 different elements in binary, we need four bits.
      Four bits, however, gives us sixteen possible combinations.  So
      we can either take the very tricky road of trying to convert
      between base 10 and binary, or take the easy road and make up a
      base 16 number system -- hexadecimal!</p><p class="releaseinfo">Hexadecimal uses the standard base 10 numerals, but adds
      <code class="computeroutput1">A B C D E F</code> which refer to
      <code class="computeroutput1">10 11 12 13 14 15</code> (n.b. we
      start from zero).</p><p class="releaseinfo">Traditionally, any time you see a number prefixed by
      <code class="computeroutput1">0x</code> this will denote a
      hexadecimal number.</p><p class="releaseinfo">As mentioned, to represent 16 different patterns in
      binary, we would need exactly four bits.  Therefore, each
      hexadecimal numeral represents exactly four bits.  You should
      consider it an exercise to learn the following table off by
      heart.</p><figure id="binary_s2_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>2<span>.</span>1<span> </span></span>Hexadecimal, Binary and Decimal</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Hexadecimal</th><th class="calibre17">Binary</th><th class="calibre17">Decimal</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">0</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0000</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">1</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0001</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">2</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0010</code>
              </td><td class="calibre19">
                <code class="computeroutput1">2</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">3</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0011</code>
              </td><td class="calibre19">
                <code class="computeroutput1">3</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">4</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0100</code>
              </td><td class="calibre19">
                <code class="computeroutput1">4</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">5</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0101</code>
              </td><td class="calibre19">
                <code class="computeroutput1">5</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">6</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0110</code>
              </td><td class="calibre19">
                <code class="computeroutput1">6</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">7</code>
              </td><td class="calibre19">
                <code class="computeroutput1">0111</code>
              </td><td class="calibre19">
                <code class="computeroutput1">7</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">8</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1000</code>
              </td><td class="calibre19">
                <code class="computeroutput1">8</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">9</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1001</code>
              </td><td class="calibre19">
                <code class="computeroutput1">9</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">A</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1010</code>
              </td><td class="calibre19">
                <code class="computeroutput1">10</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">B</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1011</code>
              </td><td class="calibre19">
                <code class="computeroutput1">11</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">C</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1100</code>
              </td><td class="calibre19">
                <code class="computeroutput1">12</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">D</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1101</code>
              </td><td class="calibre19">
                <code class="computeroutput1">13</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">E</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1110</code>
              </td><td class="calibre19">
                <code class="computeroutput1">14</code>
              </td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">F</code>
              </td><td class="calibre19">
                <code class="computeroutput1">1111</code>
              </td><td class="calibre19">
                <code class="computeroutput1">15</code>
              </td></tr></tbody></table></figure><p class="releaseinfo">Of course there is no reason not to continue the pattern
      (say, assign G to the value 16), but 16 values is an excellent
      trade off between the vagaries of human memory and the number of
      bits used by a computer (occasionally you will also see base 8
      used, for example for file permissions under UNIX).  We simply
      represent larger numbers of bits with more numerals.  For
      example, a sixteen bit variable can be represented by
      <code class="computeroutput1">0xAB12</code>, and to find it in
      binary simply take each individual numeral, convert it as per
      the table and join them all together (so
      <code class="computeroutput1">0xAB12</code> ends up as the 16-bit
      binary number
      <code class="computeroutput1">1010101100010010</code>).  We can use
      the reverse to convert from binary back to hexadecimal.</p><p class="releaseinfo">We can also use the same repeated division scheme to
      change the base of a number.  For example, to find 203 in
      hexadecimal</p><figure id="binary_s2_tab2"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>1<span>.</span>2<span>.</span>2<span> </span></span>Convert 203 to hexadecimal</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Quotient</th><th class="calibre17"/><th class="calibre17">Remainder</th><th class="calibre17"/></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">203<sub class="calibre25">10</sub> ÷ 16 =</td><td class="calibre19">12</td><td class="calibre19">11 (0xB)</td><td class="calibre19"/></tr><tr class="calibre16"><td class="calibre19">12<sub class="calibre25">10</sub> ÷ 16 =</td><td class="calibre19">0</td><td class="calibre19">12 (0xC)</td><td class="calibre19">↑</td></tr></tbody></table></figure><p class="releaseinfo">Hence 203 in hexadecimal is
      <code class="computeroutput1">0xCB</code>.</p></section><section id="binary_s3"><header class="calibre8"><h3 class="calibre2"><span class="first-last">1<span class="first-last">.</span>3<span class="first-last"> </span></span>Practical Implications</h3></header><section id="binary_s3_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last"> </span></span>Use of binary in code</h4></header><p class="releaseinfo">Whilst binary is the underlying language of every
      computer, it is entirely practical to program a computer in high
      level languages without knowing the first thing about it.
      However, for the low level code we are interested in a few
      fundamental binary principles are used repeatedly.</p></section><section id="binary_s3_s2"><header class="calibre8"><h4 class="calibre21"><span class="first-last">1<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last"> </span></span>Masking and Flags</h4></header><section id="binary_s3_s2_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last"> </span></span>Masking</h5></header><p class="releaseinfo">In low level code, it is often important to keep your
	structures and variables as space efficient as possible.  In
	some cases, this can involve effectively packing two
	(generally related) variables into one.</p><p class="releaseinfo">Remember each bit represents two states, so if we know a
	variable only has, say, 16 possible states it can be
	represented by 4 bits (i.e. 2<sup class="calibre22">4</sup>=16
	unique values).  But the smallest type we can declare in C is
	8 bits (a <code class="computeroutput1">char</code>), so we can
	either waste four bits, or find some way to use those left
	over bits.</p><p class="releaseinfo">We can easily do this by the process of
          <em class="calibre5">masking</em>.  This uses the rules of
          logical operations to extract values.</p><p class="releaseinfo">The process is illustrated in the figure below.  We
          can keep two separate 4-bit values "inside" a single 8-bit
          character.  We consider the upper four-bits as one value
          (blue) and the lower 4-bits (red) as another.  To extract
          the lower four bits, we set our mask to have the lower-4
          bits set to <code class="computeroutput1">1</code>
          (<code class="computeroutput1">0x0F</code>).  Since the
          <code class="computeroutput1">logical and</code> operation will
          only set the bit if <em class="calibre5">both</em> bits are
          <code class="computeroutput1">1</code>, those bits of the mask
          set to <code class="computeroutput1">0</code> effectively hide
          the bits we are not interested in.</p><div id="binary_s3_s2_s1_fig1" class="figure"><div class="author" summary="By using a mask consisting of all 1's and the logical and operation, we can extract only the bits we are interested in."><div class="media"><picture><img src="masking.svg" alt="By using a mask consisting of all 1's and the logical and operation, we can extract only the bits we are interested in." class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>1<span>.</span>3<span>.</span>2<span>.</span>1<span>.</span>1<span> </span></span>Masking</div></header></div><p class="releaseinfo">To get the top (blue) four bits, we would invert the
          mask; in other words, set the top 4 bits to
          <code class="computeroutput1">1</code> and the lower 4-bits to
          <code class="computeroutput1">0</code>.  You will note this
          gives a result of <code class="computeroutput1">1010 0000</code>
          (or, in hexadecimal <code class="computeroutput1">0xA0</code>)
          when really we want to consider this as a unique 4-bit value
          <code class="computeroutput1">1010</code>
          (<code class="computeroutput1">0x0A</code>).  To get the bits
          into the right position we use the <code class="computeroutput1">right
          shift</code> operation 4 times, giving a final
          value of <code class="computeroutput1">0000 1010</code>.</p><div id="flag-mask" class="figure"><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="16"><pre class="language-c"><span class="line" db-line="1"><span class="ln"> 1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdio.h&gt;</code></span></span>
<span class="line" db-line="2"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="3"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#define LOWER_MASK 0x0F</code></span></span>
<span class="line" db-line="4"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#define UPPER_MASK 0xF0</code></span></span>
<span class="line" db-line="5"><span class="ln"> 5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="6"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">int main(int argc, char* argv[])</code></span></span>
<span class="line" db-line="7"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="8"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        /* Two 4-bit values stored in one</code></span></span>
<span class="line" db-line="9"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">         * 8-bit variable */</code></span></span>
<span class="line" db-line="10"><span class="ln">10 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        char value = 0xA5;</code></span></span>
<span class="line" db-line="11"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        char lower = value &amp; LOWER_MASK;</code></span></span>
<span class="line" db-line="12"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        char upper = (value &amp; UPPER_MASK) &gt;&gt; 4;</code></span></span>
<span class="line" db-line="13"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="14"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        printf("Lower: %x\n", lower);</code></span></span>
<span class="line" db-line="15"><span class="ln">15 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        printf("Upper: %x\n", upper);</code></span></span>
<span class="line" db-line="16"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
</pre></div><header class="calibre8"><div class="title"><span>Example<span> </span></span><span>1<span>.</span>3<span>.</span>2<span>.</span>1<span>.</span>1<span> </span></span>Using masks</div></header></div><p class="releaseinfo"><em class="calibre5">Setting</em> the bits requires the
	<code class="computeroutput1">logical or</code> operation.
	However, rather than using
	<code class="computeroutput1">1</code>'s as the mask, we use
	<code class="computeroutput1">0</code>'s.  You should draw a
	diagram similar to the above figure and work through setting
	bits with the <code class="computeroutput1">logical
	or</code> operation.</p></section><section id="binary_s3_s2_s2"><header class="calibre8"><h5 class="calibre24"><span class="first-last">1<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last"> </span></span>Flags</h5></header><p class="releaseinfo">Often a program will have a large number of variables
	that only exist as <em class="calibre5">flags</em> to some
	condition.  For example, a state machine is an algorithm that
	transitions through a number of different states but may only
	be in one at a time.  Say it has 8 different states; we could
	easily declare 8 different variables, one for each state.  But
	in many cases it is better to declare <em class="calibre5">one 8 bit
	variable</em> and assign each bit to
	<em class="calibre5">flag</em> flag a particular state.</p><p class="releaseinfo">Flags are a special case of masking, but each bit
	represents a particular boolean state (on or off).  An
	<em class="calibre5">n</em> bit variable can hold
	<em class="calibre5">n</em> different flags.  See the code example
	below for a typical example of using flags -- you will see
	variations on this basic code very often.
	</p><div id="flag-code" class="figure"><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="38"><pre class="language-c"><span class="line" db-line="1"><span class="ln"> 1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdio.h&gt;</code></span></span>
<span class="line" db-line="2"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="3"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">/*</code></span></span>
<span class="line" db-line="4"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> *  define all 8 possible flags for an 8 bit variable</code></span></span>
<span class="line" db-line="5"><span class="ln"> 5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> *      name  hex     binary</code></span></span>
<span class="line" db-line="6"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> */</code></span></span>
<span class="line" db-line="7"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#define FLAG1 0x01 /* 00000001 */</code></span></span>
<span class="line" db-line="8"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#define FLAG2 0x02 /* 00000010 */</code></span></span>
<span class="line" db-line="9"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#define FLAG3 0x04 /* 00000100 */</code></span></span>
<span class="line" db-line="10"><span class="ln">10 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#define FLAG4 0x08 /* 00001000 */</code></span></span>
<span class="line" db-line="11"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">/* ... and so on */</code></span></span>
<span class="line" db-line="12"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#define FLAG8 0x80 /* 10000000 */</code></span></span>
<span class="line" db-line="13"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="14"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">int main(int argc, char *argv[])</code></span></span>
<span class="line" db-line="15"><span class="ln">15 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="16"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	char flags = 0; /* an 8 bit variable */</code></span></span>
<span class="line" db-line="17"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="18"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* set flags with a logical or */</code></span></span>
<span class="line" db-line="19"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	flags = flags | FLAG1; /* set flag 1 */</code></span></span>
<span class="line" db-line="20"><span class="ln">20 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	flags = flags | FLAG3; /* set flag 3</code></span></span>
<span class="line" db-line="21"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="22"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* check flags with a logical and.  If the flag is set (1)</code></span></span>
<span class="line" db-line="23"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	 * then the logical and will return 1, causing the if</code></span></span>
<span class="line" db-line="24"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	 * condition to be true. */</code></span></span>
<span class="line" db-line="25"><span class="ln">25 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (flags &amp; FLAG1)</code></span></span>
<span class="line" db-line="26"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		printf("FLAG1 set!\n");</code></span></span>
<span class="line" db-line="27"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="28"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* this of course will be untrue. */</code></span></span>
<span class="line" db-line="29"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (flags &amp; FLAG8)</code></span></span>
<span class="line" db-line="30"><span class="ln">30 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		printf("FLAG8 set!\n");</code></span></span>
<span class="line" db-line="31"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="32"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* check multiple flags by using a logical or</code></span></span>
<span class="line" db-line="33"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	 * this will pass as FLAG1 is set */</code></span></span>
<span class="line" db-line="34"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (flags &amp; (FLAG1|FLAG4))</code></span></span>
<span class="line" db-line="35"><span class="ln">35 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		printf("FLAG1 or FLAG4 set!\n");</code></span></span>
<span class="line" db-line="36"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="37"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	return 0;</code></span></span>
<span class="line" db-line="38"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
</pre></div><header class="calibre8"><div class="title"><span>Example<span> </span></span><span>1<span>.</span>3<span>.</span>2<span>.</span>2<span>.</span>1<span> </span></span>Using flags</div></header></div></section></section></section></section></div></main>

<main class="calibre3">
<div id="chapter01" class="author">
<section id="types"><header class="calibre8"><h2 class="calibre7" id="calibre_pb_11"><span class="first-last">2<span class="first-last"> </span></span>Types and Number Representation</h2></header><section id="types_s1"><header class="calibre8"><h3 class="calibre2"><span class="first-last">2<span class="first-last">.</span>1<span class="first-last"> </span></span>C Standards</h3></header><p class="releaseinfo">Although a slight divergence, it is important to
      understand a bit of history about the C language.</p><p class="releaseinfo">C is the common languge of the systems programming world.
      Every operating system and its associated system libraries in
      common use is written in C, and every system provides a C
      compiler.  To stop the language diverging across each of these
      systems where each would be sure to make numerous incompatible
      changes, a strict standard has been written for the
      language.</p><p class="releaseinfo">Officially this standard is known as ISO/IEC 9899:1999(E),
      but is more commonly referred to by its shortened name
      <em class="calibre5">C99</em>.  The standard is maintained by the
      International Standards Organisation (ISO) and the full standard
      is available for purchase online.  Older standards versions such
      as C89 (the predecessor to C99 released in 1989) and ANSI C are
      no longer in common usage and are encompassed within the latest
      standard.  The standard documentation is very technical, and
      details most every part of the language.  For example it
      explains the syntax (in Backus Naur form), standard
      <code class="computeroutput1">#define</code> values and how
      operations should behave.</p><p class="releaseinfo">It is also important to note what the C standards does
      <em class="calibre5">not</em> define.  Most importantly the standard
      needs to be appropriate for every architecture, both present and
      future.  Consequently it takes care <em class="calibre5">not</em> to
      define areas that are architecture dependent.  The "glue"
      between the C standard and the underlying architecture is the
      Application Binary Interface (or ABI) which we discuss below.
      In several places the standard will mention that a particular
      operation or construct has an unspecified or implementation
      dependent result.  Obviously the programmer can not depend on
      these outcomes if they are to write portable code.</p><section id="types_s1_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>GNU C</h4></header><p class="releaseinfo">The GNU C Compiler, more commonly referred to as
	<span>gcc</span>, almost completely implements
	the C99 standard.  However it also implements a range of
	extensions to the standard which programmers will often use to
	gain extra functionality, at the expense of portability to
	another compiler.  These extensions are usually related to
	very low level code and are much more common in the system
	programming field; the most common extension being used in
	this area being inline assembly code.  Programmers should read
	the <span>gcc</span> documentation and
	understand when they may be using features that diverge from
	the standard.</p><p class="releaseinfo"><span>gcc</span> can be directed to adhere
	strictly to the standard (the
	<code class="computeroutput1">-std=c99</code> flag for example)
	and warn or create an error when certain things are done that
	are not in the standard.  This is obviously appropriate if you
	need to ensure that you can move your code easily to another
	compiler.</p></section></section><section id="types_s2"><header class="calibre8"><h3 class="calibre2"><span class="first-last">2<span class="first-last">.</span>2<span class="first-last"> </span></span>Types</h3></header><p class="releaseinfo">As programmers, we are familiar with using variables to
      represent an area of memory to hold a value.  In a
      <em class="calibre5">typed</em> language, such as C, every variable
      must be declared with a <em class="calibre5">type</em>.  The type
      tells the compiler about what we expect to store in a variable;
      the compiler can then both allocate sufficient space for this
      usage and check that the programmer does not violate the rules
      of the type.  In the example below, we see an example of the
      space allocated for some common types of variables.</p><div id="types_s2_fig1" class="figure"><div class="author" summary="The processor sees memory only a row of bytes. Adding types to variables helps the compiler ensure that code is acting correctly. Above illustrates some common types, and how they map to memory."><div class="media"><picture><img src="types.svg" alt="The processor sees memory only a row of bytes. Adding types to variables helps the compiler ensure that code is acting correctly. Above illustrates some common types, and how they map to memory." class="calibre12"/></picture></div></div><header class="calibre8"><div class="title"><span>Figure<span> </span></span><span>2<span>.</span>2<span>.</span>1<span> </span></span>Types</div></header></div><p class="releaseinfo">The C99 standard purposely only mentions the
      <em class="calibre5">smallest</em> possible size of each of the types
      defined for C.  This is because across different processor
      architectures and operating systems the best size for
      types can be wildly different.</p><p class="releaseinfo">To be completely safe programmers need to never assume the
      size of any of their variables, however a functioning system
      obviously needs agreements on what sizes types are going to be
      used in the system.  Each architecture and operating system
      conforms to an <em class="calibre5">Application Binary Interface</em>
      or <em class="calibre5">ABI</em>.  The ABI for a system fills in the
      details between the C standard and the requirements of the
      underlying hardware and operating system.  An ABI is written for
      a specific processor and operating system combination.</p><figure id="types_s2_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>2<span>.</span>1<span> </span></span>Standard Integer Types and Sizes</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Type</th><th class="calibre17">C99 minimum size (bits)</th><th class="calibre17">Common size (32 bit architecture)</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">char</code>
              </td><td class="calibre19">8</td><td class="calibre19">8</td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">short</code>
              </td><td class="calibre19">16</td><td class="calibre19">16</td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">int</code>
              </td><td class="calibre19">16</td><td class="calibre19">32</td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">long</code>
              </td><td class="calibre19">32</td><td class="calibre19">32</td></tr><tr class="calibre16"><td class="calibre19">
                <code class="computeroutput1">long long</code>
              </td><td class="calibre19">64</td><td class="calibre19">64</td></tr><tr class="calibre16"><td class="calibre19">Pointers</td><td class="calibre19">Implementation dependent</td><td class="calibre19">32</td></tr></tbody></table></figure><p class="releaseinfo">Above we can see the only divergence from the standard is
      that <code class="computeroutput1">int</code> is commonly a 32 bit
      quantity, which is twice the strict minimum 16 bit size that the
      C99 requires.</p><p class="releaseinfo">Pointers are really just an address (i.e. their value is
      an address and thus "points" somewhere else in memory) therefore
      a pointer needs to be sufficient in size to be able to address
      any memory in the system.</p><section id="types_s2_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last"> </span></span>64 bit</h4></header><p class="releaseinfo">One area that causes confusion is the introduction of 64
	bit computing.  This means that the processor can handle
	addresses 64 bits in length (specifically the registers are 64
	bits wide; a topic we discuss in <a href="#chapter02" class="xref pcalibre"><span><span>Chapter<span class="sep"> </span></span><span>3, </span><span>Computer Architecture</span></span></a>).</p><p class="releaseinfo">This firstly means that all pointers are required to be
	a 64 bits wide so they can represent any possible address in
	the system.  However, system implementers must then make
	decisions about the size of the other types.  Two common
	models are widely used, as shown below.</p><figure id="types_s2_s1_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>2<span>.</span>1<span>.</span>1<span> </span></span>Standard Scalar Types and Sizes</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Type</th><th class="calibre17">C99 minimum size (bits)</th><th class="calibre17">Common size (LP64)</th><th class="calibre17">Common size (Windows)</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">char</code>
                </td><td class="calibre19">8</td><td class="calibre19">8</td><td class="calibre19">8</td></tr><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">short</code>
                </td><td class="calibre19">16</td><td class="calibre19">16</td><td class="calibre19">16</td></tr><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">int</code>
                </td><td class="calibre19">16</td><td class="calibre19">32</td><td class="calibre19">32</td></tr><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">long</code>
                </td><td class="calibre19">32</td><td class="calibre19">64</td><td class="calibre19">32</td></tr><tr class="calibre16"><td class="calibre19">
                  <code class="computeroutput1">long long</code>
                </td><td class="calibre19">64</td><td class="calibre19">64</td><td class="calibre19">64</td></tr><tr class="calibre16"><td class="calibre19">Pointers</td><td class="calibre19">Implementation dependent</td><td class="calibre19">64</td><td class="calibre19">64</td></tr></tbody></table></figure><p class="releaseinfo">You can see that in the LP64 (long-pointer 64) model
	<code class="computeroutput1">long</code> values are defined to be
	64 bits wide.  This is different to the 32 bit model we showed
	previously.  The LP64 model is widely used on UNIX
	systems.</p><p class="releaseinfo">In the other model,
	<code class="computeroutput1">long</code> remains a 32 bit value.
	This maintains maximum compatibility with 32 code.  This model
	is in use with 64 bit Windows.</p><p class="releaseinfo">There are good reasons why the size of
	<code class="computeroutput1">int</code> was not increased to 64
	bits in either model.  Consider that if the size of
	<code class="computeroutput1">int</code> is increased to 64 bits
	you leave programmers no way to obtain a 32 bit variable.  The
	only possibly is redefining
	<code class="computeroutput1">shorts</code> to be a larger 32 bit
	type.</p><p class="releaseinfo">A 64 bit variable is so large that it is not generally
	required to represent many variables.  For example, loops very
	rarely repeat more times than would fit in a 32 bit variable
	(4294967296 times!).  Images usually are usually represented
	with 8 bits for each of a red, green and blue value and an
	extra 8 bits for extra (alpha channel) information; a total of
	32 bits.  Consequently for many cases, using a 64 bit variable
	will be wasting at least the top 32 bits (if not more).  Not
	only this, but the size of an integer array has now doubled
	too.  This means programs take up more system memory (and thus
	more cache; discussed in detail in <a href="#chapter02" class="xref pcalibre"><span><span>Chapter<span class="sep"> </span></span><span>3, </span><span>Computer Architecture</span></span></a>) for no real improvement.  For
	the same reason Windows elected to keep their long values as
	32 bits; since much of the Windows API was originally written
	to use long variables on a 32 bit system and hence does not
	require the extra bits this saves considerable wasted space in
	the system without having to re-write all the API.</p><p class="releaseinfo">If we consider the proposed alternative where
	<code class="computeroutput1">short</code> was redefined to be a
	32 bit variable; programmers working on a 64 bit system could
	use it for variables they know are bounded to smaller values.
	However, when moving back to a 32 bit system their same
	<code class="computeroutput1">short</code> variable would now be
	only 16 bits long, a value which is much more realistically
	overflowed (65536).</p><p class="releaseinfo">By making a programmer request larger variables when
	they know they will be needed strikes a balance with respect
	to portability concerns and wasting space in binaries.</p></section><section id="types_s2_s2"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last"> </span></span>Type qualifiers</h4></header><p class="releaseinfo">The C standard also talks about some qualifiers for
	variable types.  For example
	<code class="computeroutput1">const</code> means that a variable
	will never be modified from its original value and
	<code class="computeroutput1">volatile</code> suggests to the
	compiler that this value might change outside program
	execution flow so the compiler must be careful not to re-order
	access to it in any way.</p><p class="releaseinfo"><code class="computeroutput1">signed</code> and
	<code class="computeroutput1">unsigned</code> are probably the two
	most important qualifiers; and they say if a variable can take
	on a negative value or not.  We examine this in more detail
	below.</p><p class="releaseinfo">Qualifiers are all intended to pass extra information
	about how the variable will be used to the compiler.  This
	means two things; the compiler can check if you are violating
	your own rules (e.g. writing to a
	<code class="computeroutput1">const</code> value) and it can make
	optimisations based upon the extra knowledge (examined in
	later chapters).</p></section><section id="types_s2_s3"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>2<span class="first-last">.</span>3<span class="first-last"> </span></span>Standard Types</h4></header><p class="releaseinfo">C99 realises that all these rules, sizes and portability
	concerns can become very confusing very quickly.  To help, it
	provides a series of special types which can specify the exact
	properties of a variable.  These are defined in
	<code class="computeroutput1">&lt;stdint.h&gt;</code> and have the
	form <code class="computeroutput1">qtypes_t</code> where
	<code class="computeroutput1">q</code> is a qualifier,
	<code class="computeroutput1">type</code> is the base type,
	<code class="computeroutput1">s</code> is the width in bits and
	<code class="computeroutput1">_t</code> is an extension so you
	know you are using the C99 defined types.</p><p class="releaseinfo">So for example <code class="computeroutput1">uint8_t</code>
	is an unsigned integer exactly 8 bits wide.  Many other types
	are defined; the complete list is detailed in C99 17.8 or
	(more cryptically) in the header file. <span id="types_s2_s3_para2_footnote1-fnote">Note
	that C99 also has portability helpers for
	<code class="computeroutput1">printf</code>.  The
	<code class="computeroutput1">PRI</code> macros in
	<code class="computeroutput1">&lt;inttypes.h&gt;</code> can be
	used as specifiers for types of specified sizes.  Again see
	the standard or pull apart the headers for full
	information.</span></p><p class="releaseinfo">It is up to the system implementing the C99 standard to
	provide these types for you by mapping them to appropriate
	sized types on the target system; on Linux these headers are
	provided by the system libraries.</p></section><section id="types_s2_s4"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>2<span class="first-last">.</span>4<span class="first-last"> </span></span>Types in action</h4></header><p class="releaseinfo">Below in <a href="#type-warnings" class="xref pcalibre"><span><span>Example<span class="sep"> </span></span><span>2<span class="sep">.</span>2<span class="sep">.</span>4<span class="sep">.</span>1, </span><span>Example of warnings when types are not matched</span></span></a> we see an
        example of how types place restrictions on what operations are
        valid for a variable, and how the compiler can use this
        information to warn when variables are used in an incorrect
        fashion.  In this code, we firstly assign an integer value
        into a <code class="computeroutput1">char</code> variable.  Since
        the <code class="computeroutput1">char</code> variable is smaller,
        we loose the correct value of the integer.  Further down, we
        attempt to assign a pointer to a
        <code class="computeroutput1">char</code> to memory we designated
        as an <code class="computeroutput1">integer</code>.  This
        operation can be done; but it is not safe.  The first example
        is run on a 32-bit Pentium machine, and the correct value is
        returned.  However, as shown in the second example, on a
        64-bit Itanium machine a pointer is 64 bits (8 bytes) long,
        but an integer is only 4 bytes long.  Clearly, 8 bytes can not
        fit into 4!  We can attempt to "fool" the compiler by
        <em class="calibre5">casting</em> the value before assigning it;
        note that in this case we have shot ourselves in the foot by
        doing this cast and ignoring the compiler warning since the
        smaller variable can not hold all the information from the
        pointer and we end up with an invalid address.</p><div id="type-warnings" class="figure"><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="30"><pre class="language-c"><span class="line" db-line="1"><span class="ln"> 1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">/*</code></span></span>
<span class="line" db-line="2"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> * types.c</code></span></span>
<span class="line" db-line="3"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> */</code></span></span>
<span class="line" db-line="4"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="5"><span class="ln"> 5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdio.h&gt;</code></span></span>
<span class="line" db-line="6"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdint.h&gt;</code></span></span>
<span class="line" db-line="7"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="8"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">int main(void)</code></span></span>
<span class="line" db-line="9"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="10"><span class="ln">10 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	char a;</code></span></span>
<span class="line" db-line="11"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	char *p = "hello";</code></span></span>
<span class="line" db-line="12"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="13"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	int i;</code></span></span>
<span class="line" db-line="14"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="15"><span class="ln">15 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	// moving a larger variable into a smaller one</code></span></span>
<span class="line" db-line="16"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	i = 0x12341234;</code></span></span>
<span class="line" db-line="17"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	a = i;</code></span></span>
<span class="line" db-line="18"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	i = a;</code></span></span>
<span class="line" db-line="19"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("i is %d\n", i);</code></span></span>
<span class="line" db-line="20"><span class="ln">20 <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="21"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	// moving a pointer into an integer</code></span></span>
<span class="line" db-line="22"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("p is %p\n", p);</code></span></span>
<span class="line" db-line="23"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	i = p;</code></span></span>
<span class="line" db-line="24"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	// "fooling" with casts</code></span></span>
<span class="line" db-line="25"><span class="ln">25 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	i = (int)p;</code></span></span>
<span class="line" db-line="26"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	p = (char*)i;</code></span></span>
<span class="line" db-line="27"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("p is %p\n", p);</code></span></span>
<span class="line" db-line="28"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="29"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	return 0;</code></span></span>
<span class="line" db-line="30"><span class="ln">30 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
</pre></div><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="25"><pre class="language-c"><span class="line" db-line="1"><span class="ln"> 1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ uname -m</code></span></span>
<span class="line" db-line="2"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">i686</code></span></span>
<span class="line" db-line="3"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="4"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ gcc -Wall -o types types.c</code></span></span>
<span class="line" db-line="5"><span class="ln"> 5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">types.c: In function 'main':</code></span></span>
<span class="line" db-line="6"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">types.c:19: warning: assignment makes integer from pointer without a cast</code></span></span>
<span class="line" db-line="7"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="8"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ ./types</code></span></span>
<span class="line" db-line="9"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">i is 52</code></span></span>
<span class="line" db-line="10"><span class="ln">10 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">p is 0x80484e8</code></span></span>
<span class="line" db-line="11"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">p is 0x80484e8</code></span></span>
<span class="line" db-line="12"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="13"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ uname -m</code></span></span>
<span class="line" db-line="14"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">ia64</code></span></span>
<span class="line" db-line="15"><span class="ln">15 <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="16"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ gcc -Wall  -o types types.c</code></span></span>
<span class="line" db-line="17"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">types.c: In function 'main':</code></span></span>
<span class="line" db-line="18"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">types.c:19: warning: assignment makes integer from pointer without a cast</code></span></span>
<span class="line" db-line="19"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">types.c:21: warning: cast from pointer to integer of different size</code></span></span>
<span class="line" db-line="20"><span class="ln">20 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">types.c:22: warning: cast to pointer from integer of different size</code></span></span>
<span class="line" db-line="21"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="22"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ ./types</code></span></span>
<span class="line" db-line="23"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">i is 52</code></span></span>
<span class="line" db-line="24"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">p is 0x40000000000009e0</code></span></span>
<span class="line" db-line="25"><span class="ln">25 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">p is 0x9e0</code></span></span>
</pre></div><header class="calibre8"><div class="title"><span>Example<span> </span></span><span>2<span>.</span>2<span>.</span>4<span>.</span>1<span> </span></span>Example of warnings when types are not matched</div></header></div></section></section><section id="types_s3"><header class="calibre8"><h3 class="calibre2"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last"> </span></span>Number Representation</h3></header><section id="types_s3_s1"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last"> </span></span>Negative Values</h4></header><p class="releaseinfo">With our modern base 10 numeral system we indicate a
	negative number by placing a minus
	(<code class="computeroutput1">-</code>) sign in front of it.
	When using binary we need to use a different system to
	indicate negative numbers.</p><p class="releaseinfo">There is only one scheme in common use on modern
	hardware, but C99 defines three acceptable methods for
	negative value representation.</p><section id="types_s3_s1_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>Sign Bit</h5></header><p class="releaseinfo">The most straight forward method is to simply say that
	  one bit of the number indicates either a negative or
	  positive value depending on it being set or not.</p><p class="releaseinfo">This is analogous to mathematical approach of having a
	  <code class="computeroutput1">+</code> and
	  <code class="computeroutput1">-</code>.  This is fairly logical,
	  and some of the original computers did represent negative
	  numbers in this way.  But using binary numbers opens up some
	  other possibilities which make the life of hardware designers
	  easier.</p><p class="releaseinfo">However, notice that the value
	  <code class="computeroutput1">0</code> now has two equivalent
	  values; one with the sign bit set and one without.
	  Sometimes these values are referred to as
	  <code class="computeroutput1">+0</code> and
	  <code class="computeroutput1">-0</code> respectively.</p></section><section id="types_s3_s1_s2"><header class="calibre8"><h5 class="calibre24"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last">.</span>2<span class="first-last"> </span></span>One's Complement</h5></header><p class="releaseinfo">One's complement simply applies the
	  <em class="calibre5">not</em> operation to the positive number to
	  represent the negative number.  So, for example the value
	  -90 (-0x5A) is represented by <code class="computeroutput1">~01011010 =
	  10100101</code><span id="types_s3_s1_s2_para1_footnote1-fnote">The
	  <code class="computeroutput1">~</code> operator is the C
	  language operator to apply
	  <code class="computeroutput1">NOT</code> to the value.  It is
	  also occasionally called the one's complement operator, for
	  obvious reasons now!</span></p><p class="releaseinfo">With this scheme the biggest advantage is that to add
	  a negative number to a positive number no special logic is
	  required, except that any additional carry left over must be
	  added back to the final value.  Consider</p><figure id="types_s3_s1_s2_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>3<span>.</span>1<span>.</span>2<span>.</span>1<span> </span></span>One's Complement Addition</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Decimal</th><th class="calibre17">Binary</th><th class="calibre17">Op</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">-90</td><td class="calibre19">10100101</td><td class="calibre19">+</td></tr><tr class="calibre16"><td class="calibre19">100</td><td class="calibre19">01100100</td><td class="calibre19"/></tr><tr class="calibre16"><td class="calibre19">---</td><td class="calibre19">--------</td><td class="calibre19"/></tr><tr class="calibre16"><td class="calibre19">10</td><td class="calibre19"><sup class="calibre22">1</sup>00001001</td><td class="calibre19">9</td></tr><tr class="calibre16"><td class="calibre19"/><td class="calibre19">00001010</td><td class="calibre19">10</td></tr></tbody></table></figure><p class="releaseinfo">If you add the bits one by one, you find you end up
	  with a carry bit at the end (highlighted above).  By adding
	  this back to the original we end up with the correct value,
	  10</p><p class="releaseinfo">Again we still have the problem with two zeros being
	  represented.  Again no modern computer uses one's
	  complement, mostly because there is a better scheme.</p></section><section id="types_s3_s1_s3"><header class="calibre8"><h5 class="calibre24"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last"> </span></span>Two's Complement</h5></header><p class="releaseinfo">Two's complement is just like one's complement, except
	  the negative representation has <em class="calibre5">one</em>
	  added to it and we discard any left over carry bit.  So to
	  continue with the example from before,
	  <code class="computeroutput1">-90</code> would be
	  <code class="computeroutput1">~01011010+1=10100101+1 =
	  10100110</code>.</p><p class="releaseinfo">This means there is a slightly odd symmetry in the
	  numbers that can be represented; for example with an 8 bit
	  integer we have
	  <code class="computeroutput1">2^<sup class="calibre23">8</sup> =
	  256</code> possible values; with our sign bit
	  representation we could represent -127 thru 127 but with
	  two's complement we can represent -127 thru 128.  This is
	  because we have removed the problem of having two zeros;
	  consider that "negative zero" is <code class="computeroutput1">(~00000000
	 +1)=(11111111+1)=00000000</code> (note
	  discarded carry bit).</p><figure id="types_s3_s1_s3_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>3<span>.</span>1<span>.</span>3<span>.</span>1<span> </span></span>Two's Complement Addition</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Decimal</th><th class="calibre17">Binary</th><th class="calibre17">Op</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">-90</td><td class="calibre19">10100110</td><td class="calibre19">+</td></tr><tr class="calibre16"><td class="calibre19">100</td><td class="calibre19">01100100</td><td class="calibre19"/></tr><tr class="calibre16"><td class="calibre19">---</td><td class="calibre19">--------</td><td class="calibre19"/></tr><tr class="calibre16"><td class="calibre19">10</td><td class="calibre19">00001010</td><td class="calibre19"/></tr></tbody></table></figure><p class="releaseinfo">You can see that by implementing two's complement
	  hardware designers need only provide logic for addition
	  circuits; subtraction can be done by two's complement
	  negating the value to be subtracted and then adding the new
	  value.</p><p class="releaseinfo">Similarly you could implement multiplication with
	  repeated addition and division with repeated subtraction.
	  Consequently two's complement can reduce all simple
	  mathematical operations down to addition!</p><p class="releaseinfo">All modern computers use two's complement
	  representation.</p><section id="sign_extension"><header class="calibre8"><h5 class="calibre24"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last">.</span>3<span class="first-last">.</span>1<span class="first-last"> </span></span>Sign-extension</h5></header><p class="releaseinfo">Because of two's complement format, when increasing
	      the size of signed value, it is important that the
	      additional bits be <em class="calibre5">sign-extended</em>;
	      that is, copied from the top-bit of the existing
	      value.</p><p class="releaseinfo">For example, the value of an 32-bit
	    <code class="computeroutput1">int</code>
	    <code class="computeroutput1">-10</code> would be represented
	    in two's complement binary as
	    <code class="computeroutput1">11111111111111111111111111110110</code>.
	    If one were to cast this to a 64-bit <code class="computeroutput1">long
	    long int</code>, we would need to ensure that
	    the additional 32-bits were set to
	    <code class="computeroutput1">1</code> to maintain the same
	    sign as the original.</p><p class="releaseinfo">Thanks to two's complement, it is sufficient to take
            the top bit of the existing value and replace all the added
            bits with this value.  This processes is referred to as
            <em class="calibre5">sign-extension</em> and is usually handled
            by the compiler in situations as defined by the language
            standard, with the processor generally providing special
            instructions to take a value and sign-extended it to some
            larger value.</p></section></section></section><section id="types_s3_s2"><header class="calibre8"><h4 class="calibre21"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last"> </span></span>Floating Point</h4></header><p class="releaseinfo">So far we have only discussed integer or whole numbers;
	the class of numbers that can represent decimal values is
	called <em class="calibre5">floating point</em>.</p><p class="releaseinfo">To create a decimal number, we require some way to
	represent the concept of the decimal place in binary.  The
	most common scheme for this is known as the <em class="calibre5">IEEE-754
	floating point standard</em> because the standard is
	published by the Institute of Electric and Electronics
	Engineers.  The scheme is conceptually quite simple and is
	somewhat analogous to "scientific notation".</p><p class="releaseinfo">In scientific notation the value
	<code class="computeroutput1">123.45</code> might commonly be
	represented as
	<code class="computeroutput1">1.2345x10<sup class="calibre23">2</sup></code>.
	We call <code class="computeroutput1">1.2345</code> the
	<em class="calibre5">mantissa</em> or
	<em class="calibre5">significand</em>,
	<code class="computeroutput1">10</code> is the
	<em class="calibre5">radix</em> and
	<code class="computeroutput1">2</code> is the
	<em class="calibre5">exponent</em>.
	</p><p class="releaseinfo">In the IEEE floating point model, we break up the
	available bits to represent the sign, mantissa and exponent of
	a decimal number.  A decimal number is represented by
	<code class="computeroutput1">sign × significand ×
	2^<sup class="calibre23">exponent</sup></code>.</p><p class="releaseinfo">The sign bit equates to either
	<code class="computeroutput1">1</code> or
	<code class="computeroutput1">-1</code>.  Since we are working in
	binary, we always have the implied radix of
	<code class="computeroutput1">2</code>.</p><p class="releaseinfo">There are differing widths for a floating point value --
	we examine below at only a 32 bit value.  More bits allows
	greater precision.</p><figure id="types_s3_s2_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>1<span> </span></span>IEEE Floating Point</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">Sign</th><th class="calibre17">Exponent</th><th class="calibre17">Significand/Mantissa</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">S</td><td class="calibre19">EEEEEEEE</td><td class="calibre19">MMMMMMMMMMMMMMMMMMMMMMM</td></tr></tbody></table></figure><p class="releaseinfo">The other important factor is <em class="calibre5">bias</em>
	of the exponent.  The exponent needs to be able to represent
	both positive and negative values, thus an implied value of
	<code class="computeroutput1">127</code> is subtracted from the
	exponent.  For example, an exponent of
	<code class="computeroutput1">0</code> has an exponent field of
	<code class="computeroutput1">127</code>,
	<code class="computeroutput1">128</code> would represent
	<code class="computeroutput1">1</code> and
	<code class="computeroutput1">126</code> would represent
	<code class="computeroutput1">-1</code>.</p><p class="releaseinfo">Each bit of the significand adds a little more precision
	to the values we can represent.  Consider the scientific
	notation representation of the value
	<code class="computeroutput1">198765</code>.  We could write this
	as
	<code class="computeroutput1">1.98765x10<sup class="calibre23">6</sup></code>,
	which corresponds to a representation below</p><figure id="types_s3_s2_tab2"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>2<span> </span></span>Scientific Notation for 1.98765x10^6</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">10<sup class="calibre22">0</sup></th><th class="calibre17">.</th><th class="calibre17">10<sup class="calibre22">-1</sup></th><th class="calibre17">10<sup class="calibre22">-2</sup></th><th class="calibre17">10<sup class="calibre22">-3</sup></th><th class="calibre17">10<sup class="calibre22">-4</sup></th><th class="calibre17">10<sup class="calibre22">-5</sup></th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">1</td><td class="calibre19">.</td><td class="calibre19">9</td><td class="calibre19">8</td><td class="calibre19">7</td><td class="calibre19">6</td><td class="calibre19">5</td></tr></tbody></table></figure><p class="releaseinfo">Each additional digit allows a greater range of decimal
	values we can represent.  In base 10, each digit after the
	decimal place increases the precision of our number by 10
	times.  For example, we can represent
	<code class="computeroutput1">0.0</code> through
	<code class="computeroutput1">0.9</code> (10 values) with one
	digit of decimal place, <code class="computeroutput1">0.00</code>
	through <code class="computeroutput1">0.99</code> (100 values)
	with two digits, and so on.  In binary, rather than each
	additional digit giving us 10 times the precision, we only get
	two times the precision, as illustrated in the table below.
	This means that our binary representation does not always map
	in a straight-forward manner to a decimal
	representation.</p><figure id="types_s3_s2_tab3"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>3<span> </span></span>Significands in binary</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">2<sup class="calibre22">0</sup></th><th class="calibre17">.</th><th class="calibre17">2<sup class="calibre22">-1</sup></th><th class="calibre17">2<sup class="calibre22">-2</sup></th><th class="calibre17">2<sup class="calibre22">-3</sup></th><th class="calibre17">2<sup class="calibre22">-4</sup></th><th class="calibre17">2<sup class="calibre22">-5</sup></th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">1</td><td class="calibre19">.</td><td class="calibre19">1/2</td><td class="calibre19">1/4</td><td class="calibre19">1/8</td><td class="calibre19">1/16</td><td class="calibre19">1/32</td></tr><tr class="calibre16"><td class="calibre19">1</td><td class="calibre19">.</td><td class="calibre19">0.5</td><td class="calibre19">0.25</td><td class="calibre19">0.125</td><td class="calibre19">0.0625</td><td class="calibre19">0.03125</td></tr></tbody></table></figure><p class="releaseinfo">With only one bit of precision, our fractional precision
	is not very big; we can only say that the fraction is either
	<code class="computeroutput1">0</code> or
	<code class="computeroutput1">0.5</code>.  If we add another bit
	of precision, we can now say that the decimal value is one of
	either <code class="computeroutput1">0,0.25,0.5,0.75</code>.  With
	another bit of precision we can now represent the values
	<code class="computeroutput1">0,0.125,0.25,0.375,0.5,0.625,0.75,0.875</code>.</p><p class="releaseinfo">Increasing the number of bits therefore allows us
	greater and greater precision.  However, since the range of
	possible numbers is infinite we will never have enough bits to
	represent <em class="calibre5">any</em> possible value.</p><p class="releaseinfo">For example, if we only have two bits of precision and
	need to represent the value
	<code class="computeroutput1">0.3</code> we can only say that it
	is closest to <code class="computeroutput1">0.25</code>; obviously
	this is insufficient for most any application.  With 22 bits
	of significand we have a much finer resolution, but it is
	still not enough for most applications.  A
	<code class="computeroutput1">double</code> value increases the
	number of significand bits to 52 (it also increases the range
	of exponent values too).  Some hardware has an 84-bit float,
	with a full 64 bits of significand.  64 bits allows a
	tremendous precision and should be suitable for all but the
	most demanding of applications (XXX is this sufficient to
	represent a length to less than the size of an atom?)</p><div id="float-v-double" class="figure"><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="33"><pre class="language-c"><span class="line" db-line="1"><span class="ln"> 1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ cat float.c</code></span></span>
<span class="line" db-line="2"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdio.h&gt;</code></span></span>
<span class="line" db-line="3"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="4"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">int main(void)</code></span></span>
<span class="line" db-line="5"><span class="ln"> 5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="6"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        float a = 0.45;</code></span></span>
<span class="line" db-line="7"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        float b = 8.0;</code></span></span>
<span class="line" db-line="8"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="9"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        double ad = 0.45;</code></span></span>
<span class="line" db-line="10"><span class="ln">10 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        double bd = 8.0;</code></span></span>
<span class="line" db-line="11"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="12"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        printf("float+float, 6dp    : %f\n", a+b);</code></span></span>
<span class="line" db-line="13"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        printf("double+double, 6dp  : %f\n", ad+bd);</code></span></span>
<span class="line" db-line="14"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        printf("float+float, 20dp   : %10.20f\n", a+b);</code></span></span>
<span class="line" db-line="15"><span class="ln">15 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        printf("dobule+double, 20dp : %10.20f\n", ad+bd);</code></span></span>
<span class="line" db-line="16"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="17"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">        return 0;</code></span></span>
<span class="line" db-line="18"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
<span class="line" db-line="19"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="20"><span class="ln">20 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ gcc -o float float.c</code></span></span>
<span class="line" db-line="21"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="22"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ ./float</code></span></span>
<span class="line" db-line="23"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">float+float, 6dp    : 8.450000</code></span></span>
<span class="line" db-line="24"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">double+double, 6dp  : 8.450000</code></span></span>
<span class="line" db-line="25"><span class="ln">25 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">float+float, 20dp   : 8.44999998807907104492</code></span></span>
<span class="line" db-line="26"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">dobule+double, 20dp : 8.44999999999999928946</code></span></span>
<span class="line" db-line="27"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="28"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ python</code></span></span>
<span class="line" db-line="29"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">Python 2.4.4 (#2, Oct 20 2006, 00:23:25)</code></span></span>
<span class="line" db-line="30"><span class="ln">30 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">[GCC 4.1.2 20061015 (prerelease) (Debian 4.1.1-16.1)] on linux2</code></span></span>
<span class="line" db-line="31"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">Type "help", "copyright", "credits" or "license" for more information.</code></span></span>
<span class="line" db-line="32"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">&gt;&gt;&gt; 8.0 + 0.45</code></span></span>
<span class="line" db-line="33"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">8.4499999999999993</code></span></span>
</pre></div><header class="calibre8"><div class="title"><span>Example<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>1<span> </span></span>Floats versus Doubles</div></header></div><p class="releaseinfo">A practical example is illustrated above.  Notice that
	for the default 6 decimal places of precision given by
	<code class="computeroutput1">printf</code> both answers are the
	same, since they are rounded up correctly.  However, when
	asked to give the results to a larger precision, in this case
	20 decimal places, we can see the results start to diverge.
	The code using <code class="computeroutput1">doubles</code> has a
	more accurate result, but it is still not
	<em class="calibre5">exactly</em> correct.  We can also see that
	programmers not explicitly dealing with
	<code class="computeroutput1">float</code> values still have
	problems with precision of variables!</p><section id="types_s3_s2_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last"> </span></span>Normalised Values</h5></header><p class="releaseinfo">In scientific notation, we can represent a value in
	  many different ways.  For example,
	  <code class="computeroutput1">10023x10^<sup class="calibre23">0</sup> =
	  1002.3x10<sup class="calibre23">1</sup> =
	  100.23x10<sup class="calibre23">2</sup></code>.  We
	  thus define the <em class="calibre5">normalised</em> version as
	  the one where <code class="computeroutput1">1/radix &lt;= significand &lt;
	  1</code>.  In binary this ensures that the
	  leftmost bit of the significand is <em class="calibre5">always
	  one</em>.  Knowing this, we can gain an extra bit of
	  precision by having the standard say that the leftmost bit
	  being one is implied.</p><figure id="types_s3_s2_s1_tab1"><header class="calibre8"><div class="title"><span>Table<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>1<span>.</span>1<span> </span></span>Example of normalising 0.375</div></header><table class="calibre14"><thead class="calibre15"><tr class="calibre16"><th class="calibre17">2<sup class="calibre22">0</sup></th><th class="calibre17">.</th><th class="calibre17">2<sup class="calibre22">-1</sup></th><th class="calibre17">2<sup class="calibre22">-2</sup></th><th class="calibre17">2<sup class="calibre22">-3</sup></th><th class="calibre17">2<sup class="calibre22">-4</sup></th><th class="calibre17">2<sup class="calibre22">-5</sup></th><th class="calibre17">Exponent</th><th class="calibre17">Calculation</th></tr></thead><tbody class="calibre18"><tr class="calibre16"><td class="calibre19">0</td><td class="calibre19">.</td><td class="calibre19">0</td><td class="calibre19">1</td><td class="calibre19">1</td><td class="calibre19">0</td><td class="calibre19">0</td><td class="calibre19">2^<sup class="calibre22">0</sup></td><td class="calibre19">(0.25+0.125) × 1 = 0.375 </td></tr><tr class="calibre16"><td class="calibre19">0</td><td class="calibre19">.</td><td class="calibre19">1</td><td class="calibre19">1</td><td class="calibre19">0</td><td class="calibre19">0</td><td class="calibre19">0</td><td class="calibre19">2^<sup class="calibre22">-1</sup></td><td class="calibre19">(0.5+0.25)×.5=0.375</td></tr><tr class="calibre16"><td class="calibre19">1</td><td class="calibre19">.</td><td class="calibre19">1</td><td class="calibre19">0</td><td class="calibre19">0</td><td class="calibre19">0</td><td class="calibre19">0</td><td class="calibre19">2^<sup class="calibre22">-2</sup></td><td class="calibre19">(1+0.5)×0.25=0.375</td></tr></tbody></table></figure><p class="releaseinfo">As you can see above, we can make the value normalised
	  by moving the bits upwards as long as we compensate by
	  increasing the exponent.</p><section id="types_s3_s2_s1_s1"><header class="calibre8"><h5 class="calibre24"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last">.</span>1<span class="first-last">.</span>1<span class="first-last"> </span></span>Normalisation Tricks</h5></header><p class="releaseinfo">A common problem programmers face is finding the
	    first set bit in a bitfield.  Consider the bitfield
	    <code class="computeroutput1">0100</code>; from the right the
	    first set bit would be bit
	    <code class="computeroutput1">2</code> (starting from zero, as
	    is conventional).</p><p class="releaseinfo">The standard way to find this value is to shift
	    right, check if the uppermost bit is a
	    <code class="computeroutput1">1</code> and either terminate or
	    repeat.  This is a slow process; if the bitfield is 64
	    bits long and only the very last bit is set, you must go
	    through all the preceding 63 bits!</p><p class="releaseinfo">However, if this bitfield value were the signficand
	    of a floating point number and we were to normalise it,
	    the value of the exponent would tell us how many times it
	    was shifted.  The process of normalising a number is
	    generally built into the floating point hardware unit on
	    the processor, so operates very fast; usually much faster
	    than the repeated shift and check operations.</p><p class="releaseinfo">The example program below illustrates two methods of
	    finding the first set bit on an Itanium processor.  The
	    Itanium, like most server processors, has support for an
	    80-bit <em class="calibre5">extended</em> floating point type,
	    with a 64-bit significand.  This means a
	    <code class="computeroutput1">unsigned long</code> neatly fits
	    into the significand of a <code class="computeroutput1">long
	    double</code>.  When the value is loaded it is
	    normalised, and and thus by reading the exponent value
	    (minus the 16 bit bias) we can see how far it was
	    shifted.</p><div id="ffs" class="figure"><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="25"><pre class="language-c"><span class="line" db-line="1"><span class="ln"> 1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdio.h&gt;</code></span></span>
<span class="line" db-line="2"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="3"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">int main(void)</code></span></span>
<span class="line" db-line="4"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="5"><span class="ln"> 5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	//  in binary = 1000 0000 0000 0000</code></span></span>
<span class="line" db-line="6"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	//  bit num     5432 1098 7654 3210</code></span></span>
<span class="line" db-line="7"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	int i = 0x8000;</code></span></span>
<span class="line" db-line="8"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	int count = 0;</code></span></span>
<span class="line" db-line="9"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	while ( !(i &amp; 0x1) ) {</code></span></span>
<span class="line" db-line="10"><span class="ln">10 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		count ++;</code></span></span>
<span class="line" db-line="11"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		i = i &gt;&gt; 1;</code></span></span>
<span class="line" db-line="12"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	}</code></span></span>
<span class="line" db-line="13"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("First non-zero (slow) is %d\n", count);</code></span></span>
<span class="line" db-line="14"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="15"><span class="ln">15 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	// this value is normalised when it is loaded</code></span></span>
<span class="line" db-line="16"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	long double d = 0x8000UL;</code></span></span>
<span class="line" db-line="17"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	long exp;</code></span></span>
<span class="line" db-line="18"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="19"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	// Itanium "get floating point exponent" instruction</code></span></span>
<span class="line" db-line="20"><span class="ln">20 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	asm ("getf.exp %0=%1" : "=r"(exp) : "f"(d));</code></span></span>
<span class="line" db-line="21"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="22"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	// note exponent include bias</code></span></span>
<span class="line" db-line="23"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("The first non-zero (fast) is %d\n", exp - 65535);</code></span></span>
<span class="line" db-line="24"><span class="ln">   <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="25"><span class="ln">25 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
</pre></div><header class="calibre8"><div class="title"><span>Example<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>1<span>.</span>1<span>.</span>1<span> </span></span>Program to find first set bit</div></header></div></section></section><section id="types_s3_s2_s2"><header class="calibre8"><h5 class="calibre24"><span class="first-last">2<span class="first-last">.</span>3<span class="first-last">.</span>2<span class="first-last">.</span>2<span class="first-last"> </span></span>Bringing it together</h5></header><p class="releaseinfo">In the example code below we extract the components of
	  a floating point number and print out the value it
	  represents.  This will only work for a 32 bit floating point
	  value in the IEEE format; however this is common for most
	  architectures with the
	  <code class="computeroutput1">float</code> type.</p><div id="float-examine" class="figure"><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="115"><pre class="language-c"><span class="line" db-line="1"><span class="ln">  1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdio.h&gt;</code></span></span>
<span class="line" db-line="2"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;string.h&gt;</code></span></span>
<span class="line" db-line="3"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">#include &lt;stdlib.h&gt;</code></span></span>
<span class="line" db-line="4"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="5"><span class="ln">  5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">/* return 2^n */</code></span></span>
<span class="line" db-line="6"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">int two_to_pos(int n)</code></span></span>
<span class="line" db-line="7"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="8"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (n == 0)</code></span></span>
<span class="line" db-line="9"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		return 1;</code></span></span>
<span class="line" db-line="10"><span class="ln"> 10 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	return 2 * two_to_pos(n - 1);</code></span></span>
<span class="line" db-line="11"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
<span class="line" db-line="12"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="13"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">double two_to_neg(int n)</code></span></span>
<span class="line" db-line="14"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="15"><span class="ln"> 15 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (n == 0)</code></span></span>
<span class="line" db-line="16"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		return 1;</code></span></span>
<span class="line" db-line="17"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	return 1.0 / (two_to_pos(abs(n)));</code></span></span>
<span class="line" db-line="18"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
<span class="line" db-line="19"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="20"><span class="ln"> 20 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">double two_to(int n)</code></span></span>
<span class="line" db-line="21"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="22"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (n &gt;= 0)</code></span></span>
<span class="line" db-line="23"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		return two_to_pos(n);</code></span></span>
<span class="line" db-line="24"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (n &lt; 0)</code></span></span>
<span class="line" db-line="25"><span class="ln"> 25 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		return two_to_neg(n);</code></span></span>
<span class="line" db-line="26"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	return 0;</code></span></span>
<span class="line" db-line="27"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
<span class="line" db-line="28"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="29"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">/* Go through some memory "m" which is the 24 bit significand of a</code></span></span>
<span class="line" db-line="30"><span class="ln"> 30 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">   floating point number.  We work "backwards" from the bits</code></span></span>
<span class="line" db-line="31"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">   furthest on the right, for no particular reason. */</code></span></span>
<span class="line" db-line="32"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">double calc_float(int m, int bit)</code></span></span>
<span class="line" db-line="33"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="34"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* 23 bits; this terminates recursion */</code></span></span>
<span class="line" db-line="35"><span class="ln"> 35 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (bit &gt; 23)</code></span></span>
<span class="line" db-line="36"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		return 0;</code></span></span>
<span class="line" db-line="37"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="38"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* if the bit is set, it represents the value 1/2^bit */</code></span></span>
<span class="line" db-line="39"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if ((m &gt;&gt; bit) &amp; 1)</code></span></span>
<span class="line" db-line="40"><span class="ln"> 40 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		return 1.0L/two_to(23 - bit) + calc_float(m, bit + 1);</code></span></span>
<span class="line" db-line="41"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="42"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* otherwise go to the next bit */</code></span></span>
<span class="line" db-line="43"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	return calc_float(m, bit + 1);</code></span></span>
<span class="line" db-line="44"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
<span class="line" db-line="45"><span class="ln"> 45 <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="46"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">int main(int argc, char *argv[])</code></span></span>
<span class="line" db-line="47"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">{</code></span></span>
<span class="line" db-line="48"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	float f;</code></span></span>
<span class="line" db-line="49"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	int m,i,sign,exponent,significand;</code></span></span>
<span class="line" db-line="50"><span class="ln"> 50 <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="51"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (argc != 2)</code></span></span>
<span class="line" db-line="52"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	{</code></span></span>
<span class="line" db-line="53"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		printf("usage: float 123.456\n");</code></span></span>
<span class="line" db-line="54"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		exit(1);</code></span></span>
<span class="line" db-line="55"><span class="ln"> 55 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	}</code></span></span>
<span class="line" db-line="56"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="57"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	if (sscanf(argv[1], "%f", &amp;f) != 1)</code></span></span>
<span class="line" db-line="58"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	{</code></span></span>
<span class="line" db-line="59"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		printf("invalid input\n");</code></span></span>
<span class="line" db-line="60"><span class="ln"> 60 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		exit(1);</code></span></span>
<span class="line" db-line="61"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	}</code></span></span>
<span class="line" db-line="62"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="63"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* We need to "fool" the compiler, as if we start to use casts</code></span></span>
<span class="line" db-line="64"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	   (e.g. (int)f) it will actually do a conversion for us.  We</code></span></span>
<span class="line" db-line="65"><span class="ln"> 65 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	   want access to the raw bits, so we just copy it into a same</code></span></span>
<span class="line" db-line="66"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	   sized variable. */</code></span></span>
<span class="line" db-line="67"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	memcpy(&amp;m, &amp;f, 4);</code></span></span>
<span class="line" db-line="68"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="69"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* The sign bit is the first bit */</code></span></span>
<span class="line" db-line="70"><span class="ln"> 70 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	sign = (m &gt;&gt; 31) &amp; 0x1;</code></span></span>
<span class="line" db-line="71"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="72"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* Exponent is 8 bits following the sign bit */</code></span></span>
<span class="line" db-line="73"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	exponent = ((m &gt;&gt; 23) &amp; 0xFF) - 127;</code></span></span>
<span class="line" db-line="74"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="75"><span class="ln"> 75 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* Significand fills out the float, the first bit is implied</code></span></span>
<span class="line" db-line="76"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	   to be 1, hence the 24 bit OR value below. */</code></span></span>
<span class="line" db-line="77"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	significand = (m &amp; 0x7FFFFF) | 0x800000;</code></span></span>
<span class="line" db-line="78"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="79"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* print out a power representation */</code></span></span>
<span class="line" db-line="80"><span class="ln"> 80 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("%f = %d * (", f, sign ? -1 : 1);</code></span></span>
<span class="line" db-line="81"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	for(i = 23 ; i &gt;= 0 ; i--)</code></span></span>
<span class="line" db-line="82"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	{</code></span></span>
<span class="line" db-line="83"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		if ((significand &gt;&gt; i) &amp; 1)</code></span></span>
<span class="line" db-line="84"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">			printf("%s1/2^%d", (i == 23) ? "" : " + ",</code></span></span>
<span class="line" db-line="85"><span class="ln"> 85 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">			       23-i);</code></span></span>
<span class="line" db-line="86"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	}</code></span></span>
<span class="line" db-line="87"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf(") * 2^%d\n", exponent);</code></span></span>
<span class="line" db-line="88"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="89"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* print out a fractional representation */</code></span></span>
<span class="line" db-line="90"><span class="ln"> 90 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("%f = %d * (", f, sign ? -1 : 1);</code></span></span>
<span class="line" db-line="91"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	for(i = 23 ; i &gt;= 0 ; i--)</code></span></span>
<span class="line" db-line="92"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	{</code></span></span>
<span class="line" db-line="93"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		if ((significand &gt;&gt; i) &amp; 1)</code></span></span>
<span class="line" db-line="94"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">			printf("%s1/%d", (i == 23) ? "" : " + ",</code></span></span>
<span class="line" db-line="95"><span class="ln"> 95 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">			       (int)two_to(23-i));</code></span></span>
<span class="line" db-line="96"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	}</code></span></span>
<span class="line" db-line="97"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf(") * 2^%d\n", exponent);</code></span></span>
<span class="line" db-line="98"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="99"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* convert this into decimal and print it out */</code></span></span>
<span class="line" db-line="100"><span class="ln">100 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("%f = %d * %.12g * %f\n",</code></span></span>
<span class="line" db-line="101"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       f,</code></span></span>
<span class="line" db-line="102"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       (sign ? -1 : 1),</code></span></span>
<span class="line" db-line="103"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       calc_float(significand, 0),</code></span></span>
<span class="line" db-line="104"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       two_to(exponent));</code></span></span>
<span class="line" db-line="105"><span class="ln">105 <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="106"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	/* do the math this time */</code></span></span>
<span class="line" db-line="107"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	printf("%f = %.12g\n",</code></span></span>
<span class="line" db-line="108"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       f,</code></span></span>
<span class="line" db-line="109"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       (sign ? -1 : 1) *</code></span></span>
<span class="line" db-line="110"><span class="ln">110 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       calc_float(significand, 0) *</code></span></span>
<span class="line" db-line="111"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	       two_to(exponent)</code></span></span>
<span class="line" db-line="112"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">		);</code></span></span>
<span class="line" db-line="113"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13"> </code></span></span>
<span class="line" db-line="114"><span class="ln">    <span class="nsep">|</span></span><span class="ld"><code class="calibre13">	return 0;</code></span></span>
<span class="line" db-line="115"><span class="ln">115 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">}</code></span></span>
</pre></div><header class="calibre8"><div class="title"><span>Example<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>2<span>.</span>1<span> </span></span>Examining Floats</div></header></div><p class="releaseinfo">Sample output of the value
	  <code class="computeroutput1">8.45</code>, which we previously
	  examined, is shown below.</p><div id="float-examine-example" class="figure"><div class="pre-wrap" db-startinglinenumber="1" db-numberoflines="5"><pre class="language-c"><span class="line" db-line="1"><span class="ln">1 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">$ ./float 8.45</code></span></span>
<span class="line" db-line="2"><span class="ln">  <span class="nsep">|</span></span><span class="ld"><code class="calibre13">8.450000 = 1 * (1/2^0 + 1/2^5 + 1/2^6 + 1/2^7 + 1/2^10 + 1/2^11 + 1/2^14 + 1/2^15 + 1/2^18 + 1/2^19 + 1/2^22 + 1/2^23) * 2^3</code></span></span>
<span class="line" db-line="3"><span class="ln">  <span class="nsep">|</span></span><span class="ld"><code class="calibre13">8.450000 = 1 * (1/1 + 1/32 + 1/64 + 1/128 + 1/1024 + 1/2048 + 1/16384 + 1/32768 + 1/262144 + 1/524288 + 1/4194304 + 1/8388608) * 2^3</code></span></span>
<span class="line" db-line="4"><span class="ln">  <span class="nsep">|</span></span><span class="ld"><code class="calibre13">8.450000 = 1 * 1.05624997616 * 8.000000</code></span></span>
<span class="line" db-line="5"><span class="ln">5 <span class="nsep">|</span></span><span class="ld"><code class="calibre13">8.450000 = 8.44999980927</code></span></span>
</pre></div><header class="calibre8"><div class="title"><span>Example<span> </span></span><span>2<span>.</span>3<span>.</span>2<span>.</span>2<span>.</span>2<span> </span></span>Analysis of <code class="computeroutput1">8.45</code></div></header></div><p class="releaseinfo">From this example, we get some idea of how the
	  inaccuracies creep into our floating point numbers.</p></section></section></section></section></div><div id="chapter02" class="author"><header class="calibre6"><div class="calibre10" id="calibre_pb_12"/>
</header></div></main></body></html>