- en: Type equivalents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型等效
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/type_equivalents.html](https://cel.cs.brown.edu/crp/idioms/type_equivalents.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cel.cs.brown.edu/crp/idioms/type_equivalents.html](https://cel.cs.brown.edu/crp/idioms/type_equivalents.html)
- en: The type equivalents listed in this document are equivalent for the purposes
    of programming in Rust as one would program in C++. They are not necessarily equivalent
    in terms of being useful for interacting with C or C++ programs via an FFI. For
    types that are useful for interoperability with C or C++, see the [Rust `std::ffi`
    module documentation](https://doc.rust-lang.org/std/ffi/index.html) and the [FFI
    documentation in the Rustonomicon](https://doc.rust-lang.org/nomicon/ffi.html).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档中列出的类型等效项在 Rust 编程中与 C++ 编程中的类型等效，但并不一定在通过 FFI 与 C 或 C++ 程序交互时等效。对于与 C 或
    C++ 互操作有用的类型，请参阅 [Rust `std::ffi` 模块文档](https://doc.rust-lang.org/std/ffi/index.html)
    和 [Rustonomicon 中的 FFI 文档](https://doc.rust-lang.org/nomicon/ffi.html)。
- en: '[Primitive types](#primitive-types)'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[原始类型](#primitive-types)'
- en: '[Integer types](#integer-types)'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[整数类型](#integer-types)'
- en: In C++, many of the integer types (like `int` and `long`) have implementation
    defined widths. In Rust, integer types are always specified with their widths,
    much like the types in `<cstdint>` in C++. When it isn't clear what integer type
    to use, [it is common to default to `i32`, which is the type that Rust defaults
    to for integer literals](https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，许多整数类型（如 `int` 和 `long`）的宽度是实现的定义。在 Rust 中，整数类型总是指定它们的宽度，类似于 C++ 中的
    `<cstdint>` 类型。当不清楚使用哪种整数类型时，[通常默认使用 `i32`，这是 Rust 为整数字面量默认的类型](https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types)。
- en: '| C++ type | Rust type |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| C++ 类型 | Rust 类型 |'
- en: '| --- | --- |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `uint8_t` | `u8` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `uint8_t` | `u8` |'
- en: '| `uint16_t` | `u16` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `uint16_t` | `u16` |'
- en: '| `uint32_t` | `u32` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `uint32_t` | `u32` |'
- en: '| `uint64_t` | `u64` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `uint64_t` | `u64` |'
- en: '| `int8_t` | `i8` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `int8_t` | `i8` |'
- en: '| `int16_t` | `i16` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `int16_t` | `i16` |'
- en: '| `int32_t` | `i32` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `int32_t` | `i32` |'
- en: '| `int64_t` | `i64` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `int64_t` | `i64` |'
- en: '| `size_t` | `usize` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `size_t` | `usize` |'
- en: '| `ptrdiff_t` | `isize` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `ptrdiff_t` | `isize` |'
- en: In C++ `size_t` is conventionally used only indexing, sizes, and offsets. The
    same is true in Rust for `usize`, which is the pointer-sized unsigned integer
    type. The pointer-sized signed integer type `isize` follows similar conventions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`size_t` 传统上仅用于索引、大小和偏移量。在 Rust 中，`usize` 也是这样，它是指针大小的无符号整数类型。指针大小的有符号整数类型
    `isize` 遵循类似的传统。
- en: Some primitive C++ and POSIX types (such as `ssize_t` and `off_t` as return
    types) do not map to `isize` because the failure case is representing using `std::io::Result`
    instead of using a negative number as a [sentinel value](./null/sentinel_values.html).
    Others (such as `fpos_t` or `off_t` as a parameter type) are represented as a
    plain `u64` or have a more explicit representation in Rust.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些原始的 C++ 和 POSIX 类型（如 `ssize_t` 和 `off_t` 作为返回类型）不映射到 `isize`，因为错误情况是用 `std::io::Result`
    表示，而不是用负数作为 [哨兵值](./null/sentinel_values.html)。其他类型（如 `fpos_t` 或 `off_t` 作为参数类型）则表示为普通的
    `u64` 或在 Rust 中有更明确的表示。
- en: '| C++ type | Rust type |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| C++ 类型 | Rust 类型 |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| POSIX `ssize_t` | [`std::io::Result<u64>`](https://doc.rust-lang.org/std/io/type.Result.html)
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| POSIX `ssize_t` | [`std::io::Result<u64>`](https://doc.rust-lang.org/std/io/type.Result.html)
    |'
- en: '| POSIX `off_t` (as argument) | `u64` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| POSIX `off_t` (作为参数) | `u64` |'
- en: '| POSIX `off_t`(as return value) | [`std::io::Result<u64>`](https://doc.rust-lang.org/std/io/type.Result.html)
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| POSIX `off_t`(作为返回值) | [`std::io::Result<u64>`](https://doc.rust-lang.org/std/io/type.Result.html)
    |'
- en: '| `fpos_t` | [`std::io::SeekFrom`](https://doc.rust-lang.org/std/io/enum.SeekFrom.html)
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `fpos_t` | [`std::io::SeekFrom`](https://doc.rust-lang.org/std/io/enum.SeekFrom.html)
    |'
- en: '[Floating point types](#floating-point-types)'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[浮点类型](#floating-point-types)'
- en: As with integer types in C++, the floating point types `float`, `double`, and
    `long double` have implementation defined widths. C++23 introduced types guaranteed
    to be IEEE 754 floats of specific widths. Of those, `float32_t` and `float64_t`
    correspond to what is usually expected from `float` and `double`. Rust's floating
    point types are analogous to these.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 中的整数类型一样，浮点类型 `float`、`double` 和 `long double` 的宽度是实现的定义。C++23 引入了保证为特定宽度的
    IEEE 754 浮点类型。其中，`float32_t` 和 `float64_t` 对应于通常从 `float` 和 `double` 期望的类型。Rust
    的浮点类型与此类似。
- en: '| C++ type | Rust type |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| C++ 类型 | Rust 类型 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `float16_t` |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `float16_t` |  |'
- en: '| `float32_t` | `f32` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `float32_t` | `f32` |'
- en: '| `float64_t` | `f64` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `float64_t` | `f64` |'
- en: '| `float128_t` |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `float128_t` |  |'
- en: The Rust types analogous to `float16_t` and `float128_t` (`f16` and `f128`)
    are [not yet available in stable Rust](https://github.com/rust-lang/rust/issues/116909).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中与 `float16_t` 和 `float128_t`（`f16` 和 `f128`）相对应的类型在稳定的 Rust 中[尚未提供](https://github.com/rust-lang/rust/issues/116909)。
- en: '[Raw memory types](#raw-memory-types)'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[原始内存类型](#raw-memory-types)'
- en: In C++ pointers to or arrays of `char`, `unsigned char`, or `byte` are used
    to represent raw memory. In Rust, arrays (`[u8; N]`), vectors (`Vec<u8>`), or
    slices (`&[u8]`) of `u8` are used to accomplish the same goal. However, accessing
    the underlying memory of another Rust value in that way requires unsafe Rust.
    There are [libraries](../etc/libraries.html) for creating safe wrappers around
    that kind of access for purposes such as serialization or interacting with hardware.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，使用 `char`、`unsigned char` 或 `byte` 的指针或数组来表示原始内存。在 Rust 中，使用 `u8` 的数组（`[u8;
    N]`）、向量（`Vec<u8>`）或切片（`&[u8]`）来完成相同的目标。然而，以这种方式访问另一个 Rust 值的底层内存需要不安全 Rust。有 [库](../etc/libraries.html)
    可以创建围绕这种访问的安全包装，用于诸如序列化或与硬件交互等目的。
- en: '[Character and string types](#character-and-string-types)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[字符和字符串类型](#character-and-string-types)'
- en: The C++ `char` or `wchar_t` types have implementation defined widths. Rust does
    not have an equivalent to these types. When working with string encodings in Rust
    one would use unsigned integer types where one would use the fixed width character
    types in C++.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的 `char` 或 `wchar_t` 类型具有实现定义的宽度。Rust 没有这些类型的等效类型。在 Rust 中处理字符串编码时，会使用无符号整数类型，而在
    C++ 中会使用固定宽度的字符类型。
- en: '| C++ type | Rust type |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| C++ 类型 | Rust 类型 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `char8_t` | `u8` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `char8_t` | `u8` |'
- en: '| `char16_t` | `u16` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `char16_t` | `u16` |'
- en: The Rust `char` type represents a Unicode scalar value. Thus, a Rust `char`
    is the same size as a `u32`. For working with characters in Rust strings (which
    are guaranteed to be valid UTF-8), the `char` type is appropriate. For representing
    a byte, one should instead use `u8`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的 `char` 类型表示一个 Unicode 标量值。因此，Rust 的 `char` 的大小与 `u32` 相同。对于在 Rust 字符串中处理字符（这些字符串保证是有效的
    UTF-8），`char` 类型是合适的。对于表示一个字节，应使用 `u8`。
- en: 'The Rust standard library includes a type for UTF-8 strings and string slices:
    `String` and `&str`, respectively. Both types guarantee that represented strings
    are valid UTF-8\. The Rust `char` type is appropriate for representing elements
    of a `String`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库包括用于 UTF-8 字符串和字符串切片的类型：`String` 和 `&str`。这两种类型都保证表示的字符串是有效的 UTF-8。Rust
    的 `char` 类型适用于表示 `String` 的元素。
- en: Because `str` (without the reference) is a slice, it is unsized and therefore
    must be used behind a pointer-like construct, such as a reference or box. For
    this reason, string slices are often described as `&str` instead of `str` in documentation,
    even though they can also be used as `Box<str>`, `Rc<str>`, etc.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `str`（不带引用）是一个切片，它没有大小，因此必须使用类似指针的结构，例如引用或盒式结构。因此，在文档中，字符串切片通常描述为 `&str`
    而不是 `str`，尽管它们也可以用作 `Box<str>`、`Rc<str>` 等。
- en: 'Rust also includes types for platform-specific string representations and slices
    of those strings: [`std::ffi::OsString`](https://doc.rust-lang.org/std/ffi/struct.OsString.html)
    and `&std::ffi::OsStr`. While these strings use the OS-specific representation,
    to use one with the Rust FFI, it must still be converted to a [`CString`](https://doc.rust-lang.org/std/ffi/struct.CString.html).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 还包括用于平台特定字符串表示及其字符串切片的类型：`std::ffi::OsString` 和 `&std::ffi::OsStr`。虽然这些字符串使用
    OS 特定的表示，但为了使用 Rust FFI，它们必须转换为 `CString`（[https://doc.rust-lang.org/std/ffi/struct.CString.html](https://doc.rust-lang.org/std/ffi/struct.CString.html)）。
- en: Unlike C++ which has `std::u16string`, Rust has no specific representation for
    UTF-16 strings. Something like `Vec<u16>` can be used, but the type will not guarantee
    that its contents are a valid UTF-16 string. Rust does provide a mechanisms for
    converting `String` to and from a UTF-16 encoding ([`String::encode_utf16`](https://doc.rust-lang.org/std/string/struct.String.html#method.encode_utf16)
    and [`String::from_utf16`](https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16),
    among others) as well as similar mechanisms for accessing the underlying UTF-8
    encoding (https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与有 `std::u16string` 的 C++ 不同，Rust 没有专门用于 UTF-16 字符串的表示形式。可以使用类似 `Vec<u16>` 的东西，但类型不会保证其内容是有效的
    UTF-16 字符串。Rust 也提供了将 `String` 转换为 UTF-16 编码以及从 UTF-16 编码转换回 `String` 的机制（例如 `[String::encode_utf16](https://doc.rust-lang.org/std/string/struct.String.html#method.encode_utf16)`
    和 `[String::from_utf16](https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16)`），以及访问底层
    UTF-8 编码的类似机制（[https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8](https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8)）。
- en: '| Purpose | Rust type |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | Rust 类型 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| representing text | `String` and `&str` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 表示文本 | `String` 和 `&str` |'
- en: '| representing bytes | vectors, arrays, or slices of `u8` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 表示字节 | 向量、数组或 `u8` 的切片 |'
- en: '| interacting with OS | `OsString` and `&OsStr` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 与操作系统交互 | `OsString` 和 `&OsStr` |'
- en: '| representing UTF-8 | `String` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 表示 UTF-8 | `String` |'
- en: '| representing UTF-16 | use [a library](../etc/libraries.html) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 表示 UTF-16 | 使用 [一个库](../etc/libraries.html) |'
- en: '[Boolean types](#boolean-types)'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[布尔类型](#boolean-types)'
- en: The `bool` type in Rust is analogous to the `bool` type in C++. Unlike C++,
    Rust makes [guarantees about the size, alignment, and bit pattern used to represent
    values of the `bool` type](https://doc.rust-lang.org/reference/types/boolean.html).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的 `bool` 类型与 C++ 中的 `bool` 类型类似。与 C++ 不同，Rust 对 `bool` 类型的值所使用的尺寸、对齐方式和位模式做出了[保证](https://doc.rust-lang.org/reference/types/boolean.html)。
- en: '[`void`](#void)'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`void`](#void)'
- en: In C++ `void` indicates that a function does not return a value. Because Rust
    is expression-oriented, all functions return values. In the place of `void`, Rust
    uses the unit type `()`. When a function does not have a return type declared,
    `()` is the return type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`void` 表示函数不返回值。由于 Rust 是面向表达式的，所有函数都返回值。在 `void` 的位置，Rust 使用单位类型 `()`。当函数没有声明返回类型时，`()`
    是返回类型。
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#![allow(unused)] fn main() { fn process() {'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { fn process() {'
- en: println!("Does something but returns nothing.");
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: println!("Does something but returns nothing.");
- en: '}'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the unit type has only one value (also written `()`), values of the type
    provide no information. This also means that the return value can be left implicit,
    as in the above example. The following example makes the unit type usage explicit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单位类型只有一个值（也写作 `()`），该类型的值不提供任何信息。这也意味着返回值可以省略，就像上面的示例一样。以下示例使单位类型的用法明确。
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#![allow(unused)] fn main() { fn process() -> () {'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { fn process() -> () {'
- en: let () = println!("Does something but returns nothing.");
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let () = println!("Does something but returns nothing.");
- en: ()
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ()
- en: '}'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The syntax of the unit type and syntax of the unit value resemble that of an
    empty tuple. Essentially, that is what the type is. The following example shows
    some equivalent types, though without the special syntax or language integration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 单位类型和单位值的语法类似于空元组的语法。本质上，类型就是这样。以下示例展示了某些等效类型，尽管没有特殊的语法或语言集成。
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: struct Pair<T1, T2>(T1, T2); // the same as (T1, T2)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: struct Pair<T1, T2>(T1, T2); // 与 (T1, T2) 相同
- en: struct Single<T>(T); // a tuple with just one value (T1)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: struct Single<T>(T); // 只包含一个值 (T1) 的元组
- en: struct Unit; // the same as ()
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: struct Unit; // 与 () 相同
- en: // can also be written as
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: // 也可以写成
- en: // struct Unit();
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: // struct Unit();
- en: fn main() {
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: let pair = Pair(1,2.0);
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let pair = Pair(1,2.0);
- en: let single = Single(1);
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let single = Single(1);
- en: let unit = Unit;
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let unit = Unit;
- en: // can also be written as
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 也可以写成
- en: // let unit = Unit();
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // let unit = Unit();
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using a unit type instead of `void` enables expressions with unit type (such
    as function calls that would return `void` in C++) to be used in contexts that
    expect a value. This is especially helpful with defining and using generic functions,
    instead of needing something like `std::is_void` to special-case the handling
    when a type is `void`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单位类型而不是 `void` 允许在需要值的环境中（例如，在 C++ 中会返回 `void` 的函数调用）使用单位类型（如函数调用），这特别有助于定义和使用泛型函数，而不需要像
    `std::is_void` 那样为 `void` 类型进行特殊处理。
- en: '[Pointers](#pointers)'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[指针](#pointers)'
- en: The following table maps the ownership-managing classes from C++ to equivalents
    types in Rust.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格将 C++ 中的所有权管理类映射到 Rust 中的等效类型。
- en: '| Use | C++ type | Rust type |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 用途 | C++ 类型 | Rust 类型 |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Owned | `T` | `T` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 所有权 | `T` | `T` |'
- en: '| Single owner, dynamic storage | `std::unique_ptr<T>` | `Box<T>` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 单个所有者，动态存储 | `std::unique_ptr<T>` | `Box<T>` |'
- en: '| Shared owner, dynamic storage, immutable, not thread-safe | `std::shared_ptr<T>`
    | `std::rc::Rc<T>` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 共享所有者，动态存储，不可变，非线程安全 | `std::shared_ptr<T>` | `std::rc::Rc<T>` |'
- en: '| Shared owner, dynamic storage, immutable, thread-safe | `std::shared_ptr<T>`
    | `std::sync::Arc<T>` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 共享所有者，动态存储，不可变，线程安全 | `std::shared_ptr<T>` | `std::sync::Arc<T>` |'
- en: '| Shared owner, dynamic storage, mutable, not thread-safe | `std::shared_ptr<T>`
    | [`std::rc::Rc<std::cell::RefCell<T>>`](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 共享所有者，动态存储，可变，非线程安全 | `std::shared_ptr<T>` | [`std::rc::Rc<std::cell::RefCell<T>>`](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt)
    |'
- en: '| Shared owner, dynamic storage, mutable, thread-safe | `std::shared_ptr<T>`
    with a `std::mutex` | [`std::sync::Arc<std::mutex::Mutex<T>>`](https://doc.rust-lang.org/book/ch16-03-shared-state.html)
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 共享所有者，动态存储，可变，线程安全 | `std::shared_ptr<T>` 与 `std::mutex` | [`std::sync::Arc<std::mutex::Mutex<T>>`](https://doc.rust-lang.org/book/ch16-03-shared-state.html)
    |'
- en: '| Const reference | `const &T` | `&T` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 常量引用 | `const &T` | `&T` |'
- en: '| Mutable reference | `&T` | `&mut T` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 可变引用 | `&T` | `&mut T` |'
- en: '| Const observer pointer | `const *T` | `&T` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 常量观察者指针 | `const *T` | `&T` |'
- en: '| Mutable observer pointer | `*T` | `&mut T` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 可变观察者指针 | `*T` | `&mut T` |'
- en: In C++, the thread safety of `std::shared_ptr` is more nuanced than it appears
    in this table (e.g., some uses may require `std::atomic`). However, in safe Rust
    the compiler will prevent the incorrect use of the shared owner types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`std::shared_ptr` 的线程安全性比表中显示的要复杂（例如，某些使用可能需要 `std::atomic`）。然而，在安全的
    Rust 中，编译器将防止错误使用共享所有者类型。
- en: Unlike with C++ references, Rust can have references-to-references. Rust references
    are more like observer pointers than they are like C++ references.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 引用不同，Rust 可以有引用到引用。Rust 的引用更像是观察者指针，而不是像 C++ 引用那样。
- en: '[`void*`](#void-1)'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`void*`](#void-1)'
- en: Rust does not have anything directly analogous to `void*` in C++. The upcoming
    chapter on `RTTI` will cover some use cases where the goal is dynamic typing.
    The [FFI chapter of the Rustonomicon](https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs)
    covers some use cases where the goal is interoperability with C programs that
    use `void*`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有与 C++ 中的 `void*` 直接对应的东西。即将到来的关于 `RTTI` 的章节将涵盖一些目标是动态类型的使用案例。Rustonomicon
    的 [FFI 章节覆盖了一些使用案例](https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs)，其中目标是与使用
    `void*` 的 C 程序进行互操作。
- en: '[Containers](#containers)'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[容器](#containers)'
- en: Both C++ and Rust containers own their elements. However, in both the element
    type may be a non-owning type, such as a pointer in C++ or a reference in Rust.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 和 Rust 容器都拥有自己的元素。然而，在两者中，元素类型可能是一个非拥有类型，例如 C++ 中的指针或 Rust 中的引用。
- en: '| C++ type | Rust type |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| C++ 类型 | Rust 类型 |'
- en: '| --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `std::vector<T>` | [`Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html)
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `std::vector<T>` | [`Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html)
    |'
- en: '| `std::array<T, N>` | [`[T; N]`](https://doc.rust-lang.org/std/primitive.array.html)
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `std::array<T, N>` | [`[T; N]`](https://doc.rust-lang.org/std/primitive.array.html)
    |'
- en: '| `std::list<T>` | [`std::collections::LinkedList<T>`](https://doc.rust-lang.org/std/collections/struct.LinkedList.html)
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `std::list<T>` | [`std::collections::LinkedList<T>`](https://doc.rust-lang.org/std/collections/struct.LinkedList.html)
    |'
- en: '| `std::queue<T>` | [`std::collections::VecDeque<T>`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html)
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `std::queue<T>` | [`std::collections::VecDeque<T>`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html)
    |'
- en: '| `std::deque<T>` | [`std::collections::VecDeque<T>`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html)
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `std::deque<T>` | [`std::collections::VecDeque<T>`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html)
    |'
- en: '| `std::stack<T>` | [`Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html)
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `std::stack<T>` | [`Vec<T>`](https://doc.rust-lang.org/std/vec/struct.Vec.html)
    |'
- en: '| `std::map<K,V>` | [`std::collections::BTreeMap<K,V>`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html)
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `std::map<K,V>` | [`std::collections::BTreeMap<K,V>`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html)
    |'
- en: '| `std::unordered_map<K,V>` | [`std::collections::HashMap<K,V>`](https://doc.rust-lang.org/std/collections/struct.HashMap.html)
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `std::unordered_map<K,V>` | [`std::collections::HashMap<K,V>`](https://doc.rust-lang.org/std/collections/struct.HashMap.html)
    |'
- en: '| `std::set<K>` | [`std::collections::BTreeSet<K>`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `std::set<K>` | [`std::collections::BTreeSet<K>`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)
    |'
- en: '| `std::unordered_set<K>` | [`std::collections::HashSet<K>`](https://doc.rust-lang.org/std/collections/struct.HashSet.html)
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `std::unordered_set<K>` | [`std::collections::HashSet<K>`](https://doc.rust-lang.org/std/collections/struct.HashSet.html)
    |'
- en: '| `std::priority_queue<T>` | [`std::collections::BinaryHeap<T>`](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `std::priority_queue<T>` | [`std::collections::BinaryHeap<T>`](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)
    |'
- en: '| `std::span<T>` | [`&[T]`](https://doc.rust-lang.org/std/primitive.slice.html)
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `std::span<T>` | [`&[T]`](https://doc.rust-lang.org/std/primitive.slice.html)
    |'
- en: For maps and sets instead of the container being parameterized over the hash
    or comparison function used, the types require that the key types implement the
    `std::hash::Hash` (unordered) or `std::cmp::Ord` (ordered) traits. To use the
    containers with different hash or comparison functions, one must use a wrapper
    type with a different implementation of the required trait.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射和集合，与容器通过哈希或比较函数参数化相比，类型要求键类型实现 `std::hash::Hash`（无序）或 `std::cmp::Ord`（有序）特性。要使用具有不同哈希或比较函数的容器，必须使用具有不同特性实现的包装类型。
- en: Some C++ container types provided by the STL have no equivalent in Rust. Many
    of those have equivalents available in third-party [libraries](../etc/libraries.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由 STL 提供的许多 C++ 容器类型在 Rust 中没有等效类型。其中许多类型在第三方 [库](../etc/libraries.html) 中有等效可用。
- en: One significant different in the use of these types between C++ in Rust is with
    the `Vec<T>` and array `[T; N]` types, from which slice references `&[T]` or `&mut
    [T]` to part or all of the data can be cheaply created. For this reason, when
    defining a function that does not modify the length of a vector and does not need
    to statically know the number of elements in an array, it is more idiomatic to
    take a parameter as `&[T]` or `&mut [T]` than as a reference to the owned type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 和 Rust 中使用这些类型的一个显著不同之处在于 `Vec<T>` 和数组 `[T; N]` 类型，可以从这些类型中便宜地创建数据的一部分或全部的切片引用
    `&[T]` 或 `&mut [T]`。因此，当定义一个不修改向量长度且不需要静态知道数组中元素数量的函数时，将参数作为 `&[T]` 或 `&mut [T]`
    而不是所有类型的引用更为习惯。
- en: In C++ it is better to take begin and end iterators or a range than a `span`
    when possible, since iterators are more general. The same is true with Rust and
    taking a generic type that implements `IntoIter<&T>` or `IntoIter<&mut T>` instead
    of `&[T]`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，如果可能的话，最好使用开始和结束迭代器或范围而不是 `span`，因为迭代器更通用。同样，在 Rust 中，使用实现 `IntoIter<&T>`
    或 `IntoIter<&mut T>` 的泛型类型，而不是 `&[T]` 也是如此。
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: use std::iter::IntoIterator;
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: use std::iter::IntoIterator;
- en: 'fn go<''a>(iter: impl IntoIterator<Item = &''a mut i32>) {'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn go<''a>(iter: impl IntoIterator<Item = &''a mut i32>) {'
- en: for x in iter {
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: for x in iter {
- en: // ...
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: fn main() {
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: let mut v = vec![1, 2, 3];
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let mut v = vec![1, 2, 3];
- en: go(&mut v);
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: go(&mut v);
- en: '}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <link rel="stylesheet" type="text/css" href="../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Type
    equivalents)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" type="text/css" href="../quiz/style.css"> [点击此处为此页面提供反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Type
    equivalents)
