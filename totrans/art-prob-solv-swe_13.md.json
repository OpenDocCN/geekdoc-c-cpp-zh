["```cpp\ntypedef std::unordered_map<\n      std::string, Gtid_set_ref *, std::hash<std::string>,\n      std::equal_to<std::string>,\n      Malloc_allocator<std::pair<const std::string, Gtid_set_ref *>>>\n      Certification_info;\n  ...\n  /**\n    Certification database.\n  */\n  Certification_info certification_info; \n```", "```cpp\nbool Certifier::add_item(const char *item, Gtid_set_ref *snapshot_version,\n                         int64 *item_previous_sequence_number) {\n  DBUG_TRACE;\n  mysql_mutex_assert_owner(&LOCK_certification_info);\n  bool error = true;\n  std::string key(item);\n  Certification_info::iterator it = certification_info.find(key);\n  snapshot_version->link();\n  if (it == certification_info.end()) {\n    std::pair<Certification_info::iterator, bool> ret =\n        certification_info.insert(\n            std::pair<std::string, Gtid_set_ref *>(key, snapshot_version));\n    error = !ret.second;\n  } else {\n    *item_previous_sequence_number =\n        it->second->get_parallel_applier_sequence_number();\n    if (it->second->unlink() == 0) delete it->second;\n    it->second = snapshot_version;\n    error = false;\n  }\n  ...\n  return error;\n} \n```", "```cpp\nvoid Plugin_gcs_events_handler::handle_certifier_message(\n    const Gcs_message &message) const {\n  if (this->applier_module == nullptr) {\n    LogPluginErr(ERROR_LEVEL,\n                 ER_GRP_RPL_MISSING_GRP_RPL_APPLIER); /* purecov: inspected */\n    return;                                           /* purecov: inspected */\n  }\n  Certifier_interface *certifier =\n      this->applier_module->get_certification_handler()->get_certifier();\n  const unsigned char *payload_data = nullptr;\n  size_t payload_size = 0;\n  Plugin_gcs_message::get_first_payload_item_raw_data(\n      message.get_message_data().get_payload(), &payload_data, &payload_size);\n  if (certifier->handle_certifier_data(payload_data,\n                                       static_cast<ulong>(payload_size),\n                                       message.get_origin())) {\n    LogPluginErr(\n        ERROR_LEVEL,\n        ER_GRP_RPL_CERTIFIER_MSSG_PROCESS_ERROR); /* purecov: inspected */\n  }\n} \n```", "```cpp\n#define REPLAY_CAL_HASH_ITEMS (REPLAY_CAL_HASH_ITEM / 8)\n#define MAX_RELATIVE_SEQUENCE_NUMBER 65535\n#define REPLAY_CAL_ARRAY 65536\n#define REPLAY_CAL_HASH_ITEM 4088 typedef struct {\n  int number;\n  int size;\n  unsigned char values[REPLAY_CAL_HASH_ITEM];\n} replay_cal_hash_item;\n\nclass Certifier : public Certifier_interface {\n ...\n private:\n  replay_cal_hash_item replayed_cal_array[REPLAY_CAL_ARRAY];\n ... \n```", "```cpp\n    static double wakeup_delay(double old) {\n      double const minimum_threshold = 0.1;\n    #ifdef EXECUTOR_TASK_AGGRESSIVE_NO_OP  \n      double const maximum_threshold = 1.0;\n    #else   \n      double const maximum_threshold = 20.0;\n    #endif /* EXECUTOR_TASK_AGGRESSIVE_NO_OP */   double retval = 0.0;\n      if (0.0 == old) {\n        double m = median_time();\n        double const fuzz = 5.0;\n        IFDBG(D_BUG, FN; NDBG(m, f));\n        // Guard against unreasonable estimates of median consensus time\n        if (m <= 0.0) m = minimum_threshold;\n        if (m > maximum_threshold / fuzz) m = (maximum_threshold / fuzz) / 2.0;\n        retval = minimum_threshold + fuzz * m + m * xcom_drand48();\n      } else {\n        retval = old * 1.4142136; /* Exponential backoff */\n      } \n      /* If we exceed maximum, choose a random value in the max/2..max interval */\n      if (retval > maximum_threshold) {\n        double const low = maximum_threshold / 2.0;\n        retval = low + xcom_drand48() * (maximum_threshold - low);\n      }\n      IFDBG(D_BUG, FN; NDBG(retval, f));\n      return retval;\n    } \n    ```", "```cpp\n     while (!finished(ep->p)) { /* Try to get a value accepted */\n            /* We will wake up periodically, and whenever a message arrives */\n            TIMED_TASK_WAIT(&ep->p->rv, ep->delay = wakeup_delay(ep->delay));\n            ... \n    ```", "```cpp\n     DECL_ENV\n      ...\n      while (!finished(*p)) {\n        ...\n        if (!((*p)->force_delivery)) {\n          ep->delay = wakeup_delay_for_perf(ep->delay, 0.003);\n        } else {\n          ep->delay = wakeup_delay_for_perf(ep->delay, 0.1);\n        }\n        IFDBG(D_NONE, FN; NDBG(ep->delay, f));\n        TIMED_TASK_WAIT(&(*p)->rv, ep->delay);\n        *p = get_cache(msgno);\n        dump_debug_exec_state();\n      }\n      FINALLY\n      IFDBG(D_NONE, FN; SYCEXP(msgno); PTREXP(*p); NDBG(ep->wait, u);\n            SYCEXP(msgno));\n      TASK_END;\n    } \n    ```", "```cpp\nstatic void expand_lru() {\n  uint64_t i;\n  for (i = 0; i < BUCKETS; i++) { \n    lru_machine *l = (lru_machine *)xcom_calloc(1, sizeof(lru_machine));\n    link_init(&l->lru_link, TYPE_HASH(\"lru_machine\"));\n    link_into(&l->lru_link, &probation_lru);\n    init_pax_machine(&l->pax, l, null_synode);\n    cache_length++;\n  }\n} \n```", "```cpp\nstatic size_t length_increment = INCREMENT;\nstatic size_t size_decrement = INCREMENT / 10;\n#define BUCKETS length_increment \n```", "```cpp\n#define MIN_LENGTH MIN_CACHE_SIZE /* Also Default value */ #define INCREMENT MIN_LENGTH /* Total number of slots to add/remove */ \n```", "```cpp\nenum {\n  EVENT_HORIZON_MIN = 10, \n  EVENT_HORIZON_MAX = 200,\n  MAX_BATCH_SIZE = 0x3fffffff, /* Limit batch size to sensible ? amount */\n  MAX_BATCH_APP_DATA = 5000,   /* Limit nr. of batched elements */\n  MAX_DEAD = 10, \n  PROPOSERS = 10,              /* The number of proposers on one node */\n  MIN_CACHE_SIZE = 250000,     /* Minimum cache size */\n  DEFAULT_CACHE_LIMIT = 1000000000UL /* Reasonable initial cache limit */\n}; \n```"]