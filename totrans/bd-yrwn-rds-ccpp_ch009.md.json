["```cpp\n[](#cb1-1)// hashtable node, should be embedded into the payload\n[](#cb1-2)struct HNode {\n[](#cb1-3)    HNode *next = NULL;\n[](#cb1-4)    uint64_t hcode = 0;\n[](#cb1-5)};\n[](#cb1-6)\n[](#cb1-7)// a simple fixed-sized hashtable\n[](#cb1-8)struct HTab {\n[](#cb1-9)    HNode **tab = NULL;\n[](#cb1-10)    size_t mask = 0;\n[](#cb1-11)    size_t size = 0;\n[](#cb1-12)};\n```", "```cpp\n[](#cb2-1)// n must be a power of 2\n[](#cb2-2)static void h_init(HTab *htab, size_t n) {\n[](#cb2-3)    assert(n > 0 && ((n - 1) & n) == 0);\n[](#cb2-4)    htab->tab = (HNode **)calloc(sizeof(HNode *), n);\n[](#cb2-5)    htab->mask = n - 1;\n[](#cb2-6)    htab->size = 0;\n[](#cb2-7)}\n[](#cb2-8)\n[](#cb2-9)// hashtable insertion\n[](#cb2-10)static void h_insert(HTab *htab, HNode *node) {\n[](#cb2-11)    size_t pos = node->hcode & htab->mask;\n[](#cb2-12)    HNode *next = htab->tab[pos];\n[](#cb2-13)    node->next = next;\n[](#cb2-14)    htab->tab[pos] = node;\n[](#cb2-15)    htab->size++;\n[](#cb2-16)}\n```", "```cpp\n[](#cb3-1)// hashtable look up subroutine.\n[](#cb3-2)// Pay attention to the return value. It returns the address of\n[](#cb3-3)// the parent pointer that owns the target node,\n[](#cb3-4)// which can be used to delete the target node.\n[](#cb3-5)static HNode **h_lookup(\n[](#cb3-6)    HTab *htab, HNode *key, bool (*cmp)(HNode *, HNode *))\n[](#cb3-7){\n[](#cb3-8)    if (!htab->tab) {\n[](#cb3-9)        return NULL;\n[](#cb3-10)    }\n[](#cb3-11)\n[](#cb3-12)    size_t pos = key->hcode & htab->mask;\n[](#cb3-13)    HNode **from = &htab->tab[pos];\n[](#cb3-14)    while (*from) {\n[](#cb3-15)        if (cmp(*from, key)) {\n[](#cb3-16)            return from;\n[](#cb3-17)        }\n[](#cb3-18)        from = &(*from)->next;\n[](#cb3-19)    }\n[](#cb3-20)    return NULL;\n[](#cb3-21)}\n```", "```cpp\n[](#cb4-1)// remove a node from the chain\n[](#cb4-2)static HNode *h_detach(HTab *htab, HNode **from) {\n[](#cb4-3)    HNode *node = *from;\n[](#cb4-4)    *from = (*from)->next;\n[](#cb4-5)    htab->size--;\n[](#cb4-6)    return node;\n[](#cb4-7)}\n```", "```cpp\n[](#cb5-1)// the real hashtable interface.\n[](#cb5-2)// it uses 2 hashtables for progressive resizing.\n[](#cb5-3)struct HMap {\n[](#cb5-4)    HTab ht1;\n[](#cb5-5)    HTab ht2;\n[](#cb5-6)    size_t resizing_pos = 0;\n[](#cb5-7)};\n```", "```cpp\n[](#cb6-1)HNode *hm_lookup(\n[](#cb6-2)    HMap *hmap, HNode *key, bool (*cmp)(HNode *, HNode *))\n[](#cb6-3){\n[](#cb6-4)    hm_help_resizing(hmap);\n[](#cb6-5)    HNode **from = h_lookup(&hmap->ht1, key, cmp);\n[](#cb6-6)    if (!from) {\n[](#cb6-7)        from = h_lookup(&hmap->ht2, key, cmp);\n[](#cb6-8)    }\n[](#cb6-9)    return from ? *from : NULL;\n[](#cb6-10)}\n```", "```cpp\n[](#cb7-1)const size_t k_resizing_work = 128;\n[](#cb7-2)\n[](#cb7-3)static void hm_help_resizing(HMap *hmap) {\n[](#cb7-4)    if (hmap->ht2.tab == NULL) {\n[](#cb7-5)        return;\n[](#cb7-6)    }\n[](#cb7-7)\n[](#cb7-8)    size_t nwork = 0;\n[](#cb7-9)    while (nwork < k_resizing_work && hmap->ht2.size > 0) {\n[](#cb7-10)        // scan for nodes from ht2 and move them to ht1\n[](#cb7-11)        HNode **from = &hmap->ht2.tab[hmap->resizing_pos];\n[](#cb7-12)        if (!*from) {\n[](#cb7-13)            hmap->resizing_pos++;\n[](#cb7-14)            continue;\n[](#cb7-15)        }\n[](#cb7-16)\n[](#cb7-17)        h_insert(&hmap->ht1, h_detach(&hmap->ht2, from));\n[](#cb7-18)        nwork++;\n[](#cb7-19)    }\n[](#cb7-20)\n[](#cb7-21)    if (hmap->ht2.size == 0) {\n[](#cb7-22)        // done\n[](#cb7-23)        free(hmap->ht2.tab);\n[](#cb7-24)        hmap->ht2 = HTab{};\n[](#cb7-25)    }\n[](#cb7-26)}\n```", "```cpp\n[](#cb8-1)const size_t k_max_load_factor = 8;\n[](#cb8-2)\n[](#cb8-3)void hm_insert(HMap *hmap, HNode *node) {\n[](#cb8-4)    if (!hmap->ht1.tab) {\n[](#cb8-5)        h_init(&hmap->ht1, 4);\n[](#cb8-6)    }\n[](#cb8-7)    h_insert(&hmap->ht1, node);\n[](#cb8-8)\n[](#cb8-9)    if (!hmap->ht2.tab) {\n[](#cb8-10)        // check whether we need to resize\n[](#cb8-11)        size_t load_factor = hmap->ht1.size / (hmap->ht1.mask + 1);\n[](#cb8-12)        if (load_factor >= k_max_load_factor) {\n[](#cb8-13)            hm_start_resizing(hmap);\n[](#cb8-14)        }\n[](#cb8-15)    }\n[](#cb8-16)    hm_help_resizing(hmap);\n[](#cb8-17)}\n[](#cb8-18)\n[](#cb8-19)static void hm_start_resizing(HMap *hmap) {\n[](#cb8-20)    assert(hmap->ht2.tab == NULL);\n[](#cb8-21)    // create a bigger hashtable and swap them\n[](#cb8-22)    hmap->ht2 = hmap->ht1;\n[](#cb8-23)    h_init(&hmap->ht1, (hmap->ht1.mask + 1) * 2);\n[](#cb8-24)    hmap->resizing_pos = 0;\n[](#cb8-25)}\n```", "```cpp\n[](#cb9-1)HNode *hm_pop(\n[](#cb9-2)    HMap *hmap, HNode *key, bool (*cmp)(HNode *, HNode *))\n[](#cb9-3){\n[](#cb9-4)    hm_help_resizing(hmap);\n[](#cb9-5)    HNode **from = h_lookup(&hmap->ht1, key, cmp);\n[](#cb9-6)    if (from) {\n[](#cb9-7)        return h_detach(&hmap->ht1, from);\n[](#cb9-8)    }\n[](#cb9-9)    from = h_lookup(&hmap->ht2, key, cmp);\n[](#cb9-10)    if (from) {\n[](#cb9-11)        return h_detach(&hmap->ht2, from);\n[](#cb9-12)    }\n[](#cb9-13)    return NULL;\n[](#cb9-14)}\n```", "```cpp\n[](#cb10-1)// the structure for the key\n[](#cb10-2)struct Entry {\n[](#cb10-3)    struct HNode node;\n[](#cb10-4)    std::string  key;\n[](#cb10-5)    std::string  val;\n[](#cb10-6)};\n```", "```cpp\n[](#cb11-1)// The data structure for the key space.\n[](#cb11-2)static struct {\n[](#cb11-3)    HMap db;\n[](#cb11-4)} g_data;\n[](#cb11-5)\n[](#cb11-6)static uint32_t do_get(\n[](#cb11-7)    std::vector<std::string> &cmd, uint8_t *res, uint32_t *reslen)\n[](#cb11-8){\n[](#cb11-9)    Entry key;\n[](#cb11-10)    key.key.swap(cmd[1]);\n[](#cb11-11)    key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());\n[](#cb11-12)\n[](#cb11-13)    HNode *node = hm_lookup(&g_data.db, &key.node, &entry_eq);\n[](#cb11-14)    if (!node) {\n[](#cb11-15)        return RES_NX;\n[](#cb11-16)    }\n[](#cb11-17)\n[](#cb11-18)    const std::string &val = container_of(node, Entry, node)->val;\n[](#cb11-19)    assert(val.size() <= k_max_msg);\n[](#cb11-20)    memcpy(res, val.data(), val.size());\n[](#cb11-21)    *reslen = (uint32_t)val.size();\n[](#cb11-22)    return RES_OK;\n[](#cb11-23)}\n[](#cb11-24)\n[](#cb11-25)static bool entry_eq(HNode *lhs, HNode *rhs) {\n[](#cb11-26)    struct Entry *le = container_of(lhs, struct Entry, node);\n[](#cb11-27)    struct Entry *re = container_of(rhs, struct Entry, node);\n[](#cb11-28)    return lhs->hcode == rhs->hcode && le->key == re->key;\n[](#cb11-29)}\n```", "```cpp\n[](#cb12-1)#define container_of(ptr,  type,  member)  ({  \\\n[](#cb12-2)  const  typeof(  ((type  *)0)->member  )  *__mptr  =  (ptr);  \\\n[](#cb12-3)  (type  *)(  (char  *)__mptr  -  offsetof(type,  member)  );})\n```", "```cpp\n[](#cb13-1)static uint32_t do_set(\n[](#cb13-2)    std::vector<std::string> &cmd, uint8_t *res, uint32_t *reslen)\n[](#cb13-3){\n[](#cb13-4)    (void)res;\n[](#cb13-5)    (void)reslen;\n[](#cb13-6)\n[](#cb13-7)    Entry key;\n[](#cb13-8)    key.key.swap(cmd[1]);\n[](#cb13-9)    key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());\n[](#cb13-10)\n[](#cb13-11)    HNode *node = hm_lookup(&g_data.db, &key.node, &entry_eq);\n[](#cb13-12)    if (node) {\n[](#cb13-13)        container_of(node, Entry, node)->val.swap(cmd[2]);\n[](#cb13-14)    } else {\n[](#cb13-15)        Entry *ent = new Entry();\n[](#cb13-16)        ent->key.swap(key.key);\n[](#cb13-17)        ent->node.hcode = key.node.hcode;\n[](#cb13-18)        ent->val.swap(cmd[2]);\n[](#cb13-19)        hm_insert(&g_data.db, &ent->node);\n[](#cb13-20)    }\n[](#cb13-21)    return RES_OK;\n[](#cb13-22)}\n[](#cb13-23)\n[](#cb13-24)static uint32_t do_del(\n[](#cb13-25)    std::vector<std::string> &cmd, uint8_t *res, uint32_t *reslen)\n[](#cb13-26){\n[](#cb13-27)    (void)res;\n[](#cb13-28)    (void)reslen;\n[](#cb13-29)\n[](#cb13-30)    Entry key;\n[](#cb13-31)    key.key.swap(cmd[1]);\n[](#cb13-32)    key.node.hcode = str_hash((uint8_t *)key.key.data(), key.key.size());\n[](#cb13-33)\n[](#cb13-34)    HNode *node = hm_pop(&g_data.db, &key.node, &entry_eq);\n[](#cb13-35)    if (node) {\n[](#cb13-36)        delete container_of(node, Entry, node);\n[](#cb13-37)    }\n[](#cb13-38)    return RES_OK;\n[](#cb13-39)}\n```"]