["```cpp\n+------+-----+------+-----+------+-----+-----+------+\n| nstr | len | str1 | len | str2 | ... | len | strn |\n+------+-----+------+-----+------+-----+-----+------+\n```", "```cpp\n+-----+---------+\n| res | data... |\n+-----+---------+\n```", "```cpp\n[](#cb3-1)static bool try_one_request(Conn *conn) {\n[](#cb3-2)    // try to parse a request from the buffer\n[](#cb3-3)    if (conn->rbuf_size < 4) {\n[](#cb3-4)        // not enough data in the buffer. Will retry in the next iteration\n[](#cb3-5)        return false;\n[](#cb3-6)    }\n[](#cb3-7)    uint32_t len = 0;\n[](#cb3-8)    memcpy(&len, &conn->rbuf[0], 4);\n[](#cb3-9)    if (len > k_max_msg) {\n[](#cb3-10)        msg(\"too long\");\n[](#cb3-11)        conn->state = STATE_END;\n[](#cb3-12)        return false;\n[](#cb3-13)    }\n[](#cb3-14)    if (4 + len > conn->rbuf_size) {\n[](#cb3-15)        // not enough data in the buffer. Will retry in the next iteration\n[](#cb3-16)        return false;\n[](#cb3-17)    }\n[](#cb3-18)\n[](#cb3-19)    // got one request, generate the response.\n[](#cb3-20)    uint32_t rescode = 0;\n[](#cb3-21)    uint32_t wlen = 0;\n[](#cb3-22)    int32_t err = do_request(\n[](#cb3-23)        &conn->rbuf[4], len,\n[](#cb3-24)        &rescode, &conn->wbuf[4 + 4], &wlen\n[](#cb3-25)    );\n[](#cb3-26)    if (err) {\n[](#cb3-27)        conn->state = STATE_END;\n[](#cb3-28)        return false;\n[](#cb3-29)    }\n[](#cb3-30)    wlen += 4;\n[](#cb3-31)    memcpy(&conn->wbuf[0], &wlen, 4);\n[](#cb3-32)    memcpy(&conn->wbuf[4], &rescode, 4);\n[](#cb3-33)    conn->wbuf_size = 4 + wlen;\n[](#cb3-34)\n[](#cb3-35)    // remove the request from the buffer.\n[](#cb3-36)    // note: frequent memmove is inefficient.\n[](#cb3-37)    // note: need better handling for production code.\n[](#cb3-38)    size_t remain = conn->rbuf_size - 4 - len;\n[](#cb3-39)    if (remain) {\n[](#cb3-40)        memmove(conn->rbuf, &conn->rbuf[4 + len], remain);\n[](#cb3-41)    }\n[](#cb3-42)    conn->rbuf_size = remain;\n[](#cb3-43)\n[](#cb3-44)    // change state\n[](#cb3-45)    conn->state = STATE_RES;\n[](#cb3-46)    state_res(conn);\n[](#cb3-47)\n[](#cb3-48)    // continue the outer loop if the request was fully processed\n[](#cb3-49)    return (conn->state == STATE_REQ);\n[](#cb3-50)}\n```", "```cpp\n[](#cb4-1)static int32_t do_request(\n[](#cb4-2)    const uint8_t *req, uint32_t reqlen,\n[](#cb4-3)    uint32_t *rescode, uint8_t *res, uint32_t *reslen)\n[](#cb4-4){\n[](#cb4-5)    std::vector<std::string> cmd;\n[](#cb4-6)    if (0 != parse_req(req, reqlen, cmd)) {\n[](#cb4-7)        msg(\"bad req\");\n[](#cb4-8)        return -1;\n[](#cb4-9)    }\n[](#cb4-10)    if (cmd.size() == 2 && cmd_is(cmd[0], \"get\")) {\n[](#cb4-11)        *rescode = do_get(cmd, res, reslen);\n[](#cb4-12)    } else if (cmd.size() == 3 && cmd_is(cmd[0], \"set\")) {\n[](#cb4-13)        *rescode = do_set(cmd, res, reslen);\n[](#cb4-14)    } else if (cmd.size() == 2 && cmd_is(cmd[0], \"del\")) {\n[](#cb4-15)        *rescode = do_del(cmd, res, reslen);\n[](#cb4-16)    } else {\n[](#cb4-17)        // cmd is not recognized\n[](#cb4-18)        *rescode = RES_ERR;\n[](#cb4-19)        const char *msg = \"Unknown cmd\";\n[](#cb4-20)        strcpy((char *)res, msg);\n[](#cb4-21)        *reslen = strlen(msg);\n[](#cb4-22)        return 0;\n[](#cb4-23)    }\n[](#cb4-24)    return 0;\n[](#cb4-25)}\n```", "```cpp\n[](#cb5-1)static int32_t parse_req(\n[](#cb5-2)    const uint8_t *data, size_t len, std::vector<std::string> &out)\n[](#cb5-3){\n[](#cb5-4)    if (len < 4) {\n[](#cb5-5)        return -1;\n[](#cb5-6)    }\n[](#cb5-7)    uint32_t n = 0;\n[](#cb5-8)    memcpy(&n, &data[0], 4);\n[](#cb5-9)    if (n > k_max_args) {\n[](#cb5-10)        return -1;\n[](#cb5-11)    }\n[](#cb5-12)\n[](#cb5-13)    size_t pos = 4;\n[](#cb5-14)    while (n--) {\n[](#cb5-15)        if (pos + 4 > len) {\n[](#cb5-16)            return -1;\n[](#cb5-17)        }\n[](#cb5-18)        uint32_t sz = 0;\n[](#cb5-19)        memcpy(&sz, &data[pos], 4);\n[](#cb5-20)        if (pos + 4 + sz > len) {\n[](#cb5-21)            return -1;\n[](#cb5-22)        }\n[](#cb5-23)        out.push_back(std::string((char *)&data[pos + 4], sz));\n[](#cb5-24)        pos += 4 + sz;\n[](#cb5-25)    }\n[](#cb5-26)\n[](#cb5-27)    if (pos != len) {\n[](#cb5-28)        return -1;  // trailing garbage\n[](#cb5-29)    }\n[](#cb5-30)    return 0;\n[](#cb5-31)}\n```", "```cpp\n[](#cb6-1)enum {\n[](#cb6-2)    RES_OK = 0,\n[](#cb6-3)    RES_ERR = 1,\n[](#cb6-4)    RES_NX = 2,\n[](#cb6-5)};\n[](#cb6-6)\n[](#cb6-7)// The data structure for the key space. This is just a placeholder\n[](#cb6-8)// until we implement a hashtable in the next chapter.\n[](#cb6-9)static std::map<std::string, std::string> g_map;\n[](#cb6-10)\n[](#cb6-11)static uint32_t do_get(\n[](#cb6-12)    const std::vector<std::string> &cmd, uint8_t *res, uint32_t *reslen)\n[](#cb6-13){\n[](#cb6-14)    if (!g_map.count(cmd[1])) {\n[](#cb6-15)        return RES_NX;\n[](#cb6-16)    }\n[](#cb6-17)    std::string &val = g_map[cmd[1]];\n[](#cb6-18)    assert(val.size() <= k_max_msg);\n[](#cb6-19)    memcpy(res, val.data(), val.size());\n[](#cb6-20)    *reslen = (uint32_t)val.size();\n[](#cb6-21)    return RES_OK;\n[](#cb6-22)}\n[](#cb6-23)\n[](#cb6-24)static uint32_t do_set(\n[](#cb6-25)    const std::vector<std::string> &cmd, uint8_t *res, uint32_t *reslen)\n[](#cb6-26){\n[](#cb6-27)    (void)res;\n[](#cb6-28)    (void)reslen;\n[](#cb6-29)    g_map[cmd[1]] = cmd[2];\n[](#cb6-30)    return RES_OK;\n[](#cb6-31)}\n[](#cb6-32)\n[](#cb6-33)static uint32_t do_del(\n[](#cb6-34)    const std::vector<std::string> &cmd, uint8_t *res, uint32_t *reslen)\n[](#cb6-35){\n[](#cb6-36)    (void)res;\n[](#cb6-37)    (void)reslen;\n[](#cb6-38)    g_map.erase(cmd[1]);\n[](#cb6-39)    return RES_OK;\n[](#cb6-40)}\n```", "```cpp\n[](#cb7-1)static int32_t send_req(int fd, const std::vector<std::string> &cmd) {\n[](#cb7-2)    uint32_t len = 4;\n[](#cb7-3)    for (const std::string &s : cmd) {\n[](#cb7-4)        len += 4 + s.size();\n[](#cb7-5)    }\n[](#cb7-6)    if (len > k_max_msg) {\n[](#cb7-7)        return -1;\n[](#cb7-8)    }\n[](#cb7-9)\n[](#cb7-10)    char wbuf[4 + k_max_msg];\n[](#cb7-11)    memcpy(&wbuf[0], &len, 4);  // assume little endian\n[](#cb7-12)    uint32_t n = cmd.size();\n[](#cb7-13)    memcpy(&wbuf[4], &n, 4);\n[](#cb7-14)    size_t cur = 8;\n[](#cb7-15)    for (const std::string &s : cmd) {\n[](#cb7-16)        uint32_t p = (uint32_t)s.size();\n[](#cb7-17)        memcpy(&wbuf[cur], &p, 4);\n[](#cb7-18)        memcpy(&wbuf[cur + 4], s.data(), s.size());\n[](#cb7-19)        cur += 4 + s.size();\n[](#cb7-20)    }\n[](#cb7-21)    return write_all(fd, wbuf, 4 + len);\n[](#cb7-22)}\n[](#cb7-23)\n[](#cb7-24)static int32_t read_res(int fd) {\n[](#cb7-25)    // code omitted...\n[](#cb7-26)\n[](#cb7-27)    // print the result\n[](#cb7-28)    uint32_t rescode = 0;\n[](#cb7-29)    if (len < 4) {\n[](#cb7-30)        msg(\"bad response\");\n[](#cb7-31)        return -1;\n[](#cb7-32)    }\n[](#cb7-33)    memcpy(&rescode, &rbuf[4], 4);\n[](#cb7-34)    printf(\"server says: [%u] %.*s\\n\", rescode, len - 4, &rbuf[8]);\n[](#cb7-35)    return 0;\n[](#cb7-36)}\n[](#cb7-37)\n[](#cb7-38)int main(int argc, char **argv) {\n[](#cb7-39)    int fd = socket(AF_INET, SOCK_STREAM, 0);\n[](#cb7-40)    if (fd < 0) {\n[](#cb7-41)        die(\"socket()\");\n[](#cb7-42)    }\n[](#cb7-43)\n[](#cb7-44)    // code omitted...\n[](#cb7-45)\n[](#cb7-46)    std::vector<std::string> cmd;\n[](#cb7-47)    for (int i = 1; i < argc; ++i) {\n[](#cb7-48)        cmd.push_back(argv[i]);\n[](#cb7-49)    }\n[](#cb7-50)    int32_t err = send_req(fd, cmd);\n[](#cb7-51)    if (err) {\n[](#cb7-52)        goto L_DONE;\n[](#cb7-53)    }\n[](#cb7-54)    err = read_res(fd);\n[](#cb7-55)    if (err) {\n[](#cb7-56)        goto L_DONE;\n[](#cb7-57)    }\n[](#cb7-58)\n[](#cb7-59)L_DONE:\n[](#cb7-60)    close(fd);\n[](#cb7-61)    return 0;\n[](#cb7-62)}\n```", "```cpp\n[](#cb8-1)$ ./client get k\n[](#cb8-2)server says: [2]\n[](#cb8-3)$ ./client set k v\n[](#cb8-4)server says: [0]\n[](#cb8-5)$ ./client get k\n[](#cb8-6)server says: [0] v\n[](#cb8-7)$ ./client del k\n[](#cb8-8)server says: [0]\n[](#cb8-9)$ ./client get k\n[](#cb8-10)server says: [2]\n[](#cb8-11)$ ./client aaa bbb\n[](#cb8-12)server says: [1] Unknown cmd\n```"]