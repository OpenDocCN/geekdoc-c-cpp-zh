<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Anonymous namespaces and static</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Anonymous namespaces and static</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/encapsulation/anonymous_namespaces.html">https://cel.cs.brown.edu/crp/idioms/encapsulation/anonymous_namespaces.html</a></blockquote>
                        
<p>Anonymous namespaces in C++ are used to avoid symbol collisions between
different translation units. Such collisions violate <a href="https://timsong-cpp.github.io/cppwp/n4950/basic.def.odr#14">the one definition
rule</a> and result in
undefined behavior (which at best manifests as linking errors).</p>
<p>For example, without the use of anonymous namespaces, the following would result
in undefined behavior (and no linking error, due to the use of <code>inline</code> producing
weak symbols in the object files).</p>
<pre><code class="language-cpp">/// a.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}

/// b.cc
namespace {
    inline void common_function_name() {
        // ...
    }
}
</code></pre>
<p>C++ static declarations are also used to achieve the same goal by making it so that
a declaration has internal linkage (and so is not visible outside of the
translation unit).</p>
<p>Rust avoids the linkage problem by controlling linkage and visibility
simultaneously, with declarations always also being definitions. Instead of
translation units, programs are structured in terms of
<a href="./headers.html">modules</a>, which provide both namespaces and
visibility controls over definitions, enabling the Rust compiler to guarantee
that symbol collision issues cannot happen.</p>
<p>The following Rust program achieves the same goal as the C++ program above, in
terms of avoiding the collision of the two functions while making them available
for use within the defining files.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a.rs
<span class="boring">mod a {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span>
// b.rs
<span class="boring">mod b {
</span>fn common_function_name() {
    // ...
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Additionally,</p>
<ol>
<li>Unlike C++ namespaces, Rust modules (which provide namespacing as well as
visibility controls) can only be defined once, and this is checked by the
compiler.</li>
<li>Each file <a href="https://doc.rust-lang.org/stable/book/ch07-05-separating-modules-into-different-files.html">defines a module which has to be explicitly included in the module
hierarchy</a>.</li>
<li>Modules from Rust crates (libraries) are always qualified with some root
module name, so they cannot conflict. If they would conflict, <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">the root
module name must be replaced with some user-chosen
name</a>.</li>
</ol>
<h2 id="caveats-about-c-interoperability"><a class="header" href="#caveats-about-c-interoperability">Caveats about C interoperability</a></h2>
<p>When using libraries not managed by Rust, the usual problems can occur if there are symbol collisions in the
object files. This can arise when using C or C++ static or dynamic libraries.
It can also arise when using Rust static or dynamic libraries built for use in C or
C++ programs.</p>
<p>Rust provides <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>#[unsafe(no_mangle)]</code></a> to bypass name mangling
in order to produce functions that can be easily
referred to from C or C++. This can also cause undefined behavior due to name collision.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;anonymous_namespaces&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;id&quot;:&quot;4ed5c1ed-81e3-448d-b20a-8f0eac301489&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\n// colors.rs\npub fn red() {}\nfn blue() {}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// colors.rs\nmod colors {\n    pub fn red() {}\n    fn blue() {}\n}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;,&quot;```rust\n// colors.rs\nmod colors {\n    fn red() {}\n\n    mod {\n        fn blue() {}\n    }\n}\n\n// main.rs\nmod colors;\n\nuse colors::*;\n\nfn main() {}\n```\n&quot;],&quot;prompt&quot;:&quot;Which is an idiomatic translation of the following C++ program?\n\n```cpp\n// colors.h\nnamespace colors {\n  void red();\n}\n\n// colors.cc\n#include \&quot;colors.h\&quot;\n\nnamespace colors {\n  void red() {}\n\n  namespace {\n    void blue() {}\n  }\n}\n\n// main.cc\n#include \&quot;colors.h\&quot;\n\nusing namespace colors;\n\nint main() {}\n```\n&quot;}},{&quot;context&quot;:&quot;Even if in C++ you wouldn't use namespaces to structure the program, in Rust\nsplitting programs into separate files also means splitting them into separate\nmodules.\n&quot;,&quot;id&quot;:&quot;eb1bde49-9ca5-4e8d-b6f3-d49c95393dfb&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;red&quot;,&quot;a::red&quot;,&quot;violet&quot;,&quot;b::violet&quot;,&quot;other_colors::green&quot;,&quot;a::other_colors::green&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;orange&quot;,&quot;green&quot;,&quot;indigo&quot;,&quot;a::green&quot;],&quot;prompt&quot;:&quot;In the following Rust program, which items would be visible within the `main`\nfunction?\n\n```rust\n// a.rs\npub fn red() {}\nfn orange() {}\n\npub mod other_colors {\n    pub fn green() {}\n    fn blue() {}\n}\n\n// b.rs\npub fn indigo() {}\npub fn violet() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::violet;\n\nfn main() {\n   // What is visible here?\n}\n```\n&quot;}},{&quot;context&quot;:&quot;Lack of `pub` is like putting it in an anonymous namespace in terms of\nvisibility outside of the defining module.\n\n`mod` is not `#include`. `mod` defines a module, and using items from the module\nrequires either importing or qualification.\n\nResolving ambiguous items works the same as it does with C++ namespaces.\nAmbiguous use is the error, not having conflicting names in scope.\n&quot;,&quot;id&quot;:&quot;b3c2c70b-26b7-4396-8f8a-0e21541896cf&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    a::go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nfn main() {\n    a::go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\npub fn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\nfn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nuse a::*;\nuse b::*;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;,&quot;```rust\n// a.rs\npub fn go() {}\n\n// b.rs\nfn go() {}\n\n// main.rs\nmod a;\nmod b;\n\nfn main() {\n    go();\n    println!(\&quot;{}\&quot;, 4);\n}\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following Rust programs compile?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Anonymous namespaces and static">Click here to leave us feedback about this page.</a>
                        
</body>
</html>