<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Template specialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Template specialization</h1>
<blockquote>原文：<a href="https://cel.cs.brown.edu/crp/idioms/data_modeling/template_specialization.html">https://cel.cs.brown.edu/crp/idioms/data_modeling/template_specialization.html</a></blockquote>
                        
<p>Template specialization in C++ makes it possible for a template entity to have
different implementations for different parameters. Most STL implementations
make use of this to, for example, provide a <a href="https://en.cppreference.com/w/cpp/container/vector_bool">space-efficient representation of
<code>std::vector&lt;bool&gt;</code></a>.</p>
<p>Because of the possibility of template specialization, when a C++ function
operates on values of a template class like <code>std::vector</code>, the function is
essentially defined in terms of the interface provided by the template class,
rather than for a specific implementation.</p>
<p>To accomplish the same thing in Rust requires defining the function in terms of
a trait for the interface against which it operates. This enables clients to
select their choice of representation for data by using any concrete type that
implements the interface.</p>
<p>This is more practical to do in Rust than in C++, because generics not being a
general metaprogramming facility means that <a href="./templates.html#a-note-on-type-checking-and-type-errors">generic entities can be type
checked
locally</a>,
making them easier to define. It is more common to do in Rust than in C++
because Rust does not have <a href="./inheritance_and_reuse.html">implementation
inheritance</a>, so there is a
sharper line between interface and implementation than there is in C++.</p>
<p>The following example shows how a Rust function can be implemented so that
different concrete representations can be selected by a client. For a compact
bit vector representation, the example uses the
<a href="https://docs.rs/bitvec/latest/bitvec/vec/struct.BitVec.html"><code>BitVec</code></a> type
from the <a href="https://docs.rs/bitvec/latest/bitvec/">bitvec crate</a>. <code>BitVec</code> is
intended intended to provide an API similar to <code>Vec&lt;bool&gt;</code> or
<code>std::vector&lt;bool&gt;</code>.</p>
<div class="comparison">
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void push_if_even(int n,
                  std::vector&lt;T&gt; &amp;collection,
                  T item) {
  if (n % 2 == 0) {
    collection.push_back(std::move(item));
  }
}

int main() {
  // Operate on the default std::vector
  // implementation
  std::vector&lt;std::string&gt; v{"a", "b"};
  push_if_even(2, v, std::string("c"));

  // Operate on the (likely space-optimized)
  // std::vector implementation
  std::vector&lt;bool&gt; bv{false, true};
  push_if_even(2, bv, false);
}
</code></pre>
<pre><code class="language-rust ignore">// The Extend trait is for types that support
// appending values to the collection.
fn push_if_even&lt;T, I: Extend&lt;T&gt;&gt;(
    n: u32,
    collection: &amp;mut I,
    item: T,
) {
    if n % 2 == 0 {
        collection.extend([item]);
    }
}

use bitvec::prelude::*;

fn main() {
    // Operate on Vec
    let mut v =
        vec!["a".to_string(), "b".to_string()];
    push_if_even(2, &amp;mut v, "c".to_string());

    // Operate on BitVec
    let mut bv = bitvec![0, 1];
    push_if_even(2, &amp;mut bv, 0);
}</code></pre>
</div>
<h2 id="trade-offs-between-generics-and-templates"><a class="header" href="#trade-offs-between-generics-and-templates">Trade-offs between generics and templates</a></h2>
<p>Because generic functions can only interact with generic values in ways defined
by the trait bounds, it is easier to test generic implementations. In
particular, code testing a generic implementation only has to consider the
possible behaviors of the given trait.</p>
<p>For a comparison, consider the following programs.</p>
<div class="comparison">
<pre><code class="language-cpp">template &lt;totally_ordered T&gt;
T max(const T &amp;x, const T &amp;y) {
  return (x &gt; y) ? x : y;
}

template &lt;&gt;
int max(const int &amp;x, const int &amp;y) {
  return (x &gt; y) ? x + 1 : y + 1;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max&lt;'a, T: Ord&gt;(x: &amp;'a T, y: &amp;'a T) -&gt; &amp;'a T {
    if x &gt; y {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
</div>
<p>In the Rust program, <em>parametricity</em> means that (assuming safe Rust) from the
type alone one can tell that if the function returns, it must return exactly one
of <code>x</code> or <code>y</code>. This is because the trait bound <code>Ord</code> doesn't give any way to
construct new values of type <code>T</code>, and the use of references doesn't give any way
for the function to store one of <code>x</code> or <code>y</code> from an earlier call to return in a
later call.</p>
<p>In the C++ program, a call to <code>max</code> with <code>int</code> as the template parameter will
give a distinctly different result than with any other parameter because of the
template specialization enabling the behavior of the function to vary based on
the type.</p>
<p>The trade-off is that in Rust specialized implementations are harder to use
because they must have different names, but that they are easier to write
because it is easier to write generic code while being confident about its
correctness.</p>
<h2 id="niche-optimization"><a class="header" href="#niche-optimization">Niche optimization</a></h2>
<p>There are several cases where the Rust compiler will perform optimizations to
achieve more efficient representations. Those situations are all ones where the
efficiency gains do not otherwise change the observable behavior of the code.</p>
<p><a href="https://doc.rust-lang.org/std/option/index.html#representation">The most common case is with the <code>Option</code>
type</a>. When
<code>Option</code> is used with a type where the compiler can tell that there are unused
values, one of those unused values will be used to represent the <code>None</code> case, so
that <code>Option&lt;T&gt;</code> will not require an extra word of memory to indicate the
discriminant of the enum.</p>
<p>This optimization is applied to reference types (<code>&amp;</code> and <code>&amp;mut</code>), since
references cannot be null. It is also applied to <code>NonNull&lt;T&gt;</code>, which represents
a non-null pointer to a value of type <code>T</code>, and to <code>NonZeroU8</code> and other non-zero
integral types. The optimization for the reference case is what makes
<code>Option&lt;&amp;T&gt;</code> and <code>Option&lt;&amp;mut T&gt;</code> safer equivalents to using non-owning
observation pointers in C++.</p>
<div class="quiz-placeholder" data-quiz-name="&quot;template_specialization&quot;" data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;&gt; Both will display \&quot;Unknown type\&quot; for everything other than `int` or `i32`.\n\nIn both cases what will be displayed for other types will depend on\nimplementations/specializations elsewhere in the program.\n\n&gt; Both `displayWithType` and `display_with_type` can be called with ANY\n&gt; arguments whose types overload `&lt;&lt;` or implement `Display`.\n\nThe default function implementation `type_display_name` in the `DisplayWithType`\ntrait does not make it possible to call `display_with_type` on any type. Types\nstill need to explicitly declare that they implement the trait.\n&quot;,&quot;id&quot;:&quot;6ac15484-9038-45b7-9b47-f08918551d3a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:[&quot;Both `displayWithType` and `display_with_type` can ONLY be called with arguments\nwhose types overload `&lt;&lt;` or implement `Display`.\n&quot;]},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Both `displayWithType` and `display_with_type` will display \&quot;Unknown type\&quot; for\neverything other than `int` or `i32`.\n&quot;,&quot;Both `displayWithType` and `display_with_type` can be called with ANY arguments\nwhose types overload `&lt;&lt;` or implement `Display`.\n&quot;],&quot;prompt&quot;:&quot;The following Rust program is an approximate translation of the C++ program.\nWhich statements are true about them?\n\nC++:\n\n```cpp\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid displayWithType(T t) {\n  std::cout &lt;&lt; \&quot;Unknown: \&quot; &lt;&lt; t &lt;&lt; std::endl;\n}\n\ntemplate &lt;&gt;\nvoid displayWithType&lt;int&gt;(int t) {\n  std::cout &lt;&lt; \&quot;int: \&quot; &lt;&lt; t &lt;&lt; std::endl;\n}\n```\n\nRust:\n\n```rust\ntrait TypeDisplayName {\n    fn type_display_name() -&gt; &amp;'static str {\n        \&quot;Unknown\&quot;\n    }\n}\n\nimpl TypeDisplayName for i32 {\n    fn type_display_name() -&gt; &amp;'static str {\n        \&quot;i32\&quot;\n    }\n}\n\nuse std::fmt::Display;\n\nfn display_with_type&lt;T: TypeDisplayName + Display&gt;(x: T) {\n    println!(\&quot;{}: {}\&quot;, T::type_display_name(), x);\n}\n```\n&quot;}},{&quot;context&quot;:&quot;`Option&lt;NonZero&lt;u32&gt;&gt;` makes use of the niche optimization.\n&quot;,&quot;id&quot;:&quot;5523ba5a-2772-4700-946e-2028471ead73&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;They are all the same size.&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nOption&lt;NonZero&lt;u32&gt;&gt;\n```\n&quot;,&quot;```rust\nNonZero&lt;u32&gt;\n```\n&quot;,&quot;```rust\nu32\n```\n&quot;],&quot;prompt&quot;:&quot;Which of the following types is the largest?\n&quot;}},{&quot;id&quot;:&quot;2f5fbeda-ab4a-48cc-92be-509d8191da0a&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;```rust\nOption&lt;u32&gt;\n```\n&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;```rust\nNonZero&lt;u32&gt;\n```\n&quot;,&quot;```rust\nu32\n```\n&quot;,&quot;They are all the same size.&quot;],&quot;prompt&quot;:&quot;Which of the following types is the largest?\n&quot;}}]}" data-quiz-fullscreen="true" data-quiz-initial-text="&quot;Check your understanding&quot;"/>
<link rel="stylesheet" type="text/css" href="../../quiz/style.css"/>

                        <a class="feedback-link" href="https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&amp;entry.1450251950=Template specialization">Click here to leave us feedback about this page.</a>
                        
</body>
</html>