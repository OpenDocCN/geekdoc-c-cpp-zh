# 第十七章编写多线程程序

# 第十七章编写多线程程序

大多数时候,事件驱动的 GUI 程序可以给你造成一个很好的假象:多个任务在同时的运行.这是因为,重绘窗口通常只占用很少的时间,用户输入也被很快的进行了处理.然后,有时候,有些任务很难将其分割成足够小的让人难以察觉的小块来运行,这时候就要使用多线程编程了.本章我们来介绍一下在 wxWidgets 中怎样实现多线程编程.在本章的最后,我们将介绍一下多线程编程的一些替代解决方案.

# 17.1 什么时候使用多线程,什么时候不要使用

# 17.1 什么时候使用多线程,什么时候不要使用

线程基本上来说是你的应用程序中一条单独的执行路径.有些地方把线程成为轻量级的进程,但是线程和进程有着一个最本质的区别,那就是:进程是在不同的地址空间运行的,而同一个进程内的所有的线程都在同一个地址空间运行. 当然这样的好处是,同一个进程的线程互相访问公共的数据是非常方便的,不过这也造成了另外一个经常犯错误的地方,就是很一个数据很容易被多个线程同时访问,造成不可知的后果,因此强烈推荐对于这些数据的访问,必须小心的使用用于同步变量访问的变量,比如信号量和关键区域.

如果使用的当,多线程编程可以简化应用程序的体系结构,并且将用户界面和其后面的真实世界分割开来.注意这通常不会让你的应用程序运行的更快,除非你有多个处理器,但是用户界面通常会变得更灵敏.

wxWidgets 既提供了线程的支持,也提供了信号量和带条件的关键区域的支持.其线程 API 主要参考的是 pthread(POSIX 线程)模型,不过某些 API 采用了不同的名字,而另外一些 API 则吸收了部分 Win32 线程 API 的灵感.

这些类使得编写多线程的程序变得简单,并且还提供了相对于本地线程 API 更多的错误检查.尽管如此,多线程编程仍然不是一个很简单的事情,对于大型的项目尤其如此.因此,在考虑编写新的多线程程序或者在旧的代码中加入多线程之前,仔细的考虑一下是不是应该采取可选的替代方案来实现同样的功能,是一件很值得一做的事情.在有些情况下,线程是唯一最优的选择,比如对于一个 FTP 服务器来说,为每一个新的连接创建一个线程,但是,如果只是增加一个线程来为某个长时间的运算显示一个进度条来说,这种线程的时候就有点过犹不及了.在这种情况下,你可以将计算任何放在系统空闲的时候进行,并且周期性的调用 wxWindow::Update 来更新用户界面就可以了.关于这个问题更详细的描述,请参考本章的最后一节,"多线程的替代方案"中的描述.

如果你还是决定在你的代码中使用多线程,我们强烈建议你只在你的主线程中调用所有和 GUI 有关的函数.尽管 wxWidgets 自带的线程例子中演示了怎样在多个线程中同时调用 GUI 函数,但是,一般来说,这是非常非常差劲的设计.一个主线程负责 GUI,其它多个线程负责别的计算工作,他们之间通过事件互相通讯,这样的设计是更好的设计并且通常可以避免很多的错误从而节约你大量的调试的时间.比如说,在 Win32 平台上,线程只能使用由自己而不是别的线程创建的 GUI 对象(画笔,画刷之类).

要实现线程之间通讯,你可以使用 wxEvtHandler::AddPendingEvent 函数或者它的简化版本 wxPostEvent,这些函数被设计成线程安全的因此你可以使用他们在线程之间发送事件.

# 17.2 使用 wxThread

# 17.2 使用 wxThread

如果你要在你的代码中使用线程,首先要实现一个 wxThread 的派生类,并且至少要重载其虚函数 Entry,这个函数包含了线程要做的主要的事情.举例来说,比如我们要用一个单独的线程来计算图片中颜色的数目,下面是我们的派生类的声明:

```cpp
class MyThread : public wxThread
{
public:
    MyThread(wxImage* image, int* count):
        m_image(image), m_count(count) {}
    virtual void *Entry();
private:
    wxImage* m_image;
    int*     m_count;
};
// 一个标识符 用来在线程工作完成的时候通知应用程序.
#define ID_COUNTED_COLORS    100 
```

Entry 函数用来进行计算工作并且返回一个返回值(对于联合线程(即将介绍),Wait 函数将返回这个值),下面是我们的 Entry 函数:

```cpp
void *MyThread::Entry()
{
    (* m_count) = m_image->CountColours();
    // 使用一个已知的事件来通知应用程序.
    wxCommandEvent event(wxEVT_COMMAND_MENU_SELECTED,
                         ID_COUNTED_COLORS);
    wxGetApp().AddPendingEvent(event);
    return NULL;
} 
```

为了简单起见,我们没有定义新的事件而是使用了一个已有的事件通知应用程序线程的工作已经做完了.

线程的创建

线程的创建分为两步,首先产生一个线程的实例,然后调用线程的 Create 函数:

```cpp
MyThread *thread = new MyThread();
if ( thread->Create() != wxTHREAD_NO_ERROR )
{
    wxLogError(wxT("Can't create thread!"));
} 
```

有两种不同的线程,一种线程你在启动之后就可以忘记它的存在,而另外一种,你需要等待它返回一个结果.前者我们称为分离线程,后者称为联合线程. 线程的类型是通过调用 wxThread 的构造函数时传递的参数是 wxTHREAD_DETACHED 还是 wxThrEAD_JOINABLE 来决定的,联合线程的返回值是由对其成员函数 Wait 的调用返回的,而对于分离线程,不可以调用 Wait 函数.

你不必把所有的线程都创建为联合线程,,因为联合线程有它不方便的地方,你必须调用联合线程的 Wait 函数来等待联合线程结束,否则系统为这个线程分配的所有的资源将不会被释放,并且你还需要自己删除这个线程对象(尽管这个对象只能使用一次).而分离线程则具有"点火以后就忘掉"的特性,你只需要启动它,它将自己自己中止和释放.

当然,这也意味者分离线程必须在堆上创建,因为它将在结束的时候调用 delte(this).联合线程既可以在栈上创建也可以在堆上创建,不同通常也都是在堆上创建的.不要创建全局的线程对象,因为他们将在他们的构造函数执行的时候分配内存,这将导致内存检测系统出现一些问题.

指定栈大小

你可以在调用线程的 Create 函数的时候指定它的栈大小,默认的 0 代表使用操作系统默认的大小.

指定优先级

某些操作系统允许应用程序自己提供一个线程的优先级(时间片的大小),你可以通过 wxThread::SetPriority 函数来达到这个目的.优先级的数值在 0 到 100 之间,0 为最低优先级而 100 为最高优先级,不过最好使用预定义的宏 wxTHREAD*MIN_PRIORITY, wxTHREAD_DEFAULT_PRIORITY 和 wxTHREAD_MAX* PRIORITY,他们的值分别为 0,50 和 100.SetPriority 函数应该在调用 Create 之后,调用 Run 函数之前被调用.

启动线程

调用 Create 函数以后,线程还没有开始运行,你还需要调用 wxThread::Run 函数来启动线程,这个函数将会调用你自定义的 Entry 函数.

怎样暂停线程以等待一个外部条件

如果线程需要等待某些事情发生,你应该避免直接使用查询和什么事都不做这样的循环,这会让你的程序"忙于等待",白白浪费 CPU 的时间.

如果你需要等待几秒钟,你可以使用 wxThread::Sleep 函数.

如果你正在等待什么事情发生,你应该使用一种调用来阻止当前线程执行直到你收到事情已经发生的通知.例如,如果你在线程中使用了 socket,你应该阻塞在 socket 的系统调用上,直至 socket 收到数据,这就不会白白浪费 CPU 了,或者如果你正在等待一个联合线程使用的数据,你可以调用 Wait 其函数来阻塞自己.

有时候你可能会想用线程的 Pause 和 Resume 函数来临时将你的线程置入睡眠状态,但是这样做有两个问题,首先,暂停机制不是所有的系统都支持,有些系统(尤其是 POSIX 标准的系统)的 Pause 是模拟的,线程必须调用 TestDestroy 并且在这个函数返回 True 的时候立刻中断自己的运行.第二个问题是,调用 Pause 的线程有时候很难回复正常运行,因为这使得操作系统可能在任何时候中止你的线程的运行,如果你的线程正在锁定一个信号量,很可能来不及释放这个信号量导致出现死锁.

因此,使用 Pause 和 Resume 并不是一个很好的设计,你应该尽可能使用信号量或者关键区域(参见下一小节)来重新设计你的代码.

线程中止

正如前面我们谈到的那样,分离线程是自动结束和释放自己的.而对于联合线程,你可以简单的调用 wxThread::Wait 函数.或者在一个 GUI 程序中,你可以在系统空闲事件处理函数中调用 wxThread::IsAlive 函数,然后仅在 IsAlive 返回 False 的时候调用 Wait 函数.Wait 函数是释放联合线程资源的唯一的方法.

你可以调用 wxThread::Delete 来请求删除一个线程,不过要让它工作正常,你需要在你的线程中周期性的调用 TestDestroy 函数(译者注:根据经验,在 Windows 平台上,对于联合线程使用这种方法好像不是一个好主意).

# 17.3 用于线程同步的对象

# 17.3 用于线程同步的对象

在几乎所有的线程使用中,数据都是几个线程共享的.当有两个或以上的线程试图访问同一个数据的时候,无论这个数据是一个对象还是一个资源,这种访问都应该被同步,以避免数据在同一时刻被超过 1 个线程访问或者修改.因为应用程序中充满了所谓的不变量,比如,对于一个链表来说,我们总认为它的第一个元素是有效的,每个元素都指向它的下一个元素,最后的一个元素是空指针.但是在对链表进行插入新元素操作的时候,有一小段时间间隔,这个所谓不变量是被打破的.这时候假如有两个线程同时在使用这个链表,如果没有进行数据同步的动作,就会出现不可知的问题.因此你必须保证,在你插入元素这一小段时间间隔内,没有别的线程在访问同样的数据.

保证所有的共享数据被各个访问它的线程快速的并且是以一个合理的顺序访问是程序员自己的责任.因此这一小节我们来介绍一下 wxWidgets 提供了哪些类来帮助程序员达到这个目的.

wxMutex

这个名字来源于 mutual exclusion(共有的互斥量),它是最简单的一种数据同步手段.它可以保证同一个时刻只有一个线程在访问某一部分数据.要获取数据的访问权,线程必须调用 wxMutex::Lock 函数,这将阻塞当前线程的执行直到它所请求的数据已经不再有任何别的线程使用.而在它开始使用这个数据以后,别的线程对 wxMutex::Lock 的调用同样将被阻塞,直至当前使用的线程调用 wxMutex::Unlock 函数释放它所使用的资源.尽管你可以直接使用 wxMutex 的 Lock 和 Unlock 函数,我们还是推荐你使用 wxMutexLocker 类来使用 wxMutex,这将确保你不会忘记在 Lock 以后调用 Unlock 函数(译者注:你可以想像假如你忘了 Unlock 的后果,呵呵),因为这两个函数被隐藏在 wxMutexLocker 类的构造函数和析构函数中,因此,即使发生了异常,wxMutexLocker 类仍然会在自己被释放的时候进行 Unlock.

下面的代码中,我们确信 MyApp 有一个 wxMutex 类型的变量 m_mutex:

```cpp
void MyApp::DoSomething()
{
    wxMutexLocker lock(m_mutex);
    if (lock.IsOk())
    {
        ... do something
    }
    else
    {
        ... we have not been able to
        ... acquire the mutex, fatal error
    }
} 
```

使用互斥量有三个重要的规则:

1.  线程不可以锁定已经被锁定的互斥量(不允许互斥量递归). 尽管有些系统允许你这样做,但这是不可移植的.
2.  线程不允许解锁别的线程锁定的互斥量. 如果你需要这个功能,参考我们马上会讲到的信号量机制.
3.  如果你的线程即使无法锁定互斥量也还有别的事情可以做,你应该先使用 wxMutex::TryLock 函数判断是否可以锁定.这个函数是立即返回的,返回值为可以锁定(wxMUTEX_NO_ERROR)或者不可锁定(wxMUTEX_DEAD_LOCK 或 wxMUTEX_BUSY). 这在主线程中尤其有用,因为主线程(GUI 线程)是不可以被阻塞的,否则它将不能响应任何用户的输入.

死锁

如果两个线程在互相等待对方已经锁定的互斥量,我们称之为发生了死锁.举例来说,假如线程 A 已经锁定了互斥量 1,线程 B 已经锁定了互斥量 2,线程 A 正等待锁定互斥量 2,而线程 B 正等待锁定互斥量 1,那么,他们两个人将无限期的等待下去,在某些系统上,如果出现这种情况,Lock 或者 Unlock 或者 TryLock 函数将返回错误码 wxMUTEX_DEAD_LOCK,但是在另外一些系统上,除非你把整个程序杀死,否则他们将一直等下去.

解决死锁的方法有一下两种:

*   修改顺序.一个一致的互斥量锁定顺序将减少死锁发生的概率.在前面的例子中,如果线程 A 和线程 B 都要求先锁定互斥量 1 再锁定互斥量 2,则死锁将不会发生.
*   使用 TryLock. 在成功锁定第一个互斥量以后,在后续的互斥量锁定之前都使用 TryLock 函数判断,如果 TryLock 返回失败,解锁第一个然后重新开始锁定第一个. 这种方法系统开销较大,但是如果修改顺序的方法有明显的缺陷或者导致你的代码乱七八糟,你可以考虑使用这种方法.

wxCriticalSection

关键区域用来保证某一段代码在某一个时刻只被一个线程执行,而前面介绍的互斥量则用来保证互斥量在某一个时刻只被一个线程锁定.他们之间是非常相似的,除了在某些系统上,互斥量是系统范围内的变量而关键区域只在本应用程序范围内有效.在这样的系统上,使用关键区域的效率会比使用互斥量高一点点.也因为这些细微的差别,他们的一些术语也略有不同,互斥量称为锁定(或者装载)和解锁(或者卸载),而关键区域称为进入或者离开.

关键区域也有对应的 wxCriticalSectionLocker 对象,出于和 wxMutexLocker 同样的原因,你应该尽量使用它而不要直接使用 wxCriticalSection 的函数.

wxCondition

所谓条件变量 wxCondition,是用来指示共享数据的某些条件已经满足.比如,你可以使用它来指示一个消息队列已经有数据到来.而共享数据本身(在这里指的这个消息队列)通常还需要另外使用一个互斥量来保护.

你可以通过锁定互斥量,检测队列有无数据,然后释放信号量这样的循环来进行消息队列数据的处理,不过如果队列里一直没有数据,这样的作法也太浪费了,时间全部浪费在锁定和解锁互斥量上面了.象这种情况,最好是使用条件变量,这样消息处理线程就可以被阻塞直到等到别的线程把事件放入事件队列以后发出通知事件.

多个线程可能都在等待同一个条件,这时你可以选择唤醒一个线程还是唤醒多个线程,唤醒一个线程的函数是 Signal,唤醒所有正在等待的线程的函数是 Broadcast.如果有多个条件都是由同一个 wxCondition 通知的,你必须使用 Broadcast 函数,否则可能某个线程被唤醒了但是却什么也做不了,因为它的条件还没有满足,而另外的可以满足条件的那个线程却无法唤醒了.

wxCondition 使用举例

我们来假设一下我们有两个线程:

一个是生产线程,它负责产生 10 个元素并且将其放入队列,然后发送队列满信号并且在继续填充元素之前等待队列空信号.

一个是消费线程,它在收到队列满信号的时候移除队列中所有的元素.

我们需要一个互斥量 m_mutex,用来保护整个队列和两个条件变量:m_isFull 和 m_isEmpty.这个互斥量被传递给两个条件变量的构造函数作为参数.另外你需要总是显示判断条件是否满足,然后再开始等待通知,因为可能在你还没有开始等待之前,已经有一个信号通知了,由于你还没有等待,那个信号就丢失了.

我们来看看生产线程的 Entry 函数的伪代码:

```cpp
while ( notDone )
{
   wxMutexLocker lock(m_mutex) ;
   while( m_queue.GetCount() &gt; 0 )
   {
      m_isEmpty.Wait() ;
   }
   for ( int i = 0 ; i &lt; 10 ; ++i )
   {
      m_queue.Append( wxString::Format(wxT("Element %d"),i) ) ;
   }
   m_isFull.Signal();
} 
```

消费线程:

```cpp
while ( notDone )
{
   wxMutexLocker lock(m_mutex) ;
   while( m_queue.GetCount() == 0 )
   {
      m_isFull.Wait() ;
   }
   for ( int i = queue.GetCount() ; i &gt; 0 ; i )
   {
      m_queue.RemoveAt( i ) ;
   }
   m_isEmpty.Signal();
} 
```

Wait 函数首先 Unlock 其内部的互斥量 ,然后等待条件被通知.当它被通知唤醒时,会首先再次锁定内部的信号量,因此数据同步时非常严格满足的.

另外,在 Wait 函数被唤醒之后再次检测条件是否满足也是必要的,因为在信号被发送和线程被唤醒之间可能发生某些事情,导致条件又一次不满足了;另外,系统有时候也会产生一些假的信号导致 Wait 函数返回.

Signal 可能在 Wait 之前发生,正象 pthread 中的那样,这时这个信号会丢失.因此如果你想要确定你没有错过任何信号,你必须保证和条件变量绑定的互斥量在最开始就处于锁定状态,并且在你调用 Signal 函数之前再次尝试锁定它,这意味着对 Signal 的调用将被阻塞直到另外一个线程调用了 Wait 函数.

OK,上面的这段话读起来比较费劲,我们来看一个例子,在这个例子中,主线程创建了一个工作线程,工作线程的 Signal 函数直到主线程调用了 Wait 以后才能被调用:

```cpp
class MySignallingThread : public wxThread
{
public:
    MySignallingThread(wxMutex *mutex, wxCondition *condition)
    {
        m_mutex = mutex;
        m_condition = condition;
        Create();
    }
    virtual ExitCode Entry()
    {
        ... do our job ...
        // 告诉其它线程我们马上就要退出了.
        // 我们必须先锁定信号量,这个动作会阻塞自己
        // 直到主线程调用了 Wait
        wxMutexLocker lock(m_mutex);
        m_condition.Broadcast(); // 我们只有一个线程在等待,所以等同于 Signal()
        return 0;
    }
private:
    wxCondition *m_condition;
    wxMutex *m_mutex;
};
void TestThread()
{
    wxMutex mutex;
    wxCondition condition(mutex);
    // 互斥量应该先出于锁定状态
    mutex.Lock();
    // 先创建和运行工作线程,注意这个线程不能退出
    // 除非我们解锁了互斥量
    MySignallingThread *thread =
        new MySignallingThread(&mutex, &condition);
    thread->Run();
    // Wait 工作线程退出,Wait 函数将自动解锁和它绑定的互斥量
    // 因此工作线程可以继续直至发出 Signal 并且终至自己.
    condition.Wait();
    // 我们收到了 Signal 就可以退出了.
} 
```

当然上面的这个例子指示出于演示如何实现条件变量中第一个 Singal 在第一个 Wait 之后执行,如果单就代码例子实现的功能来说,我们应该直接使用一个联合线程,然后在主线程调用 wxThread::Join 函数就可以了.

wxSemaphore

信号量(wxSemaphore)可以通俗的看成一个互斥量和一个记数器的结合,它和记数器最大的不同在于信号量的值可以被任何线程更改,而不仅仅是拥有它的那个线程.所以你也可以把信号量看作是一个没有主人的记数器.

如果一个线程调用信号量的 Wait 函数,这个调用将阻塞,除非记数器当前为一个正数,然后 Wait 函数将记数器减一,然后返回.而对 Post 函数的调用则将增加记数器的值然后返回.

wxWidgets 实现的信号量还有一个额外的特性,你可以在其构造函数中指定一个记数器的最大值,默认为 0 表明最大值没有限制,如果你给定了一个最大值,而 Post 函数的调用使得当前的记数器超过了这个最大值,你将会得到一个 wxSEMA_OVERFLOW 错误.让我们再回到前面说的用信号量实现特殊互斥的描述:

*   一个可以被不同的线程锁定和解锁的互斥量可以通过一个记数器最大值为 1 的信号量实现,互斥量的 Lock 函数等同于信号量的 Wait 函数而互斥量的 Unlock 函数等同于信号量的 Post 函数.
*   前一个线程调用 Lock(Wait)发现是一个整数值,于是减一,然后立即继续.
*   第二个线程调用 Lock 发现是零,将必须等待某个线程(不一定是前一个线程)调用 Unlock(Post).

你可以在 wxWidgets 自带的 samples/thread 中找到一个用来演示多线程编程的例子.如下图所示.在这个例子中,你可以启动,停止,暂停,恢复线程的运行.它演示了一个工作线程周期性的通过 wxPostEvent 往主程序发送事件,一个进度条对话框用来指示当前进度并在进度到达最后的时候取消工作线程的运行.

![](img/mhtE6E8%281%29.tmp)

# 17.4 多线程的替代方案

# 17.4 多线程的替代方案

如果线程使用的复杂性让你感到气馁,也许你可以尝试一些简单的替代方案,比如使用定时器,空闲时间处理或者两者一起使用.

使用 wxTimer

wxTimer 类让你的程序可以周期性的收到提示,或者在某个特定的时间间隔收到提醒.如果你要使用线程处理的事情可以分成小的时间片,每隔几个毫秒处理一次,以便你的应用程序可以有足够的时间响应用户的输入,你就可以使用 wxTimer 来代替多线程.

你可以自己选择提醒的通知方式,如果你更喜欢使用虚函数,就实现一个 wxTimer 的派生类,然后重载其 Notify 函数,如果你更倾向使用事件机制,就给你的 wxTimer 构造函数指定一个 wxEvtHandler 指针(或者使用 SetOwner)函数,然后使用 EVT_TIMER(id, func)事件映射宏来将事件映射到对应的处理函数.

你可以给 wxTimer 的构造函数或者 SetOwner 函数传递一个可选的定时器标识符,这个标识符可以用在 EVT_TIMER 事件映射宏中.这在你需要使用多个定时器的时候比较有用.

使用 Start 函数启动定时器,需要传递的参数包括一个毫秒为单位的定时器时长和可选的 wxTIMER_ONE_SHOT 指示(如果你只希望收到一次提示).Stop 函数用来终止某个定时器,IsRunning 函数用来检测当前定时器是否出于运行状态.

下面的代码演示了怎样通过事件的方式使用定时器:

```cpp
#define TIMER_ID 1000
class MyFrame : public wxFrame
{
public:
    ...
    void OnTimer(wxTimerEvent& event);
private:
    wxTimer m_timer;
};
BEGIN_EVENT_TABLE(MyFrame, wxFrame)
    EVT_TIMER(TIMER_ID, MyFrame::OnTimer)
END_EVENT_TABLE()
MyFrame::MyFrame()
       : m_timer(this, TIMER_ID)
{
    // 1 秒的间隔
    m_timer.Start(1000);   
}
void MyFrame::OnTimer(wxTimerEvent& event)
{
    // 你可以在这里作任何你希望 1 秒执行一次的动作
} 
```

注意这里的时间间隔很难作到精确,实际的间隔时长要看定时器时间处理函数执行之前发生的事情的忙闲状况而定.

当我们想精确的测量时长的时候,wxStopWatch 是一个很有用的类,它的构造函数开始记录时间,你可以暂停和恢复它以便获得某个特定时长的精确时间.

```cpp
wxStopWatch sw;
SlowBoringFunction();
// 暂停监视
sw.Pause();
wxLogMessage("The slow boring function took %ldms to execute",
             sw.Time());
// 恢复监视
sw.Resume();
SlowBoringFunction();
wxLogMessage("And calling it twice took %ldms in all", sw.Time()); 
```

空闲时间处理

另外一种代替多线程处理的方法是使用空闲时间处理函数.应用程序类和所有的窗口类在所有其它的事件处理完以后都会收到系统空闲事件,你可以拦截这个事件并增加自己的处理函数.如果你希望收到更多的空闲事件,你可以调用 wxIdleEvent::RequestMore 函数,否则一次空闲事件处理完成以后,要等到下次用户界面事件处理周期结束才会再次收到系统空闲事件.另外,通常你还需要调用 wxIdleEvent::Skip 函数,以便别的对象的系统空闲事件处理函数可以被执行.

在下面的例子中,假想的函数 FinishedIdleTask 在每次空闲事件处理函数中处理一部分工作,这个函数在整个工作完成以后返回 True.

```cpp
class MyFrame : public wxFrame
{
public:
    ...
    void OnIdle(wxIdleEvent& event);
    // 作一小部分工作,如果做完则返回 True
    bool FinishedIdleTask();
};
BEGIN_EVENT_TABLE(MyFrame, wxFrame)
    EVT_IDLE(MyFrame::OnIdle)
END_EVENT_TABLE()
void MyFrame::OnIdle(wxIdleEvent& event)
{
    // 进行空闲事件处理,如果没有处理完
    // 再次请求空闲事件
    if (!FinishedIdleTask())
        event.RequestMore();
    event.Skip();
} 
```

虽然我们的例子中使用的是 frame 窗口,并不意味着空闲事件只能存在于顶层窗口,实际上,任何窗口都可以处理这个事件.比如,如果你想制作一个定制的图像显示控件,如果窗口大小发生了变化,这个控件只在空闲事件才进行重画以避免窗口大小改变时立即重画可能引发的闪铄.为了确定这个空闲处理不被应用程序的空闲事件处理函数打断,你可以在你的自定义控件中重载虚函数 OnInternalIdle,并调用其基类的 OnInternalIdle 函数.它的代码大致象下面的样子:

```cpp
void wxImageCtrl::OnInternalIdle()
{
    wxControl::OnInternalIdle();

    if (m_needResize)
    {
        m_needResize = false;
        SizeContent();
    }
}
void wxImageCtrl::OnSize(wxSizeEvent& event)
{
    m_needResize = true;
} 
```

有时候你可能想强制执行系统空闲处理函数,即使没有任何事件导致系统空闲事件被再次调用.你可以通过 wxWakeUpIdle 函数强制启动空闲事件处理.另外一个方法是启动一个不做任何事情的定时器,由于定时器会定时送出定时器事件,因此在定时器事件处理完以后(实际上什么事也没做),就会周期性的引发系统空闲事件处理,要强制立即处理所有的空闲事件,你可以直接调用 wxApp::ProcessIdle 函数,但是依平台的不同,这可能会影响到内部空闲事件处理(比如在 GTK+平台上,窗口重绘都是在空闲时间完成的).

使用空闲事件进行用户界面更新的内容,我们已经在第九章,"创建定制的对话框"中介绍过,它用来另外一种形式的系统空闲事件 wxUpdateUIEvent.

强制处理用户界面更新事件

当一个应用程序忙于处理一个很耗时的工作的时候,它可能来不及更新用户界面,这时候用户界面就好像被冻结一样,要避免这种情况,你可以在那个耗时的任务中周期性的调用 wxApp::Yield 函数(或者它的等价体 wxYield).不过这种方法应该尽量少的使用,因为它可能会导致不可知的问题.比如,Yield 可能会导致处理用户命令事件,这个事件可能会导致特定的任务被重新执行,尽管我们目前仍在执行这个任务.我们称之为重入.函数 wxSafeYield 会首先禁用所有的窗口,然后 Yield,然后再重新使能所有的窗口以尽可能避免重入.如果你给 wxApp::Yield 函数传递 True 作为参数,那么如果正在进行 Yield,第二次的 Yield 动作将放弃,这也是另外一种降低重入风险的办法.

如果你希望周期的更新特定显示,直接调用 wxWindow::Update 函数会比较好,因为这将只会导致未处理的重绘事件被处理.

# 第十七章小结

# 第十七章小结

正如给一个银行业务员的业务窗口从一个变成两个不大会提高他每小时接待的顾客数目一样,多线程并不会让你的程序运行的更快(至少在普通的硬件环境下是这样).然而,它可以让你的程序看上去比不用线程更流畅了,正如那个业务员在一个柜台等刷卡的时候可以跑到另外一个窗口继续办公一样,多线程可以让你的系统的资源使用的更有效率.在解决某些特定的问题方面,它也比不用多线程的手段看上去更优雅.在这一章的最后,我们还介绍了多线程替代方案相关的内容,包括空闲事件处理,定时器和 Yield 等.

关于多线程编程还有很多方面的问题这里没有涉及到,如果你对更深入的内容感兴趣,推荐你阅读 David R. Butenhof 写的书"Programming with POSIX Threads".

下一章我们来看看怎样使用 socket 编程以便在进程间传递数据.