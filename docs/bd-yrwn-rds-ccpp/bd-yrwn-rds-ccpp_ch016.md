# A1: 练习提示

### 08. 数据结构：哈希表

> Q: 当哈希表的负载因子过高时，我们的哈希表会触发调整大小，当负载因子过低时，我们也应该缩小哈希表吗？收缩可以自动执行吗？

<details><summary>提示：</summary>在实际应用中，哈希表收缩并不是自动完成的。许多实际使用模式是周期性的，收缩并不总是明显有益。此外，收缩并不总是将内存返回给操作系统，这取决于许多因素，如 malloc 实现和内存碎片程度；收缩的结果不易预测。</details>

### 10. AVL 树：实现与测试

> Q: 你能创建更多的测试用例吗？本章中提供的测试用例可能不足以满足需求。

<details><summary>提示：</summary>

我们现有的测试用例列出了各种大小的 AVL 树。然而，给定一个特定大小的树，存在许多可能的配置，我们可以通过枚举树配置来进一步扩展。

此外，对于更复杂的代码，使用分析工具检查测试用例是否对目标代码提供了全面覆盖是有帮助的。非全面覆盖表明测试用例或目标代码中存在错误。

值得一提的另一种技术是模糊测试。</details>

### 11. AVL 树与有序集合

> Q: `avl_offset` 函数使我们能够按排名查询有序集合，现在反过来，给定 AVL 树中的一个节点，找到它的排名，最坏情况下的复杂度为 `O(log(n))`。（这是 `zrank` 命令。）

<details><summary>提示：</summary>一个节点的排名与其父节点的排名相关。而根节点的排名是明显的。</details>

> Q: 另一个有序集合的应用：计算一个范围内的元素数量。（最坏情况下的复杂度也是 `O(log(n))`。）

<details><summary>提示：</summary>使用节点的排名。</details>

### 13. 堆数据结构与 TTL

> Q: 基于堆的定时器给服务器增加了 `O(log(n))` 的操作，这可能会成为足够多键的大瓶颈。你能想到针对大量定时器的优化方法吗？

<details><summary>提示：</summary>

我们可以通过使用 n-ary 树而不是二叉树来使堆更缓存友好。一些实际项目使用四叉树，它适合 64 字节缓存行。

此外，在我们的情况下，TTL 定时器不需要在确切的时间触发。我们可以为 TTL 定时器使用一个非常粗略的时间戳（例如，四舍五入到 1 分钟分辨率），具有相同时间戳的键可以共享同一个定时器。这减少了定时器的数量，但定时器会延迟，因此我们需要在访问键时检查实际的过期时间。

> Q: 真实的 Redis 不使用排序进行过期处理，找出它是如何完成的，并列出两种方法的优缺点。

<details><summary>提示：</summary>

采用键不需要在确切时间过期的想法，Redis 通过随机采样键空间来寻找死键。死键的比例越高，找到并消除它们就越容易。

这种方法的优点是：

1.  它不需要额外的空间。

1.  概念简单，实现也容易。

缺点：

1.  它要求带有 TTL 的键不应与不带 TTL 的键混合，否则非 TTL 键会干扰采样，使得寻找死键变得更加困难。这可能会让操作员感到意外。

1.  虽然这个概念很简单，但在实现过程中使用了一些启发式算法来确定采样的速率。如果启发式算法没有调整得当，在最坏的情况下，服务器可能无法足够快地移除死键，导致内存使用过多，这可能会让操作员感到沮丧。</details>

### 14. 线程池与异步任务

> Q: 仅使用互斥锁实现条件变量。（中级）

<details><summary>提示：</summary>首先，你需要弄清楚如何使用互斥锁来实现休眠和唤醒。然后，你需要跟踪条件变量中的休眠者列表，以便稍后唤醒它们。</details>
