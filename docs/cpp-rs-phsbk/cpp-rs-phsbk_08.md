# 数据建模

> 原文：[`cel.cs.brown.edu/crp/idioms/data_modeling.html`](https://cel.cs.brown.edu/crp/idioms/data_modeling.html)

在 C++ 中，可用于数据建模的机制有类、枚举和联合。

相反，Rust 使用记录（[结构体](https://doc.rust-lang.org/book/ch05-00-structs.html)）和代数数据类型（[枚举](https://doc.rust-lang.org/book/ch06-00-enums.html)）。

尽管 Rust 支持面向对象设计的一个重要方面，即使用接口的多态性，但 Rust 也具有用于使用代数数据类型（在简单情况下类似于更易于使用的 `std::variant`）建模事物的语言特性。

本节提供了在 C++ 中编程时使用的常见构造示例，以及如何使用 Rust 的功能实现相同的效果。

## 固定操作，可变数据

在需要建模一组固定操作，但实现这些操作的数据在事先不是固定的情况下，C++ 和 Rust 的方法相同。在两种情况下，都定义了定义所需操作的接口。具体类型，可能由客户端定义，实现这些接口。

这种建模数据的方式可以利用 动态 或 静态分派，每个都在其自己的章节中进行了介绍。

## 固定数据，可变操作

在存在一组固定数据但必须支持的操作可变的情况下，C++ 中有一些方法。可用的方法取决于所使用的标准版本。

在旧版标准中，可能会使用手动定义的标记联合。在新版本中，`std::variant` 可用于提高标记联合的安全性和易用性。这两种方法在 Rust 中映射到相同的方法。

此外，尽管建模一组固定的变体不是严格必要的，但访问者模式有时用于这种情况，尤其是在使用在引入 `std::variant` 之前的 C++ 标准版本时。在这些情况的大多数中，Rust 的惯用解决方案与将使用 标记联合 的 C++ 解决方案转换为 Rust 解决方案时所做的相同。关于 访问者模式 的章节描述了何时使用 Rust 版本的访问者模式，何时使用 Rust 的枚举（它们比 C++ 枚举更接近 `std::variant`）来建模数据。

## 可变数据和操作

当数据和操作都可能被客户端扩展时，所需的解决方案更为复杂。在 C++中，通常涉及对访问者模式的某种扩展，以及动态类型转换。由于 Rust 不支持动态类型转换操作所需的 RTTI（运行时类型识别），需要使用不同的方法。其中一些方法在关于访问者模式的章节中进行了讨论。

[点击此处给我们关于此页面的反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Data modeling)
