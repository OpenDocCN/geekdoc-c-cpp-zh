# RTTI and dynamic_cast

> 原文：[`cel.cs.brown.edu/crp/idioms/rtti.html`](https://cel.cs.brown.edu/crp/idioms/rtti.html)

Rust does not have built-in support for generalized RTTI, nor does Rust have a direct analog to `dynamic_cast`.

The only language primitive provided by Rust in this vein is [`TypeId`](https://doc.rust-lang.org/std/any/struct.TypeId.html), which is a globally unique identifier for a type. Rust's standard library builds on `TypeId` to provide an [`Any` trait](https://doc.rust-lang.org/std/any/trait.Any.html) that supports similar uses to `std::any` in C++. However, `Any` does not enable testing for implementation of, or converting to, another trait. It only enables testing for and converting to a specific type.

Every type with a `'static` lifetime bound (i.e., that does not contain references with a non-static lifetime) implements `Any` via a blanket implementation in the standard library.

```rs
#include <any>
#include <iostream>
#include <string>

void print_if_string(const std::any &x) {
  try {
    const std::string &s =
        any_cast<std::string const &>(x);
    std::cout << s << std::endl;
  } catch (std::bad_any_cast &e) {
    std::cout << "Not a string!" << std::endl;
  }
}

int main() {
  print_if_string(std::string("hello world"));
  print_if_string(5);
} 
```

```rs

```

use std::any::Any;

fn print_if_string(x: &dyn Any) {

    match x.downcast_ref::<String>() {

        Some(s) => println!("{}", s),

        None    => println!("Not a string!")

    }

}

fn main() {

    print_if_string(&String::from("hello world"));

    print_if_string(&5);

}

```rs

```

## Event handling

One practical use of RTTI and `dynamic_cast` in C++ is for event handling in situations where both the subsystem generating events and the events themselves need to be decoupled from the handling logic. This is usually because the events are generated by a framework, such as a GUI or game framework, while the response to the events is application-specific.

```rs
struct Event {
  virtual ~Event() = default;
};

struct ClickEvent : public Event {
  int x;
  int y;
};

struct ResizeEvent : public Event {
  int old_height;
  int old_width;
  int new_height;
  int new_width;
};

void handle_event(Event *e) {
  if (auto click_event =
          dynamic_cast<ClickEvent *>(e)) {
    // ...
  } else if (auto resize_event =
                 dynamic_cast<ResizeEvent *>(e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
}

// register event handler in main 
```

```rs

```

#![allow(unused)] fn main() { enum Event {

    ClickEvent {

        x: i32,

        y: i32,

    },

    ResizeEvent {

        old_height: i32,

        old_width: i32,

        new_height: i32,

        new_width: i32,

    },

}

fn handle_event(e: Event) {

    match e {

        Event::ClickEvent { x, y } => {

            // ...

        }

        Event::ResizeEvent {

            old_height,

            old_width,

            new_height,

            new_width,

        } => {

            // ...

        }

    }

}

}

```rs

```

即使库的客户端需要能够定义自定义事件，通常也可以使用事件枚举。这是[winit crate](https://docs.rs/winit/latest/winit/event/enum.Event.html)所采取的方法，它实现了跨平台的窗口和事件循环管理。

```rs
struct Event {
 virtual ~Event() = default; };   struct ClickEvent : public Event {
 int x; int y; };   struct ResizeEvent : public Event {
 int old_height; int old_width; int new_height; int new_width; };   struct DoSomething : public Event {
  double how_much;
}

struct DoSomethingElse : public Event {
  double how_many;
}

void handle_event(Event *e) {
 if (auto click_event = dynamic_cast<ClickEvent *>(e)) { // ... } else if (auto resize_event = dynamic_cast<ResizeEvent *>(e)) { // ...  // ...
  } else if (auto user_event =
                 dynamic_cast<DoSomething *>(e)) {
    // ...
  } else if (auto user_event =
                 dynamic_cast<DoSomethingElse *>(
                     e)) {
    // ...
  } else {
    // ... handle unknown event ...
  }
} 
```

```rs

```

#![allow(unused)] fn main() { enum Event<T> {

ClickEvent { x: i32, y: i32, }, ResizeEvent { old_height: i32, old_width: i32, new_height: i32, new_width: i32, },    // ...

    UserEvent(T),

}

enum UserEvent {

    DoSomething { how_much: f64 },

    DoSomethingElse { how_many: i32 },

}

fn handle_event(e: Event<UserEvent>) {

    match e {

Event::ClickEvent { x, y } => { // ... } Event::ResizeEvent { old_height, old_width, new_height, new_width, } => { // ... }        // ...

        Event::UserEvent(

            UserEvent::DoSomething { how_much },

        ) => {

            // ...

        }

        Event::UserEvent(

            UserEvent::DoSomethingElse {

                how_many,

            },

        ) => {

            // ...

        }

    }

}

}

```rs

```

当将事件表示为枚举实际上不可行时，有时可以使用双重分派来代替。否则，可能需要使用`Any`特质或定义一个`Event`特质，该特质公开一个类型标识符，可用于安全下转型（通过`Any`）或在不安全接口背后的不安全下转型.^(1)

## 通过宏实现的库对反射的支持

RTTI 的一些用例可以通过在 Rust 中使用第三方反射库来实现。这些库通过提供用于推导特质的宏来实现反射，以支持常见的反射操作。Rust 反射库包括[bevy_reflect](https://docs.rs/bevy_reflect/latest/bevy_reflect/)、[facet](https://facet.rs/)和[mirror-mirror](https://docs.rs/mirror-mirror/latest/mirror_mirror/)。

通过推导宏的反射方法基本上是可选的，这样不使用反射的软件就不必为此付出代价（性能成本或二进制大小）。然而，由于 Rust 的[孤儿规则](https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules)，这种方法使得集成缺乏推导特质的第三方类型变得更加困难。

* * *

1.  这样的接口通常涉及为特定类型提供单独的事件处理函数，而不是一个单一的大型事件处理函数，这样底层实现就可以管理执行下转型所需的一致性强制。 ↩

[点击此处为此页面提供反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=RTTI and dynamic_cast)
