# [11] 析构函数

# [11] 析构函数

## FAQs in section [11]:

*   [11.1] 析构函数做什么？
*   [11.2] 局部对象析构的顺序是什么？
*   [11.3] 数组中的对象析构顺序是什么？
*   [11.4] 我能重载类的析构函数吗？
*   [11.5] 我可以对局部变量显式调用析构函数吗？
*   [11.6] 如果我要一个局部对象在其被创建的代码块的 } 之前被析构，如果我真的想这样，能调用其析构函数吗？
*   [11.7] 好，好；我不显式调用局部对象的析构函数；但如何处理上面那种情况？
*   [11.8] 如果我无法将局部对象包裹于人为的块中，怎么办？
*   [11.9] 如果我是用 `new` 分配对象的，可以显式调用析构函数吗？
*   [11.10] 什么是“定位放置 `new`（placement `new` ）”，为什么要用它？
*   [11.11] 编写析构函数时，需要显式调用成员对象的析构函数吗？
*   [11.12] 当我写派生类的析构函数时，需要显式调用基类的析构函数吗？
*   [11.13] 当析构函数检测到错误时，可以抛出异常吗？

## 11.1 析构函数做什么？

析构函数为对象举行葬礼。

析构函数用来释放对象所分配的资源。举例来说，`Lock` 类可能锁定了一个信号量，那么析构函数将释放该信号量。最常见的例子是，当构造函数中使用了`new`，那么析构函数则使用`delete`。

析构函数是“准备后事”的成员函数。经常缩写成“dtor”。

## 11.2 局部对象析构的顺序是什么？

与构造函数反序：先被构造的，被后析构。

以下的例子中，`b`的析构函数会被首先执行，然后是 `a` 的析构函数：

```cpp
 void userCode()
 {
   Fred a;
   Fred b;
   // ...
 } 
```

## 11.3 数组中的对象析构顺序是什么？

与构造函数反序：先被构造的，后被析构。

以下的例子中，析构的顺序是`a[9]`, `a[8]`, ..., `a[1]`, `a[0]`：

```cpp
 void userCode()
 {
   Fred a[10];
   _// ..._
 } 
```

## 11.4 我能重载类的析构函数吗？

不行。

类只能有一个析构函数。`Fred` 类的析构函数能是`Fred::~Fred()`。不带任何参数，不返回任何东西（译注：void 也不行）。

由于你不会显式地调用析构函数（是的，永远不会），因此无论如何不能传递参数给析构函数。

## 11.5 我可以对局部变量显式调用析构函数吗？

不行！

在创建该局部对象的代码块的 `}` 处，析构函数会自动被调用。这是语言所保证的；自动发生。没有办法阻止它。而两次调用同一个对象的析构函数，你得到的真是坏的结果！砰！你完蛋了！

## 11.6 如果我要一个局部对象在其被创建的代码块的 `}`之前被析构，如果我真的想这样，能调用其析构函数吗？

不行！详见 [前一个 FAQ].

假设析构 `File` 对象的作用是关闭文件。现在假定你有一个 `File`类的对象 `f`，并且你想 `File` `f` 在 `f` 对象的作用范围结束（也就是 `}` ）之前被关闭：

```cpp
 void someCode()
 {
   File f;

   // ... [这些代码在 f 打开的时候执行] ...
   // <— 希望在此处关闭 f
   // ... [这些代码在 f 关闭后执行] ...
 } 
```

对这个问题有一个简单的解决方案。但现在请记住：*不要显式调用析构函数！*

## 11.7 好，好；我不显式调用局部对象的析构函数；但如何处理上面那种情况？

内容详见 [前一个 FAQ].

只要将局部对象的生命期长度包裹于一个人为的 `{`...`}` 块中：

```cpp
 void someCode()
 {
   {
     File f;
     // ... [这些代码在 f 打开的时候执行] ...
   }
   // ^— f 的析构函数在此处会被自动调用!
   // ... [这些代码在 f 关闭后执行] ...
 } 
```

## 11.8 如果我无法将局部对象包裹于人为的块中，怎么办？

大多数时候，你可以通过将局部对象包裹于人为的`{`...`}`块中，限制其生命期。但如果由于一些原因无法这样做，则增加一个模拟析构函数作用的成员函数。但*不要调用析构函数本身*！

例如，`File`类的情况下，可以添加一个`close()`方法。典型的析构函数只是调用`close()`方法。注意`close()`方法需要标记 `File` 对象，以便后续的调用不会再次关闭一个已经关闭的文件。举例来说，可以将一个`fileHandle_`数据成员设置为 -1，并且在开头检查`fileHandle_`是否已经等于-1：

```cpp
 class File {
 public:
   void close();
   ~File();
   // ...
 private:
   int fileHandle_;   // 当且仅当文件打开时 fileHandle_ >= 0
 };

 File::~File()
 {
   close();
 }

 void File::close()
 {
   if (fileHandle_ >= 0) {
     // ... [执行一些操作－系统调用来关闭文件] ...
     fileHandle_ = -1;
   }
 } 
```

注意其他的 `File`方法可能也需要检查`fileHandle_`是否为 -1（也就是说，检查文件是否被关闭了）。

还要注意任何没有实际打开文件的构造函数，都应该将`fileHandle_`设置为 -1。

## 11.9 如果我是用`new`分配对象的，可以显式调用析构函数吗？

可能不行。

除非你使用定位放置 `new`，否则应该 `delete` 对象而不是显式调用析构函数。例如，假设通过一个典型的 `new` 表达式分配一个对象：

```cpp
Fred* p = new Fred(); 
```

那么，当你`delete`它时，析构函数 `Fred::~Fred()` 会被调用：

```cpp
delete p;  // 自动调用 p->~Fred() 
```

由于显式调用析构函数不会释放 `Fred` 对象本身分配的内存，因此不要这样做。记住：`delete p` 做了两件事情：调用析构函数，回收内存。

## 11.10 什么是“定位放置`new`（placement `new`）”，为什么要用它 ？

定位放置`new`（placement `new`）有很多作用。最简单的用处就是将对象放置在内存中的特殊位置。这是依靠 `new`表达式部分的指针参数的位置来完成的：

```cpp
 #include <new>        // 必须 #include 这个，才能使用 "placement new"
 #include "Fred.h"     // class Fred 的声明

 void someCode()
 {
   char memory[sizeof(Fred)];     // Line #1
   void* place = memory;          // Line #2

   Fred* f = new(place) Fred();   // Line #3 (详见以下的“危险”)
   // The pointers f and place will be equal
   // ...
 } 
```

Line #1 在内存中创建了一个`sizeof(Fred)`字节大小的数组，足够放下 `Fred` 对象。Line #2 创建了一个指向这块内存的首字节的`place`指针（有经验的 C 程序员会注意到这一步是多余的，这儿只是为了使代码更明显）。Line #3 本质上只是调用了构造函数 `Fred::Fred()`。`Fred`构造函数中的`this`指针将等于`place`。因此返回的 `f` 将等于`place`。

建议：万不得已时才使用“placement `new`”语法。只有当你真的在意对象在内存中的特定位置时才使用它。例如，你的硬件有一个内存映象的 I/O 计时器设备，并且你想放置一个`Clock`对象在那个内存位置。

危险：你要独自承担这样的责任，传递给“placement `new`”操作符的指针所指向的内存区域必须足够大，并且可能需要为所创建的对象进行边界调整。编译器和运行时系统都不会进行任何的尝试来检查你做的是否正确。如果 `Fred`类需要将边界调整为 4 字节，而你提供的位置没有进行边界调整的话，你就会亲手制造一个严重的灾难（如果你不明白“边界调整”的意思，那么就不要使用 placement `new`语法）。

你还有析构放置的对象的责任。这通过显式调用析构函数来完成：

```cpp
 void someCode()
 {
   char memory[sizeof(Fred)];
   void* p = memory;
   Fred* f = new(p) Fred();
   // ...
   f->~Fred();   // 显式调用定位放置的对象的析构函数
 } 
```

这是显式调用析构函数的唯一时机。

## 11.11 编写析构函数时，需要显式调用成员对象的析构函数吗？

不！永远不需要显式调用析构函数（除了定位放置 `new`的情况）。

类的析构函数（不论你是否显式地定义了）自动调用成员对象的析构函数。它们以出现在类声明中的顺序的反序被析构。

```cpp
 class Member {
 public:
   ~Member();
   // ...
 };

 class Fred {
 public:
   ~Fred();
   _// ..._
 private:
   Member x_;
   Member y_;
   Member z_;
 };

 Fred::~Fred()
 {
   // 编译器自动调用 z_.~Member()
   // 编译器自动调用 y_.~Member()
   // 编译器自动调用 x_.~Member()
 } 
```

## 11.12 当我写派生类的析构函数时，需要显式调用基类的析构函数吗？

不！永远不需要显式调用析构函数（除了定位放置 `new`的情况）。

派生类的析构函数（不论你是否显式地定义了）自动调用基类子对象的析构函数。基类在成员对象之后被析构。在多重继承的情况下，直接基类以出现在继承列表中的顺序的反序被析构。

```cpp
 class Member {
 public:
   ~Member();
   // ...
 };

 class Base {
 public:
   virtual ~Base();     // 虚析构函数
   // ...
 };

 class Derived : public Base {
 public:
   ~Derived();
   // ...
 private:
   Member x_;
 };

 Derived::~Derived()
 {
   // 编译器自动调用 x_.~Member()
   // 编译器自动调用 Base::~Base()
 } 
```

注意：虚拟继承的顺序相关性是多变的。如果你在一个虚拟继承层次中依赖于其顺序相关性，那么你需要比这个 FAQ 更多的信息。

## 11.13 当析构函数检测到错误时，可以抛出异常吗？

谨防!!! 详见 该 FAQ。