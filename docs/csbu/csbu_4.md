<main class="calibre3">

## 第五章. 进程

</main>

<main class="calibre3">

## 1 什么是进程？

我们都熟悉现代操作系统同时运行许多任务或*多任务处理*。

我们可以将每个进程视为内核保存的一组元素，用以跟踪所有这些正在运行的任务。

</main>

<main class="calibre3">

## 2 进程的元素

<picture>![进程的基本元素；进程 ID、内存、文件和寄存器。](img/theprocess.svg)</picture>图 2.1 进程的元素

### 2.1 进程 ID

*进程 ID*（或 PID）由操作系统分配，并且对每个运行进程是唯一的。

### 2.2 内存

在接下来的几周里，我们将学习进程如何获得其内存——这是操作系统工作原理中最基本的组成部分之一。然而，现在我们只需要知道每个进程都有自己的内存部分。

在这个内存中存储了所有程序代码，以及变量和任何其他分配的存储空间。

内存的部分可以由进程共享（称为，不出所料的是*共享内存*）。你经常会看到在较老操作系统中原始实现之后，将其称为*系统五共享内存*（或 SysV SHM）。

进程可能利用的另一个重要概念是将磁盘上的文件*mmap*到内存中。这意味着不需要打开文件并使用`read()`和`write()`等命令，文件看起来就像任何其他类型的 RAM。`mmaped`区域具有读、写和执行等权限，需要跟踪。正如我们所知，维护安全和稳定是操作系统的职责，因此它需要检查进程是否尝试写入只读区域，并返回错误。

#### 2.2.1 代码和数据

进程可以进一步分为*代码*和`数据`部分。程序代码和数据应该分开存储，因为它们需要来自操作系统的不同权限，并且分离有助于代码的共享（正如你稍后看到的）。操作系统需要给予程序代码读取和执行的权限，但通常不写入。另一方面，数据（变量）需要读取和写入权限，但不应该可执行。然而，并非所有架构都支持这一点。这导致了许多架构上出现了广泛的安全问题。

#### 2.2.2 栈

进程的另一个非常重要的部分是称为*栈*的内存区域。这可以被认为是进程数据部分的一部分，并且与任何程序的执行密切相关。

栈是一种通用数据结构，其工作方式与盘子堆叠完全一样；你可以*push*一个项目（将盘子放在盘子堆的顶部），然后它成为顶部项目，或者你可以*pop*一个项目（取下盘子，露出下面的盘子）。

栈对于函数调用是基本的。每次调用函数时，它都会获得一个新的`栈帧`。这是一个内存区域，通常至少包含完成时返回的地址、函数的输入参数以及局部变量的空间。

按照惯例，栈通常*向下增长*。一些架构，如惠普的 PA-RISC，栈向上增长。在其他一些架构上，如 IA64，有其他存储区域（寄存器后端存储）从底部向栈增长。这意味着栈从内存中的高地址开始，逐渐变低。

![栈与函数调用的工作方式。注意栈向下增长，从内存中的高地址到低地址。](img/stack.svg)图 2.2.2.1 栈

我们可以看到拥有栈如何带来了许多函数的特性。

+   每个函数都有其输入参数的副本。这是因为每个函数都被分配了一个新的栈帧，其参数在一个新的内存区域中。

+   这就是为什么在函数内部定义的变量不能被其他函数看到的原因。全局变量（可以被任何函数看到）保存在数据内存的单独区域。

+   这促进了*递归*调用。这意味着一个函数可以自由地再次调用自己，因为将为所有局部变量创建一个新的栈帧。

+   每个帧都包含返回的地址。C 语言只允许从函数返回单个值，因此按照惯例，这个值是通过指定的寄存器返回给调用函数的，而不是在栈上。

+   因为每个帧都有一个对之前帧的引用，调试器可以“向后走”，沿着栈上的指针向上跟踪。从这个角度来看，它可以生成一个*堆栈跟踪*，显示所有调用此函数之前调用的函数。这对于调试非常有用。

    你可以看到函数的工作方式如何完美地符合栈的本质。任何函数都可以调用任何其他函数，然后它成为最顶层的函数（放在栈顶）。最终，该函数将返回到调用它的函数（从栈中移除自己）。

+   栈确实会使调用函数变慢，因为必须将值从寄存器移动到内存中。一些架构允许直接在寄存器中传递参数；然而，为了保持每个函数获得每个参数唯一副本的语义，寄存器必须*旋转*。

+   你可能听说过“*栈溢出*”这个术语。这是一种常见的通过传递虚假值来黑客攻击系统的方法。如果你作为一个程序员接受任意输入到栈变量中（比如从键盘读取或通过网络），你需要明确说明数据的大小。

    允许任意数量的数据未经检查就会简单地覆盖内存。通常这会导致崩溃，但有些人意识到，如果他们覆盖足够的内存来在栈帧的返回地址部分放置特定的值，当函数完成时，它不会返回到正确的位置（即它被调用的地方），而是可以使其返回到他们刚刚发送的数据中。如果这些数据包含可以篡改系统的二进制可执行代码（例如，以 root 权限为用户启动一个终端），那么你的计算机已经被入侵。

    这是因为栈向下增长，但数据是以“向上”的方式读取的（即从低地址到高地址）。

    有几种方法可以解决这个问题；首先，作为程序员，你必须确保你总是检查你接收到的变量中的数据量。操作系统可以通过确保栈被标记为*不可执行*来代表程序员避免这种情况；也就是说，处理器不会运行任何代码，即使恶意用户试图将一些代码传递到你的程序中。现代架构和操作系统支持这种功能。

+   栈最终由编译器管理，因为它负责生成程序代码。对于操作系统来说，栈看起来就像进程的任何其他内存区域一样。

为了跟踪栈的当前增长，硬件定义了一个寄存器作为*栈指针*。编译器（或当用汇编语言编写时程序员）使用这个寄存器来跟踪栈的当前顶部。

```cpp
 1 |$ cat sp.c 
 |void function(void) 
 |{ 
 | int i = 100; 
 5 | int j = 200; 
 | int k = 300; 
 |} 
 |
 |$ gcc -fomit-frame-pointer -S sp.c 
10 |
 |$ cat sp.s 
 | .file   "sp.c" 
 | .text 
 |.globl function 
15 | .type   function, @function 
 |function: 
 | subl    $16, %esp 
 | movl    $100, 4(%esp) 
 | movl    $200, 8(%esp) 
20 | movl    $300, 12(%esp) 
 | addl    $16, %esp 
 | ret 
 | .size   function, .-function 
 | .ident  "GCC: (GNU) 4.0.2 20050806 (prerelease) (Debian 4.0.1-4)" 
25 | .section        .note.GNU-stack,"",@progbits 

```

示例 2.2.2.1 栈指针示例

在上面，我们展示了一个简单的函数，在栈上分配了三个变量。反汇编代码说明了在 x86 架构上使用栈指针的情况。注意，我们使用了 gcc 的特殊标志`-fomit-frame-pointer`，该标志指定不应使用额外的寄存器来保持对栈帧开始的指针。这个指针有助于调试器向上遍历栈帧，然而它使得可用的寄存器数量减少了一个，这对于其他应用程序来说可能不太方便。首先，我们在栈上为我们的局部变量分配一些空间。由于栈向下增长，我们从栈指针中减去值。数值 16 足够容纳我们的局部变量，但可能不是所需的精确大小（例如，对于 3 个 4 字节的`int`值，我们实际上只需要 12 字节，而不是 16）以保持栈在内存中特定边界上的对齐，因为编译器要求这样做。

然后，我们将值移动到栈内存中（在真实函数中，使用它们）。最后，在返回父函数之前，我们通过将栈指针移回到开始之前的位置来“弹出”栈上的值。

#### 2.2.3 堆

堆是进程管理的内存区域，用于动态内存分配。这是对于在编译时不知道内存需求的变量。

堆的底部被称为*brk*，这个名字来源于修改它的系统调用。通过使用`brk`调用向下扩展区域，进程可以请求内核为其分配更多的内存。

堆通常由`malloc`库函数管理。这使得程序员通过简单地分配和释放（通过`free`调用）堆内存来管理堆变得容易。`malloc`可以使用如*buddy allocator*这样的方案来管理用户的堆内存。`malloc`还可以在分配方面更加智能，并可能使用*匿名 mmaps*来为进程提供额外的内存。这就是在将*mmap*文件映射到进程内存中而不是直接映射系统 RAM 区域的地方。这可能会更高效。由于正确管理内存的复杂性，任何现代程序直接调用`brk`的情况都非常罕见。

#### 2.2.4 内存布局

![如何分配进程内存的示例](img/memory-layout.svg)图 2.2.4.1 进程内存布局

正如我们所见，进程被分配了较小的内存区域，每个区域都有特定的用途。

上面给出了内核如何在内存中布局进程的一个例子。从顶部开始，内核在进程的顶部保留了一些内存（我们通过虚拟内存可以看到这些内存实际上是所有进程共享的）。

在下面是`mmaped`文件和库的空间。再下面是栈，再下面是堆。

在最底层是程序映像，这是从磁盘上的可执行文件中加载的。我们将在后面的章节中更详细地探讨加载这些数据的过程。

### 2.3 文件描述符

在第一周，我们学习了`stdin`、`stdout`和`stderr`；每个进程都分配的默认文件。你们会记得，这些文件总是有相同的文件描述符号（分别是 0、1、2）。

因此，内核为每个进程单独保留文件描述符。

文件描述符也有权限。例如，你可能能够从文件中读取但不能写入。当文件被打开时，操作系统会在文件描述符中记录进程对该文件的权限，并阻止进程执行它不应该做的事情。

### 2.4 寄存器

我们从上一章了解到，处理器本质上是在寄存器中的值上执行一些简单的操作。这些值会被读取（和写入）到内存中——我们上面提到，每个进程都会分配内存，内核会跟踪这些内存。

因此，等式的另一边是跟踪寄存器。当当前运行的进程需要放弃处理器以便另一个进程运行时，它需要保存其当前状态。同样，当进程在 CPU 上获得更多运行时间时，我们需要能够恢复此状态。为此，操作系统需要将 CPU 寄存器的副本存储到内存中。当进程再次运行时，操作系统将从内存中将寄存器值复制回 CPU 寄存器，进程将回到它离开的地方。

### 2.5 内核状态

内核需要为每个进程跟踪多个元素。

#### 2.5.1 进程状态

操作系统需要跟踪的另一个重要元素是进程状态。如果进程当前正在运行，那么将其置于*运行*状态是有意义的。

然而，如果进程请求从磁盘读取文件，我们知道从我们的内存层次结构来看，这可能需要相当长的时间。进程应该放弃当前的执行以允许另一个进程运行，但内核不需要在磁盘上的数据可用在内存中之前让进程再次运行。因此，它可以标记进程为*磁盘等待*（或类似状态）直到数据准备好。

#### 2.5.2 优先级

一些进程比其他进程更重要，并具有更高的优先级。请参阅下面的调度器讨论。

#### 2.5.3 统计信息

内核可以跟踪每个进程的行为统计信息，这有助于它做出关于进程行为的决策；例如，它主要从磁盘读取还是主要进行 CPU 密集型操作？

</main>

<main class="calibre3">

## 3 进程层次结构

虽然操作系统可以同时运行许多进程，但实际上它只直接启动一个名为*init*（简称初始）的进程。这个进程并不特别特殊，除了它的 PID 总是 0，它将*始终*在运行。

所有其他进程都可以被认为是这个初始进程的*孩子*。进程有一个家族树，就像任何其他东西一样；每个进程都有一个*父进程*，可以有许多*兄弟*，这些是由同一个父进程创建的进程。

当然，孩子们可以创造更多的孩子，等等。

```cpp
1 |init-+-apmd 
 | |-atd 
 | |-cron 
 | ... 
5 | |-dhclient 
 | |-firefox-bin-+-firefox-bin---2*[firefox-bin] 
 | |             |-java_vm---java_vm---13*[java_vm] 
 | `|             `-swf_play` 

```

示例 3.1 `pstree` 示例</main>

<main class="calibre3">

## 4 分支和执行

新进程是通过两个相关的接口`fork`和`exec`创建的。

### 4.1 分支

当你来到比喻性的“分岔路口”时，你通常有两个选择，你的决定会影响你的未来。当计算机程序遇到`fork()`系统调用时，它们会达到这个“分岔路口”。

在这一点上，操作系统将创建一个与父进程完全相同的新进程。这意味着之前提到的所有状态都被复制，包括打开的文件、寄存器状态以及所有内存分配，这包括程序代码。

系统调用的返回值是进程确定它是否是现有进程或新进程的唯一方式。对父进程的返回值将是子进程的进程 ID (PID)，而子进程将得到返回值 0。

在这一点上，我们说进程已经 `fork`，并且我们有上面描述的父子关系。

### 4.2 Exec

`fork` 提供了一种方式，让现有进程可以启动一个新的进程，但如果是新进程不是父进程所属的同一程序呢？这在 shell 中就是这样；当用户启动一个需要在新进程中运行的命令时，它与 shell 无关。

这就是 `exec` 系统调用发挥作用的地方。`exec` 会 *替换* 当前运行进程的内容，用程序二进制文件中的信息来替换。

因此，shell 启动新程序时遵循的进程是首先 `fork`，创建一个新进程，然后 `exec`（即加载到内存中并执行）它应该运行的程序二进制文件。

### 4.3 Linux 实际上如何处理 fork 和 exec

#### 4.3.1 `clone`

在内核中，`fork` 实际上是通过一个 `clone` 系统调用来实现的。这个 `clone` 接口有效地为 Linux 内核创建进程提供了一种抽象级别。

`clone` 允许你明确指定新进程的哪些部分被复制到新进程中，哪些部分在两个进程之间共享。这乍一看可能有点奇怪，但允许我们通过一个非常简单的接口轻松实现 *线程*。

##### 4.3.1.1 线程

虽然 `fork` 复制了我们提到的所有属性，但想象一下，如果除了内存之外的所有东西都被复制到新进程中会怎样。这意味着父进程和子进程共享相同的内存，包括程序代码和数据。

<picture>![进程的内存（包括程序代码和变量）由线程共享，但每个线程都有自己的内核状态，因此它们可以同时运行代码的不同部分。](img/threads.svg)</picture>图 4.3.1.1.1 线程

这种混合子进程被称为 *线程*。线程相对于你可能使用的 *fork* 有许多优势

1.  分离的进程不能看到彼此的内存。它们只能通过其他系统调用来相互通信。

    然而，线程共享相同的内存。因此，你有了多进程的优势，但代价是需要使用系统调用来在它们之间进行通信。

    这引发的问题是，线程可以非常容易地相互干扰。一个线程可能会增加一个变量，而另一个线程可能会减少它，而不通知第一个线程。这类问题被称为 *并发问题*，它们种类繁多。

    为了帮助解决这个问题，有一些用户空间库可以帮助程序员正确地处理线程。最常见的一个叫做`POSIX threads`，或者更常见地称为`pthreads`。

1.  进程切换相当昂贵，其中主要开销之一是跟踪每个进程使用什么内存。通过共享内存，可以避免这种开销，性能可以显著提高。

实现线程的方法有很多种。一方面，用户空间实现可以在内核不知道的情况下在一个进程内实现线程。对内核来说，这些线程看起来就像是在单个进程中运行的。

这主要是因为内核被隐瞒了关于系统中正在运行什么的信息。确保系统资源以最佳方式使用是内核的工作，如果内核认为是一个单独的进程实际上正在运行多个线程，它可能会做出次优决策。

因此，另一种方法是内核对线程有完全的了解。在 Linux 中，这是通过使所有进程都能通过`clone`系统调用共享资源来实现的。每个线程仍然关联着内核资源，因此内核在分配资源时可以将其考虑在内。

其他操作系统采用了一种混合方法，其中一些线程可以指定仅在用户空间运行（“对内核隐藏”），而其他线程可能是一个*轻量级进程*，向内核表明该进程是线程组的一部分。

##### 4.3.1.2 写时复制

正如我们提到的，当调用`fork`时，将一个进程的全部内存复制到另一个进程是一个昂贵的操作。

一种优化称为*写时复制*。这意味着当调用 fork 时，内存实际上是共享的，而不是复制的，两个进程之间共享内存，而不是复制。如果进程只打算读取内存，那么实际复制数据是不必要的。

然而，当一个进程向其内存写入时，它需要一个私有的副本，而不是共享的。正如其名称所暗示的，写时复制通过仅在写入时实际复制内存来优化这一点。

写时复制对`exec`也有很大的优势。由于`exec`将简单地用新程序覆盖所有内存，实际上复制内存会浪费很多时间。写时复制节省了我们实际进行复制的时间。

### 4.4 初始化进程

我们之前讨论了 init 进程的整体目标，现在我们能够理解它是如何工作的。

在引导时，内核启动 init 进程，然后它进行分叉和执行系统引导脚本。这些分叉和执行更多的程序，最终导致分叉一个登录进程。

`init`进程的另一个任务是“回收”。当一个进程以返回码调用`exit`时，父进程通常会检查这个代码，以查看子进程是否正确退出。

然而，这个退出代码是刚刚调用 `exit` 的进程的一部分。因此，进程是 "dead"（例如，未运行），但仍然需要保留，直到收集到返回代码。处于这种状态的过程被称为 *僵尸*（你可以将其特性与神秘的僵尸进行对比！）

一个进程会保持僵尸状态，直到父进程通过 `wait` 调用收集返回代码。然而，如果父进程在收集这个返回代码之前退出，僵尸进程仍然存在，无目的地等待向某人提供其状态。

在这种情况下，僵尸子进程将被 *重新分配* 到具有特殊处理程序（用于 *回收* 返回值）的 init 进程。因此，进程最终是自由的，描述符可以从内核的进程表中移除。

#### 4.4.1 僵尸进程示例

```cpp
 1 |$ cat zombie.c 
 |#include <stdio.h> 
 |#include <stdlib.h> 
 |
 5 |int main(void) 
 |{ 
 | pid_t pid; 
 |
 | printf("parent : %d\n", getpid()); 
10 |
 | pid = fork(); 
 |
 | if (pid == 0) { 
 | printf("child : %d\n", getpid()); 
15 | sleep(2); 
 | printf("child exit\n"); 
 | exit(1); 
 | } 
 |
20 | /* in parent */ 
 | while (1) 
 | { 
 | sleep(1); 
 | } 
25 |} 
 |
 |$ ps ax | grep [z]ombie 
 |16168 pts/9    S      0:00 ./zombie 
 |16169 pts/9    Z      0:00 [zombie] <defunct> 

```

示例 4.4.1.1 僵尸进程示例

在上面，我们创建了一个僵尸进程。父进程将永远休眠，而子进程将在几秒钟后退出。

在代码下方，你可以看到程序运行的结果。父进程（16168）处于 `S` 睡眠状态（正如我们所预期的），而子进程处于 `Z` 僵尸状态。ps 输出还告诉我们，该进程在进程描述中是 `defunct`（已终止）。围绕 "zombie" 中的 "z" 的方括号是一个小技巧，用于从 ps 输出中移除 grep 进程本身。grep 将方括号之间的所有内容解释为字符类，但由于进程名称将是 "grep [z]ombie"（带有方括号），这不会匹配！

</main>

<main class="calibre3">

## 5 上下文切换

上下文切换是指内核从一个进程切换到另一个进程的过程。XXX？

</main>

<main class="calibre3">

## 6 调度

运行中的系统有许多进程，可能甚至达到数百或数千。内核中负责跟踪所有这些进程的部分被称为 *调度器*，因为它负责安排哪个进程应该被运行。

调度算法种类繁多。大多数用户都有不同的目标，这些目标与他们的计算机想要执行的任务相关，这会影响调度决策。例如，对于台式电脑，你想要确保你的桌面图形应用程序有足够的时间运行，即使系统进程运行得稍微长一点。这将增加用户感受到的响应速度，因为他们的操作将得到更及时的响应。对于服务器，你可能希望你的网络服务器应用程序得到优先权。

人们总是想出新的算法，你也许可以很容易地想到自己的算法。但是，调度有许多不同的组成部分。

### 6.1 预先调度与协作调度

调度策略可以大致分为两大类

1.  *合作式*调度是当前运行的进程自愿放弃执行以允许另一个进程运行。这种方法的明显缺点是，进程可能决定永远不放弃执行，这可能是由于导致某种形式无限循环的 bug，因此其他任何东西都无法运行。

1.  *抢占式*调度是在中断进程以允许另一个进程运行时停止进程。每个进程都有一个运行的时间片；在每次上下文切换时，计时器将被重置，并在时间片结束时产生中断。

    我们知道硬件独立于运行中的进程处理中断，因此在这个点上控制将返回到操作系统。在这个点上，调度程序可以决定下一个要运行哪个进程。

    这就是所有现代操作系统使用的调度类型。

### 6.2 实时性

一些进程需要确切知道它们的时间片将持续多长时间，以及它们再次获得运行时间片之前需要等待多长时间。比如说，你有一个正在运行心肺机的系统；你不希望下一个脉冲被延迟，因为系统中的其他东西决定运行！

硬实时系统对调度决策做出保证，例如在进程再次运行之前可能被中断的最大时间量。它们通常用于生命攸关的应用，如医疗、航空和军事应用。

软实时是对此的一种变体，其中保证不那么严格，但系统行为是可预测的。Linux 可以像这样使用，并且通常用于处理音频和视频的系统。如果你正在录制音频流，你不想长时间中断，否则你会丢失无法恢复的音频数据。

### 6.3 nice 值

UNIX 系统为每个进程分配一个**nice**值。调度程序会查看这个 nice 值，并可以给那些具有更高“友好度”的进程优先权。

### 6.4 简要了解 Linux 调度程序

Linux 调度程序随着新开发人员尝试改进其行为而不断进行许多变化。

当前调度程序被称为 O(1)调度程序，这指的是无论调度程序需要从多少个进程中选择，它都会在恒定的时间内选择下一个要运行的进程。*Big-O*表示法是一种描述算法在给定增加输入时运行时间的方法。如果算法在两倍输入的情况下运行时间是原来的两倍，这是线性增加。如果另一个算法在两倍输入的情况下运行时间是原来的四倍，那么它是指数增加。最后，如果无论输入多少，算法运行时间都相同，那么算法是恒定时间的。直观上，你可以看到算法随着输入的增加而增长得越慢，它就越好。计算机科学教科书更详细地处理算法分析。

Linux 调度器的先前版本使用 *良好度* 的概念来确定下一个要运行的进程。所有可能的任务都保存在一个 *运行队列* 中，它是一个简单的进程链表，内核知道这些进程处于 "可运行" 状态（即不是在等待磁盘活动或以其他方式休眠）。问题在于，为了计算下一个要运行的进程，必须计算每个可能的可运行进程的 *良好度*，并且具有最高良好度的进程 "获胜"。你可以看到，对于更多的任务，决定下一个要运行的进程将需要更长的时间。

![Linux 调度器管理进程的视图](img/o1queue.svg)图 6.4.1 O(1) 调度器

与之相反，O(1) 调度器使用上面所示的一种运行队列结构。运行队列按优先级顺序包含若干个 *桶*，以及一个位图来标记哪些桶中有可用的进程。找到下一个要运行的进程，就是读取位图以找到第一个包含进程的桶，然后从该桶的队列中选取第一个进程。调度器维护两个这样的结构，一个是 *活动* 数组，用于可运行的进程；另一个是 *过期* 数组，用于已经使用完其整个时间片的进程。当所有进程都获得了一些 CPU 时间后，可以通过简单地修改指针来交换这些结构。

然而，真正有趣的部分是它如何决定进程在运行队列中的位置。需要考虑的一些因素包括优先级、处理器亲和性（将进程与其运行的处理器绑定在一起，因为在 SMP 系统中将进程移动到另一个 CPU 可能是一个昂贵的操作）以及更好地识别交互式程序（例如 GUI 应用程序，这些程序可能花费大量时间休眠，等待用户输入，但当用户 *确实* 与其交互时，希望得到快速响应）。

</main>

<main class="calibre3">

## 7 Shell

在 UNIX 系统中，shell 是处理系统上进程的标准接口。一旦 shell 成为主要的接口，尽管现代 Linux 系统提供了 GUI 并通过 "终端应用程序" 或类似的方式提供 shell，但 shell 的主要任务仍然是帮助用户处理启动、停止以及控制系统中运行的进程。

当你在 shell 提示符下输入一个命令时，它将 `fork` 出一个自身的副本并 `exec` 执行你指定的命令。

因此，shell 默认会等待该进程运行完成，然后返回到提示符以重新开始整个过程。

作为一种增强，shell 还允许你将作业 *后台运行*，通常是在命令名称后放置一个 `&`。这只是一个信号，表明 shell 应该 `fork` 并执行命令，但在显示提示符之前不需要等待命令完成。

新的过程在后台运行，shell 已经准备好，等待您启动一个新的进程。您通常可以指示 shell 将进程 *前台化*，这意味着我们确实希望等待其完成。

XXX：关于 bourne shell 的一些历史

</main>

<main class="calibre3">

## 8 信号

系统中运行的进程需要一种方式来告知它们受影响的事件。在 UNIX 中，内核和进程之间有一种称为 *信号* 的基础设施，它允许进程接收与其重要事件相关的通知。

当向进程发送信号时，内核调用一个 *处理程序*，进程必须将其注册到内核以处理该信号。处理程序只是代码中设计用来专门处理中断的函数。通常，信号会从内核内部发送，然而，一个进程向另一个进程发送信号（一种 *进程间通信* 的形式）也是很常见的。信号处理程序是 *异步调用* 的；也就是说，当前运行的程序会中断其正在执行的操作来处理信号事件。

例如，一种信号类型是 *中断*（在系统头文件中定义为 `SIGINT`），当按下 `ctrl-c` 组合键时，它被发送到进程。

当一个进程使用 `read` 系统调用来从键盘读取输入时，内核会监视输入流，寻找特殊字符。如果它看到 `ctrl-c`，它将进入信号处理模式。内核会检查进程是否为这个中断注册了处理程序。如果有，则执行将传递到那个函数，该函数将 *处理* 它。如果进程没有为这个特定的信号注册处理程序，那么内核将采取一些默认操作。对于 `ctrl-c`，默认操作是终止进程。

一个进程可以选择忽略一些信号，但其他信号不允许被忽略。例如，`SIGKILL` 是当进程应该被终止时发送的信号。内核会看到进程已经收到了这个信号，并终止进程的运行，无需询问。进程不能请求内核忽略这个信号，内核非常小心地处理哪些进程被允许向其他进程发送这个信号；除非你是 root 用户，否则你只能向属于你的进程发送。你可能见过命令 `kill -9`；这来自于 `SIGKILL` 信号的实现。众所周知，`SIGKILL` 实际上定义为 `0x9`，因此当作为 `kill` 程序的参数指定时，意味着指定的进程将被立即停止。由于进程不能选择忽略或处理这个信号，它被视为最后的手段，因为程序将没有机会清理或干净地退出。通常认为，首先向进程发送一个 `SIGTERM`（用于终止），如果它崩溃或无法退出，再求助于 `SIGKILL` 是更好的做法。按照惯例，大多数程序都会安装一个处理 `SIGHUP`（挂起——来自串行终端和调制解调器时代的遗留问题）的处理程序，该处理程序将重新加载程序，可能是为了获取配置文件或类似文件的更改。

如果你曾在 Unix 系统上编程，当你尝试读取或写入未分配给你的内存时，你会熟悉 `segmentation faults`。当内核注意到你在访问你分配之外的内存时，它会向你发送分段错误信号。通常，进程不会安装处理这个信号的处理程序，因此默认的操作是终止程序（这就是你的程序“崩溃”的原因）。在某些情况下，程序可能会安装一个处理分段错误的处理程序，尽管这样做的原因有限。

这引发了信号接收后的情况。一旦信号处理程序运行完成，控制权返回到进程，它从上次离开的地方继续执行。

### 8.1 示例

以下简单的程序引入了许多信号来运行！

```cpp
 1 |$ cat signal.c 
 |#include <stdio.h> 
 |#include <unistd.h> 
 |#include <signal.h> 
 5 |
 |void sigint_handler(int signum) 
 |{ 
 | printf("got SIGINT\n"); 
 |} 
10 |
 |int main(void) 
 |{ 
 | signal(SIGINT, sigint_handler); 
 | printf("pid is %d\n", getpid()); 
15 | while (1) 
 | sleep(1); 
 |} 
 |$ gcc -Wall -o signal signal.c 
 |$ ./signal 
20 |pid is 2859 
 |got SIGINT # press ctrl-c` 
 | # press ctrl-z 
 |`[1]+  Stopped                 ./signal 
 |
25 |$ kill -SIGINT 2859 
 |$ fg 
 |./signal 
 |got SIGINT 
 |Quit # press ctrl-\ 
30 |
 |`<main class="calibre3"

```

示例 8.1.1 信号示例

我们有一个简单的程序，它简单地定义了一个处理 `SIGINT` 信号的处理程序，该信号是在用户按下 `ctrl-c` 时发送的。系统中所有的信号都在 `signal.h` 中定义，包括 `signal` 函数，它允许我们注册处理函数。

程序简单地坐在一个紧密的循环中什么也不做，直到它退出。当我们启动程序时，我们尝试按 `ctrl-c` 来使其退出。而不是采取默认操作，处理程序被调用，我们得到了预期的输出。

然后，我们按 `ctrl-z` 发送一个 `SIGSTOP` 信号，默认情况下将进程置于休眠状态。这意味着它不会被放入调度器的队列中运行，因此在系统中是休眠的。

为了说明这一点，我们使用`kill`程序从另一个终端窗口发送相同的信号。这实际上是通过`kill`系统调用来实现的，它接受一个信号和一个 PID 来发送（这个函数的名字有点误导，因为并非所有信号实际上都会杀死进程，正如我们所看到的，但`signal`函数已经被用来注册处理程序）。由于进程被停止，信号被*排队*等待处理。这意味着内核会注意这个信号，并在适当的时候传递它。

在这一点上，我们通过使用命令`fg`唤醒进程。这实际上向进程发送了一个`SIGCONT`信号，默认情况下这将唤醒进程。内核知道将进程放入运行队列，并再次给它分配 CPU 时间。我们在这个时候看到队列中的信号被传递。

在绝望地想要摆脱程序的情况下，我们最终尝试使用`ctrl-\`发送一个`SIGQUIT`（中止）信号到进程。但如果进程已经中止，`Quit`输出是从哪里来的呢？

你猜对了，还有更多的信号！当一个父进程的子进程死亡时，它会收到一个`SIGCHLD`信号。在这种情况下，shell 是父进程，因此它接收到了这个信号。还记得我们如何使用`wait`调用回收僵尸进程，并从子进程获取返回码吗？嗯，它还提供给父进程的是子进程可能死亡的原因的信号编号。因此，shell 知道子进程是因为`SIGABRT`而死亡的，并且作为信息服务，它会向用户打印出尽可能多的信息（当子进程因为`SIGSEGV`而死亡时，这个进程也会打印出“Segmentation Fault”）。

你可以看到，即使在简单的程序中，也有大约 5 种不同的信号被用来在进程和内核之间进行通信，并保持程序的运行。还有很多其他的信号，但这些都无疑是其中最常见的一些。大多数信号都有内核定义的系统功能，但也有一些信号是为用户保留的，用户可以在自己的程序中用于自己的目的（`SIGUSR`）。

</main>
