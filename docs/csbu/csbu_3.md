<main class="calibre3">

## 第四章. 操作系统

</main>

<main class="calibre3">

## 1 操作系统的角色

操作系统支撑着现代计算机的整个运行。

### 1.1 硬件抽象

操作系统（OS）的基本操作是将硬件抽象给程序员和用户。操作系统提供了通用的接口，用于访问底层硬件提供的服务。

在没有操作系统的世界里，每个程序员都需要了解底层硬件的最亲密细节才能让任何东西运行。更糟糕的是，即使硬件只有细微的差异，他们的程序也无法在其他硬件上运行。

### 1.2 多任务处理

我们期望现代计算机同时做很多事情，我们需要一种方式来仲裁系统上运行的所有不同程序。这是操作系统的任务，使其无缝发生。

操作系统负责系统内的**资源管理**。当系统运行时，许多任务将竞争系统的资源，包括处理器时间、内存、磁盘和用户输入。操作系统的任务是仲裁这些资源分配给多个任务，并允许它们有序地访问。你可能经历过这种**失败**的情况，因为它通常会导致你的电脑崩溃（例如著名的“蓝屏死机”）。

### 1.3 标准化接口

程序员希望编写可以在尽可能多的不同硬件平台上运行的程序。通过操作系统对标准化接口的支持，程序员可以获得这种功能。

例如，如果一个系统上打开文件的函数是`open()`，另一个是`open_file()`，还有另一个是`openf()`，程序员将面临双重问题：必须记住每个系统做了什么，而且他们的程序在多个系统上无法工作。

可移植操作系统接口（POSIX）

X 来自*Unix*，标准就是从 Unix 发展而来的。今天，POSIX 与单一 UNIX 规范版本 3 或 ISO/IEC 9945:2002 相同。这是一个免费标准，可在网上获取。

从前，单一 UNIX 规范和 POSIX 标准是分开的实体。单一 UNIX 规范由一个名为“开放集团”的财团发布，并且根据他们的要求免费提供。最新版本是单一 UNIX 规范版本 3。

IEEE POSIX 标准作为 IEEE Std 1003.[插入各种年份、修订版本]，并且并非免费提供。最新版本是 IEEE 1003.1-2001，等同于单一 UNIX 规范版本 3。

因此，这两个单独的标准最终合并成了所谓的单一 UNIX 规范版本 3，该规范也被 ISO 在 ISO/IEC 9945:2002 下标准化。这发生在 2002 年初。所以当人们谈论 POSIX、SUS3 或 ISO/IEC 9945:2002 时，它们都指同一件事！

是 UNIX 类型操作系统实现的一个非常重要的标准。Microsoft Windows 有类似的自有标准。

### 1.4 安全性

在多用户系统中，安全性非常重要。作为系统访问的仲裁者，操作系统负责确保只有那些拥有正确权限的人才能访问资源。

例如，如果一个文件属于一个用户，另一个用户不应被允许打开和读取它。然而，也需要有机制在用户想要共享该文件时安全地将其共享。

操作系统是大型且复杂的程序，并且通常会发现安全问题。通常，病毒或蠕虫会利用这些漏洞来访问它不应被允许访问的资源，例如您的文件或网络连接；为了对抗它们，您必须安装操作系统供应商提供的*补丁*或更新。

### 1.5 性能

由于操作系统为计算机提供了如此多的服务，其性能至关重要。操作系统的许多部分运行频率极高，因此即使是仅仅几个处理器的周期开销也可能导致整体系统性能的大幅下降。

操作系统需要利用底层硬件的功能，以确保它为操作获得最佳性能，因此系统程序员需要了解他们正在构建的架构的密切细节。

在许多情况下，系统程序员的职责是决定系统的策略。通常情况下，使操作系统的一部分运行更快可能会使另一部分运行得更慢或效率更低。系统程序员在构建他们的操作系统时需要理解所有这些权衡。

</main>

<main class="calibre3">

## 2 操作系统组织

操作系统的组织结构大致如图下所示。

![内核](img/kernel.svg)

内核的组织结构。内核正在运行的进程在*用户空间*中，内核直接与硬件通信，并通过*驱动程序*进行通信。

图 2.1 操作系统

### 2.1 内核

内核*是*操作系统。如图所示，内核直接与硬件通信，并通过*驱动程序*进行通信。

正如内核将硬件抽象化以供用户程序使用一样，驱动程序将硬件抽象化以供内核使用。例如，有各种不同类型的显卡，每种显卡都有略微不同的功能。只要内核导出 API，能够访问硬件规格的人就可以编写驱动程序来实现该 API。这样，内核就可以访问许多不同类型的硬件。

内核通常是我们所说的**特权**。正如你将学到的，硬件在运行多个任务和保持系统安全方面发挥着重要作用，但这些规则并不适用于内核。我们知道内核必须处理崩溃的程序（记住，操作系统的工作是仲裁同一系统上运行的多个程序，并且不能保证它们的行为），但如果操作系统的任何内部部分崩溃，整个系统可能变得毫无用处。同样，安全问题也可能被用户进程利用，将自己提升到内核的特权级别；到那时，它们可以完全不受检查地访问系统的任何部分。

#### 2.1.1 单一内核与微内核

围绕操作系统的一个经常出现的辩论是内核应该是**微内核**还是**单一内核**。

单一内核方法是最常见的，如大多数常见的 Unix 系统（如 Linux）所采用。在这个模型中，核心特权内核很大，包含硬件驱动程序、文件系统访问控制、权限检查以及如网络文件系统（NFS）等服务。

由于内核始终是特权的，如果它的任何部分崩溃，整个系统有可能停止运行。如果一个驱动程序有错误，它可以毫无问题地覆盖系统中的任何内存，最终导致系统崩溃。

微内核架构试图通过尽可能缩小内核的特权部分来最小化这种可能性。这意味着大多数系统作为非特权程序运行，限制了任何崩溃组件可能造成的损害。例如，硬件驱动程序可以在单独的进程中运行，所以如果一个走偏了，它就不能覆盖分配给它的任何内存。

虽然这听起来是最明显的主意，但问题又回到了两个主要问题上。

1.  性能会降低。在许多不同的组件之间进行通信会降低性能。

1.  对于程序员来说，这稍微有些困难。

这两种批评都源于为了保持组件之间的分离，大多数微内核都是基于**消息传递**的系统实现的，通常被称为**进程间通信**或 IPC。各个组件之间的通信是通过离散的消息进行的，这些消息必须打包，发送到另一个组件，解包，操作，重新打包并发送回去，然后再解包以获取结果。

这对于来自外部组件的简单请求来说是一大堆步骤。显然，一个请求可能会使另一个组件对更多组件进行更多请求，问题会成倍增加。慢消息传递实现在很大程度上是早期微内核系统性能不佳的原因，传递消息的概念对于程序员来说编程稍微困难一些。组件分别运行的增强保护在早期微内核系统中不足以克服这些障碍，因此它们已经不再流行。

在单核内核中，组件之间的调用是简单的函数调用，因为所有程序员都熟悉这种方式。

关于哪种组织方式最好，并没有一个确定的答案，它已经在学术界和非学术界引发了众多争论。希望随着你对操作系统的了解越来越多，你将能够形成自己的观点！

##### 2.1.1.1 模块

Linux 内核实现了一个模块系统，其中驱动程序可以在需要时“即时”加载到正在运行的内核中。这很好，因为驱动程序构成了操作系统代码的大部分，但不会为系统中不存在的设备加载。那些想要创建尽可能通用的内核的人（即，在许多不同的硬件上运行，如 RedHat 或 Debian）可以将大多数驱动程序作为模块包含在内，这些模块只有在系统上运行的硬件可用时才会加载。

然而，模块是直接加载到特权内核中，并且与内核的其他部分处于相同的权限级别，因此系统仍然被视为一个单核内核。

#### 2.1.2 虚拟化

与内核紧密相关的是硬件虚拟化的概念。现代计算机非常强大，通常将其视为一个整体系统并不总是有用的，而是将单个物理计算机分割成多个“虚拟”机器。从所有意图和目的来看，这些虚拟机看起来都是一个完全独立的机器，尽管它们在物理上都在同一个盒子里，同一个地方。

<picture>![](img/virtual.svg)</picture>

一些不同的虚拟化方法。

图 2.1.2.1 操作系统

这可以通过许多不同的方式来组织。在 simplest case，一个小的 *虚拟机监控器* 可以直接在硬件上运行，并为运行在其上的客户操作系统提供一个接口。这个 VMM 通常被称为 hypervisor（来自“supervisor”一词）。实际上，hypervisor 与微内核有很多共同之处；两者都力求成为小的层，以安全的方式向其上层的层提供硬件。实际上，上层的操作系统可能根本不知道 hypervisor 是否存在，因为 hypervisor 展示的是一个看似完整的系统。它拦截客户操作系统和硬件之间的操作，并且只向每个操作系统呈现系统资源的一个子集。

这通常用于大型机器（具有许多 CPU 和大量 RAM）以实现*分区*。这意味着机器可以被分割成更小的虚拟机。通常，可以根据需求动态分配更多资源给正在运行的系统。许多大型 IBM 机器上的虚拟机管理程序实际上相当复杂，拥有数百万行代码。它提供了多种系统管理服务。

另一个选项是操作系统意识到底层虚拟机管理程序，并通过它请求系统资源。由于其折衷性质，这有时被称为*半虚拟化*。这与早期版本的 Xen 系统的工作方式相似，是一种折衷方案。它希望提供更好的性能，因为操作系统在需要时明确从虚拟机管理程序请求系统资源，而不是虚拟机管理程序必须动态解决问题。

最后，你可能遇到的情况是，在现有操作系统之上运行的应用程序提供了一个虚拟化系统（包括 CPU、内存、BIOS、磁盘等），普通操作系统可以在其上运行。该应用程序通过现有操作系统将请求转换为硬件，通过底层硬件。这与 VMWare 的工作方式相似。这种方法有很多开销，因为应用程序进程必须模拟整个系统并将所有内容转换为底层操作系统的请求。然而，这让你可以模拟一个完全不同的架构，因为你可以动态地将指令从一种处理器类型转换为另一种（就像 Rosetta 系统在苹果软件从 PowerPC 处理器迁移到基于 Intel 的处理器时所做的那样）。

在使用这些虚拟化技术时，性能是一个主要关注点，因为曾经直接在硬件上快速执行的操作现在需要通过抽象层层层传递。

英特尔讨论了在最新处理器中即将推出的虚拟化硬件支持。这些扩展通过为可能需要虚拟机监控器干预的操作引发特殊异常来实现。因此，处理器对在其上运行的应用程序来说看起来与非虚拟化处理器相同，但当该应用程序请求可能与其他虚拟操作系统共享的资源时，虚拟机监控器可以被调用。

这提供了优越的性能，因为虚拟机监控器不需要监控每个操作以查看其是否安全，而可以等待处理器通知发生*不安全*的情况。

##### 2.1.2.1 隐蔽通道

这是一个离题的话题，但与虚拟化机器相关的有趣安全漏洞。如果系统的分区不是静态的，而是*动态的*，那么就存在潜在的安全问题。

在一个动态系统中，资源根据需要分配给运行在其上的操作系统。因此，如果一个正在进行特别密集的 CPU 操作，而另一个正在等待从磁盘来的数据，那么更多的 CPU 功率将分配给第一个任务。在一个静态系统中，每个都会得到 50%，未使用的部分将浪费掉。

动态分配实际上在两个操作系统之间打开了一个通信通道。任何可以表示两种状态的地方都足以进行二进制通信。想象一下，两个系统都非常安全，而且不应该有任何信息能够在它们之间传递，永远不应该。两个有权访问的人可以通过编写两个尝试同时占用大量资源的程序来串通彼此传递信息。

当占用大量内存时，其他可用的内存就减少了。如果两者都跟踪最大分配量，就可以传递一些信息。比如说，他们达成协议，每隔一秒检查一次是否可以分配这么大的内存。如果目标可以，那么这被认为是二进制 0，如果它不能（另一台机器已经占用了所有内存），那么这被认为是二进制 1。每秒一个比特的数据速率并不令人惊讶，但信息正在流动。

这被称为*隐蔽通道*，虽然承认有些牵强，但确实有通过这种机制造成安全漏洞的例子。这仅仅表明，系统程序员的生涯永远不是简单的！

### 2.2 用户空间

我们称用户通过用户空间运行程序的理论位置为*用户空间*。每个程序都在用户空间运行，通过*系统调用*（下面将讨论）与内核通信。

如前所述，用户空间是*非特权*的。用户程序只能做有限范围内的事情，而且永远不应该能够崩溃其他程序，即使它们自己崩溃。

</main>

<main class="calibre3">

## 3 系统调用

### 3.1 概述

系统调用是用户空间程序与内核交互的方式。它们工作背后的基本原则如下所述。

#### 3.1.1 系统调用号

每一个系统调用都有一个*系统调用号*，这个号是用户空间和内核都知道的。例如，两者都知道系统调用号 10 是`open()`，系统调用号 11 是`read()`，等等。

*应用程序二进制接口*（ABI）与 API 非常相似，但它是为硬件而不是软件设计的。API 将定义系统调用号应该放在哪个寄存器中，以便内核在请求执行系统调用时能够找到它。

#### 3.1.2 参数

系统调用没有参数是不行的；例如`open()`需要告诉内核确切地*打开*什么文件。再次强调，ABI 将定义应该将参数放入哪个寄存器以供系统调用使用。

#### 3.1.3 中断

要实际执行系统调用，需要有一种方式与内核通信，表明我们想要进行系统调用。所有架构都定义了一个指令，通常称为`break`或类似名称，它向硬件发出信号，表明我们想要进行系统调用。

具体来说，这条指令会告诉硬件修改指令指针，使其指向内核的系统调用处理程序（当操作系统设置自身时，它会告诉硬件其系统调用处理程序的位置）。因此，一旦用户空间调用中断指令，它就失去了对程序的掌控，并将其传递给了内核。

其余的操作相当直接。内核会在预定义的寄存器中查找系统调用号，并在表中查找它应该调用的函数。这个函数被调用，执行它需要执行的操作，并将它的返回值放入由 ABI 定义的另一个寄存器中，作为返回寄存器。

最后一步是内核跳转回用户空间程序，以便它可以从上次离开的地方继续执行。用户空间程序从返回寄存器中获取所需的数据，并继续愉快地前进！

虽然进程的细节可能会变得相当复杂，但系统调用基本上就是如此。

#### 3.1.4 libc

尽管你可以为每个系统调用手动完成所有这些操作，但系统库通常为你完成大部分工作。处理 UNIX-like 系统上系统调用的标准库是`libc`；我们将在未来的几周中了解更多关于其角色的信息。

### 3.2 分析系统调用

由于系统库通常负责为你处理系统调用，我们需要进行一些低级黑客行为来展示系统调用是如何工作的。

我们将展示最简单的系统调用之一，`getpid()`，是如何工作的。这个调用不接受任何参数，并返回当前运行程序的 ID（或进程；我们将在接下来的几周中更详细地探讨进程）。

```cpp
 1 |#include <stdio.h> 
 |
 |/* for syscall() */ 
 |#include <sys/syscall.h> 
 5 |#include <unistd.h> 
 |
 |/* system call numbers */ 
 |#include <asm/unistd.h> 
 |
10 |void function(void) 
 |{ 
 | int pid; 
 |
 | pid = __syscall(__NR_getpid); 
15 |} 

```

示例 3.2.1 getpid()示例

我们首先编写一个小型的 C 程序，以此来开始展示系统调用背后的机制。首先要注意的是，系统库提供了一个名为`syscall`的参数，用于直接进行系统调用。这为程序员提供了一个简单的方法，可以直接进行系统调用，而无需了解在他们的硬件上执行调用所需的精确汇编语言例程。那么我们为什么要使用`getpid()`呢？首先，在代码中使用符号函数名更清晰。然而，更重要的是，`getpid()`在不同的系统上可能以非常不同的方式工作。例如，在 Linux 上，`getpid()`调用可以被缓存，所以如果它运行两次，系统库将不会再次承受整个系统调用的惩罚，以找到相同的信息。

根据 Linux 的惯例，系统调用号在内核源代码的 `asm/unistd.h` 文件中定义。由于位于 `asm` 子目录下，每个 Linux 运行的架构都有所不同。再次根据惯例，系统调用号被赋予一个由 `__NR_` 组成的 `#define` 名称。因此，你可以看到我们的代码将执行 `getpid` 系统调用，并将值存储在 `pid` 中。

我们将查看几种架构在底层如何实现这段代码。我们将查看真实代码，所以事情可能会变得相当复杂。但请坚持下去——这正是你的系统是如何工作的！

#### 3.2.1 PowerPC

PowerPC 是一种 RISC 架构，常见于较老的苹果电脑，以及最新版本的 Xbox 等设备的内核。

```cpp
 1 |
 |/* On powerpc a system call basically clobbers the same registers like a 
 | * function call, with the exception of LR (which is needed for the 
 | * "sc; bnslr" sequence) and CR (where only CR0.SO is clobbered to signal 
 5 | * an error return status). 
 | */ 
 |
 |#define __syscall_nr(nr, type, name, args...)				\ 
 | unsigned long __sc_ret, __sc_err;				\ 
10 | {								\ 
 | register unsigned long __sc_0  __asm__ ("r0");		\ 
 | register unsigned long __sc_3  __asm__ ("r3");		\ 
 | register unsigned long __sc_4  __asm__ ("r4");		\ 
 | register unsigned long __sc_5  __asm__ ("r5");		\ 
15 | register unsigned long __sc_6  __asm__ ("r6");		\ 
 | register unsigned long __sc_7  __asm__ ("r7");		\ 
 | \ 
 | __sc_loadargs_##nr(name, args);				\ 
 | __asm__ __volatile__					\ 
20 | ("sc           \n\t"				\ 
 | "mfcr %0      "				\ 
 | : "=&r" (__sc_0),				\ 
 | "=&r" (__sc_3),  "=&r" (__sc_4),		\ 
 | "=&r" (__sc_5),  "=&r" (__sc_6),		\ 
25 | "=&r" (__sc_7)				\ 
 | : __sc_asm_input_##nr				\ 
 | : "cr0", "ctr", "memory",			\ 
 | "r8", "r9", "r10","r11", "r12");		\ 
 | __sc_ret = __sc_3;					\ 
30 | __sc_err = __sc_0;					\ 
 | }								\ 
 | if (__sc_err & 0x10000000)					\ 
 | {								\ 
 | errno = __sc_ret;					\ 
35 | __sc_ret = -1;						\ 
 | }								\ 
 | return (type) __sc_ret 
 |
 |#define __sc_loadargs_0(name, dummy...)					\ 
40 | __sc_0 = __NR_##name 
 |#define __sc_loadargs_1(name, arg1)					\ 
 | __sc_loadargs_0(name);						\ 
 | __sc_3 = (unsigned long) (arg1) 
 |#define __sc_loadargs_2(name, arg1, arg2)				\ 
45 | __sc_loadargs_1(name, arg1);					\ 
 | __sc_4 = (unsigned long) (arg2) 
 |#define __sc_loadargs_3(name, arg1, arg2, arg3)				\ 
 | __sc_loadargs_2(name, arg1, arg2);				\ 
 | __sc_5 = (unsigned long) (arg3) 
50 |#define __sc_loadargs_4(name, arg1, arg2, arg3, arg4)			\ 
 | __sc_loadargs_3(name, arg1, arg2, arg3);			\ 
 | __sc_6 = (unsigned long) (arg4) 
 |#define __sc_loadargs_5(name, arg1, arg2, arg3, arg4, arg5)		\ 
 | __sc_loadargs_4(name, arg1, arg2, arg3, arg4);			\ 
55 | __sc_7 = (unsigned long) (arg5) 
 |
 |#define __sc_asm_input_0 "0" (__sc_0) 
 |#define __sc_asm_input_1 __sc_asm_input_0, "1" (__sc_3) 
 |#define __sc_asm_input_2 __sc_asm_input_1, "2" (__sc_4) 
60 |#define __sc_asm_input_3 __sc_asm_input_2, "3" (__sc_5) 
 |#define __sc_asm_input_4 __sc_asm_input_3, "4" (__sc_6) 
 |#define __sc_asm_input_5 __sc_asm_input_4, "5" (__sc_7) 
 |
 |#define _syscall0(type,name)						\ 
65 |type name(void)								\ 
 |{									\ 
 | __syscall_nr(0, type, name);					\ 
 |} 
 |
70 |#define _syscall1(type,name,type1,arg1)					\ 
 |type name(type1 arg1)							\ 
 |{									\ 
 | __syscall_nr(1, type, name, arg1);				\ 
 |} 
75 |
 |#define _syscall2(type,name,type1,arg1,type2,arg2)			\ 
 |type name(type1 arg1, type2 arg2)					\ 
 |{									\ 
 | __syscall_nr(2, type, name, arg1, arg2);			\ 
80 |} 
 |
 |#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\ 
 |type name(type1 arg1, type2 arg2, type3 arg3)				\ 
 |{									\ 
85 | __syscall_nr(3, type, name, arg1, arg2, arg3);			\ 
 |} 
 |
 |#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \ 
 |type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4)		\ 
90 |{									\ 
 | __syscall_nr(4, type, name, arg1, arg2, arg3, arg4);		\ 
 |} 
 |
 |#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5) \ 
95 |type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5)	\ 
 |{									\ 
 | __syscall_nr(5, type, name, arg1, arg2, arg3, arg4, arg5);	\ 
 |} 

```

示例 3.2.1.1 PowerPC 系统调用示例

这个来自内核头文件 `asm/unistd.h` 的代码片段展示了我们如何在 PowerPC 上实现系统调用。它看起来非常复杂，但可以一步一步地分解。

首先，跳转到定义 `_syscallN` 宏的示例末尾。你可以看到有很多宏，每个宏都逐渐多一个参数。我们将从最简单的版本 `_syscall0` 开始。它只接受两个参数，系统调用的返回类型（例如 C 语言的 `int` 或 `char` 等）和系统调用的名称。对于 `getpid`，这将是通过 `_syscall0(int,getpid)` 来实现的。

到目前为止都很简单！我们现在必须开始分解 `__syscall_nr` 宏。这与我们之前的位置不太一样，我们取参数的数量作为第一个参数，类型、名称，然后是实际的参数。

第一步是声明一些寄存器的名称。这本质上就是声明 `__sc_0` 指的是 `r0`（即寄存器 0）。编译器通常会按照自己的意愿使用寄存器，因此我们很重要的一点是要给它一些约束，这样它就不会决定以某种临时方式使用我们需要的寄存器。

然后我们用有趣的 `##` 参数调用 `sc_loadargs`。这只是一个 *粘贴* 命令，它会被 `nr` 变量替换。因此，对于我们的示例，它扩展为 `__sc_loadargs_0(name, args);`。下面我们可以看到 `__sc_loadargs` 将 `__sc_0` 设置为系统调用号；注意再次出现的粘贴操作符，以及我们之前提到的 `__NR_` 前缀和引用特定寄存器的变量名。

因此，所有这些看起来很棘手的代码实际上只是将系统调用号放入寄存器 0！跟随代码，我们可以看到其他宏会将系统调用参数放入 `r3` 到 `r7`（你的系统调用最多只能有 5 个参数）。

现在我们已经准备好处理 `__asm__` 部分。这里我们称之为 *内联汇编*，因为它是在源代码中混合了汇编代码。确切的语法在这里过于复杂，但我们可以指出重要的部分。

现在先忽略`__volatile__`部分；它是在告诉编译器这段代码是不可预测的，因此它不应该试图对它做任何聪明的事情。我们再次从结尾开始，逆向工作。冒号后面的所有内容都是一种方式，用来向编译器传达内联汇编对 CPU 寄存器所做的事情。编译器需要知道这一点，这样它就不会尝试以可能导致崩溃的方式使用这些寄存器。

但有趣的部分是第一个参数中的两个汇编语句。做所有工作的那个是`sc`调用。这就是你需要做的所有事情来执行你的系统调用！

当这个调用被调用时会发生什么？好吧，处理器被中断，知道将控制权转移到系统启动时设置的特定代码块，以处理中断。有许多中断；系统调用只是其中之一。然后这段代码会在寄存器 0 中查找系统调用号；然后查找表，找到跳转到以处理该系统调用的正确函数。这个函数在其寄存器 3-7 中接收其参数。

那么，系统调用处理程序运行并完成后会发生什么？控制权返回到`sc`之后的下一个指令，在这种情况下是一个*内存栅栏*指令。这个指令本质上说的是“确保一切都已经提交到内存”；还记得我们关于超标量架构中的流水线吗？这个指令确保我们认为已经写入内存的每一件事实际上都已经写入，并且没有在某个流水线中传递。

好吧，我们几乎完成了！剩下要做的就是从系统调用中返回值。我们看到`__sc_ret`是从 r3 设置的，而`__sc_err`是从 r0 设置的。这很有趣；这两个值究竟是什么意思？

一个是返回值，另一个是错误值。为什么我们需要两个变量？系统调用可能会失败，就像任何其他函数一样。问题是系统调用可以返回任何可能的值；我们不能说“负值表示失败”，因为对于某些特定的系统调用，负值可能是完全可接受的。

因此，我们的系统调用函数在返回之前，确保其结果在寄存器 r3 中，任何错误代码在寄存器 r0 中。我们检查错误代码以查看最高位是否被设置；这将表示一个负数。如果是这样，我们将全局`errno`值设置为它（这是获取调用失败错误信息的标准变量）并将返回值设置为`-1`。当然，如果收到有效结果，我们直接返回它。

因此，我们的调用函数应该检查返回值不是`-1`；如果是，它可以检查`errno`来找到调用失败的确切原因。

那就是一个在 PowerPC 上的整个系统调用！

#### 3.2.2 x86 系统调用

下面我们有与为 x86 处理器实现的相同接口。

```cpp
 1 |/* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */ 
 |
 |#define __syscall_return(type, res)				\ 
 |do {								\ 
 5 | if ((unsigned long)(res) >= (unsigned long)(-125)) {	\ 
 | errno = -(res);					\ 
 | res = -1;					\ 
 | }							\ 
 | return (type) (res);					\ 
10 |} while (0) 
 |
 |/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */ 
 |#define _syscall0(type,name)			\ 
 |type name(void)					\ 
15 |{						\ 
 |long __res;					\ 
 |__asm__ volatile ("int $0x80"			\ 
 | : "=a" (__res)				\ 
 | : "0" (__NR_##name));			\ 
20 |__syscall_return(type,__res); 
 |} 
 |
 |#define _syscall1(type,name,type1,arg1)			\ 
 |type name(type1 arg1)					\ 
25 |{							\ 
 |long __res;						\ 
 |__asm__ volatile ("int $0x80"				\ 
 | : "=a" (__res)					\ 
 | : "0" (__NR_##name),"b" ((long)(arg1)));	\ 
30 |__syscall_return(type,__res); 
 |} 
 |
 |#define _syscall2(type,name,type1,arg1,type2,arg2)			\ 
 |type name(type1 arg1,type2 arg2)					\ 
35 |{									\ 
 |long __res;								\ 
 |__asm__ volatile ("int $0x80"						\ 
 | : "=a" (__res)							\ 
 | : "0" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)));	\ 
40 |__syscall_return(type,__res); 
 |} 
 |
 |#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\ 
 |type name(type1 arg1,type2 arg2,type3 arg3)				\ 
45 |{									\ 
 |long __res;								\ 
 |__asm__ volatile ("int $0x80"						\ 
 | : "=a" (__res)							\ 
 | : "0" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)),	\ 
50 | "d" ((long)(arg3)));					\ 
 |__syscall_return(type,__res);						\ 
 |} 
 |
 |#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)	\ 
55 |type name (type1 arg1, type2 arg2, type3 arg3, type4 arg4)			\ 
 |{										\ 
 |long __res;									\ 
 |__asm__ volatile ("int $0x80"							\ 
 | : "=a" (__res)								\ 
60 | : "0" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)),		\ 
 | "d" ((long)(arg3)),"S" ((long)(arg4)));				\ 
 |__syscall_return(type,__res);							\ 
 |} 
 |
65 |#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,	\ 
 | type5,arg5)								\ 
 |type name (type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5)		\ 
 |{										\ 
 |long __res;									\ 
70 |__asm__ volatile ("int $0x80"							\ 
 | : "=a" (__res)								\ 
 | : "0" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)),		\ 
 | "d" ((long)(arg3)),"S" ((long)(arg4)),"D" ((long)(arg5)));		\ 
 |__syscall_return(type,__res);							\ 
75 |} 
 |
 |#define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,			\ 
 | type5,arg5,type6,arg6)								\ 
 |type name (type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5,type6 arg6)			\ 
80 |{												\ 
 |long __res;											\ 
 |__asm__ volatile ("push %%ebp ; movl %%eax,%%ebp ; movl %1,%%eax ; int $0x80 ; pop %%ebp"	\ 
 | : "=a" (__res)										\ 
 | : "i" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)),				\ 
85 | "d" ((long)(arg3)),"S" ((long)(arg4)),"D" ((long)(arg5)),				\ 
 | "0" ((long)(arg6)));									\ 
 |__syscall_return(type,__res);									\ 
 |} 

```

示例 3.2.2.1 x86 系统调用示例

x86 架构与我们之前所探讨的 PowerPC 架构非常不同。x86 被归类为 CISC 处理器，与 RISC 的 PowerPC 相比，它具有显著更少的寄存器。

首先，让我们看看最简单的 `_syscall0` 宏。它只是调用 `int` 指令，值为 `0x80`。这条指令使 CPU 引发中断 0x80，这将跳转到内核中处理系统调用的代码。

我们可以从检查如何使用较长的宏传递参数开始。注意 PowerPC 实现是如何向下级联宏的，每次添加一个参数。这种实现有稍微多一点复制的代码，但稍微容易一些。

x86 寄存器名称基于字母，而不是 PowerPC 的基于数字的寄存器名称。我们可以从零参数宏中看到，只有 `A` 寄存器被加载；从这个我们可以推断出系统调用号预期在 `EAX` 寄存器中。当我们开始在其他宏中加载寄存器时，你可以看到 `__asm__` 调用参数中的寄存器短名称。

在 `__syscall6` 中，我们看到一些更有趣的东西，这是一个接受 6 个参数的宏。注意 `push` 和 `pop` 指令吗？这些指令与 x86 上的栈一起工作，将值“推”到内存栈的顶部，并将值从栈中“弹出”到内存。因此，在拥有六个寄存器的情况下，我们需要将 `ebp` 寄存器的值存储在内存中，将我们的参数放入（使用 `mov` 指令），执行系统调用，然后将原始值恢复到 `ebp`。在这里，你可以看到没有足够寄存器的缺点；存储到内存是昂贵的，所以你能避免的越多越好。

另一件你可能注意到的事情是，没有像 PowerPC 中我们之前看到的 *内存栅栏* 指令。这是因为 x86 上所有指令的效果在完成时都将得到保证可见。这对编译器（和程序员）来说更容易编程，但提供了更少的灵活性。

剩下的唯一需要对比的是返回值。在 PowerPC 中，我们有两个寄存器用于从内核获取返回值，一个用于存储值，另一个用于存储错误代码。然而，在 x86 中，我们只有一个返回值，它被传递到 `__syscall_return`。这个宏将返回值转换为 `unsigned long` 并将其与一个（架构和内核相关的）可能表示错误代码的负值范围进行比较（注意，`errno` 的值是正的，所以内核的负结果会被取反）。然而，这意味着系统调用不能返回小的负值，因为它们与错误代码无法区分。一些有此要求的系统调用，如 `getpriority()`，会在它们的返回值上添加一个偏移量，以确保它始终为正；用户空间需要意识到这一点，并减去这个常数值以获得“真实”的值。

</main>

<main class="calibre3">

## 4 权限

### 4.1 硬件

我们提到操作系统的主要任务之一是实现安全性；也就是说，不允许一个应用程序或用户干扰系统中运行的任何其他应用程序。这意味着应用程序不应能够覆盖彼此的内存或文件，并且只能按照系统策略访问系统资源。

然而，当应用程序运行时，它对处理器有独占使用权。我们将在下一章中查看进程时了解这一点是如何工作的。确保应用程序只访问它拥有的内存是通过虚拟内存系统实现的，我们将在下一章中对其进行考察。基本点是硬件负责强制执行这些规则。

我们所考察的系统调用接口是应用程序获取系统资源的门户。通过强制应用程序通过系统调用向内核请求资源，内核可以强制执行有关可以提供何种访问的规则。例如，当应用程序执行`open()`系统调用以在磁盘上打开文件时，它将检查用户的权限与文件权限是否匹配，并允许或拒绝访问。

#### 4.1.1 权限级别

硬件保护通常可以看作是在一组核心操作周围的一系列同心环。

![图片](img/priv.svg)

x86 的权限级别

图 4.1.1.1 环

在最内层环中是受保护程度最高的指令；只有内核应该被允许调用的指令。例如，用于停止处理器的`HLT`指令不应允许用户应用程序运行，因为这会停止整个计算机的工作。然而，当计算机合法关闭时，内核需要能够调用这个指令。当“顽皮”的应用程序无论如何调用这个指令时会发生什么？硬件通常会引发异常，这涉及到跳转到操作系统中指定的处理程序，类似于系统调用处理程序。然后操作系统可能会终止程序，通常会给用户一些关于应用程序如何崩溃的错误信息。

每个内层环都可以访问由更外层环保护的任何指令，但不能访问由更内层环保护的指令。并非所有架构都具有如上所述的多级环，但大多数至少会提供“内核”和“用户”级别。

##### 4.1.1.1 386 保护模型

386 保护模型有四个环，尽管大多数操作系统（如 Linux 和 Windows）只使用其中的两个环以与其他架构保持兼容，这些架构现在不允许有如此多的离散保护级别。

386 通过为系统内运行的每一块应用程序代码创建一个小的描述符，称为*代码描述符*，来维护权限。该描述符描述了其权限级别，以及其他一些信息。当应用程序代码跳转到由其代码描述符描述的区域之外的其他代码时，会检查目标代码的权限级别。如果目标权限级别高于当前运行的代码，硬件将不允许跳转（并且应用程序将崩溃）。

##### 4.1.1.2 提升权限

应用程序只能通过允许其提升权限的特定调用来提升其权限级别，例如实现系统调用的指令。这些通常被称为*调用门*，因为它们的功能就像一个物理门；一个穿过其他方面不可穿透的墙的小入口。当调用该指令时，我们已经看到硬件如何完全停止运行的应用程序并将控制权交给内核。内核必须充当看门人；确保没有恶意的东西通过这个门。这意味着它必须仔细检查系统调用参数，以确保它不会陷入做不应该做的事情（如果可能的话，那将是一个安全漏洞）。由于内核在最内层环中运行，它有权执行任何它想要的操作；当它完成时，它将控制权返回给应用程序，应用程序将再次以较低的权限级别运行。

##### 4.1.1.3 快速系统调用

如上所述，陷阱的一个问题是它们对处理器来说非常昂贵。在可以切换上下文之前，有很多状态需要保存。现代处理器已经意识到这种开销，并努力减少它。

要理解上述的调用门机制，需要调查处理器使用的巧妙但复杂的分段方案。分段的原意是为了能够使用比寄存器中可用的 16 位更多的位来表示地址，如图 4.1.1.3.1，x86 分段寻址所示。

![图片](img/ia32-segmentation.svg)

分段通过将处理器地址空间划分为块来扩展处理器地址空间。处理器保留特殊的段寄存器，地址通过段寄存器和偏移量的组合来指定。将段寄存器的值加到偏移量部分，以找到最终的地址。

图 4.1.1.3.1 x86 分段寻址

当 x86 迁移到 32 位寄存器时，分段方案保持不变，但格式不同。而不是固定段大小，段可以是任何大小。这意味着处理器需要跟踪所有这些不同的段及其大小，它使用*描述符*来做到这一点。对所有人可用的段描述符保存在*全局描述符表*或简称 GDT 中。每个进程都有一些寄存器，它们指向 GDT 中的条目；这些是进程可以访问的段（还有*局部*描述符表，以及它与任务状态段的所有交互，但那不是现在的重要问题）。整体情况在图 4.1.1.3.2，x86 段中得到了说明。

![图片](img/ia32-segments.svg)

x86 段在实际操作中的表现。注意“远调用”是如何通过调用门传递的，该调用门将重定向到运行在较低环级别的代码段。唯一修改代码段选择器（隐式用于所有代码地址）的方法是通过调用机制。因此，调用门机制确保要选择新的段描述符，并可能更改保护级别，您必须通过已知的入口点进行转换。

图 4.1.1.3.2 x86 段

由于操作系统将段寄存器作为进程状态的一部分进行分配，处理器硬件知道当前运行进程可以访问哪些内存段，并且可以执行*保护*以确保进程不会触及它不应该触及的内容。如果它超出了范围，你会收到一个*段错误*，这是大多数程序员都熟悉的。

当运行代码需要调用位于*另一个*段的代码时，情况变得更加有趣。如第 4.1.1.1 节，386 保护模型所述，x86 使用*环*来实现这一点，其中环 0 是最高权限，环 3 是最低权限，内环可以访问外环，但反之则不行。

如第 4.1.1.2 节，提升权限所述，当环 3 代码想要跳转到环 0 代码时，它实际上是在修改其代码段选择器，使其指向不同的段。为了做到这一点，它必须使用一个特殊的*远调用*指令，硬件确保它通过调用门。运行进程没有其他方式来选择新的代码段描述符，因此处理器将在环 0 段中已知的偏移处开始执行代码，该段负责保持完整性（例如，不读取任意和可能恶意的代码并执行它。当然，恶意攻击者总是会寻找方法让您的代码执行您不希望它执行的操作！）。

这允许在段之间以及它们之间的权限之间存在整个层次结构。你可能已经注意到，跨段调用听起来就像系统调用。如果你曾经以标准方式查看过 Linux x86 汇编，那么执行系统调用的标准方法是 `int 0x80`，这会引发中断 `0x80`。中断会停止处理器并转到中断门，然后它的工作方式与调用门相同——它会改变特权级别并将你弹射到代码的另一个区域。

这种方案的问题在于它很**慢**。进行所有这些检查需要付出很多努力，并且需要保存许多寄存器以进入新代码。在返回的过程中，所有这些都需要被恢复。

在现代 x86 系统中，由于虚拟内存的存在，不再使用分段和四级环系统，这在第六章，虚拟内存中已充分讨论。分段切换真正发生的事情只是系统调用，这本质上是从模式 3（用户空间）切换到模式 0 并跳转到内核内部的系统调用处理程序代码。因此，处理器提供了额外的**快速系统调用**指令，称为 `sysenter`（以及 `sysexit` 以返回），通过消除远调用的通用性——即在任何环级别转换到任何段的可能性——并将调用限制为仅转换到特定段和偏移处的环 0 代码，从而在寄存器中存储，来加快整个过程，相对于 `int 0x80` 调用。

由于通用性已被大量已知信息所取代，整个过程可以加快，因此我们有了前面提到的**快速系统调用**。值得注意的是，当内核获得控制权时，状态不会被保留。内核必须小心不要破坏状态，但这同时也意味着它只需保存完成工作所需的最少状态，因此可以在这方面更加高效。这是一个非常 RISC 的哲学，并说明了 RISC 和 CISC 处理器之间的界限是如何模糊的。

关于如何在 Linux 内核中实现这一点的更多信息，请参阅第 8.1.1 节，内核库。

### 4.2 与内核的其他通信方式

#### 4.2.1 ioctl

关于 ioctl

### 4.3 文件系统

关于 proc、sysfs、debugfs 等

</main>
