<main class="calibre3">

## 第二章 二进制和数字表示

</main>

<main class="calibre3">

## 1 二进制——计算的基础

### 1.1 二进制理论

#### 1.1.1 简介

二进制是一种基数为 2 的数字系统，它使用两种互斥的状态来表示信息。一个二进制数由称为*比特*的元素组成，每个比特可以处于两种可能状态之一。通常，我们用数字`1`和`0`来表示它们。我们也谈论它们是真是假。从电的角度来看，这两种状态可能由高电压和低电压或某种形式的开关打开或关闭来表示。

我们构建二进制数的方式与我们构建传统十进制系统中的数的方式相同。然而，我们不是有一个个位、十位、百位（等等），而是有一个个位、二位、四位、八位，等等，如下所示。

表 1.1.1.1 二进制

| 2^(...) | 2⁶ | 2⁵ | 2⁴ | 2³ | 2² | 2¹ | 2⁰ |
| --- | --- | --- | --- | --- | --- | --- | --- |
| ... | 64 | 32 | 16 | 8 | 4 | 2 | 1 |

例如，要表示十进制中的数字 203，我们知道我们在个位上放置一个`3`，在十位上放置一个`0`，在百位上放置一个`2`。这在下表中的指数中得到了表达。

表 1.1.1.2 十进制中的 203

| 10² | 10¹ | 10⁰ |
| --- | --- | --- |
| 2 | 0 | 3 |

或者换句话说，2 × 10² + 3 × 10⁰ = 200 + 3 = 203。要在二进制中表示相同的内容，我们将有以下的表格。

表 1.1.1.3 2 进制的 203

| 2⁷ | 2⁶ | 2⁵ | 2⁴ | 2³ | 2² | 2¹ | 2⁰ |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 1 | 0 | 0 | 1 | 0 | 1 | 1 |

这等于 2⁷ + 2⁶ + 2³ + 2¹ + 2⁰ = 128 + 64 + 8 + 2 + 1 = 203。

#### 1.1.2 计算的基础

你可能想知道一个简单的数字是如何成为计算机能够做到所有这些奇妙事情的基础的。信不信由你，它确实是！你电脑中的处理器可以执行一系列复杂但最终有限的指令，如加法、乘法等。本质上，每个这样的指令都被分配了一个数字，这样整个程序（将这个加到那个上，乘以那个，除以这个等等）就可以用一个数字流来表示。例如，如果处理器知道操作`2`是加法，那么`252`可能意味着“将 5 和 2 相加并将结果存储在某处”。当然，现实情况要复杂得多（参见第三章，计算机架构），但简而言之，这就是计算机的工作原理。

在穿孔卡片的时代，人们可以通过观察卡片上的孔洞来直接看到构成程序流的 1 和 0。当然，这种存储方式很快演变为通过小磁粒的极性来存储（磁带、磁盘），并且发展到今天，我们可以在口袋里携带难以想象的大量数据。

将这些数字翻译成对人类有用的东西，这就是计算机之所以有用的原因。例如，屏幕由数百万个离散的*像素*组成，每个像素太小，人眼无法分辨，但组合起来可以形成一个完整的图像。通常每个像素都有一定的红色、绿色和蓝色成分，这些成分构成了其显示颜色。当然，这些值可以用数字表示，当然也可以用二进制表示！因此，任何图像都可以分解成数百万个单独的点，每个点由一个表示像素红色、绿色和蓝色值的*元组*表示。因此，给定一个这样的数字的长字符串，格式正确，你电脑中的视频硬件可以将这些数字转换为电信号，以打开和关闭单个像素，从而显示图像。

随着你的阅读继续，我们将从这个基本构建块构建整个现代计算环境；如果你愿意的话，就是从下往上！

#### 1.1.3 位和字节

如上所述，我们可以选择用数字来表示任何东西，这些数字可以转换为二进制并由计算机操作。例如，要表示所有字母表中的字母，我们需要至少有足够的不同组合来表示所有小写字母、大写字母、数字和标点符号，再加上一些额外的组合。加起来意味着我们可能需要大约 80 种不同的组合。

如果我们有两位，我们可以表示四种可能的唯一组合（`00 01 10 11`）。如果我们有三个位，我们可以表示 8 种不同的组合。一般来说，有`n`位，我们可以表示`2^n`种唯一组合。

8 位给我们`2⁸ = 256`种唯一表示，对于我们字母组合来说已经足够多了。我们称 8 位为一组*字节*。猜一下 C 语言中的`char`变量有多大？一个字节。

##### 1.1.3.1 ASCII

由于一个字节可以表示从 0 到 255 的任何值，任何人都可以任意地创建字符和数字之间的映射。例如，一个显卡制造商可能会决定`1`代表`A`，所以当发送值`1`到显卡时，它会在屏幕上显示大写字母`A`。一个打印机制造商可能出于某种奇怪的原因决定`1`代表小写字母`z`，这意味着需要复杂的转换才能显示和打印相同的内容。

为了避免这种情况发生，发明了*美国信息交换标准代码*或 ASCII。这是一个*7 位*代码，意味着有 2⁷或 128 个可用的代码。

代码的范围分为两大类；不可打印的和可打印的。可打印字符包括字母（大写和小写）、数字和标点符号。不可打印代码用于控制，例如实现回车、响铃终端或表示什么都没有的特殊`NULL`代码。

127 个独特的字符对于美式英语来说足够了，但当需要表示其他语言中常见的字符时，尤其是亚洲语言，它们可能拥有成千上万的独特字符，这就会变得非常受限。

为了缓解这个问题，现代系统正在从 ASCII 转向*Unicode*，它可以使用多达 4 字节来表示一个字符，从而提供*更多*的空间！

##### 1.1.3.2 奇偶校验

ASCII 仅是一个 7 位代码，字节中留有一个比特是空闲的。这可以用来实现*奇偶校验*，这是一种简单的错误检查形式。考虑一个使用穿孔卡片作为输入的计算机，其中孔代表 1，没有孔代表 0。任何不慎覆盖孔都会导致读取到错误值，从而引起未定义的行为。

奇偶校验允许对字节的比特进行简单检查，以确保它们被正确读取。我们可以通过使用额外的比特作为*奇偶校验位*来实现*奇偶校验*。

在奇偶校验中，如果 7 位信息中 1 的数量是奇数，则奇偶校验位被设置，否则不被设置。偶数奇偶校验正好相反；如果 1 的数量是偶数，则奇偶校验位被设置为 1。

以这种方式，单个比特的翻转将导致奇偶校验错误，这可以被检测到。

XXX 更多关于错误纠正的内容

##### 1.1.3.3 16 位、32 位和 64 位计算机

数字无法适应字节；希望你的美元银行余额需要比一个字节能容纳的范围更大！几乎所有通用架构至少都是*32 位*计算机。这意味着它们的内部寄存器宽度为 32 位（或 4 字节），并且操作通常在 32 位值上执行。我们将 4 字节称为*字*；这类似于语言中，字母（比特）组成句子中的单词，但在计算中每个单词都有相同的大小！C 语言中的`int`变量大小为 32 位。现代架构是 64 位，这使处理器处理的大小增加到 8 字节。

##### 1.1.3.4 千字节、兆字节和吉字节

计算机处理大量的字节；这就是它们如此强大的原因！我们需要一种方式来谈论大量字节，而一种自然的方式是使用“国际单位制”（SI）前缀，正如在大多数其他科学领域所使用的那样。例如，千字节指的是 10³或 1000 个单位，就像千克有 1000 克一样。

1000 是一个在十进制中很漂亮的整数，但在二进制中它是`1111101000`，这不是一个特别“漂亮”的数字。然而，1024（或 2¹⁰）是一个漂亮的数字——(`10000000000`——并且碰巧非常接近“千”的十进制意义值（1000 而不是 1024）。因此，1024 字节自然被称为千字节。下一个 SI 单位是“兆”对于`10⁶`，前缀以 10³的倍数向上继续（对应于在写大数时通常的每三位数字分组）。碰巧的是，`2²⁰`又接近 SI 基 10 的定义；1048576 与 1000000 相比。通过 10 的幂次增加 2 的基数单位在功能上仍然接近 SI 基 10 值，尽管每个增加的因子都稍微偏离了基 SI 意义。因此，SI 基 10 单位“足够接近”并且已成为基 2 值的常用单位。

表 1.1.3.4.1 与字节相关的 2 和 10 的基数因子

| 名称 | 2 的基数因子 | 字节 | 接近的十进制因子 | 十进制字节 |
| --- | --- | --- | --- | --- |
| 1 千字节 | 2¹⁰ | 1,024 | 10³ | 1,000 |
| 1 兆字节 | 2²⁰ | 1,048,576 | 10⁶ | 1,000,000 |
| 1 吉字节 | 2³⁰ | 1,073,741,824 | 10⁹ | 1,000,000,000 |
| 1 太字节 | 2⁴⁰ | 1,099,511,627,776 | 10¹² | 1,000,000,000,000 |
| 1 皮字节 | 2⁵⁰ | 1,125,899,906,842,624 | 10¹⁵ | 1,000,000,000,000,000 |
| 1 艾字节 | 2⁶⁰ | 1,152,921,504,606,846,976 | 10¹⁸ | 1,000,000,000,000,000,000 |

将 2 的基数因子记住作为快速关联比特数和“人类”大小之间关系的辅助工具非常有用。例如，我们可以快速计算出 32 位计算机可以寻址高达四千兆字节的内存，通过注意到`2³²`可以重新组合为`2^((2 + 30))`或`2² × 2³⁰`，这正好是`4 × 2³⁰`，其中我们知道`2³⁰`是千兆字节。64 位值可以类似地寻址高达 16 泽字节（`2⁴ × 2⁶⁰`）；你可能对计算出这个数字有多大感兴趣。为了了解这个数字有多大，如果你每秒增加一次，计算一下要数到`2⁶⁴`需要多长时间。

##### 1.1.3.5 千字节、兆字节和吉字节

除了二进制和十进制 SI 单位之间的混淆之外，容量通常以*比特*而不是字节来表示。通常这种情况发生在谈论网络或存储设备时；你可能已经注意到你的 ADSL 连接被描述为类似 1500 千比特/秒的东西。计算很简单；乘以 1000（对于千字节），除以 8 得到字节，然后乘以 1024 得到千字节（因此 1500 千比特/秒=183 千字节/秒）。

国际单位制标准化机构已经认可了这些双重用途，并指定了二进制使用的唯一前缀。根据标准，1024 字节是一个 `kibibyte`，简称 *kilo binary* 字节（缩写为 KiB）。其他前缀有类似的缩写（例如，Mebibyte，MiB）。传统上阻止使用这些术语，但您可能在某些文献中看到它们。

##### 1.1.3.6 转换

转换进制之间最简单的方法是使用计算机，毕竟这是它们的强项！然而，了解如何手动进行转换通常很有用。

在进制之间转换的最简单方法是 *重复除法*。转换时，反复将商除以基数，直到商为零，并记录每一步的余数。然后，将余数反向写出，从底部开始，每次都添加到右边。以下是一个例子；由于我们要转换为二进制，我们使用基数为 2。

表 1.1.3.6.1 将 203 转换为二进制

| 商 |  | 余数 |  |
| --- | --- | --- | --- |
| 203[10] ÷ 2 = | 101 | 1 |  |
| 101[10] ÷ 2 = | 50 | 1 | ↑ |
| 50[10] ÷ 2 = | 25 | 0 | ↑ |
| 25[10] ÷ 2 = | 12 | 1 | ↑ |
| 12[10] ÷ 2 = | 6 | 0 | ↑ |
| 6[10] ÷ 2 = | 3 | 0 | ↑ |
| 3[10] ÷ 2 = | 1 | 1 | ↑ |
| 1[10] ÷ 2 = | 0 | 1 | ↑ |

从底部开始读取并每次向右添加，得到 `11001011`，这是我们之前例子中看到的 203。

#### 1.1.4 布尔运算

乔治·布尔是一位数学家，他发现了一个被称为 *布尔代数* 的整个数学领域。虽然他在 19 世纪中叶做出了这些发现，但他的数学是所有计算机科学的基础。布尔代数是一个广泛的主题，我们在这里只介绍最基本的内容，以帮助您入门。

布尔运算简单地根据规则接受特定的输入并产生特定的输出。例如，最简单的布尔运算 `not` 简单地反转输入操作数的值。其他操作数通常接受两个输入，并产生单个输出。

计算机科学中使用的根本布尔运算很容易记住，下面列出。我们用 *真值表* 表示它们；它们简单地显示了所有可能的输入和输出。术语 *真* 简单地反映了二进制中的 `1`。

##### 1.1.4.1 非

通常用 `!` 表示，`not` 简单地反转值，所以 `0` 变为 `1`，`1` 变为 `0`

表 1.1.4.1.1 *非* 运算的真值表

| 输入 | 输出 |
| --- | --- |
| `1` | `0` |
| `0` | `1` |

##### 1.1.4.2 与

要记住与运算的工作方式，可以将其想象为“如果两个输入都为真，则结果为真”

表 1.1.4.2.1 *与* 运算的真值表

| 输入 1 | 输入 2 | 输出 |
| --- | --- | --- |
| `0` | `0` | `0` |
| `1` | `0` | `0` |
| `0` | `1` | `0` |
| `1` | `1` | `1` |

##### 1.1.4.3 或

要记住或运算的工作方式，可以将其想象为“如果任一输入或另一个输入为真，则结果为真”

表 1.1.4.3.1 *或* 运算的真值表

| 输入 1 | 输入 2 | 输出 |
| --- | --- | --- |
| `0` | `0` | `0` |
| `1` | `0` | `1` |
| `0` | `1` | `1` |
| `1` | `1` | `1` |

##### 1.1.4.4 异或（xor）

异或，写作 `xor`，是 `or` 的一个特殊情况，其中如果只有一个输入为真，输出才是真的。这个操作可以出人意料地做很多有趣的事情，但在内核中你不会看到很多。

表 1.1.4.4.1 *异或（xor）* 的真值表

| 输入 1 | 输入 2 | 输出 |
| --- | --- | --- |
| `0` | `0` | `0` |
| `1` | `0` | `1` |
| `0` | `1` | `1` |
| `1` | `1` | `0` |

#### 1.1.5 计算机如何使用布尔操作

信不信由你，本质上你计算机做的每一件事都回到了上述操作。例如，半加器是由布尔操作组成的一种电路，可以组合位（它被称为半加器，因为它不处理进位位）。将更多的半加器组合起来，你将开始构建可以组合长二进制数的东西。添加一些外部存储器，你就有了计算机。

在电子学中，布尔操作是通过由 *晶体管* 制成的 *门* 来实现的。这就是为什么你可能听说过晶体管数量和摩尔定律之类的事情。晶体管越多，门越多，你可以组合的东西就越多。为了创建现代计算机，需要大量的门和晶体管。一些最新的 Itanium 处理器大约有 4.6 亿个晶体管。

#### 1.1.6 在 C 语言中处理二进制

在 C 语言中，我们直接接口到上述所有操作。以下表格描述了运算符

表 1.1.6.1 C 语言中的布尔操作

| 操作 | C 语言中的用法 |
| --- | --- |
| `not` | `!` |
| `and` | `&` |
| `or` | `&#124;` |
| `xor` | `^` |

我们使用这些操作在变量上修改变量内的位。在我们看到这个例子之前，首先我们必须转向描述十六进制表示法。

### 1.2 十六进制

十六进制指的是十六进制数系统。我们在计算机科学中只使用它一个原因，那就是它使人类更容易思考二进制数。计算机只处理二进制，而十六进制只是我们人类试图与计算机一起工作的一个捷径。

所以为什么是十六进制呢？好吧，最自然的选择是十进制，因为我们习惯于从我们的日常数字系统中以十进制思考。但是十进制与二进制不兼容——为了在二进制中表示 10 个不同的元素，我们需要四个位。然而，四个位给了我们十六种可能的组合。所以我们可以选择一条非常棘手的道路，尝试在十进制和二进制之间转换，或者选择一条简单的道路，创建一个十六进制的数制——十六进制！

十六进制使用标准的十进制数，但增加了 `A B C D E F`，它们分别代表 `10 11 12 13 14 15`（注意：我们是从零开始的）。

传统上，任何以 `0x` 前缀的数字都将表示十六进制数。

如前所述，为了在二进制中表示 16 种不同的模式，我们需要正好四个比特。因此，每个十六进制数字正好代表四个比特。你应该将学习以下表格作为一项练习来记忆。

表 1.2.1 十六进制、二进制和十进制

| 十六进制 | 二进制 | 十进制 |
| --- | --- | --- |
| `0` | `0000` | `0` |
| `1` | `0001` | `1` |
| `2` | `0010` | `2` |
| `3` | `0011` | `3` |
| `4` | `0100` | `4` |
| `5` | `0101` | `5` |
| `6` | `0110` | `6` |
| `7` | `0111` | `7` |
| `8` | `1000` | `8` |
| `9` | `1001` | `9` |
| `A` | `1010` | `10` |
| `B` | `1011` | `11` |
| `C` | `1100` | `12` |
| `D` | `1101` | `13` |
| `E` | `1110` | `14` |
| `F` | `1111` | `15` |

当然，没有必要继续这种模式（比如说，将 G 分配给值 16），但 16 个值在人类记忆的不可预测性和计算机使用的比特数之间是一个很好的权衡（偶尔你也会看到基数为 8，例如在 UNIX 下的文件权限）。我们只是用更多的数字来表示更多的比特数。例如，一个 16 比特的变量可以表示为`0xAB12`，要找到它的二进制表示，只需将每个单独的数字转换，按照表格进行转换，并将它们全部连接起来（所以`0xAB12`最终成为 16 比特的二进制数`1010101100010010`）。我们可以使用相反的方法将二进制转换回十六进制。

我们也可以使用相同的重复除法方案来改变一个数的基数。例如，要找到十六进制的 203

表 1.2.2 将 203 转换为十六进制

| 商 |  | 余数 |  |
| --- | --- | --- | --- |
| 203[10] ÷ 16 = | 12 | 11 (0xB) |  |
| 12[10] ÷ 16 = | 0 | 12 (0xC) | ↑ |

因此，十六进制的 203 表示为`0xCB`。

### 1.3 实际应用

#### 1.3.1 二进制在代码中的应用

虽然二进制是每个计算机的底层语言，但实际上，即使不了解任何关于它的东西，也可以用高级语言编写计算机程序。然而，对于我们所感兴趣的底层代码，一些基本的二进制原则被反复使用。

#### 1.3.2 掩码和标志

##### 1.3.2.1 掩码

在低级代码中，尽可能保持你的结构和变量空间效率是很重要的。在某些情况下，这可能涉及到有效地将两个（通常相关的）变量打包到一个中。

记住每个比特代表两种状态，所以如果我们知道一个变量只有，比如说，16 种可能的状态，它可以由 4 比特表示（即 2⁴=16 个唯一值）。但是，C 语言中最小的类型是 8 比特（一个`char`），所以我们要么浪费四个比特，要么找到某种方法来使用这些剩余的比特。

我们可以通过掩码过程轻松做到这一点。这使用逻辑运算的规则来提取值。

下面的图示说明了这个过程。我们可以在单个 8 位字符中“内部”保持两个独立的 4 位值。我们将高四位视为一个值（蓝色），将低四位（红色）视为另一个值。为了提取低四位，我们将掩码设置为低 4 位设置为`1`（`0x0F`）。由于`逻辑与`操作只有当*两个*位都是`1`时才会设置位，因此掩码中设置为`0`的位实际上隐藏了我们不感兴趣的位。

<picture>![通过使用由所有 1 组成的掩码和逻辑与操作，我们可以提取我们感兴趣的位。](img/masking.svg)</picture>图 1.3.2.1.1 掩码

要获取最高（蓝色）的四位，我们需要反转掩码；换句话说，将最高 4 位设置为`1`，将较低的 4 位设置为`0`。你会注意到这给出了`1010 0000`的结果（或者，用十六进制表示为`0xA0`），但实际上我们希望将其视为一个独特的 4 位值`1010`（`0x0A`）。为了将位放到正确的位置，我们使用`右移`操作 4 次，得到最终的值为`0000 1010`。

```cpp
 1 |#include <stdio.h> 
 |
 |#define LOWER_MASK 0x0F 
 |#define UPPER_MASK 0xF0 
 5 |
 |int main(int argc, char* argv[]) 
 |{ 
 | /* Two 4-bit values stored in one 
 | * 8-bit variable */ 
10 | char value = 0xA5; 
 | char lower = value & LOWER_MASK; 
 | char upper = (value & UPPER_MASK) >> 4; 
 |
 | printf("Lower: %x\n", lower); 
15 | printf("Upper: %x\n", upper); 
 |} 

```

示例 1.3.2.1.1 使用掩码

*设置*位需要使用`逻辑或`操作。然而，我们不是使用`1`作为掩码，而是使用`0`。你应该画一个类似于上图那样的图，并通过使用`逻辑或`操作来设置位。

##### 1.3.2.2 标志

通常，一个程序会有许多变量，这些变量仅作为某些条件的*标志*存在。例如，状态机是一种算法，它通过多个不同的状态进行转换，但一次可能只处于一个状态。假设它有 8 个不同的状态；我们可以很容易地声明 8 个不同的变量，每个状态一个。但在许多情况下，声明*一个 8 位变量*并将每个位分配给*标志*，将每个位分配给表示特定状态的标志会更好。

标志是掩码的特殊情况，但每个位代表一个特定的布尔状态（开启或关闭）。一个*n*位变量可以存储*n*个不同的标志。请参见下面的代码示例，以了解使用标志的典型示例--你将非常频繁地看到这种基本代码的变体。

```cpp
 1 |#include <stdio.h> 
 |
 |/* 
 | *  define all 8 possible flags for an 8 bit variable 
 5 | *      name  hex     binary 
 | */ 
 |#define FLAG1 0x01 /* 00000001 */ 
 |#define FLAG2 0x02 /* 00000010 */ 
 |#define FLAG3 0x04 /* 00000100 */ 
10 |#define FLAG4 0x08 /* 00001000 */ 
 |/* ... and so on */ 
 |#define FLAG8 0x80 /* 10000000 */ 
 |
 |int main(int argc, char *argv[]) 
15 |{ 
 | char flags = 0; /* an 8 bit variable */ 
 |
 | /* set flags with a logical or */ 
 | flags = flags | FLAG1; /* set flag 1 */ 
20 | flags = flags | FLAG3; /* set flag 3 
 |
 | /* check flags with a logical and.  If the flag is set (1) 
 | * then the logical and will return 1, causing the if 
 | * condition to be true. */ 
25 | if (flags & FLAG1) 
 | printf("FLAG1 set!\n"); 
 |
 | /* this of course will be untrue. */ 
 | if (flags & FLAG8) 
30 | printf("FLAG8 set!\n"); 
 |
 | /* check multiple flags by using a logical or 
 | * this will pass as FLAG1 is set */ 
 | if (flags & (FLAG1|FLAG4)) 
35 | printf("FLAG1 or FLAG4 set!\n"); 
 |
 | return 0; 
 |} 

```

示例 1.3.2.2.1 使用标志</main>

<main class="calibre3">

## 2 类型和数字表示

### 2.1 C 标准

虽然略有分歧，但了解 C 语言的一些历史是很重要的。

C 语言是系统编程领域的通用语言。每个操作系统及其常用的相关系统库都是用 C 语言编写的，每个系统都提供了一个 C 编译器。为了防止这些系统中的语言发生分歧，每个系统都可能会做出许多不兼容的更改，因此为该语言制定了一个严格的标准。

官方上这个标准被称为 ISO/IEC 9899:1999(E)，但更常见的是用其缩写名 *C99*。该标准由国际标准化组织（ISO）维护，完整的标准可以在网上购买。较旧的标准版本，如 C89（1989 年发布的 C99 的前身）和 ANSI C，现在不再普遍使用，并被包含在最新的标准中。标准文档非常技术性，详细说明了语言的各个方面。例如，它解释了语法（以 Backus Naur 形式），标准的 `#define` 值以及操作应该如何表现。

也很重要的是要注意 C 标准没有定义的内容。最重要的是，标准需要适用于所有架构，包括现有的和未来的。因此，它注意不要定义依赖于架构的领域。C 标准和底层架构之间的“粘合剂”是应用程序二进制接口（或 ABI），我们将在下面讨论。在几个地方，标准会提到某个特定操作或构造有一个未指定或实现依赖的结果。显然，如果程序员要编写可移植的代码，他们不能依赖于这些结果。

#### 2.1.1 GNU C

GNU C 编译器，更常见地被称为 gcc，几乎完全实现了 C99 标准。然而，它也实现了一系列对标准的扩展，程序员经常使用这些扩展来获得额外的功能，但牺牲了迁移到另一个编译器的可移植性。这些扩展通常与非常底层的代码相关，在系统编程领域中更为常见；这个领域中最常见的扩展是内联汇编代码。程序员应该阅读 gcc 文档，并理解他们何时可能在使用与标准不同的功能。

gcc 可以被设置为严格遵循标准（例如 `-std=c99` 标志），当执行某些不在标准中的操作时，会发出警告或创建错误。这显然是合适的，如果你需要确保你的代码可以轻松地迁移到另一个编译器。

### 2.2 类型

作为程序员，我们熟悉使用变量来表示一个内存区域以存储值。在 *类型化* 语言，如 C 中，每个变量都必须使用 *类型* 声明。类型告诉编译器我们期望在变量中存储什么；编译器可以为此用途分配足够的空间，并检查程序员是否违反了类型的规则。在下面的例子中，我们可以看到为一些常见的变量类型分配的空间示例。

<picture>![处理器只看到一行的内存。给变量添加类型有助于编译器确保代码正在正确执行。上图展示了常见的类型，以及它们如何映射到内存中。](img/types.svg)</picture>图 2.2.1 类型

C99 标准故意只提到了为 C 定义的每种类型的*最小*可能大小。这是因为跨不同的处理器架构和操作系统，类型的最优大小可能会有很大的不同。

为了完全安全，程序员需要永远不要假设任何变量的大小，然而一个正常工作的系统显然需要就系统中将要使用的类型大小达成一致。每个架构和操作系统都遵循一个*应用程序二进制接口*或*ABI*。一个系统的 ABI 在 C 标准和底层硬件及操作系统的需求之间填充了细节。ABI 是为特定的处理器和操作系统组合编写的。

表 2.2.1 标准整数类型和大小

| 类型 | C99 最小大小（位） | 常见大小（32 位架构） |
| --- | --- | --- |
| `char` | 8 | 8 |
| `short` | 16 | 16 |
| `int` | 16 | 32 |
| `long` | 32 | 32 |
| `long long` | 64 | 64 |
| 指针 | 实现相关 | 32 |

如上所示，与标准唯一的不同是`int`通常是一个 32 位量，这是 C99 要求的严格最小 16 位大小的两倍。

指针实际上只是一个地址（即它们的值是一个地址，因此“指向”内存中的另一个位置），因此指针需要足够大，以便能够访问系统中的任何内存。

#### 2.2.1 64 位

一个引起混淆的领域是 64 位计算的引入。这意味着处理器可以处理 64 位长度的地址（特别是寄存器是 64 位宽；这是我们在第三章，计算机架构中讨论的主题）。

这首先意味着所有指针都需要是 64 位宽，以便它们可以表示系统中的任何可能的地址。然而，系统实现者必须就其他类型的大小做出决定。以下两种常用模型被广泛使用。

表 2.2.1.1 标准标量类型和大小

| 类型 | C99 最小大小（位） | 常见大小（LP64） | 常见大小（Windows） |
| --- | --- | --- | --- |
| `char` | 8 | 8 | 8 |
| `short` | 16 | 16 | 16 |
| `int` | 16 | 32 | 32 |
| `long` | 32 | 64 | 32 |
| `long long` | 64 | 64 | 64 |
| 指针 | 实现相关 | 64 | 64 |

你可以看到，在 LP64（长指针 64）模型中，`long`值被定义为 64 位宽。这与我们之前展示的 32 位模型不同。LP64 模型在 UNIX 系统中广泛使用。

在另一种模型中，`long`保持 32 位值。这保持了与 32 位代码的最大兼容性。这种模型在 64 位 Windows 中使用。

有很好的理由说明为什么在两种模型中`int`的大小都没有增加到 64 位。考虑一下，如果`int`的大小增加到 64 位，程序员将没有方法获得 32 位变量。唯一可能的方法是将`short`重新定义为更大的 32 位类型。

64 位变量非常大，通常不需要表示许多变量。例如，循环很少会重复超过 32 位变量能容纳的次数（4294967296 次！）！图像通常使用每个红色、绿色和蓝色值 8 位，以及额外的 8 位用于额外的（alpha 通道）信息；总共 32 位。因此，在许多情况下，使用 64 位变量至少会浪费至少 32 位（如果不是更多）。不仅如此，整数数组的大小现在也翻倍了。这意味着程序需要更多的系统内存（以及更多的缓存；在第三章，计算机架构中详细讨论），而实际上并没有真正的改进。出于同样的原因，Windows 选择保持其长值作为 32 位；因为 Windows API 的大部分最初是为在 32 位系统上使用长变量而编写的，因此不需要额外的位，这可以在不重写所有 API 的情况下节省大量的空间。

如果我们考虑一个替代方案，其中 `short` 被重新定义为 32 位变量；在 64 位系统上工作的程序员可以使用它来表示他们知道是有限制的小值变量。然而，当回到 32 位系统时，他们相同的 `short` 变量现在只有 16 位长，这是一个很容易溢出的值（65536）。

当程序员知道需要更大的变量时，请求更大的变量在可移植性和二进制文件空间浪费之间取得平衡。

#### 2.2.2 类型限定符

C 标准还讨论了变量类型的某些限定符。例如，`const` 表示变量将永远不会从其原始值被修改，而 `volatile` 则向编译器暗示这个值可能会在程序执行流程之外改变，因此编译器必须小心不要以任何方式重新排序对其的访问。

`signed` 和 `unsigned` 可能是两个最重要的限定符；它们表示变量是否可以取负值。我们将在下面更详细地探讨这一点。

限定符的目的是向编译器传递关于变量如何使用的额外信息。这意味着两件事；编译器可以检查你是否违反了自己的规则（例如，向一个 `const` 值写入）并且它可以基于额外的知识进行优化（在后面的章节中探讨）。

#### 2.2.3 标准类型

C99 意识到所有这些规则、大小和可移植性关注点可能会很快变得非常混乱。为了帮助，它提供了一系列特殊类型，可以指定变量的确切属性。这些类型在 `<stdint.h>` 中定义，形式为 `qtypes_t`，其中 `q` 是限定符，`type` 是基本类型，`s` 是位数，`_t` 是扩展，这样你知道你正在使用 C99 定义的类型。

例如，`uint8_t`是一个宽度正好为 8 位的无符号整数。还定义了许多其他类型；完整的列表在 C99 17.8 中详细说明，或者（更隐晦地）在头文件中。请注意，C99 还为`printf`提供了可移植性辅助工具。`<inttypes.h>`中的`PRI`宏可以用作指定大小的类型的说明符。再次查看标准或拆解头文件以获取完整信息。

提供这些类型供您使用，将它们映射到目标系统上的适当大小的类型，是系统实现 C99 标准的事情；在 Linux 上，这些头文件由系统库提供。

#### 2.2.4 类型应用

在示例 2.2.4.1，类型不匹配时的警告示例中，我们看到一个例子，说明了类型如何对变量的有效操作施加限制，以及编译器如何利用这些信息来警告变量使用不当的情况。在这个代码中，我们首先将一个整数值赋给一个`char`变量。由于`char`变量较小，我们丢失了整数的正确值。进一步向下，我们尝试将一个`char`指针赋值到我们指定的`integer`内存中。这个操作是可以完成的；但是它是不安全的。第一个例子是在 32 位奔腾机器上运行的，并返回了正确的值。然而，正如第二个例子所示，在 64 位安腾机器上，指针是 64 位（8 字节）长，而整数只有 4 字节长。显然，8 字节不能放入 4 字节中！我们可以尝试通过在赋值之前进行*类型转换*来“欺骗”编译器；请注意，在这种情况下，我们通过进行这种转换并忽略编译器警告而自食其果，因为较小的变量不能存储指针的所有信息，我们最终得到一个无效的地址。

```cpp
 1 |/* 
 | * types.c 
 | */ 
 |
 5 |#include <stdio.h> 
 |#include <stdint.h> 
 |
 |int main(void) 
 |{ 
10 | char a; 
 | char *p = "hello"; 
 |
 | int i; 
 |
15 | // moving a larger variable into a smaller one 
 | i = 0x12341234; 
 | a = i; 
 | i = a; 
 | printf("i is %d\n", i); 
20 |
 | // moving a pointer into an integer 
 | printf("p is %p\n", p); 
 | i = p; 
 | // "fooling" with casts 
25 | i = (int)p; 
 | p = (char*)i; 
 | printf("p is %p\n", p); 
 |
 | return 0; 
30 |} 

```

```cpp
 1 |$ uname -m 
 |i686 
 |
 |$ gcc -Wall -o types types.c 
 5 |types.c: In function 'main': 
 |types.c:19: warning: assignment makes integer from pointer without a cast 
 |
 |$ ./types 
 |i is 52 
10 |p is 0x80484e8 
 |p is 0x80484e8 
 |
 |$ uname -m 
 |ia64 
15 |
 |$ gcc -Wall  -o types types.c 
 |types.c: In function 'main': 
 |types.c:19: warning: assignment makes integer from pointer without a cast 
 |types.c:21: warning: cast from pointer to integer of different size 
20 |types.c:22: warning: cast to pointer from integer of different size 
 |
 |$ ./types 
 |i is 52 
 |p is 0x40000000000009e0 
25 |p is 0x9e0 

```

示例 2.2.4.1 类型不匹配时的警告示例

### 2.3 数字表示

#### 2.3.1 负值

使用我们现代的十进制数制，我们在负数前面放置一个减号（`-`）来表示负数。当使用二进制时，我们需要使用不同的系统来表示负数。

现代硬件上只有一个常用的方案，但 C99 定义了三种可接受的负值表示方法。

##### 2.3.1.1 符号位

最直接的方法是简单地说，数字的一个位表示该数是负数还是正数，取决于该位是否被设置。

这与数学方法中的`+`和`-`类似。这是相当合理的，一些原始计算机也是以这种方式表示负数的。但是使用二进制数打开了一些其他可能性，这使得硬件设计者的生活更容易。

然而，请注意，现在值`0`有两个等效值；一个设置了符号位，一个没有设置。有时这些值分别被称为`+0`和`-0`。

##### 2.3.1.2 一的补码

原码只是将正数应用`NOT`操作来表示负数。例如，值-90（-0x5A）被表示为`~01011010 = 10100101`。`~`操作符是 C 语言中应用`NOT`的运算符。它也偶尔被称为原码操作符，原因很明显！

使用这种方案，最大的优点是，在将负数加到正数上时，不需要特殊的逻辑，除了任何额外的进位必须加回到最终值。考虑

表 2.3.1.2.1 原码加法

| 十进制 | 二进制 | 操作 |
| --- | --- | --- |
| -90 | 10100101 | + |
| 100 | 01100100 |  |
| --- | -------- |  |
| 10 | ¹00001001 | 9 |
|  | 00001010 | 10 |

如果你逐位相加，你会发现你最终会在末尾得到一个进位位（如上所示）。通过将这个进位位加回到原始值，我们得到正确的值，10

再次，我们仍然有两个零的表示问题。现代计算机几乎都不使用原码，主要是因为有一个更好的方案。

##### 2.3.1.3 二进制补码

二进制补码与原码类似，只是负数的表示中加上了`1`，并且我们丢弃任何多余的进位位。所以，继续之前的例子，`-90`将被表示为`~01011010+1=10100101+1 = 10100110`。

这意味着可表示的数字存在一种略微奇特的对称性；例如，对于 8 位整数，我们有`2⁸ = 256`种可能的值；使用符号位表示法，我们可以表示从-127 到 127，但使用二进制补码，我们可以表示从-127 到 128。这是因为我们消除了有两个零的问题；考虑“负零”是`(~00000000 +1)=(11111111+1)=00000000`（注意丢弃的进位位）。

表 2.3.1.3.1 二进制补码加法

| 十进制 | 二进制 | 操作 |
| --- | --- | --- |
| -90 | 10100110 | + |
| 100 | 01100100 |  |
| --- | -------- |  |
| 10 | 00001010 |  |

你可以看到，通过实现二进制补码，硬件设计者只需要提供加法电路的逻辑；减法可以通过二进制补码对要减去的值取反，然后添加新值来完成。

类似地，你也可以通过重复加法实现乘法，通过重复减法实现除法。因此，二进制补码可以将所有简单的数学运算简化为加法！

所有现代计算机都使用二进制补码表示。

##### 2.3.1.3.1 符号扩展

由于二进制补码格式，当增加有符号值的位数时，重要的是要确保额外的位被*符号扩展*；也就是说，从现有值的最高位复制过来。

例如，一个 32 位的`int`类型`-10`在二进制补码表示中为`11111111111111111111111111110110`。如果将这个值转换为 64 位的`long long int`，我们需要确保额外的 32 位被设置为`1`以保持与原始值相同的符号。

多亏了二进制补码，我们只需要取现有值的最高位，并用这个值替换所有添加的位。这个过程被称为 *符号扩展*，通常由编译器在语言标准定义的情况下处理，处理器通常提供特殊的指令来取一个值并将其符号扩展到更大的值。

#### 2.3.2 浮点数

到目前为止，我们只讨论了整数或整个数字；可以表示小数值的数字类别称为 *浮点数*。

要创建一个十进制数，我们需要某种方式来表示二进制中的小数点概念。最常用的方案被称为 *IEEE-754 浮点标准*，因为该标准由电气和电子工程师协会发布。该方案在概念上相当简单，并且在某种程度上类似于“科学记数法”。

在科学记数法中，数值 `123.45` 通常表示为 `1.2345x10²`。我们称 `1.2345` 为 *尾数* 或 *有效数字*，`10` 是 *基数*，而 `2` 是 *指数*。

在 IEEE 浮点模型中，我们将可用的位拆分来表示十进制数的符号、尾数和指数。一个十进制数由 `sign × significand × 2^^(exponent)` 表示。

符号位等于 `1` 或 `-1`。由于我们在二进制中工作，我们始终有隐含的基数 `2`。

浮点数的宽度可能不同——我们下面只考察 32 位值。更多的位允许更高的精度。

表 2.3.2.1 IEEE 浮点数

| 符号 | 指数 | 尾数/尾数 |
| --- | --- | --- | --- | --- | --- | --- |
| S | EEEEEEEE | MMMMMMMMMMMMMMMMMMMMMMM |

另一个重要因素是指数的 *偏置*。指数需要能够表示正负值，因此从指数中减去一个隐含的 `127` 值。例如，指数为 `0` 时，指数字段为 `127`，`128` 表示 `1`，而 `126` 表示 `-1`。

尾数的每一位都会使我们可以表示的值增加一点精度。考虑数值 `198765` 的科学记数法表示，我们可以将其写成 `1.98765x10⁶`，这对应于以下表示

表 2.3.2.2 1.98765x10⁶ 的科学记数法

| 10⁰ | . | 10^(-1) | 10^(-2) | 10^(-3) | 10^(-4) | 10^(-5) |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | . | 9 | 8 | 7 | 6 | 5 |

每增加一位数字，我们就可以表示更多的十进制值。在十进制中，小数点后的每一位数字将我们的数字精度提高 10 倍。例如，我们可以用一个十进制小数位表示`0.0`到`0.9`（10 个值），用两个十进制小数位表示`0.00`到`0.99`（100 个值），以此类推。在二进制中，而不是每个额外的数字给我们 10 倍的精度，我们只得到两倍的精度，如下表所示。这意味着我们的二进制表示并不总是直接映射到十进制表示。

表 2.3.2.3 二进制中的有效数字

| 2⁰ | . | 2^(-1) | 2^(-2) | 2^(-3) | 2^(-4) | 2^(-5) |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | . | 1/2 | 1/4 | 1/8 | 1/16 | 1/32 |
| 1 | . | 0.5 | 0.25 | 0.125 | 0.0625 | 0.03125 |

仅使用一位精度，我们的分数精度并不大；我们只能说分数是`0`或`0.5`。如果我们增加一位精度，现在我们可以说出十进制值是`0,0.25,0.5,0.75`中的任何一个。再增加一位精度，我们现在可以表示的值有`0,0.125,0.25,0.375,0.5,0.625,0.75,0.875`。

因此，增加位数可以让我们获得更高的精度。然而，由于可能数字的范围是无限的，我们将永远没有足够的位数来表示*任何*可能的值。

例如，如果我们只有两位精度，需要表示`0.3`这个值，我们只能说它最接近`0.25`；显然，这对于大多数应用来说是不够的。如果我们有 22 位有效数字，我们就有更高的分辨率，但对于大多数应用来说仍然不够。`double`值将有效数字位数增加到 52（它也增加了指数值的范围）。一些硬件有 84 位的浮点数，具有完整的 64 位有效数字。64 位提供了巨大的精度，应该适合除了最苛刻的应用之外的所有应用（XXX 这足以表示小于原子大小的长度吗？）

```cpp
 1 |$ cat float.c 
 |#include <stdio.h> 
 |
 |int main(void) 
 5 |{ 
 | float a = 0.45; 
 | float b = 8.0; 
 |
 | double ad = 0.45; 
10 | double bd = 8.0; 
 |
 | printf("float+float, 6dp    : %f\n", a+b); 
 | printf("double+double, 6dp  : %f\n", ad+bd); 
 | printf("float+float, 20dp   : %10.20f\n", a+b); 
15 | printf("dobule+double, 20dp : %10.20f\n", ad+bd); 
 |
 | return 0; 
 |} 
 |
20 |$ gcc -o float float.c 
 |
 |$ ./float 
 |float+float, 6dp    : 8.450000 
 |double+double, 6dp  : 8.450000 
25 |float+float, 20dp   : 8.44999998807907104492 
 |dobule+double, 20dp : 8.44999999999999928946 
 |
 |$ python 
 |Python 2.4.4 (#2, Oct 20 2006, 00:23:25) 
30 |[GCC 4.1.2 20061015 (prerelease) (Debian 4.1.1-16.1)] on linux2 
 |Type "help", "copyright", "credits" or "license" for more information. 
 |>>> 8.0 + 0.45 
 |8.4499999999999993 

```

示例 2.3.2.1 浮点数与双精度浮点数

上面的实际例子说明了这一点。注意，对于`printf`默认提供的 6 位精度，两个答案都是相同的，因为它们都正确地四舍五入。然而，当要求提供更高精度的结果时，在这种情况下是 20 位十进制精度，我们可以看到结果开始发散。使用`doubles`的代码有更准确的结果，但它仍然不是*完全*正确的。我们还可以看到，没有明确处理`float`值的程序员仍然会遇到变量精度的问题！

##### 2.3.2.1 规范化值

在科学记数法中，我们可以用许多不同的方式表示一个值。例如，`10023x10⁰ = 1002.3x10¹ = 100.23x10²`。因此，我们定义 *标准化* 版本为 `1/radix <= 尾数 < 1` 的那个版本。在二进制中，这确保了尾数的最左位总是 *一个*。了解这一点后，我们可以通过标准规定最左位为隐含的一位来获得额外的精度。

表 2.3.2.1.1 标准化 0.375 的示例

| 2⁰ | . | 2^(-1) | 2^(-2) | 2^(-3) | 2^(-4) | 2^(-5) | 指数 | 计算 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | . | 0 | 1 | 1 | 0 | 0 | 2⁰ | (0.25+0.125) × 1 = 0.375 |
| 0 | . | 1 | 1 | 0 | 0 | 0 | 2^(-1) | (0.5+0.25)×0.5=0.375 |
| 1 | . | 1 | 0 | 0 | 0 | 0 | 2^(-2) | (1+0.5)×0.25=0.375 |

如上图所示，我们可以通过增加指数来补偿，将位向上移动，从而使值标准化。

##### 2.3.2.1.1 标准化技巧

程序员常见的问题之一是找到位域中的第一个置位。考虑位域 `0100`；从右向左，第一个置位将是位 `2`（从零开始，这是惯例）。

查找此值的标准方法是向右移位，检查最高位是否为 `1`，然后终止或重复。这是一个缓慢的过程；如果位域长度为 64 位，而只有最后一个位被置位，你必须遍历所有前面的 63 位！

然而，如果这个位域值是浮点数的尾数，并且我们要对其进行标准化，则指数的值将告诉我们它被移动了多少次。数字标准化的过程通常内置在处理器的浮点硬件单元中，因此运行非常快；通常比重复移位和检查操作快得多。

以下示例程序说明了在 Itanium 处理器上查找第一个置位位的两种方法。Itanium，像大多数服务器处理器一样，支持 80 位的 *扩展* 浮点类型，具有 64 位的尾数。这意味着 `unsigned long` 可以完美地适应 `long double` 的尾数。当值被加载时，它是标准化的，因此通过读取指数值（减去 16 位偏移量）我们可以看到它移动了多远。

```cpp
 1 |#include <stdio.h> 
 |
 |int main(void) 
 |{ 
 5 | //  in binary = 1000 0000 0000 0000 
 | //  bit num     5432 1098 7654 3210 
 | int i = 0x8000; 
 | int count = 0; 
 | while ( !(i & 0x1) ) { 
10 | count ++; 
 | i = i >> 1; 
 | } 
 | printf("First non-zero (slow) is %d\n", count); 
 |
15 | // this value is normalised when it is loaded 
 | long double d = 0x8000UL; 
 | long exp; 
 |
 | // Itanium "get floating point exponent" instruction 
20 | asm ("getf.exp %0=%1" : "=r"(exp) : "f"(d)); 
 |
 | // note exponent include bias 
 | printf("The first non-zero (fast) is %d\n", exp - 65535); 
 |
25 |} 

```

2.3.2.1.1.1 查找第一个置位位的程序

##### 2.3.2.2 将内容整合

在下面的示例代码中，我们提取浮点数的组成部分并打印出它所表示的值。这仅适用于 IEEE 格式的 32 位浮点值；然而，这对于大多数具有 `float` 类型的架构来说很常见。

```cpp
 1 |#include <stdio.h> 
 |#include <string.h> 
 |#include <stdlib.h> 
 |
 5 |/* return 2^n */ 
 |int two_to_pos(int n) 
 |{ 
 | if (n == 0) 
 | return 1; 
 10 | return 2 * two_to_pos(n - 1); 
 |} 
 |
 |double two_to_neg(int n) 
 |{ 
 15 | if (n == 0) 
 | return 1; 
 | return 1.0 / (two_to_pos(abs(n))); 
 |} 
 |
 20 |double two_to(int n) 
 |{ 
 | if (n >= 0) 
 | return two_to_pos(n); 
 | if (n < 0) 
 25 | return two_to_neg(n); 
 | return 0; 
 |} 
 |
 |/* Go through some memory "m" which is the 24 bit significand of a 
 30 | floating point number.  We work "backwards" from the bits 
 | furthest on the right, for no particular reason. */ 
 |double calc_float(int m, int bit) 
 |{ 
 | /* 23 bits; this terminates recursion */ 
 35 | if (bit > 23) 
 | return 0; 
 |
 | /* if the bit is set, it represents the value 1/2^bit */ 
 | if ((m >> bit) & 1) 
 40 | return 1.0L/two_to(23 - bit) + calc_float(m, bit + 1); 
 |
 | /* otherwise go to the next bit */ 
 | return calc_float(m, bit + 1); 
 |} 
 45 |
 |int main(int argc, char *argv[]) 
 |{ 
 | float f; 
 | int m,i,sign,exponent,significand; 
 50 |
 | if (argc != 2) 
 | { 
 | printf("usage: float 123.456\n"); 
 | exit(1); 
 55 | } 
 |
 | if (sscanf(argv[1], "%f", &f) != 1) 
 | { 
 | printf("invalid input\n"); 
 60 | exit(1); 
 | } 
 |
 | /* We need to "fool" the compiler, as if we start to use casts 
 | (e.g. (int)f) it will actually do a conversion for us.  We 
 65 | want access to the raw bits, so we just copy it into a same 
 | sized variable. */ 
 | memcpy(&m, &f, 4); 
 |
 | /* The sign bit is the first bit */ 
 70 | sign = (m >> 31) & 0x1; 
 |
 | /* Exponent is 8 bits following the sign bit */ 
 | exponent = ((m >> 23) & 0xFF) - 127; 
 |
 75 | /* Significand fills out the float, the first bit is implied 
 | to be 1, hence the 24 bit OR value below. */ 
 | significand = (m & 0x7FFFFF) | 0x800000; 
 |
 | /* print out a power representation */ 
 80 | printf("%f = %d * (", f, sign ? -1 : 1); 
 | for(i = 23 ; i >= 0 ; i--) 
 | { 
 | if ((significand >> i) & 1) 
 | printf("%s1/2^%d", (i == 23) ? "" : " + ", 
 85 | 23-i); 
 | } 
 | printf(") * 2^%d\n", exponent); 
 |
 | /* print out a fractional representation */ 
 90 | printf("%f = %d * (", f, sign ? -1 : 1); 
 | for(i = 23 ; i >= 0 ; i--) 
 | { 
 | if ((significand >> i) & 1) 
 | printf("%s1/%d", (i == 23) ? "" : " + ", 
 95 | (int)two_to(23-i)); 
 | } 
 | printf(") * 2^%d\n", exponent); 
 |
 | /* convert this into decimal and print it out */ 
100 | printf("%f = %d * %.12g * %f\n", 
 | f, 
 | (sign ? -1 : 1), 
 | calc_float(significand, 0), 
 | two_to(exponent)); 
105 |
 | /* do the math this time */ 
 | printf("%f = %.12g\n", 
 | f, 
 | (sign ? -1 : 1) * 
110 | calc_float(significand, 0) * 
 | two_to(exponent) 
 | ); 
 |
 | return 0; 
115 |} 

```

2.3.2.2.1 检查浮点数

之前我们考察过的值 `8.45` 的样本输出如下所示。

```cpp
1 |$ ./float 8.45 
 |8.450000 = 1 * (1/2⁰ + 1/2⁵ + 1/2⁶ + 1/2⁷ + 1/2¹⁰ + 1/2¹¹ + 1/2¹⁴ + 1/2¹⁵ + 1/2¹⁸ + 1/2¹⁹ + 1/2²² + 1/2²³) * 2³ 
 |8.450000 = 1 * (1/1 + 1/32 + 1/64 + 1/128 + 1/1024 + 1/2048 + 1/16384 + 1/32768 + 1/262144 + 1/524288 + 1/4194304 + 1/8388608) * 2³ 
 |8.450000 = 1 * 1.05624997616 * 8.000000 
5 |8.450000 = 8.44999980927 

```

2.3.2.2.2 分析 `8.45`

从这个例子中，我们可以了解浮点数中的不精确是如何逐渐渗透进来的。

</main>
