<main class="calibre3">

## 第一章. 通用 Unix 和高级 C

</main>

<main class="calibre3">

## 1 *一切皆文件！*

类似于 Linux 或 BSD 这样的 UNIX 系统的一个经常引用的原则是*一切皆文件*。

想象一下在像文字处理器这样的熟悉环境中的文件。我们可以在这个假想的文字处理文件上使用两个基本操作：

1.  从它读取（来自文字处理器的现有保存数据）。

1.  向它写入（来自用户的新数据）。

考虑一些常见的连接到计算机的设备以及它们如何与我们的基本文件操作相关：

1.  屏幕

1.  键盘

1.  打印机

1.  CD-ROM

屏幕和打印机都像是一个只写文件，但信息不是以位的形式存储在磁盘上，而是以点在屏幕上显示或以线条在页面上显示。键盘像是一个只读文件，数据来自用户提供的按键。CD-ROM 类似，但数据不是随机来自用户，而是直接存储在磁盘上。

因此，文件的概念是对数据接收器或源的一个很好的抽象。这样，它就是所有可能连接到计算机的设备的优秀抽象。这种认识是 UNIX 的强大之处，这一点在整个平台的设计中都很明显。操作系统的一个基本角色就是向程序员提供这种硬件抽象。

可能不会过分夸张地说，抽象是支撑所有现代计算的首要概念。没有人能够理解从设计现代用户界面到现代 CPU 内部工作的一切，更不用说自己构建它了。对于程序员来说，抽象是我们协作和创新的共同语言。

学习在抽象之间导航可以让人更深入地了解如何以最佳和最具创新性的方式使用抽象。在这本书中，我们关注的是最低层的抽象；在应用程序和操作系统之间，以及操作系统和硬件之间。还有更多层次，每个都值得有自己的一本书。随着这些章节的进展，你可能会希望对现代操作系统提供的抽象有所了解。

<picture>![你能发现 CD-ROM 和键盘之间的区别吗？作为一个应用程序程序员，你不应该能够做到。](img/abstraction.svg)</picture>图 1.1 抽象</main>

<main class="calibre3">

## 2 实现抽象

通常，抽象是通过所谓的应用程序编程接口（API）实现的。API 是一个有些模糊的术语，在不同的编程任务中有不同的含义。从根本上讲，程序员设计一组函数，并记录它们的接口和功能，原则上是提供 API 的实际实现是透明的。

例如，许多大型网络应用程序提供通过 HTTP 访问的 API。通过这种方法访问数据无疑会触发许多复杂的远程过程调用、数据库查询和数据传输系列，所有这些都对最终用户来说是透明的，他们只是简单地接收合同数据。

熟悉 Java、Python 或 C++ 等面向对象语言的那些人会对 *类* 提供的抽象很熟悉。方法提供了对类的接口，但抽象了实现。

### 2.1 使用 C 实现抽象

Linux 内核和其他缺乏内置面向对象概念的 C 代码库中常用的一个常见方法是 *函数指针*。学会阅读这种习语是导航大多数大型 C 代码库的关键。通过理解如何在代码中读取提供的抽象，可以构建对内部 API 设计的理解。

```cpp
 1 |#include <stdio.h> 
 |
 |/* The API to implement */ 
 |struct greet_api 
 5 |{ 
 | int (*say_hello)(char *name); 
 | int (*say_goodbye)(void); 
 |}; 
 |
10 |/* Our implementation of the hello function */ 
 |int say_hello_fn(char *name) 
 |{ 
 | printf("Hello %s\n", name); 
 | return 0; 
15 |} 
 |
 |/* Our implementation of the goodbye function */ 
 |int say_goodbye_fn(void) 
 |{ 
20 | printf("Goodbye\n"); 
 | return 0; 
 |} 
 |
 |/* A struct implementing the API */ 
25 |struct greet_api greet_api = 
 |{ 
 | .say_hello = say_hello_fn, 
 | .say_goodbye = say_goodbye_fn 
 |}; 
30 |
 |/* main() doesn't need to know anything about how the 
 | * say_hello/goodbye works, it just knows that it does */ 
 |int main(int argc, char *argv[]) 
 |{ 
35 | greet_api.say_hello(argv[1]); 
 | greet_api.say_goodbye(); 
 |
 | printf("%p, %p, %p\n", greet_api.say_hello, say_hello_fn, &say_hello_fn); 
 |
40 | exit(0); 
 |} 

```

示例 2.1.1 使用函数指针的抽象

上述代码是 Linux 内核和其他 C 程序中反复使用的结构的最简单示例。让我们看看一些具体的元素。

我们从一个定义 API 的结构体开始（`struct greet_api`）。括号中带有指针标记的函数名称描述了一个 *函数指针*。通常你会看到省略了参数名称，只指定了参数类型。这允许实现者指定他们自己的参数名称，从而避免编译器警告。函数指针描述了它必须指向的函数的 *原型*；如果指向一个没有正确返回类型或参数的函数，至少会生成编译器警告；如果留在代码中，很可能会导致操作不正确或崩溃。

然后我们有我们的 API 实现。通常，对于更复杂的功能，你会看到一种习语，其中 API 实现函数将仅是围绕其他函数的包装，这些函数传统上以一个或两个下划线开头。一个双下划线函数 `__foo` 可以口语化地称为 "dunder foo"。（例如，`say_hello_fn()` 会调用另一个函数 `_say_hello_function()`）。这有几个用途；通常它与 API 的更简单、更小的部分（例如参数打包或检查）与更复杂的实现分离有关，这通常简化了内部工作方式的重大变化，同时确保 API 保持不变。然而，我们的实现非常简单，甚至不需要自己的支持函数。在不同的项目中，单下划线、双下划线或甚至三下划线函数前缀可能意味着不同的事情，但普遍来说，这是一个视觉警告，表明该函数不应该从 "API 之外" 直接调用。

最后一个，我们在 `struct greet_api greet_api` 中填充了函数指针。函数的名称是一个指针；因此不需要取函数的地址（即 `&say_hello_fn`）。

最后，我们可以通过 `main` 中的结构调用 API 函数。

当在源代码中导航时，你将经常看到这种习惯用法。下面的微小示例是从 Linux 内核源代码中的 `include/linux/virtio.h` 中取出的，以说明：

```cpp
 1 |/** 
 | * virtio_driver - operations for a virtio I/O driver 
 | * @driver: underlying device driver (populate name and owner). 
 | * @id_table: the ids serviced by this driver. 
 5 | * @feature_table: an array of feature numbers supported by this driver. 
 | * @feature_table_size: number of entries in the feature table array. 
 | * @probe: the function to call when a device is found.  Returns 0 or -errno. 
 | * @remove: the function to call when a device is removed. 
 | * @config_changed: optional function to call when the device configuration 
10 | *    changes; may be called in interrupt context. 
 | */ 
 |struct virtio_driver { 
 | struct device_driver driver; 
 | const struct virtio_device_id *id_table; 
15 | const unsigned int *feature_table; 
 | unsigned int feature_table_size; 
 | int (*probe)(struct virtio_device *dev); 
 | void (*scan)(struct virtio_device *dev); 
 | void (*remove)(struct virtio_device *dev); 
20 | void (*config_changed)(struct virtio_device *dev); 
 |#ifdef CONFIG_PM 
 | int (*freeze)(struct virtio_device *dev); 
 | int (*restore)(struct virtio_device *dev); 
 |#endif 
25 |}; 

```

示例 2.1.2 `include/linux/virtio.h` 中的抽象

只需大致了解这个结构是虚拟 I/O 设备的描述即可。我们可以看到，使用此 API 的用户（设备驱动程序作者）预计将在系统操作的各种条件下调用一系列函数（当探测新硬件时，当硬件被移除时等）。它还包含一系列数据；结构，应填充相关数据。

从这样的描述符开始通常是开始理解内核代码各层最容易的方式。

### 2.2 库

库有两个角色，可以说明抽象。

+   允许程序员重用常用代码。

+   作为实现程序员功能的一个 *黑盒*。

例如，一个实现访问 JPEG 文件原始数据的库具有这样的优势：所有希望访问图像文件的程序都可以使用同一个库，而构建这些程序的程序员不需要担心 JPEG 文件格式的确切细节，而可以将精力集中在他们的程序想要对图像做什么。

UNIX 平台的标准库通常被称为 `libc`。它提供了对系统的基本接口：如 `read()`、`write()` 和 `printf()` 等基本调用。这个 API 由一个称为 `POSIX` 的规范完整描述。它可以在网上免费获取，并描述了构成标准 UNIX API 的许多调用。

大多数 UNIX 平台广泛遵循 POSIX 标准，尽管在许多小但有时重要的方面存在差异（因此各种 GNU 自动工具的复杂性，它们经常试图为你抽象这些差异）。Linux 有许多 POSIX 没有指定的接口；仅使用这些接口编写应用程序将使你的应用程序的可移植性降低。

库是一个具有许多细节的基本抽象。后面的章节将更详细地描述库是如何工作的。

</main>

<main class="calibre3">

## 3 文件描述符

UNIX 程序员最初学到的一件事是，每个正在运行的程序都会预先打开三个文件：

表 3.1 Unix 提供的标准文件

| 描述名称 | 简称 | 文件编号 | 描述 |
| --- | --- | --- | --- |
| 标准输入 | stdin | 0 | 从键盘输入 |
| 标准输出 | stdout | 1 | 输出到控制台 |
| 标准错误 | stderr | 2 | 错误输出到控制台 |

<picture>![任何 UNIX 程序打开的标准文件。](img/stdfds.svg)</picture>图 3.1 默认 Unix 文件

这引发了一个问题：*打开文件*代表什么。`open`调用返回的值被称为*文件描述符*，实际上是内核保持的打开文件数组中的一个索引。

<picture>![文件描述符将设备驱动程序提供的抽象与提供给用户的文件接口关联起来。](img/file-descriptors.svg)</picture>

文件描述符是内核存储的文件描述符表中的一个索引。内核在响应`open`调用时创建一个文件描述符，并将文件描述符与底层文件-like 对象的某种抽象相关联，无论是实际硬件设备、文件系统还是其他完全不同的东西。因此，一个进程的`read`或`write`调用，如果引用该文件描述符，将被内核路由到正确的地方，最终执行一些有用的操作。

图 3.2 抽象

简而言之，文件描述符是进入内核对底层硬件抽象的门户。物理设备的抽象概述如图图 3.2，抽象所示。

从最低级别开始，操作系统要求程序员创建一个*设备驱动程序*以便能够与硬件设备通信。这个设备驱动程序被编写到内核提供的 API 中，就像在示例 2.1.2，`include/linux/virtio.h`中的抽象一样；设备驱动程序将提供一系列函数，这些函数将在内核响应各种需求时被调用。在上面的简化示例中，我们可以看到驱动程序提供了`read`和`write`函数，这些函数将在对文件描述符的类似操作时被调用。设备驱动程序知道如何将这些通用请求转换为特定设备的具体请求或命令。

为了提供用户空间的抽象，内核通过所谓的*设备层*提供了一个文件接口。主机上的物理设备在特殊文件系统（如`/dev`）中用一个文件来表示。在类 UNIX 系统中，所谓的*设备节点*有一个称为*主次编号*的编号，这允许内核将特定的节点与其底层驱动程序关联起来。这些可以通过`ls`命令识别，如示例 3.1，主次编号示例所示。

```cpp
 |$ ls -l /dev/null /dev/zero /dev/tty 
 |crw-rw-rw- 1 root root 1, 3 Aug 26 13:12 /dev/null 
 |crw-rw-rw- 1 root root 5, 0 Sep  2 15:06 /dev/tty 
 |crw-rw-rw- 1 root root 1, 5 Aug 26 13:12 /dev/zero 

```

示例 3.1 主次编号示例

这将我们引向文件描述符，它是用户空间用来与底层设备通信的句柄。从广义上讲，当文件被`open`时，内核正在使用路径信息将文件描述符映射到提供适当`read`和`write`等 API 的东西。当这个`open`是为设备（如上面的`/dev/sr0`）时，打开的设备节点的 major 和 minor 号提供了内核需要的信息，以找到正确的设备驱动程序并完成映射。然后内核将知道如何将进一步的调用，如`read`，路由到设备驱动程序提供的底层函数。

非设备文件的操作方式类似，尽管中间有更多层。这里的抽象是*挂载点*；挂载文件系统具有双重目的，即设置映射以便文件系统知道提供存储的底层设备，内核知道在该挂载点下打开的文件应指向文件系统驱动程序。与设备驱动程序一样，文件系统是编写到内核提供的特定通用文件系统 API 上的。

确实存在许多其他层，这些层在现实生活中使情况变得复杂。例如，内核会不遗余力地将尽可能多的数据从磁盘缓存到其他空闲内存中；这提供了许多速度优势。它还会尝试以最有效的方式组织设备访问；例如，尝试对磁盘访问进行排序，以确保存储在物理上靠近的数据可以一起检索，即使请求没有按顺序到达。此外，许多设备属于更通用的类别，如 USB 或 SCSI 设备，它们提供自己的抽象层以进行写入。因此，而不是直接写入设备，文件系统将通过这些许多层。理解内核就是理解这些许多 API 如何相互关联和共存。

### 3.1 壳层

壳层是交互操作系统的门户。无论是`bash`、`zsh`、`csh`还是许多其他壳层，它们在本质上只有一个主要任务——允许你执行程序（当你我们讨论操作系统的某些内部结构时，你将开始理解壳层实际上是如何做到这一点的）。

但是，壳层不仅仅允许你简单地执行程序。它们具有强大的重定向文件、允许你同时执行多个程序以及脚本完整程序的能力。这些都回到了“一切皆文件”的习语。

#### 3.1.1 重定向

经常我们不想在第三部分，文件描述符中提到的标准文件描述符指向它们的默认位置。例如，你可能希望将程序的所有输出捕获到磁盘上的一个文件中，或者，你也可以让它从你之前准备好的文件中读取命令。另一个有用的任务可能是将一个程序的输出传递给另一个程序作为输入。操作系统通过 shell 提供了所有这些以及更多功能。

表 3.1.1.1 标准 Shell 重定向功能

| 名称 | 命令 | 描述 | 示例 |
| --- | --- | --- | --- |
| 重定向到文件 | `> 文件名` | 将所有标准输出内容放入`文件名`中。注意使用`>>`将内容追加到文件中，而不是覆盖它。 | `ls > 文件名` |
| 从文件读取 | < `文件名` | 将文件中的所有数据复制到程序的标准输入 | `echo < 文件名` |
| 管道 | `program1 &#124; program2` | 从`program1`的标准输出中获取所有内容，并将其传递到`program2`的标准输入 | `ls &#124; more` |

#### 3.1.2 实现管道

`ls | more` 的实现只是抽象力量强大性的另一个例子。在这里本质上发生的事情是，不是将标准输出文件描述符与某种底层设备（如控制台，用于输出到终端）关联起来，而是将描述符指向内核提供的一个内存缓冲区，通常称为`管道`。这里的技巧是，另一个进程可以将它的标准输入与这个相同缓冲区的另一端关联起来，并有效地消费另一个进程的输出。这如图图 3.1.2.1，管道操作所示。

<picture>![管道是内核提供的内存缓冲区，允许一个进程的输出作为另一个进程的输入。](img/pipe.svg)</picture>

管道是一个连接两个进程的内存缓冲区。文件描述符指向管道对象，它缓冲发送给它（通过`write`）的数据，以便通过`read`进行*排空*。

图 3.1.2.1 管道操作

向管道写入的数据会被内核存储，直到从另一侧进行相应的读取操作将缓冲区中的数据*排空*。这是一个非常强大的概念，也是 UNIX-like 操作系统中的基本进程间通信（IPC）形式之一。管道不仅允许数据传输，还可以作为信号通道。如果一个进程尝试从空管道中读取，它将默认*阻塞*或进入休眠状态，直到有数据可用（这一点在第五章，进程中有更深入的讨论）。因此，两个进程可以通过管道来通信，表明某个操作已被执行，只需写入一个字节的数据；实际上数据的重要性并不大，管道中*任何*数据的存在都可以作为信号。例如，一个进程请求另一个进程打印一个文件——这需要一些时间。这两个进程可以在它们之间设置一个管道，请求进程在空管道上执行`read`操作；由于管道为空，这个调用会阻塞，进程不会继续执行。一旦打印完成，另一个进程可以向管道写入一条消息，这实际上会唤醒请求进程并表明工作已完成。

允许进程以这种方式相互传递数据，又引发了另一个常见的 UNIX 惯用语：小型工具各自完成特定任务。将这些小型工具串联起来，可以提供单一大型工具通常无法提供的灵活性。

</main>
