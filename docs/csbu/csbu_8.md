

## 第九章。动态链接





## 1 代码共享

我们知道对于操作系统，代码被认为是只读的，并且与数据分开。因此，如果程序不能修改代码并且有大量公共代码，那么它应该被许多可执行文件共享，而不是为每个可执行文件复制它，这似乎是合理的。

使用虚拟内存，这可以很容易地完成。库代码加载到的物理页面可以通过任何数量的虚拟页面在任何数量的地址空间中轻松引用。因此，尽管你只有一个库代码的物理副本在系统内存中，但每个进程都可以在任何它喜欢的虚拟地址上访问那个库代码。

因此，人们很快就想出了*共享库*的概念，正如其名所示，它被多个可执行文件共享。每个可执行文件都包含一个基本引用，表示“我需要库 foo”。当程序被加载时，系统需要检查是否有其他程序已经将库 foo 的代码加载到内存中，并因此通过将页面映射到该物理内存的可执行文件中共享它，或者否则将库加载到可执行文件的内存中。

这个过程被称为*动态链接*，因为它在程序在系统中执行时“即时”完成部分链接过程。

### 1.1 动态库细节

库非常类似于一个永远不会启动的程序。它们有代码和数据部分（函数和变量），就像每个可执行文件一样；但没有开始运行的地方。它们只是为开发者提供函数库以供调用。

因此，ELF 可以像表示可执行文件一样表示动态库。有一些基本区别，例如没有指向执行开始位置的指针，但所有共享库都像任何其他可执行文件一样是 ELF 对象。

ELF 头有两个互斥标志，`ET_EXEC`和`ET_DYN`，用于标记 ELF 文件是可执行文件还是共享对象文件。

### 1.2 在可执行文件中包含库

#### 1.2.1 编译

当你编译使用动态库的程序时，对象文件会保留对库函数的引用，就像对任何其他外部引用一样。

你需要包含库的 *头文件*，这样编译器才知道你调用函数的具体类型。注意编译器只需要知道与函数相关的类型（例如，它接受一个 `int` 并返回一个 `char *`），以便它可以为函数调用正确地分配空间。这并不是 C 标准一直以来的情况。以前，编译器会假设它不知道的任何函数都返回一个 `int`。在 32 位系统上，指针的大小与 `int` 的大小相同，所以没有问题。然而，在 64 位系统上，指针的大小通常是 `int` 的大两倍，所以如果函数实际上返回一个指针，它的值将被破坏。这显然是不可接受的，因为指针将不会指向有效的内存。C99 标准已经改变，要求你指定包含函数的类型。

#### 1.2.2 链接

尽管动态链接器为共享库做了很多工作，但传统的链接器在创建可执行文件时仍然扮演着一定的角色。

传统的链接器需要在可执行文件中留下一个指针，这样动态链接器就知道在运行时将满足依赖关系的库是什么。

可执行文件的 `dynamic` 部分需要为可执行文件依赖的每个共享库提供一个 `NEEDED` 条目。

再次，我们可以使用 `readelf` 程序来检查这些字段。下面我们查看一个非常标准的二进制文件，`/bin/ls`

```cpp
1 |$ readelf --dynamic /bin/ls` 
 |
 |`Dynamic segment at offset 0x22f78 contains 27 entries: 
 | Tag        Type                         Name/Value 
5 | 0x0000000000000001 (NEEDED)             Shared library: [librt.so.1] 
 | 0x0000000000000001 (NEEDED)             Shared library: [libacl.so.1] 
 | 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6.1] 
 | 0x000000000000000c (INIT)               0x4000000000001e30 
 | ... snip ... 

```

示例 1.2.2.1 指定动态库

你可以看到它指定了三个库。在系统中，如果不是所有，那么大多数程序共享的最常见的库是 `libc`。还有一些其他库，程序需要它们才能正确运行。

直接读取 ELF 文件有时很有用，但检查动态链接可执行文件通常是通过 `ldd` 来完成的。`ldd` "遍历"库的依赖关系为你；也就是说，如果一个库依赖于另一个库，它将显示给你。

```cpp
 1 |$ ldd /bin/ls 
 | librt.so.1 => /lib/tls/librt.so.1 (0x2000000000058000) 
 | libacl.so.1 => /lib/libacl.so.1 (0x2000000000078000) 
 | libc.so.6.1 => /lib/tls/libc.so.6.1 (0x2000000000098000) 
 5 | libpthread.so.0 => /lib/tls/libpthread.so.0 (0x20000000002e0000) 
 | /lib/ld-linux-ia64.so.2 => /lib/ld-linux-ia64.so.2 (0x2000000000000000) 
 | libattr.so.1 => /lib/libattr.so.1 (0x2000000000310000) 
 |$ readelf --dynamic /lib/librt.so.1 
 |
10 |Dynamic segment at offset 0xd600 contains 30 entries: 
 | Tag        Type                         Name/Value 
 | 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6.1] 
 | 0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0] 
 | ... snip ... 

```

示例 1.2.2.2 查看动态库

我们可以看到上面已经从某处要求了 `libpthread`。如果我们稍作调查，我们可以看到这个需求来自 `librt`。





## 2 动态链接器

动态链接器是代表可执行文件管理共享动态库的程序。它负责将库加载到内存中，并在运行时修改程序以调用库中的函数。

ELF 允许可执行文件指定一个 *解释器*，这是一个应该用来运行可执行文件的程序。编译器和静态链接器将依赖于动态库的可执行文件的解释器设置为动态链接器。

```cpp
 1 |ianw@lime:~/programs/csbu$ readelf --headers /bin/ls 
 |
 |Program Headers: 
 | Type           Offset             VirtAddr           PhysAddr 
 5 | FileSiz            MemSiz              Flags  Align 
 | PHDR           0x0000000000000040 0x4000000000000040 0x4000000000000040 
 | 0x0000000000000188 0x0000000000000188  R E    8 
 | INTERP         0x00000000000001c8 0x40000000000001c8 0x40000000000001c8 
 | 0x0000000000000018 0x0000000000000018  R      1 
10 | [Requesting program interpreter: /lib/ld-linux-ia64.so.2] 
 | LOAD           0x0000000000000000 0x4000000000000000 0x4000000000000000 
 | 0x0000000000022e40 0x0000000000022e40  R E    10000 
 | LOAD           0x0000000000022e40 0x6000000000002e40 0x6000000000002e40 
 | 0x0000000000001138 0x00000000000017b8  RW     10000 
15 | DYNAMIC        0x0000000000022f78 0x6000000000002f78 0x6000000000002f78 
 | 0x0000000000000200 0x0000000000000200  RW     8 
 | NOTE           0x00000000000001e0 0x40000000000001e0 0x40000000000001e0 
 | 0x0000000000000020 0x0000000000000020  R      4 
 | IA_64_UNWIND   0x0000000000022018 0x4000000000022018 0x4000000000022018 
20 | 0x0000000000000e28 0x0000000000000e28  R      8 

```

示例 2.1 检查程序解释器

你可以看到上面的解释器被设置为 /lib/ld-linux-ia64.so.2，这是动态链接器。当内核加载二进制文件以执行时，它将检查 `PT_INTERP` 字段是否存在，如果存在，则将其指向的内容加载到内存中并启动它。

我们提到，动态链接的可执行文件会留下需要用运行时才可用的信息来修复的引用，例如共享库中函数的地址。留下的这些引用被称为*重定位*。

### 2.1 重定位

动态链接器的基本部分是在运行时修复地址，这是唯一可以确定你在内存中加载位置的时候。重定位可以简单地被视为一个笔记，表明某个地址在加载时将需要被修复。在代码准备好运行之前，你需要遍历所有重定位，修复它所引用的地址，使其指向正确的地方。

表 2.1.1 重定位示例

| 地址 | 操作 |
| --- | --- |
| 0x123456 | 符号"x"的地址 |
| 0x564773 | 函数 X |

每个架构都有许多种重定位类型，每种类型的精确行为都作为系统 ABI 的一部分进行了文档化。重定位的定义相当直接。

```cpp
 1 |typedef struct { 
 | Elf32_Addr    r_offset;  <--- address to fix 
 | Elf32_Word    r_info;    <--- symbol table pointer and relocation type 
 |} 
 5 |
 |typedef struct { 
 | Elf32_Addr    r_offset; 
 | Elf32_Word    r_info; 
 | Elf32_Sword   r_addend; 
10 |} Elf32_Rela 

```

示例 2.1.1 由 ELF 定义的重定位

`r_offset`字段指的是文件中需要修复的偏移量。`r_info`字段指定了重定位的类型，它描述了为了修复这段代码必须执行的确切操作。对于某个架构来说，最简单的重定位通常定义为符号的值。在这种情况下，你只需将符号的地址替换到指定的位置，重定位就已被“修复”。

这两种类型，一种带有加数，一种不带，指定了重定位操作的不同方式。加数简单来说就是应该加到修复地址上以找到正确地址的东西。例如，如果重定位是为了符号`i`，因为原始代码正在执行类似`i[8]`的操作，那么加数将被设置为 8。这意味着“找到`i`的地址，然后过去 8 个位置”。

那个加数值需要存储在某个地方。这两种解决方案分别由两种形式涵盖。在`REL`形式中，加数实际上存储在程序代码中，在应该放置修复地址的地方。这意味着要正确地修复地址，你需要首先读取你即将修复的内存以获取任何加数，存储它，找到“真实”的地址，将加数加到它上面，然后写回（覆盖加数）。`RELA`格式指定了重定位中的加数。

每种方法的权衡应该很清楚。使用`REL`时，你需要进行额外的内存引用来找到修复前的加数，但你不会在二进制文件中浪费空间，因为你使用了重定位目标内存。使用`RELA`时，你将加数与重定位一起保留，但在磁盘上的二进制文件中浪费了空间。大多数现代系统使用`RELA`重定位。

#### 2.1.1 重定位的实际应用

下面的示例展示了重定位是如何工作的。我们创建了两个非常简单的共享库，并在其中一个中引用了另一个。

```cpp
 1 |$ cat addendtest.c 
 |extern int i[4]; 
 |int *j = i + 2; 
 |
 5 |$ cat addendtest2.c 
 |int i[4]; 
 |
 |$ gcc -nostdlib -shared -fpic -s -o addendtest2.so addendtest2.c 
 |$ gcc -nostdlib -shared -fpic -o addendtest.so addendtest.c ./addendtest2.so 
10 |
 |$ readelf -r ./addendtest.so 
 |
 |Relocation section '.rela.dyn' at offset 0x3b8 contains 1 entries: 
 | Offset          Info           Type           Sym. Value    Sym. Name + Addend 
15 |0000000104f8  000f00000027 R_IA64_DIR64LSB   0000000000000000 i + 8 

```

示例 2.1.1.1 指定动态库

因此，在`addendtest.so`中有一个类型为`R_IA64_DIR64LSB`的重定位。如果你在 IA64 ABI 中查找这个缩写，它可以分解为

1.  *R_IA64* : 所有重定位都以这个前缀开始。

1.  *DIR64* : 64 位直接类型重定位

1.  *LSB* : 由于 IA64 可以在大端和小端模式下运行，这个重定位是小端（最低有效字节）。

ABI 继续说明，重定位意味着“重定位所指向的符号的值，加上任何加数”。我们可以看到我们有一个 8 的加数，因为`sizeof(int) == 4`，并且我们已经将两个 int 移动到数组中（`*j = i + 2`）。所以，在运行时，要修复这个重定位，你需要找到符号`i`的内存地址，并将它的值加上 8 放入`0x104f8`。

### 2.2 位置无关性

在 *可执行文件* 中，代码和数据段在虚拟内存中给定一个指定的基址。可执行代码不可共享，每个可执行文件都获得自己的地址空间。这意味着编译器确切地知道数据段在哪里，可以直接引用它。

库没有这样的保证。它们可以知道它们的数据段将是从基址开始的指定 *偏移量*；但确切的位置只能在运行时知道。

因此，所有库都必须生成可以在内存中任何位置执行的代码，这被称为 *位置无关代码*（或 PIC）。请注意，数据段仍然是从代码段的固定偏移量；但要找到数据的确切地址，需要将偏移量加到加载地址上。





## 3 全局偏移表

你可能在考虑共享库的目标时注意到了重定位的一个关键问题。我们之前提到，具有虚拟内存的共享库的一个大优势是多个程序可以通过页面共享来使用内存中的代码。

问题源于库没有关于它们将在内存中放置位置的保证。动态链接器将为每个所需的库在虚拟内存中找到最方便的位置并将其放置在那里。想想如果这种情况不发生会发生什么；系统中的每个库都需要自己的虚拟内存块，以便不重叠。每次向系统中添加新的库时，都需要分配。有人可能会写一个 *巨大的* 库，没有为其他库留下足够的空间！而且，你的程序可能根本不想使用那个库。

因此，如果你修改了带有重定位的共享库代码，那么这段代码就不再可共享了。我们失去了共享库的优势。

下面我们解释实现这一机制的方法。

### 3.1 全局偏移表

所以想象一下这样的情况，我们取一个符号的值。只有重定位的话，动态链接器会查找该符号的内存地址，并重新编写代码来加载该地址。

一个相当直接的功能增强是在我们的二进制文件中预留空间来保存该符号的地址，并让动态链接器将地址放在那里而不是直接放在代码中。这样我们就永远不需要触摸二进制文件的代码部分。

为这些地址预留的区域称为全局偏移表，或 GOT。GOT 位于 ELF 文件的 `.got` 部分。

![为了保持代码（绿色）可共享，我们定义了进程私有区域，我们可以将公共变量的地址存储在其中。这允许我们在进程地址空间的任何位置加载代码，同时仍然共享底层物理页面。](img/got-plt.svg)图 3.1.1 通过 GOT 的内存访问

GOT 对每个进程是私有的，并且进程必须对其有写权限。相反，库代码是共享的，进程应该只有对代码的读和执行权限；如果进程可以修改代码，那将是一个严重的安全漏洞。

#### 3.1.1 GOT 的作用

```cpp
 1 |$ cat got.c 
 |extern int i; 
 |
 |void test(void) 
 5 |{ 
 | i = 100; 
 |} 
 |
 |$ gcc -nostdlib  -shared -o got.so ./got.c 
10 |
 |$ objdump --disassemble ./got.so 
 |
 |./got.so:     file format elf64-ia64-little 
 |
15 |Disassembly of section .text: 
 |
 |0000000000000410 <test>: 
 | 410:   0d 10 00 18 00 21       [MFI]       mov r2=r12 
 | 416:   00 00 00 02 00 c0                   nop.f 0x0 
20 | 41c:   81 09 00 90                         addl r14=24,r1;; 
 | 420:   0d 78 00 1c 18 10       [MFI]       ld8 r15=[r14] 
 | 426:   00 00 00 02 00 c0                   nop.f 0x0 
 | 42c:   41 06 00 90                         mov r14=100;; 
 | 430:   11 00 38 1e 90 11       [MIB]       st4 [r15]=r14 
25 | 436:   c0 00 08 00 42 80                   mov r12=r2 
 | 43c:   08 00 84 00                         br.ret.sptk.many b0;; 
 |
 |$ readelf --sections ./got.so 
 |There are 17 section headers, starting at offset 0x640: 
30 |
 |Section Headers: 
 | [Nr] Name              Type             Address           Offset 
 | Size              EntSize          Flags  Link  Info  Align 
 | [ 0]                   NULL             0000000000000000  00000000 
35 | 0000000000000000  0000000000000000           0     0     0 
 | [ 1] .hash             HASH             0000000000000120  00000120 
 | 00000000000000a0  0000000000000004   A       2     0     8 
 | [ 2] .dynsym           DYNSYM           00000000000001c0  000001c0 
 | 00000000000001f8  0000000000000018   A       3     e     8 
40 | [ 3] .dynstr           STRTAB           00000000000003b8  000003b8 
 | 000000000000003f  0000000000000000   A       0     0     1 
 | [ 4] .rela.dyn         RELA             00000000000003f8  000003f8 
 | 0000000000000018  0000000000000018   A       2     0     8 
 | [ 5] .text             PROGBITS         0000000000000410  00000410 
45 | 0000000000000030  0000000000000000  AX       0     0     16 
 | [ 6] .IA_64.unwind_inf PROGBITS         0000000000000440  00000440 
 | 0000000000000018  0000000000000000   A       0     0     8 
 | [ 7] .IA_64.unwind     IA_64_UNWIND     0000000000000458  00000458 
 | 0000000000000018  0000000000000000  AL       5     5     8 
50 | [ 8] .data             PROGBITS         0000000000010470  00000470 
 | 0000000000000000  0000000000000000  WA       0     0     1 
 | [ 9] .dynamic          DYNAMIC          0000000000010470  00000470 
 | 0000000000000100  0000000000000010  WA       3     0     8 
 | [10] .got              PROGBITS         0000000000010570  00000570 
55 | 0000000000000020  0000000000000000 WAp       0     0     8 
 | [11] .sbss             NOBITS           0000000000010590  00000590 
 | 0000000000000000  0000000000000000   W       0     0     1 
 | [12] .bss              NOBITS           0000000000010590  00000590 
 | 0000000000000000  0000000000000000  WA       0     0     1 
60 | [13] .comment          PROGBITS         0000000000000000  00000590 
 | 0000000000000026  0000000000000000           0     0     1 
 | [14] .shstrtab         STRTAB           0000000000000000  000005b6 
 | 000000000000008a  0000000000000000           0     0     1 
 | [15] .symtab           SYMTAB           0000000000000000  00000a80 
65 | 0000000000000258  0000000000000018          16    12     8 
 | [16] .strtab           STRTAB           0000000000000000  00000cd8 
 | 0000000000000045  0000000000000000           0     0     1 
 |Key to Flags: 
 | W (write), A (alloc), X (execute), M (merge), S (strings) 
70 | I (info), L (link order), G (group), x (unknown) 
 | O (extra OS processing required) o (OS specific), p (processor specific) 

```

示例 3.1.1.1 使用 GOT

在上面，我们创建了一个简单的共享库，它引用了一个外部符号。我们在编译时不知道这个符号的地址，所以我们将其留给动态链接器在运行时修复。

但我们希望我们的代码保持可共享，以防其他进程也想使用我们的代码。

反汇编揭示了我们是如何使用 `.got` 来做到这一点的。在 IA64（库编译的架构）中，寄存器 `r1` 被称为 *全局指针*，总是指向 `.got` 部分被加载到内存的位置。

如果我们查看 `readelf` 输出，我们可以看到 `.got` 部分从库被加载到内存中的位置开始偏移了 0x10570 字节。因此，如果库被加载到内存地址 0x6000000000000000，`.got` 将位于 0x6000000000010570，寄存器 `r1` 总是指向这个地址。

通过反汇编回溯，我们可以看到我们将值 100 存储在寄存器 `r15` 所持有的内存地址中。如果我们回顾一下，我们可以看到寄存器 15 持有寄存器 14 中存储的内存地址的值。再往回一步，我们看到我们通过向寄存器 1 加一个小的数字来找到这个地址。GOT 简单来说是一个长长的条目列表，每个外部变量一个。这意味着外部变量 `i` 的 GOT 条目存储了 24 字节（即 3 个 64 位地址）。

```cpp
1 |$ readelf --relocs ./got.so 
 |
 |Relocation section '.rela.dyn' at offset 0x3f8 contains 1 entries: 
 | Offset          Info           Type           Sym. Value    Sym. Name + Addend 
5 |000000010588  000f00000027 R_IA64_DIR64LSB   0000000000000000 i + 0 

```

示例 3.1.1.2 对 GOT 的重定位

我们也可以检查这个条目的重定位。重定位说明“将偏移量 10588 处的值替换为符号 i 存储的内存位置”。

我们知道 `.got` 从上一个输出的偏移量 0x10570 开始。我们也看到了代码如何加载比这多 0x18（十进制的 24）的地址，给我们一个地址 0x10570 + 0x18 = 0x10588 ... 这就是重定位的地址！

因此，在程序开始之前，动态加载器将修复重定位，以确保内存偏移量 0x10588 处的值是全局变量`i`的地址！





## 4 库

### 4.1 程序查找表（PLT）

库可能包含许多函数，一个程序可能需要包含许多库来完成其工作。一个程序可能只使用每个库中可用的一个或两个函数，并且根据代码的运行时路径，可能使用一些函数而不用其他函数。

正如我们所见，动态链接的过程是一个相当计算密集型的过程，因为它涉及到查找和搜索许多表。任何可以减少开销的事情都会提高性能。

程序查找表（PLT）促进了程序中所谓的“惰性绑定”。绑定与上述 GOT 中变量定位的修复过程同义。当一个条目被“修复”后，它就被说成是“绑定”到其实际地址。

正如我们提到的，有时一个程序会从一个库中包含一个函数，但实际上从未调用过该函数，这取决于用户输入。绑定此函数的过程相当复杂，涉及到加载代码、搜索表和写入内存。通过绑定一个未使用的函数的过程纯粹是浪费时间。

惰性绑定通过使用 PLT 将这种开销推迟到实际函数被调用时。

每个库函数在 PLT 中都有一个条目，最初指向一些特殊的虚拟代码。当程序调用函数时，它实际上调用 PLT 条目（就像变量通过 GOT 引用一样）。

这个虚拟函数将加载一些需要传递给动态加载器的参数，以便它能够解析函数，然后调用动态加载器的特殊查找函数。动态加载器找到函数的真实地址，并将该位置写入调用二进制文件中虚拟函数调用的上方。

因此，下次函数被调用时，可以加载地址而无需再次进入动态加载器。如果一个函数从未被调用，那么 PLT 条目将不会被修改，但不会有运行时开销。

#### 4.1.1 PLT 的实际应用

这里的事情开始变得有点复杂！至少，你应该开始欣赏解析动态符号所涉及的相当多的工作！

让我们考虑简单的“Hello World”应用程序。这个程序只会调用一次库中的`printf`函数，将字符串输出给用户。

```cpp
 1 |
 | $ cat hello.c 
 |#include <stdio.h> 
 |
 5 |int main(void) 
 |{ 
 | printf("Hello, World!\n"); 
 | return 0; 
 |} 
10 |
 |$ gcc -o hello hello.c 
 |
 |$ readelf --relocs ./hello 
 |
15 |Relocation section '.rela.dyn' at offset 0x3f0 contains 2 entries: 
 | Offset          Info           Type           Sym. Value    Sym. Name + Addend 
 |6000000000000ed8  000700000047 R_IA64_FPTR64LSB  0000000000000000 _Jv_RegisterClasses + 0 
 |6000000000000ee0  000900000047 R_IA64_FPTR64LSB  0000000000000000 __gmon_start__ + 0 
 |
20 |Relocation section '.rela.IA_64.pltoff' at offset 0x420 contains 3 entries: 
 | Offset          Info           Type           Sym. Value    Sym. Name + Addend 
 |6000000000000f10  000200000081 R_IA64_IPLTLSB    0000000000000000 printf + 0 
 |6000000000000f20  000800000081 R_IA64_IPLTLSB    0000000000000000 __libc_start_main + 0 
 |6000000000000f30  000900000081 R_IA64_IPLTLSB    0000000000000000 __gmon_start__ + 0 

```

示例 4.1.1.1 “Hello World” PLT 示例

我们在上面可以看到，我们有一个针对`printf`符号的`R_IA64_IPLTLSB`重定位。这意味着“将符号 printf 的地址放入内存地址 0x6000000000000f10”。我们必须深入挖掘以找到获取函数的确切过程。

下面我们查看程序`main()`函数的汇编代码。

```cpp
 1 |
 | 4000000000000790 : 
 |4000000000000790:       00 08 15 08 80 05       [MII]       alloc r33=ar.pfs,5,4,0 
 |4000000000000796:       20 02 30 00 42 60                   mov r34=r12 
 5 |400000000000079c:       04 08 00 84                         mov r35=r1 
 |40000000000007a0:       01 00 00 00 01 00       [MII]       nop.m 0x0 
 |40000000000007a6:       00 02 00 62 00 c0                   mov r32=b0 
 |40000000000007ac:       81 0c 00 90                         addl r14=72,r1;; 
 |40000000000007b0:       1c 20 01 1c 18 10       [MFB]       ld8 r36=[r14] 
10 |40000000000007b6:       00 00 00 02 00 00                   nop.f 0x0 
 |40000000000007bc:       78 fd ff 58                         br.call.sptk.many b0=4000000000000520 <_init+0xb0> 
 |40000000000007c0:       02 08 00 46 00 21       [MII]       mov r1=r35 
 |40000000000007c6:       e0 00 00 00 42 00                   mov r14=r0;; 
 |40000000000007cc:       01 70 00 84                         mov r8=r14 
15 |40000000000007d0:       00 00 00 00 01 00       [MII]       nop.m 0x0 
 |40000000000007d6:       00 08 01 55 00 00                   mov.i ar.pfs=r33 
 |40000000000007dc:       00 0a 00 07                         mov b0=r32 
 |40000000000007e0:       1d 60 00 44 00 21       [MFB]       mov r12=r34 
 |40000000000007e6:       00 00 00 02 00 80                   nop.f 0x0 
20 |40000000000007ec:       08 00 84 00                         br.ret.sptk.many b0;; 

```

示例 4.1.1.2 Hello world main()

对 0x4000000000000520 的调用必须是我们调用`printf`函数。我们可以通过查看`readelf`的输出找到这个位置。

```cpp
 1 |
 | $ readelf --sections ./hello 
 |There are 40 section headers, starting at offset 0x25c0: 
 |
 5 |Section Headers: 
 | [Nr] Name              Type             Address           Offset 
 | Size              EntSize          Flags  Link  Info  Align 
 | [ 0]                   NULL             0000000000000000  00000000 
 | 0000000000000000  0000000000000000           0     0     0 
10 |... 
 | [11] .plt              PROGBITS         40000000000004c0  000004c0 
 | 00000000000000c0  0000000000000000  AX       0     0     32 
 | [12] .text             PROGBITS         4000000000000580  00000580 
 | 00000000000004a0  0000000000000000  AX       0     0     32 
15 | [13] .fini             PROGBITS         4000000000000a20  00000a20 
 | 0000000000000040  0000000000000000  AX       0     0     16 
 | [14] .rodata           PROGBITS         4000000000000a60  00000a60 
 | 000000000000000f  0000000000000000   A       0     0     8 
 | [15] .opd              PROGBITS         4000000000000a70  00000a70 
20 | 0000000000000070  0000000000000000   A       0     0     16 
 | [16] .IA_64.unwind_inf PROGBITS         4000000000000ae0  00000ae0 
 | 00000000000000f0  0000000000000000   A       0     0     8 
 | [17] .IA_64.unwind     IA_64_UNWIND     4000000000000bd0  00000bd0 
 | 00000000000000c0  0000000000000000  AL      12     c     8 
25 | [18] .init_array       INIT_ARRAY       6000000000000c90  00000c90 
 | 0000000000000018  0000000000000000  WA       0     0     8 
 | [19] .fini_array       FINI_ARRAY       6000000000000ca8  00000ca8 
 | 0000000000000008  0000000000000000  WA       0     0     8 
 | [20] .data             PROGBITS         6000000000000cb0  00000cb0 
30 | 0000000000000004  0000000000000000  WA       0     0     4 
 | [21] .dynamic          DYNAMIC          6000000000000cb8  00000cb8 
 | 00000000000001e0  0000000000000010  WA       5     0     8 
 | [22] .ctors            PROGBITS         6000000000000e98  00000e98 
 | 0000000000000010  0000000000000000  WA       0     0     8 
35 | [23] .dtors            PROGBITS         6000000000000ea8  00000ea8 
 | 0000000000000010  0000000000000000  WA       0     0     8 
 | [24] .jcr              PROGBITS         6000000000000eb8  00000eb8 
 | 0000000000000008  0000000000000000  WA       0     0     8 
 | [25] .got              PROGBITS         6000000000000ec0  00000ec0 
40 | 0000000000000050  0000000000000000 WAp       0     0     8 
 | [26] .IA_64.pltoff     PROGBITS         6000000000000f10  00000f10 
 | 0000000000000030  0000000000000000 WAp       0     0     16 
 | [27] .sdata            PROGBITS         6000000000000f40  00000f40 
 | 0000000000000010  0000000000000000 WAp       0     0     8 
45 | [28] .sbss             NOBITS           6000000000000f50  00000f50 
 | 0000000000000008  0000000000000000  WA       0     0     8 
 | [29] .bss              NOBITS           6000000000000f58  00000f50 
 | 0000000000000008  0000000000000000  WA       0     0     8 
 | [30] .comment          PROGBITS         0000000000000000  00000f50 
50 | 00000000000000b9  0000000000000000           0     0     1 
 | [31] .debug_aranges    PROGBITS         0000000000000000  00001010 
 | 0000000000000090  0000000000000000           0     0     16 
 | [32] .debug_pubnames   PROGBITS         0000000000000000  000010a0 
 | 0000000000000025  0000000000000000           0     0     1 
55 | [33] .debug_info       PROGBITS         0000000000000000  000010c5 
 | 00000000000009c4  0000000000000000           0     0     1 
 | [34] .debug_abbrev     PROGBITS         0000000000000000  00001a89 
 | 0000000000000124  0000000000000000           0     0     1 
 | [35] .debug_line       PROGBITS         0000000000000000  00001bad 
60 | 00000000000001fe  0000000000000000           0     0     1 
 | [36] .debug_str        PROGBITS         0000000000000000  00001dab 
 | 00000000000006a1  0000000000000001  MS       0     0     1 
 | [37] .shstrtab         STRTAB           0000000000000000  0000244c 
 | 000000000000016f  0000000000000000           0     0     1 
65 | [38] .symtab           SYMTAB           0000000000000000  00002fc0 
 | 0000000000000b58  0000000000000018          39    60     8 
 | [39] .strtab           STRTAB           0000000000000000  00003b18 
 | 0000000000000479  0000000000000000           0     0     1 
 |Key to Flags: 
70 | W (write), A (alloc), X (execute), M (merge), S (strings) 
 | I (info), L (link order), G (group), x (unknown) 
 | O (extra OS processing required) o (OS specific), p (processor specific) 

```

示例 4.1.1.3 Hello world 部分

这个地址（不出所料）在`.plt`部分。所以，我们在这里调用了 PLT！但我们并不满足于此，让我们继续深入挖掘，看看我们能发现什么。我们反汇编`.plt`部分，看看这个调用实际上做了什么。

```cpp
 1 |
 | 40000000000004c0 <.plt>: 
 |40000000000004c0:       0b 10 00 1c 00 21       [MMI]       mov r2=r14;; 
 |40000000000004c6:       e0 00 08 00 48 00                   addl r14=0,r2 
 5 |40000000000004cc:       00 00 04 00                         nop.i 0x0;; 
 |40000000000004d0:       0b 80 20 1c 18 14       [MMI]       ld8 r16=[r14],8;; 
 |40000000000004d6:       10 41 38 30 28 00                   ld8 r17=[r14],8 
 |40000000000004dc:       00 00 04 00                         nop.i 0x0;; 
 |40000000000004e0:       11 08 00 1c 18 10       [MIB]       ld8 r1=[r14] 
10 |40000000000004e6:       60 88 04 80 03 00                   mov b6=r17 
 |40000000000004ec:       60 00 80 00                         br.few b6;; 
 |40000000000004f0:       11 78 00 00 00 24       [MIB]       mov r15=0 
 |40000000000004f6:       00 00 00 02 00 00                   nop.i 0x0 
 |40000000000004fc:       d0 ff ff 48                         br.few 40000000000004c0 <_init+0x50>;; 
15 |4000000000000500:       11 78 04 00 00 24       [MIB]       mov r15=1 
 |4000000000000506:       00 00 00 02 00 00                   nop.i 0x0 
 |400000000000050c:       c0 ff ff 48                         br.few 40000000000004c0 <_init+0x50>;; 
 |4000000000000510:       11 78 08 00 00 24       [MIB]       mov r15=2 
 |4000000000000516:       00 00 00 02 00 00                   nop.i 0x0 
20 |400000000000051c:       b0 ff ff 48                         br.few 40000000000004c0 <_init+0x50>;; 
 |4000000000000520:       0b 78 40 03 00 24       [MMI]       addl r15=80,r1;; 
 |4000000000000526:       00 41 3c 70 29 c0                   ld8.acq r16=[r15],8 
 |400000000000052c:       01 08 00 84                         mov r14=r1;; 
 |4000000000000530:       11 08 00 1e 18 10       [MIB]       ld8 r1=[r15] 
25 |4000000000000536:       60 80 04 80 03 00                   mov b6=r16 
 |400000000000053c:       60 00 80 00                         br.few b6;; 
 |4000000000000540:       0b 78 80 03 00 24       [MMI]       addl r15=96,r1;; 
 |4000000000000546:       00 41 3c 70 29 c0                   ld8.acq r16=[r15],8 
 |400000000000054c:       01 08 00 84                         mov r14=r1;; 
30 |4000000000000550:       11 08 00 1e 18 10       [MIB]       ld8 r1=[r15] 
 |4000000000000556:       60 80 04 80 03 00                   mov b6=r16 
 |400000000000055c:       60 00 80 00                         br.few b6;; 
 |4000000000000560:       0b 78 c0 03 00 24       [MMI]       addl r15=112,r1;; 
 |4000000000000566:       00 41 3c 70 29 c0                   ld8.acq r16=[r15],8 
35 |400000000000056c:       01 08 00 84                         mov r14=r1;; 
 |4000000000000570:       11 08 00 1e 18 10       [MIB]       ld8 r1=[r15] 
 |4000000000000576:       60 80 04 80 03 00                   mov b6=r16 
 |400000000000057c:       60 00 80 00                         br.few b6;; 

```

示例 4.1.1.4 Hello world PLT

让我们逐步执行指令。首先，我们将 80 加到`r1`中的值，将其存储在`r15`中。我们知道之前`r1`将指向 GOT，所以这是说“在 GOT 中存储 80 个字节到`r15`”。接下来，我们将 GOT 中这个位置的值加载到`r16`中，并将`r15`中的值增加 8 个字节。然后我们将 GOT 的位置（`r1`）存储在`r14`中，并将`r1`设置为`r15`之后下一个 8 字节的值。然后我们跳转到`r16`。

在上一章中，我们讨论了函数实际上是通过一个包含函数地址和全局指针地址的函数描述符来调用的。在这里，我们可以看到 PLT 条目首先加载函数值，然后移动 8 个字节到函数描述符的第二部分，然后将该值加载到操作寄存器中，最后调用函数。

但我们到底在加载什么呢？我们知道`r1`将指向 GOT。我们在 GOT 之后走 80 个字节（0x50）。

```cpp
 1 |
 | $ objdump --disassemble-all ./hello` 
 |Disassembly of section .got: 
 |
 5 |`6000000000000ec0 <.got>: 
 | ... 
 |6000000000000ee8:       80 0a 00 00 00 00                   data8 0x02a000000 
 |6000000000000eee:       00 40 90 0a                         dep r0=r0,r0,63,1 
 |6000000000000ef2:       00 00 00 00 00 40       [MIB] (p20) break.m 0x1 
10 |6000000000000ef8:       a0 0a 00 00 00 00                   data8 0x02a810000 
 |6000000000000efe:       00 40 50 0f                         br.few 6000000000000ef0 <_GLOBAL_OFFSET_TABLE_+0x30> 
 |6000000000000f02:       00 00 00 00 00 60       [MIB] (p58) break.m 0x1 
 |6000000000000f08:       60 0a 00 00 00 00                   data8 0x029818000 
 |6000000000000f0e:       00 40 90 06                         br.few 6000000000000f00 <_GLOBAL_OFFSET_TABLE_+0x40> 
15 |Disassembly of section .IA_64.pltoff: 
 |
 |6000000000000f10 <.IA_64.pltoff>: 
 |6000000000000f10:       f0 04 00 00 00 00       [MIB] (p39) break.m 0x0 
 |6000000000000f16:       00 40 c0 0e 00 00                   data8 0x03b010000 
20 |6000000000000f1c:       00 00 00 60                         data8 0xc000000000 
 |6000000000000f20:       00 05 00 00 00 00       [MII] (p40) break.m 0x0 
 |6000000000000f26:       00 40 c0 0e 00 00                   data8 0x03b010000 
 |6000000000000f2c:       00 00 00 60                         data8 0xc000000000 
 |6000000000000f30:       10 05 00 00 00 00       [MIB] (p40) break.m 0x0 
25 |6000000000000f36:       00 40 c0 0e 00 00                   data8 0x03b010000 
 |6000000000000f3c:       00 00 00 60                         data8 0xc000000000 

```

示例 4.1.1.5 Hello world GOT

0x6000000000000ec0 + 0x50 = 0x6000000000000f10，或者`.IA_64.pltoff`部分。现在我们开始有所进展了！

我们可以解码 objdump 的输出，这样我们就可以看到这里具体加载了什么。交换前 8 个字节`f0 04 00 00 00 00 00 40`的顺序，我们得到`0x4000000000004f0`。现在这个地址看起来很熟悉！回顾 PLT 的汇编输出，我们看到这个地址。

`0x4000000000004f0`地址处的代码首先将零值放入`r15`，然后跳转回`0x40000000000004c0`。等等！那是我们 PLT 部分的开始。

我们也可以跟踪这段代码。首先，我们保存全局指针（`r2`）的值，然后我们将三个 8 字节值加载到`r16`、`r17`和最后，`r1`。然后我们跳转到`r17`中的地址。我们在这里看到的是对动态链接器的实际调用！

我们需要深入研究 ABI（应用程序二进制接口）来了解在这个点上具体加载了什么。ABI 说明了两点——动态链接程序必须有一个特殊的部分（称为`DT_IA_64_PLT_RESERVE`部分），它可以存储三个 8 字节的值。在二进制的动态段中有一个指针指向这个预留区域。

```cpp
 1 |
 |
 |Dynamic segment at offset 0xcb8 contains 25 entries: 
 | Tag        Type                         Name/Value 
 5 | 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6.1] 
 | 0x000000000000000c (INIT)               0x4000000000000470 
 | 0x000000000000000d (FINI)               0x4000000000000a20 
 | 0x0000000000000019 (INIT_ARRAY)         0x6000000000000c90 
 | 0x000000000000001b (INIT_ARRAYSZ)       24 (bytes) 
10 | 0x000000000000001a (FINI_ARRAY)         0x6000000000000ca8 
 | 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes) 
 | 0x0000000000000004 (HASH)               0x4000000000000200 
 | 0x0000000000000005 (STRTAB)             0x4000000000000330 
 | 0x0000000000000006 (SYMTAB)             0x4000000000000240 
15 | 0x000000000000000a (STRSZ)              138 (bytes) 
 | 0x000000000000000b (SYMENT)             24 (bytes) 
 | 0x0000000000000015 (DEBUG)              0x0 
 | 0x0000000070000000 (IA_64_PLT_RESERVE)  0x6000000000000ec0 -- 0x6000000000000ed8 
 | 0x0000000000000003 (PLTGOT)             0x6000000000000ec0 
20 | 0x0000000000000002 (PLTRELSZ)           72 (bytes) 
 | 0x0000000000000014 (PLTREL)             RELA 
 | 0x0000000000000017 (JMPREL)             0x4000000000000420 
 | 0x0000000000000007 (RELA)               0x40000000000003f0 
 | 0x0000000000000008 (RELASZ)             48 (bytes) 
25 | 0x0000000000000009 (RELAENT)            24 (bytes) 
 | 0x000000006ffffffe (VERNEED)            0x40000000000003d0 
 | 0x000000006fffffff (VERNEEDNUM)         1 
 | 0x000000006ffffff0 (VERSYM)             0x40000000000003ba 
 | 0x0000000000000000 (NULL)               0x0 

```

示例 4.1.1.6 动态段

你注意到什么了吗？它的值与 GOT 相同。这意味着 GOT 中的前三个 8 字节条目实际上是预留区域；因此，它们总是由全局指针指向。

当动态链接器启动时，它的职责是填写这些值。ABI 说第一个值将由动态链接器填写，给这个 *模块* 一个唯一的 ID。第二个值是动态链接器的全局指针值，第三个值是找到并修复符号的函数的地址。

```cpp
 1 |
 | /* Set up the loaded object described by L so its unrelocated PLT 
 | entries will jump to the on-demand fixup code in dl-runtime.c.  */ 
 |
 5 |static inline int __attribute__ ((unused, always_inline)) 
 |elf_machine_runtime_setup (struct link_map *l, int lazy, int profile) 
 |{ 
 | extern void _dl_runtime_resolve (void); 
 | extern void _dl_runtime_profile (void); 
10 |
 | if (lazy) 
 | { 
 | register Elf64_Addr gp __asm__ ("gp"); 
 | Elf64_Addr *reserve, doit; 
15 |
 | /* 
 | * Careful with the typecast here or it will try to add l-l_addr 
 | * pointer elements 
 | */ 
20 | reserve = ((Elf64_Addr *) 
 | (l->l_info[DT_IA_64 (PLT_RESERVE)]->d_un.d_ptr + l->l_addr)); 
 | /* Identify this shared object.  */ 
 | reserve[0] = (Elf64_Addr) l; 
 |
25 | /* This function will be called to perform the relocation.  */ 
 | if (!profile) 
 | doit = (Elf64_Addr) ((struct fdesc *) &_dl_runtime_resolve)->ip; 
 | else 
 | { 
30 | if (GLRO(dl_profile) != NULL 
 | && _dl_name_match_p (GLRO(dl_profile), l)) 
 | { 
 | /* This is the object we are looking for.  Say that we really 
 | want profiling and the timers are started.  */ 
35 | GL(dl_profile_map) = l; 
 | } 
 | doit = (Elf64_Addr) ((struct fdesc *) &_dl_runtime_profile)->ip; 
 | } 
 |
40 | reserve[1] = doit; 
 | reserve[2] = gp; 
 | } 
 |
 | return lazy; 
45 |} 

```

示例 4.1.1.7 动态链接器中设置特殊值的代码（来自 libc `sysdeps/ia64/dl-machine.h`）

我们可以通过查看为二进制文件执行此操作的函数来了解这是如何由动态链接器设置的。`reserve` 变量是从二进制文件中的 PLT_RESERVE 部分指针设置的。唯一值（放入 `reserve[0]`）是此对象的*链接映射*的地址。链接映射是 `glibc` 内部对共享对象的内部表示。然后我们将 `_dl_runtime_resolve` 的地址放入第二个值（假设我们没有使用分析）。`reserve[2]` 最终被设置为 gp，这是通过 `__asm__` 调用从 r2 中找到的。

回顾一下 ABI，我们看到入口点的重定位索引必须放在 `r15` 中，而唯一标识符必须通过 `r16` 传递。

`r15` 在存根代码中之前已经被设置，在我们跳回到 PLT 的起始处之前。向下查看条目，注意每个 PLT 条目是如何将 `r15` 加载为一个递增值的？如果你查看重定位，`printf` 重定位是编号零，这应该不会让你感到惊讶。

`r16` 我们从动态链接器初始化的值中加载，正如之前所讨论的。一旦准备好，我们就可以加载函数地址和全局指针，并跳转到该函数。

在这一点上发生的事情是动态链接器函数 `_dl_runtime_resolve` 被运行。它找到重定位；还记得重定位是如何指定符号名称的吗？它使用这个名称来找到正确的函数；这可能涉及到从磁盘加载库（如果它尚未在内存中），或者以其他方式共享代码。

重定位记录为动态链接器提供了它需要的“修复”地址；记得它是在 GOT 中，并且由初始 PLT 存根加载的吗？这意味着在函数第一次被调用后，第二次加载它将获得函数的直接地址；绕过动态链接器。

#### 4.1.2 概述

你已经看到了 PLT 背后的*确切*机制，以及动态链接器的内部工作原理。需要记住的重要点是

+   你的程序中的库调用实际上调用二进制 PLT 中的存根代码。

+   那个存根代码加载一个地址并跳转到它。

+   初始时，该地址指向动态链接器中的一个函数，该函数能够根据该函数的重定位条目中的信息查找“真实”的函数。

+   动态链接器重写存根代码读取的地址，这样下次调用该函数时，它将直接跳转到正确的地址。





## 5 与库和链接器一起工作

动态链接器的存在为我们提供了可以利用的一些优势，以及需要解决的一些额外问题，以获得一个功能性的系统。

### 5.1 库版本

一个潜在的问题是库的不同版本。只有静态库时，出现问题的可能性要小得多，因为所有库代码都是直接构建到应用程序的二进制文件中的。如果你想使用库的新版本，你需要将其重新编译到一个新的二进制文件中，替换旧的版本。

这对于常见的库来说显然相当不实用，最常见的是当然包括在大多数应用程序中的 libc。如果它只能作为静态库提供，任何更改都需要系统中每个应用程序都重新构建。

然而，动态库工作方式的变化可能会引起多个问题。在最好的情况下，修改是完全兼容的，并且没有外部可见的变化。另一方面，变化可能会导致应用程序崩溃；例如，如果一个函数曾经接受一个 `int`，现在改为接受一个 `int *`。更糟糕的是，新的库版本可能已经改变了语义，突然开始静默地返回不同的、可能是错误的价值。这可能会是一个非常棘手的错误，尝试追踪它；当应用程序崩溃时，你可以使用调试器来隔离错误发生的位置，而数据损坏或修改可能只会在应用程序看似无关的部分显示出来。

动态链接器需要一种方法来确定系统内库的版本，以便可以识别新修订版本。现代动态链接器可以使用多种方案来找到库的正确版本。

#### 5.1.1  `sonames`

使用 `sonames` 我们可以向库中添加一些额外信息，以帮助识别版本。

正如我们之前所看到的，应用程序在二进制文件的动态部分中的 `DT_NEEDED` 字段中列出它所需的库。实际的库存储在磁盘上的一个文件中，通常在 `/lib` 中为内核系统库，或在 `/usr/lib` 中为可选库。

为了允许库的多个版本存在于磁盘上，它们显然需要不同的文件名。`soname` 方案通过名称和文件系统链接的组合来构建库的层次结构。

这是通过引入 *主要* 和 *次要* 库修订的概念来实现的。一个次要修订是与库的先前版本完全向后兼容的；这通常只包括错误修复。因此，任何不兼容的修订都是主要修订；例如，更改函数的输入或函数的行为方式。

由于每个库版本（无论是主要版本还是次要版本）都需要在磁盘上单独保存到一个文件中，这构成了库层次结构的基础。按照惯例，库的名称是`libNAME.so.MAJOR.MINOR`。你可以选择在次要数字之后有一个*发布*作为最终的标识符。通常这足以区分所有不同的库版本。然而，如果每个应用程序都直接链接到这个文件，我们就会遇到与静态库相同的问题；每次发生次要更改时，我们都需要重新构建应用程序以指向新的库。

我们真正想要引用的是库的*主要*号。如果这个数字发生变化，我们合理地需要重新编译我们的应用程序，因为我们需要确保我们的程序仍然与新库兼容。

因此，`soname`是`libNAME.so.MAJOR`。`soname`应该在共享库的动态部分的`DT_SONAME`字段中设置；库作者可以在构建库时指定这个版本。

因此，磁盘上的每个次要版本库文件都可以在其`DT_SONAME`字段中指定相同的较大版本号，这样动态链接器就可以知道这个特定的库文件实现了库 API 和 ABI 的特定主要版本。

为了跟踪这一点，通常会运行一个名为 ldconfig 的应用程序来创建指向系统上最新次要版本的以主要版本命名的符号链接。ldconfig 通过遍历实现特定主要修订号的库，然后选择具有最高次要修订号的库。然后，它创建一个从`libNAME.so.MAJOR`到磁盘上实际库文件的符号链接，即`libNAME.so.MAJOR.MINOR`。

XXX : 讨论 libtool 版本

层次结构的最后一部分是库的*编译名称*。当你编译程序时，要链接到库，你使用`-lNAME`标志，它会搜索库搜索路径中的`libNAME.so`文件。然而，请注意，我们没有指定任何版本号；我们只想链接到系统上的最新库。创建编译`libNAME.so`名称和系统上最新库代码之间的符号链接是库安装过程的责任。通常这由你的包管理系统（dpkg 或 rpm）处理。这不是一个自动化的过程，因为系统上最新的库可能不是你总是想编译的库；例如，如果最新安装的库是一个开发版本，不适合一般使用。

以下图示了整个过程。

<picture>![描述 soname 系统](img/libs.svg)</picture>图 5.1.1.1  `sonames`

##### 5.1.1.1 动态链接器如何查找库

当应用程序启动时，动态链接器查看`DT_NEEDED`字段以找到所需的库。该字段包含库的`soname`，因此下一步是动态链接器遍历其搜索路径中的所有库以查找它。

这个过程在概念上涉及两个步骤。首先，动态链接器需要搜索所有库以找到实现给定`soname`的库。其次，需要比较次要版本的文件名以找到最新版本，然后就可以加载了。

我们之前提到，ldconfig 在库的`soname`和最新次要版本之间设置了一个符号链接。因此，动态链接器只需要跟随该链接来找到正确的文件进行加载，而不是每次应用程序需要时都要打开所有可能的库并决定使用哪一个。

由于文件系统访问非常慢，ldconfig 还创建了一个系统上安装的库的*缓存*。这个缓存只是一个动态链接器可用的库的`soname`列表以及指向磁盘上主要版本链接的指针，从而节省了动态链接器读取整个目录的文件来定位正确链接的需要。您可以使用/sbin/ldconfig -p 来分析它；它实际上位于文件`/etc/ldconfig.so.cache`中。如果库未在缓存中找到，动态链接器将回退到较慢的选项，即遍历文件系统，因此当安装新库时重新运行 ldconfig 非常重要。

### 5.2 寻找符号

我们已经讨论了动态链接器如何获取库函数的地址并将其放入程序的 PLT 中。但到目前为止，我们还没有讨论动态链接器是如何找到函数地址的。整个过程被称为*绑定*，因为符号名称被绑定到它所代表的地址。

符号表中的动态链接器有一些信息；首先，它正在搜索的*符号*，其次是一个符号可能存在的库列表，如二进制中的`DT_NEEDED`字段所定义的。

每个共享对象库都有一个标记为`SHT_DYNSYM`并称为`.dynsym`的部分，这是动态链接所需的最小符号集——也就是说，库中任何可能被外部程序调用的符号。

#### 5.2.1 动态符号表

实际上，有三个部分都参与了描述动态符号。首先，让我们看看 ELF 规范中对符号的定义

```cpp
1 |typedef struct { 
 | Elf32_Word    st_name; 
 | Elf32_Addr    st_value; 
 | Elf32_Word    st_size; 
5 | unsigned char st_info; 
 | unsigned char st_other; 
 | Elf32_Half    st_shndx; 
 |} Elf32_Sym; 

```

示例 5.2.1.1 从 ELF 符号表中定义符号

| 字段 | 值 |
| --- | --- |
| `st_name` | 字符串表的*索引* |
| `st_value` | 值 - 在可重定位的共享对象中，这包含从`st_shndx`中给出的索引部分的偏移量 |
| `st_size` | 符号相关的任何大小 |
| `st_info` | 符号绑定信息（如下所述）以及此符号的类型（函数、对象等） |
| `st_other` | 目前未使用 |
| `st_shndx` | 符号所在的节索引（见 `st_value` |

如您所见，符号名称的实际字符串保存在一个单独的节（`.dynstr`；`.dynsym` 节中的条目仅包含字符串节的索引。这为动态链接器创建了一些开销；动态链接器必须读取 `.dynsym` 节中的所有符号条目，然后跟随索引指针找到用于比较的符号名称。

为了加快这个过程，引入了一个名为 `.hash` 的第三部分，其中包含符号名称到符号表条目的哈希表。这个哈希表在库构建时预先计算，使得动态链接器能够更快地找到符号条目，通常只需要一两次查找。

#### 5.2.2 符号绑定

虽然我们通常说查找符号地址的过程是绑定该符号的过程，但 *符号绑定* 有一个不同的含义。

符号的绑定决定了它在动态链接过程中的外部可见性。一个 *局部* 符号在其定义的对象文件之外是不可见的。一个 *全局* 符号对其他对象文件可见，并且可以满足其他对象中的未定义引用。

一个 *弱引用* 是一种特殊类型的低优先级全局引用。这意味着它被设计为可以被覆盖，正如我们很快就会看到的。

下面我们有一个示例 C 程序，我们分析它以检查符号绑定。

```cpp
 1 |$ cat test.c 
 |static int static_variable; 
 |
 |extern int extern_variable; 
 5 |
 |int external_function(void); 
 |
 |int function(void) 
 |{ 
10 | return external_function(); 
 |} 
 |
 |static int static_function(void) 
 |{ 
15 | return 10; 
 |} 
 |
 |#pragma weak weak_function 
 |int weak_function(void) 
20 |{ 
 | return 10; 
 |} 
 |
 |$ gcc -c test.c 
25 |$ objdump --syms test.o 
 |
 |test.o:     file format elf32-powerpc 
 |
 |SYMBOL TABLE: 
30 |00000000 l    df *ABS*  00000000 test.c 
 |00000000 l    d  .text  00000000 .text 
 |00000000 l    d  .data  00000000 .data 
 |00000000 l    d  .bss   00000000 .bss 
 |00000038 l     F .text  00000024 static_function 
35 |00000000 l    d  .sbss  00000000 .sbss 
 |00000000 l     O .sbss  00000004 static_variable 
 |00000000 l    d  .note.GNU-stack        00000000 .note.GNU-stack 
 |00000000 l    d  .comment       00000000 .comment 
 |00000000 g     F .text  00000038 function 
40 |00000000         *UND*  00000000 external_function 
 |0000005c  w    F .text  00000024 weak_function 
 |
 |$ nm test.o 
 | U external_function 
45 |00000000 T function 
 |00000038 t static_function 
 |00000000 s static_variable 
 |0000005c W weak_function 

```

5.2.2.1 示例 5.2.2.1 符号绑定示例

注意使用 `#pragma` 来定义弱符号。`pragma` 是向编译器传达额外信息的一种方式；它的使用并不常见，但有时是必需的，以便让编译器执行非标准操作。

我们使用两种不同的工具检查符号；在两种情况下，绑定都显示在第二列；代码应该是相当直接的（在工具的手册页中有文档）。

##### 5.2.2.1 覆盖符号

对于程序员来说，能够覆盖库中的符号通常非常有用；也就是说，用不同的定义来颠覆正常的符号。

我们提到库的搜索顺序由库中 `DT_NEEDED` 字段的顺序给出。然而，可以将库作为最后搜索的库插入；这意味着它们中的任何符号都将作为最终引用找到。

这通过一个名为 `LD_PRELOAD` 的环境变量来完成，该变量指定了链接器应该最后加载的库。

```cpp
 1 |$ cat override.c 
 |#define _GNU_SOURCE 1 
 |#include <stdio.h> 
 |#include <stdlib.h> 
 5 |#include <unistd.h> 
 |#include <sys/types.h> 
 |#include <dlfcn.h> 
 |
 |pid_t getpid(void) 
10 |{ 
 | pid_t (*orig_getpid)(void) = dlsym(RTLD_NEXT, "getpid"); 
 | printf("Calling GETPID\n"); 
 |
 | return orig_getpid(); 
15 |} 
 |
 |$ cat test.c 
 |#include <stdio.h> 
 |#include <stdlib.h> 
20 |#include <unistd.h> 
 |
 |int main(void) 
 |{ 
 | printf("%d\n", getpid()); 
25 |} 
 |
 |$ gcc -shared -fPIC -o liboverride.so override.c -ldl 
 |$ gcc -o test test.c 
 |$ LD_PRELOAD=./liboverride.so ./test 
30 |Calling GETPID 
 |15187 

```

5.2.2.1.1 示例 5.2.2.1.1 `LD_PRELOAD` 示例

在上面的例子中，我们覆盖了 `getpid` 函数，以便在调用时打印出一个小声明。我们使用 `libc` 提供的 `dlysm` 函数，并通过一个参数告诉它继续查找下一个名为 `getpid` 的符号。

##### 5.2.2.1.1 随时间变化的弱符号

*弱* 符号的概念是，符号被标记为低优先级，可以被另一个符号覆盖。只有在没有找到其他实现时，弱符号才会被使用。

对于动态加载器来说，这一逻辑的扩展是所有库都应该被加载，并且那些库中的任何弱符号都应该被忽略，以便处理任何其他库中的正常符号。这确实是 Linux 上 glibc 最初实现弱符号处理的方式。

然而，这实际上与当时 Unix 标准的字面意思不符 (*SysVr4*)。标准实际上规定，弱符号应由 *静态* 链接器处理；它们应该与动态链接器无关（参见下面的绑定顺序部分）。

当时，Linux 实现动态链接器覆盖弱符号与 SGI 的 IRIX 平台相匹配，但与其他平台如 Solaris 和 AIX 不同。当开发者意识到这种行为违反了标准时，它被逆转了，旧的行为被降级为需要设置特殊的环境标志 (*LD_DYNAMIC_WEAK*)。

##### 5.2.2.2 指定绑定顺序

我们已经看到，我们可以通过 *预加载* 另一个具有相同符号定义的共享库来覆盖另一个库中的函数。最终解析的符号是动态加载器加载库的顺序中的最后一个。

库的加载顺序是它们在二进制文件的 `DT_NEEDED` 标志中指定的顺序。这反过来又是由构建对象时在命令行上传递的库的顺序决定的。当要定位符号时，动态链接器从最后加载的库开始，反向工作，直到找到符号。

然而，一些共享库需要一种方法来覆盖这种行为。它们需要告诉动态链接器“首先在我内部查找这些符号，而不是从最后加载的库反向工作”。库可以通过在它们的动态节标题中设置 `DT_SYMBOLIC` 标志来获得这种行为（这通常是通过在构建共享库时在静态链接器命令行上传递 `-Bsymbolic` 标志来设置的）。

这个标志的作用是控制 *符号可见性*。库中的符号不能被覆盖，因此可以被认为是加载的库的私有符号。

然而，这失去了很多粒度，因为库要么被标记为这种行为，要么没有被标记。一个更好的系统会允许我们使一些符号私有，而使一些符号公共。

##### 5.2.2.3 符号版本化

更好的系统来自符号版本化。通过符号版本化，我们向静态链接器提供一些额外的输入，以便它对我们的共享库中的符号有更多的信息。

```cpp
 1 |$ cat Makefile 
 |all: test testsym 
 |
 |clean: 
 5 | rm -f *.so test testsym 
 |
 |liboverride.so : override.c 
 | $(CC) -shared -fPIC -o liboverride.so override.c 
 |
10 |libtest.so : libtest.c 
 | $(CC) -shared -fPIC -o libtest.so libtest.c 
 |
 |libtestsym.so : libtest.c 
 | $(CC) -shared -fPIC -Wl,-Bsymbolic -o libtestsym.so libtest.c 
15 |
 |test : test.c libtest.so liboverride.so 
 | $(CC) -L. -ltest -o test test.c 
 |
 |testsym : test.c libtestsym.so liboverride.so 
20 | $(CC) -L. -ltestsym -o testsym test.c 
 |
 |$ cat libtest.c 
 |#include <stdio.h> 
 |
25 |int foo(void) { 
 | printf("libtest foo called\n"); 
 | return 1; 
 |} 
 |
30 |int test_foo(void) 
 |{ 
 | return foo(); 
 |} 
 |
35 |$ cat override.c 
 |#include <stdio.h> 
 |
 |int foo(void) 
 |{ 
40 | printf("override foo called\n"); 
 | return 0; 
 |} 
 |
 |$ cat test.c 
45 |#include <stdio.h> 
 |
 |int main(void) 
 |{ 
 | printf("%d\n", test_foo()); 
50 |} 
 |
 |$ cat Versions 
 |{global: test_foo;  local: *; }; 
 |
55 |$ gcc -shared -fPIC -Wl,-version-script=Versions -o libtestver.so libtest.c 
 |
 |$ gcc -L. -ltestver -o testver test.c 
 |
 |$ LD_LIBRARY_PATH=. LD_PRELOAD=./liboverride.so ./testver 
60 |libtest foo called 
 |
 |100000574 l     F .text	00000054              foo 
 |000005c8 g     F .text	00000038              test_foo 

```

示例 5.2.2.3.1 符号版本化的示例

在最简单的情况下，如上所述，我们只需声明符号是*全局*还是*局部*。因此，在上面的例子中，`foo`函数很可能是`test_foo`的支持函数；虽然我们很高兴让`test_foo`函数的整体功能被覆盖，但如果我们确实使用了共享库版本，它需要保持未更改的访问权限，任何人都不能修改支持函数。

这使我们能够更好地组织我们的*命名空间*。许多库可能想要实现一些可能被命名为像`read`或`write`这样的通用函数；然而，如果它们都这样做，程序实际接收到的版本可能完全错误。通过将符号指定为*局部*的，开发者可以确保没有任何东西会与那个内部名称冲突，反之亦然，他选择的名称不会影响任何其他程序。

此方案的一个扩展是*符号版本化*。使用它，你可以在同一库中指定同一符号的多个版本。静态链接器在符号名称后附加一些版本信息（例如`@VER`），描述符号的版本。

如果开发者实现了一个具有相同名称但可能二进制或程序上不同的实现的功能，他可以增加版本号。当构建针对共享库的新应用程序时，它们将获取符号的最新版本。然而，针对同一库的早期版本构建的应用程序将请求旧版本（例如，它们请求的符号名称中将包含旧的`@VER`字符串）并因此获取原始实现。XXX：示例





## 术语表

A

应用程序二进制接口

操作系统应该如何与硬件接口的技术描述。

参见 应用程序编程接口。

应用程序编程接口

用于在程序的不同部分之间通信的变量和函数集。

参见 应用程序二进制接口。

E

可扩展标记语言

这里有一些合理的定义。

参见 标准化通用标记语言。

标准化通用标记语言

所有文档的鼻祖

参见 可扩展标记语言。

M

MMU

硬件架构中的*内存管理单元*组件。

互斥

当许多事物互斥时，一次只能有一个有效。其中一件事情的有效性使得其他事情无效。

O

开源

在保证任何人都可以自由使用、修改和重新分发代码的许可证下分发的软件。

S

Shell

用于与操作系统交互的接口。


