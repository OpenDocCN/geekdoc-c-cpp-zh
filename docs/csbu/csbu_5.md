<main class="calibre3">

## 第六章 虚拟内存

</main>

<main class="calibre3">

## 1 虚拟内存*不是什么*

虚拟内存通常被天真地讨论为通过使用硬盘作为额外的、较慢的系统内存来扩展你的 RAM。也就是说，一旦你的系统内存不足，它就会流到硬盘上，硬盘被用作“虚拟”内存。

在现代操作系统中，这通常被称为*交换空间*，因为未使用的内存部分被交换到磁盘上以释放主内存（记住，程序只能从主内存中执行）。

事实上，将内存交换到磁盘的能力是一个重要的功能，但正如你将看到的，这并不是虚拟内存的目的，而是一个非常有用的副作用！

</main>

<main class="calibre3">

## 2 虚拟内存*是什么*

虚拟内存全部关于利用*地址空间*。

处理器的地址空间指的是它在加载和存储到内存时可以使用的可能地址的范围。地址空间受寄存器宽度的限制，因为我们知道要加载一个地址，我们需要发出一个带有要加载地址的`load`指令，该地址存储在寄存器中。例如，32 位宽的寄存器可以存储从`0x00000000`到`0xFFFFFFF`的地址。2^³²等于 4GB，所以 32 位处理器可以加载或存储多达 4GB 的内存。

### 2.1 64 位计算

新处理器通常是 64 位处理器，正如其名称所暗示的，具有 64 位宽的寄存器。作为一个练习，你应该计算出这些处理器可用的地址空间（提示：它很大！）。

64 位计算与使用较小位宽处理器相比有一些权衡。在 64 位模式下编译的每个程序都需要 8 字节的指针，这可能会增加代码和数据的大小，从而影响指令和数据缓存性能。然而，64 位处理器通常具有更多的寄存器，这意味着当编译器处于寄存器压力之下时，不需要将临时变量保存到内存中。

#### 2.1.1 规范地址

虽然 64 位处理器具有 64 位宽的寄存器，但系统通常不会实现所有 64 位用于寻址——实际上不可能对理论上的 16 艾字节物理内存的所有 16 艾字节进行`load`或`store`操作！

因此，大多数架构定义了一个*未实现*的地址空间区域，处理器将认为该区域无效且不可用。x86-64 和 Itanium 都定义了地址的最重要有效位，然后必须对其进行符号扩展（见第 2.3.1.3.1 节，符号扩展）以创建一个有效的地址。结果是，整个地址空间实际上被分为两部分，一个上部分和一个下部分，中间的地址被认为是无效的。这如图 2.1.1.1 所示，有效地址被称为*规范地址*（无效地址被称为*非规范*地址）。

<picture>![通过定义一个必须进行符号扩展以创建完整地址的最高有效位，地址空间实际上被划分为上部分和下部分，中间地址被处理器视为无效。](img/canonical.svg)</picture>图 2.1.1.1 标准地址的说明

处理器的确切最高有效位值通常可以通过使用其信息指令查询处理器本身来找到。尽管确切值取决于实现，但典型值可能是 48；提供 2⁴⁸ = 256 TiB 的可用地址空间。

以这种方式减少可能的地址空间意味着处理器和相关组件的地址逻辑部分可以节省大量空间，因为它们知道它们不需要处理完整的 64 位地址。由于实现定义了高位为有符号扩展，这防止了可移植操作系统使用这些位来存储或标记附加信息，并确保如果实现希望在将来实现更多地址空间时保持兼容性。

### 2.2 使用地址空间

与操作系统的许多组件一样，虚拟内存充当了地址空间和系统可用物理内存之间的抽象。这意味着当一个程序使用一个地址时，该地址并不指向内存中实际物理位置的位。

因此，从这个意义上说，我们说程序使用的所有地址都是*虚拟*的。操作系统跟踪虚拟地址以及它们如何分配到*物理*地址。当程序从一个地址进行加载或存储时，处理器和操作系统一起工作，将这个虚拟地址转换为系统内存芯片中的实际地址。

</main>

<main class="calibre3">

## 3 页面

总地址空间被划分为单独的*页面*。页面可以有不同的大小；通常它们大约是 4 KiB，但这并不是一个固定的规则，它们可以更大，但通常不会更小。页面是操作系统和硬件可以处理的最小内存单位。

此外，每个页面都有操作系统设置的若干属性。通常，这些包括当前页面的读取、写入和执行权限。例如，操作系统通常会给进程的代码页面标记一个可执行标志，处理器可以选择不执行没有设置此位的任何代码页面。

<picture>![Pages](img/page.svg)</picture>图 3.1 虚拟内存页面

程序员可能会在这个时候认为他们可以轻松地分配少量内存，远小于 4 KiB，使用`malloc`或类似的调用。这种*堆*内存实际上是由页面大小的分配支持的，`malloc`实现会以高效的方式为您分割和管理这些分配。

</main>

<main class="calibre3">

## 4 物理内存

正如操作系统将可能的地址空间划分为页面一样，它也将可用的物理内存划分为*帧*。帧只是与系统页面大小相同的物理内存块的传统名称。

操作系统维护一个*帧表*，这是一个所有可能的物理内存页面的列表，以及它们是否空闲（可用于分配）。当内存分配给一个进程时，它在帧表中标记为已使用。这样，操作系统就能跟踪所有内存分配。

操作系统如何知道哪些内存可用？有关内存位置、多少、属性等信息是在初始化过程中由 BIOS 传递给操作系统的。

</main>

<main class="calibre3">

## 5 页面 + 帧数 = 页面表

操作系统的任务是跟踪哪个虚拟页面指向哪个物理帧。这些信息保存在一个*页面表*中，在其最简单形式下，可以是一个表格，其中每一行包含其关联的帧——这被称为*线性页面表*。如果您使用这个简单的系统，在 32 位地址空间和 4 KiB 页面的情况下，页面表中需要跟踪的可能页面有 1048576 个（2³² ÷ 4096）；因此，表格将包含 1048576 个条目以确保我们总能将虚拟页面映射到物理页面。

页面表可以有多种不同的结构，并且高度优化，因为查找页面表中的页面可能是一个耗时的过程。我们将在稍后更深入地研究页面表。

进程的页面表完全由操作系统控制。当进程请求内存时，操作系统找到一个空闲的物理内存页面，并在进程的页面表中记录虚拟到物理的转换。相反，当进程释放内存时，虚拟到物理的记录被移除，底层帧变为空闲，可供其他进程分配。

</main>

<main class="calibre3">

## 6 虚拟地址

当程序访问内存时，它不知道或关心支持该地址的物理内存存储在哪里。它知道这取决于操作系统和硬件共同工作以定位正确的物理地址，从而提供对所需数据的访问。因此，我们将程序用于访问内存的地址称为*虚拟地址*。虚拟地址由两部分组成；页面和该页面的偏移量。

### 6.1 页面

由于整个可能的地址空间被划分为固定大小的页面，每个可能的地址都位于一个页面内。虚拟地址的页面部分充当页面表的索引。由于页面是系统内内存分配的最小单元，因此存在在使页面非常小、从而为操作系统管理提供非常多的页面，以及使页面更大但可能浪费内存之间的权衡。

### 6.2 偏移量

虚拟地址的最后几位称为*偏移量*，它是你想要的字节地址与页面起始位置之间的位置差异。你需要足够的偏移量位来能够到达页面中的任何字节。对于一个 4K 页面，你需要（4K == (4 * 1024) == 4096 == 2¹² ==) 12 位的偏移量。记住，操作系统或硬件处理的最小内存单位是一个页面，因此这些 4096 个字节都位于单个页面内，并被当作“一个”来处理。

### 6.3 虚拟地址转换

虚拟地址转换是指找出哪个物理页面映射到哪个虚拟页面的过程。

在将虚拟地址转换为物理地址时，我们只处理*页面号*。这个过程的核心是取给定地址的页面号，在*页表*中查找以找到指向物理地址的指针，然后加上虚拟地址的偏移量，给出系统内存中的实际位置。

由于页表受操作系统的控制，如果虚拟地址不在页表中，则操作系统知道进程正在尝试访问未分配给它的内存，访问将不被允许。

<picture>![将虚拟地址转换为物理地址](img/virtaddress.svg)</picture>图 6.3.1 虚拟地址转换

我们可以按照我们之前的简单*线性*页表示例来跟踪这个过程。我们计算出使用 4KiB 页面时，32 位地址空间需要一个包含 1048576 个条目的表。因此，要将理论地址 0x80001234 映射，第一步是移除偏移量位。在这种情况下，使用 4KiB 页面，我们知道我们有 12 位（2¹² == 4096）的偏移量。所以我们会将虚拟地址右移 12 位，留下 0x80001。因此（以十进制表示），线性页表第 524289 行的值将是与此页面对应的物理帧。

你可能会遇到线性页表的问题：由于每个页面都必须被考虑，无论是否使用，在 64 位地址空间中使用物理线性页表是完全不切实际的。考虑一个 64 位地址空间被分成 64 KiB 页面，这将创建 2⁶⁴/2¹⁶ = 2⁵²个页面需要管理；假设每个页面需要一个指向物理位置的 8 字节指针，总共需要 2⁵²*2³ = 2⁵⁵或 32 PiB 的连续内存仅用于页表！有方法可以分割地址来避免这种情况，我们将在后面讨论。

</main>

<main class="calibre3">

## 7 虚拟地址、页面和页表的影响

虚拟地址、页面和页表是每个现代操作系统的基石。它们支撑着我们使用系统的大部分功能。

### 7.1 单独的地址空间

通过为每个进程提供它自己的页表，每个进程都可以假装它有权访问处理器提供的整个地址空间。两个进程可能使用相同的地址无关紧要，因为每个进程的不同页表会将其映射到物理内存的不同帧。每个现代操作系统都以这种方式为每个进程提供自己的地址空间。

随着时间的推移，物理内存会变得*碎片化*，这意味着物理内存中会有“空洞”的空闲空间。不得不绕过这些空洞最多是令人烦恼的，并且会成为程序员的严重限制。例如，如果你`malloc` 8 KiB 的内存，需要两个 4 KiB 的帧作为后盾，如果这些帧必须连续（即，在物理上相邻），那将是非常令人怀疑的。使用虚拟地址则无关紧要；对于进程来说，它拥有 8 KiB 的连续内存，即使这些页面由相隔很远的帧支持。通过为每个进程分配一个虚拟地址空间，程序员可以将处理碎片化的问题留给操作系统。

### 7.2 保护

我们之前提到，386 处理器的虚拟模式被称为保护模式，这个名字来源于虚拟内存可以为运行在其上的进程提供的保护。

在没有虚拟内存的系统里，每个进程都可以完全访问整个系统内存。这意味着没有任何东西可以阻止一个进程覆盖另一个进程的内存，导致它崩溃（或者更糟，返回错误值，尤其是如果那个程序正在管理你的银行账户！）

这种级别的保护是因为操作系统现在是进程和内存访问之间的抽象层。如果一个进程提供了一个不在其页表覆盖范围内的虚拟地址，那么操作系统就知道该进程正在做错事，并且可以通知该进程它已经越界。

由于每个页面都有额外的属性，页面可以被设置为只读、只写或者具有任何数量的其他有趣属性。当进程尝试访问页面时，操作系统可以检查它是否有足够的权限，如果没有则阻止它（例如，向只读页面写入）。

使用虚拟内存的系统本质上更稳定，因为，假设操作系统是完美的，一个进程只能崩溃自己，而不能崩溃整个系统（当然，人类编写操作系统，我们不可避免地会忽略仍然可能导致整个系统崩溃的 bug）。

### 7.3 交换

我们现在也可以看到交换内存是如何实现的。如果页指针不是指向系统内存的一个区域，而是可以改变指向磁盘上的一个位置。

当引用这个页面时，操作系统需要将其从磁盘移动回系统内存（记住，程序代码只能从系统内存中执行）。如果系统内存已满，那么就需要将 *另一个* 页面从系统内存中移出并放入交换磁盘，然后才能将所需的页面放入内存。如果另一个进程想要那个刚刚被移出的页面，这个过程会重复。

这对于交换内存来说可能是一个大问题。从硬盘加载非常慢（与内存中的操作相比），大多数人都会熟悉坐在电脑前，硬盘不停地旋转，而系统却无响应的情况。

#### 7.3.1 mmap

一个不同但相关的过程是内存映射，或称为 `mmap`（来自系统调用名称）。如果页表不是指向物理内存或交换空间，而是指向磁盘上的文件，我们说这个文件被 `mmap` 了。

通常，你需要 `打开` 磁盘上的一个文件来获取文件描述符，然后以顺序形式 `读取` 和 `写入` 它。当一个文件被 mmap 时，它可以像系统 RAM 一样访问。

### 7.4 内存共享

通常，每个进程都有自己的页表，所以它使用的任何地址都会映射到物理内存中的一个唯一帧。但如果操作系统将两个页表条目指向同一个帧呢？这意味着这个帧将被共享；并且一个进程所做的任何更改都将对另一个进程可见。

你现在可以看到线程是如何实现的。在 第 4.3.1 节，`clone` 中，我们提到 Linux 的 `clone()` 函数可以根据需要与旧进程共享新进程的尽可能多或尽可能少的资源。如果一个进程调用 `clone()` 来创建新进程，但请求两个进程共享相同的页表，那么实际上就有一个 *线程*，因为两个进程都看到相同的底层物理内存。

你现在也可以看到写时复制的实现方式。如果你将页面的权限设置为只读，当进程尝试写入页面时，操作系统会收到通知。如果它知道这个页面是写时复制页面，那么它需要在系统内存中创建页面的新副本，并将页表中的页面指向这个新页面。然后可以更新其属性以具有写权限，进程就有页面的唯一副本。

### 7.5 磁盘缓存

在现代系统中，通常不是内存不足需要交换内存，而是系统当前使用的内存比可用的内存多。

内存层次结构告诉我们，磁盘访问比内存访问慢得多，所以尽可能将数据从磁盘移动到系统内存是有意义的。

Linux 以及许多其他系统，在它们使用文件时，会将磁盘上的数据复制到内存中。即使一个程序最初只请求文件的一小部分，它很可能在继续处理时还需要访问文件的其余部分。当操作系统需要读取或写入文件时，它首先检查文件是否在其内存缓存中。

当系统内存压力增加时，这些页面应该是首先被移除的。

#### 7.5.1 页缓存

在讨论内核时可能会听到的一个术语是*页缓存*。

*页缓存*指的是内核保持的页面列表，这些页面指向磁盘上的文件。从上面来看，交换页、mmap 页和磁盘缓存页都属于这一类。内核保持这个列表是因为它需要能够快速查找它们以响应读写请求 XXX：这部分内容似乎不适用？

</main>

<main class="calibre3">

## 8 硬件支持

到目前为止，我们只提到硬件与操作系统合作以实现虚拟内存。然而，我们忽略了具体是如何发生的细节。

虚拟内存必然非常依赖于硬件架构，每种架构都有其自己的细微差别。然而，硬件中的虚拟内存有一些普遍的元素。

### 8.1 物理模式与虚拟模式

所有处理器都有在*物理*或*虚拟*模式下运行的概念。在物理模式下，硬件期望任何地址都将指向实际系统内存中的地址。在虚拟模式下，硬件知道地址需要被转换以找到它们的物理地址。

在许多处理器中，这两种模式简单地被称为物理模式和虚拟模式。安腾（Itanium）就是这样一个例子。最常见的处理器 x86 有很多来自虚拟内存之前的遗留问题，因此这两种模式被称为*实*模式和*保护*模式。第一个实现保护模式的处理器是 386，即使是 x86 家族中最现代的处理器仍然可以执行实模式，尽管它不再使用。在实模式下，处理器实现了一种称为分段的内存组织形式。

#### 8.1.1 分段问题

分段实际上只作为一个历史性的注释而有趣，因为虚拟内存使其变得不那么相关。分段有几个缺点，其中最不重要的是它对经验不足的程序员来说非常复杂，而虚拟内存系统在很大程度上是为了绕过这些缺点而发明的。

在分段中，有一些寄存器持有地址，这个地址是段的起始点。到达内存中的地址的唯一方法是将它指定为从这些段寄存器之一的一个偏移量。段的大小（因此你可以指定的最大偏移量）由可用于从段基寄存器偏移的位数决定。在 x86 中，最大偏移量是 16 位，或者只有 64K。想象一下最大偏移量是 32 位；在这种情况下，整个地址空间都可以作为一个从`0x00000000`段偏移的偏移量来访问，你将基本上有一个平坦的布局--但它仍然不如虚拟内存好，你将看到。事实上，它之所以是 16 位，仅仅是因为原始的英特尔处理器被限制在这个范围内，芯片保持了向后兼容性。这如果在想要使用超过 64K 的地址时会导致各种混乱。随着内存增长到兆字节（现在甚至是吉字节），这变成了一个严重的不便，甚至可能导致完全失败。

<picture>![一个分段问题。你只有三个段寄存器，并且只能从每个段偏移一个短距离。你怎么到达另一个地址？你需要手动重新组织段寄存器，这很快就会变成一个瓶颈。](img/segmentation.svg)</picture>图 8.1.1.1 分段

在上面的图中，有三个段寄存器，它们都指向段。最大偏移量（由可用的位数限制）通过阴影显示。如果程序想要这个范围之外的地址，段寄存器必须重新配置。这很快就会变成一个主要的不便。另一方面，虚拟内存允许程序指定任何地址，操作系统和硬件则负责将这个地址转换成物理地址。

### 8.2 TLB

*转换查找缓冲区*（或简称 TLB）是处理器负责虚拟内存的主要组件。它是在处理器内部的一个虚拟页到物理帧转换的缓存。操作系统和硬件在系统运行时共同管理 TLB。

#### 8.2.1 页面错误

当硬件请求一个虚拟地址时--比如通过一个`load`指令请求获取一些数据--处理器会在其 TLB 中查找虚拟地址到物理地址的转换。如果它有一个有效的转换，它就可以将这个转换与偏移部分结合起来，直接访问物理地址并完成加载。

然而，如果处理器在 TLB 中找不到翻译，它必须引发一个*页面错误*。这类似于之前讨论过的中断，操作系统必须处理它。

当操作系统接收到页面错误时，它需要通过其页表来查找正确的翻译并将其插入到 TLB 中。

如果操作系统在页面表中找不到翻译，或者如果操作系统检查了相关页面的权限，并且进程未被授权访问，操作系统必须终止该进程。如果你曾经见过段错误（或 segfault），这就是操作系统终止越界进程的情况。

如果找到了翻译，并且当前 TLB 已满，那么在插入另一个翻译之前需要移除一个翻译。移除将来可能被使用的翻译没有意义，因为这会导致你再次在页面表中查找条目的成本。TLBs 通常使用类似*最近最少使用*（LRU）的算法，其中最老的未使用翻译将被新的翻译替换。

然后，可以再次尝试访问，如果一切顺利，应该会在 TLB 中找到并正确翻译。

##### 8.2.1.1 查找页面表

当我们说操作系统在页面表中找到翻译时，逻辑上会问操作系统是如何找到包含页面表的内存的。

页面表的基址将被保存在与每个进程关联的寄存器中。这通常被称为页面表基址寄存器或类似名称。通过取该寄存器中的地址并加上页面号，可以找到正确的条目。

#### 8.2.2 其他页面相关错误

TLB 通常可以生成两种其他重要的错误，这些错误有助于管理访问和脏页面。每个页面通常包含一个表示页面是否被访问或是否为脏的单比特属性。

被访问的页面简单地是指任何被访问过的页面。当页面翻译最初被加载到 TLB 中时，页面可以被标记为已访问（否则你为什么要加载它？实际上，如果你在没有待访问的情况下加载它，这将被称为*推测*，这是你期望它能带来回报时采取的行动。例如，如果代码线性地读取内存，将下一个页面翻译放入 TLB 可能会节省时间并提高性能。）

操作系统可以定期遍历**所有**页面并清除访问位，以了解当前哪些页面正在使用。当系统内存满时，操作系统需要选择将页面交换到磁盘，显然那些访问位未被重置的页面是移除的最佳候选者，因为它们未被使用的时间最长。

脏页面是指写入数据的页面，因此与磁盘上的任何数据都不匹配。例如，如果页面从交换区加载并由进程写入，在它可以从交换区移出之前，需要更新其磁盘上的副本。干净的页面没有变化，所以我们不需要将页面复制回磁盘的开销。

这两者在帮助操作系统管理页面方面是相似的。一般概念是页面有两个额外的位；脏位和访问位。当页面被放入 TLB 时，这些位被设置为指示 CPU 应该引发故障。

当进程尝试引用内存时，硬件会执行常规的转换过程。然而，它还会进行额外的检查，以查看访问标志是否*未*设置。如果是这样，它会向操作系统发出故障，操作系统应该设置该位并允许进程继续。同样，如果硬件检测到它正在写入一个没有设置脏位（dirty bit）的页面，它将向操作系统发出故障，以标记该页面为脏。

### 8.3 TLB 管理

我们可以说硬件使用的 TLB 由软件管理。操作系统负责将正确的条目加载到 TLB 中并删除旧条目。

#### 8.3.1 刷新 TLB

从 TLB 中删除条目的过程称为*刷新*。更新 TLB 是维护进程独立地址空间的关键部分；因为每个进程都可能使用相同的虚拟地址，如果不更新 TLB，则意味着一个进程可能会覆盖另一个进程的内存（相反，在*线程*共享地址空间的情况下，这是你所希望的，因此当在同一个进程之间切换线程时，TLB 不会被刷新）。

在某些处理器中，每次进行上下文切换时，整个 TLB 都会被刷新。这可能会相当昂贵，因为这意味着新进程将不得不经历整个页面故障、在页面表中查找页面并插入转换的过程。

其他处理器实现了一个额外的*地址空间标识符*（ASID），它被添加到每个 TLB 转换中，使其唯一。这意味着每个地址空间（通常是每个进程，但请记住线程想要共享相同的地址空间）都获得自己的 ID，该 ID 与 TLB 中的任何转换一起存储。因此，在上下文切换时，TLB 不需要被刷新，因为下一个进程将具有不同的地址空间 ID，即使它请求相同的虚拟地址，地址空间 ID 也会不同，因此物理页面的转换也会不同。这种方案减少了刷新并提高了整体系统性能，但需要更多的 TLB 硬件来存储 ASID 位。

通常，这是通过在进程状态中包含 ASID（地址空间标识符）的额外寄存器来实现的。在执行虚拟到物理转换时，TLB 会咨询这个寄存器，并且只会匹配具有与当前运行进程相同 ASID 的条目。当然，这个寄存器的宽度决定了可用的 ASID 数量，从而具有性能影响。有关处理器架构中 ASID 的示例，请参阅第 10.2.1 节，地址空间。

#### 8.3.2 硬件和软件加载的 TLB

虽然对 TLB 的控制是操作系统的领域；但这并不是全部。在 第 8.2.1 节，页面错误 中描述的过程描述了一个页面错误被提交给操作系统，它遍历页面表以找到虚拟到物理的转换并将其安装到 TLB 中。这被称为 *软件加载的 TLB* — 但还有另一种选择；*硬件加载的 TLB*。

在一个硬件加载的 TLB 中，处理器架构定义了页面表信息的特定布局（第五部分，页面 + 帧等于页面表，这是进行虚拟地址转换必须遵循的。对于 TLB 中不存在的虚拟地址的访问，处理器将自动遍历页面表以加载正确的转换条目。只有当转换条目不存在时，处理器才会引发异常，由操作系统处理。

在专用硬件中实现页面表遍历在查找转换时提供了速度优势，但减少了操作系统实现者实现页面表替代方案的灵活性。

所有架构都可以广泛地分为这两种方法。稍后，我们将检查一些常见的架构及其虚拟内存支持。

</main>

<main class="calibre3">

## 9 Linux 特性

虽然虚拟内存的基本概念保持不变，但实现的具体细节高度依赖于操作系统和硬件。

### 9.1 地址空间布局

Linux 将可用的地址空间划分为共享内核组件和私有用户空间地址。这意味着地址空间内核端口的地址映射到每个进程相同的物理内存，而用户空间地址对进程是私有的。在 Linux 中，共享内核空间位于可用地址空间的顶部。在最常见的处理器 32 位 x86 上，这种划分发生在 3GB 处。由于 32 位可以映射最大 4GB，这为共享内核区域留下了顶部 1GB。这不幸是一个过于简化的说法，因为许多机器希望支持每个进程超过 4GB。*高内存*支持允许处理器通过特殊扩展访问完整的 4GB。

<picture>![Linux 地址空间布局。注意，用户空间地址空间中的页面是私有的，而内核页面是共享的。](img/linux-layout.svg)</picture>图 9.1.1 Linux 地址空间布局

### 9.2 三级页面表

操作系统有许多不同的方式来组织页面表，但 Linux 选择使用 *分层*系统。

由于页面表使用的是深度为三级的层次结构，Linux 方案通常被称为*三级页面表*。三级页面表已被证明是一个稳健的选择，尽管它并非没有批评。每个处理器的虚拟内存实现细节各不相同，Whitley 意味着 Linux 选择的通用页面表必须是可移植的和相对通用的。

三级页面表的概念并不复杂。我们已经知道虚拟地址由页面号和物理内存页面中的偏移量组成。在三级页面表中，虚拟地址进一步分为*级别*数。

每一级都是它自己的页面表；即它映射一个物理页面的页面号。在单级页面表中，“级别 1”的条目会直接映射到物理框架。在多级版本中，每一级上级都给出包含下一级页面表的物理内存框架的地址。

<picture>![三级页面表](img/threelevel.svg)</picture>图 9.2.1 Linux 三级页面表

因此，一个示例引用涉及前往顶级页面表，找到包含下一级地址的物理框架，读取该级别的表，并找到包含下一级页面表的物理框架，依此类推。

起初，这个模型看起来过于复杂。这个模型实施的主要原因是为了考虑大小。想象一下这样一个理论情况：一个进程只有一个页面映射在其虚拟地址空间的末尾。我们之前说过，页面表条目是作为页面表基寄存器的偏移量来找到的，所以页面表需要在内存中是一个连续的数组。因此，地址空间末尾的单一页面需要整个数组，这可能会占用相当大的空间（许多许多物理页面的内存）。

在一个三级系统中，第一级仅是一个物理内存框架。这映射到第二级，它同样只是一个内存框架，再映射到第三级。因此，三级系统将所需的页面数量减少到单级系统所需数量的一个分数。

这个系统有明显的缺点。查找单个地址需要更多的引用，这可能会很昂贵。Linux 理解这个系统可能不适合许多不同类型的处理器，因此每个架构都可以轻松地将页面表*折叠*以减少级别（例如，最常用的架构 x86 在其实现中只使用两级系统）。

</main>

<main class="calibre3">

## 10 虚拟内存的硬件支持

如第 8.2 节，转换后备缓冲区（TLB）所述，处理器硬件提供了一个查找表，将虚拟地址链接到物理地址。每个处理器架构定义了不同的方式来管理 TLB，具有各种优点和缺点。

处理器中处理虚拟内存的部分通常被称为*内存管理单元*或 MMU

### 10.1 x86-64

XXX

### 10.2 Itanium

Itanium MMU 为操作系统提供了许多与虚拟内存一起工作的有趣功能。

#### 10.2.1 地址空间

第 8.3.1 节，刷新 TLB 介绍了*地址空间 ID*的概念，以减少在上下文切换时刷新 TLB 的开销。然而，程序员经常使用*线程*来允许执行上下文共享地址空间。每个线程都有相同的 ASID，因此共享 TLB 条目，从而提高了性能。然而，单个 ASID 阻止 TLB 执行保护；共享变成了一种“全有或全无”的方法。为了共享几个字节，线程必须放弃彼此之间的所有保护（参见第 7.2 节，保护）。

<picture>![Itanium 区域和保护键。在这个例子中，进程别名区域 1。每个进程都有一个私有映射，并共享另一个的密钥。](img/ia64-regions-keys.svg)</picture>图 10.2.1.1 Itanium 区域和保护键示意图

Itanium MMU 考虑了这些问题，并提供了在硬件中保持保护的同时，以更细粒度共享地址空间（以及相应的转换条目）的能力。Itanium 将 64 位地址空间划分为 8 个*区域*，如图图 10.2.1.1，Itanium 区域和保护键示意图所示。每个进程作为其状态的一部分拥有八个 24 位的*区域寄存器*，每个寄存器为进程地址空间的八个区域中的每一个保存一个*区域 ID*（RID）。TLB 转换被标记为 RID，因此只有当进程也持有此 RID 时才会匹配，如图图 10.2.1.2，Itanium TLB 转换示意图所示。

<picture>![Itanium 转换过程示意图（Mosberger）](img/ia64-tlb-translation.svg)</picture>图 10.2.1.2 Itanium TLB 转换示意图

此外，最高三位（区域位）在虚拟地址转换中不被考虑。因此，如果两个进程共享一个 RID（即，在它们的区域寄存器中持有相同的值），那么它们对该区域有一个别名视图。例如，如果进程-A 在区域寄存器 3 中持有 RID `0x100`，而进程-B 在区域寄存器 5 中也持有相同的 RID `0x100`，那么进程-A 的区域 3 被别名映射到进程-B 的区域 5。这种有限的共享意味着两个进程都能从共享的 TLB 条目中获得好处，而无需授予对它们整个地址空间的访问权限。

##### 10.2.1.1 保护键

为了允许更细粒度的共享，Itanium 上的每个 TLB 条目也被标记为*保护键*。每个进程在操作系统控制下有额外的*保护键寄存器*数量。

当一系列页面需要共享（例如，共享系统库的代码）时，每个页面都会被标记上唯一的关键字，操作系统授予允许访问页面的任何进程该关键字。当引用页面时，TLB 将检查与翻译条目关联的关键字与进程在其保护关键字寄存器中持有的关键字进行比对，如果存在关键字则允许访问，否则向操作系统引发*保护*故障。

关键字还可以强制执行权限；例如，一个进程可能有一个授予写权限的关键字，而另一个可能有一个只读关键字。这允许在更广泛的场景中共享翻译条目，粒度可以细到单页级别，从而带来 TLB 性能的巨大潜在改进。

#### 10.2.2 Itanium 硬件页表遍历器

在解决 TLB 缺失时切换上下文到操作系统会增加故障处理路径的显著开销。为了解决这个问题，Itanium 允许使用内置硬件读取页表并自动将虚拟到物理的转换加载到 TLB 中。硬件页表遍历器（HPW）避免了昂贵的操作系统转换，但需要转换以固定格式存在，以便硬件理解。

在英特尔文档中，Itanium HPW 被称为*虚拟哈希页表遍历器*或 VHPT 遍历器，原因将在下面变得清晰。Itanium 为开发者提供了两种互斥的 HPW 实现选项；一种基于虚拟线性页表，另一种基于哈希表。

应该注意的是，可以不使用硬件页表遍历器进行操作；在这种情况下，每个 TLB 缺失都由操作系统解决，处理器变成一个软件加载的架构。然而，禁用 HPW 的性能影响如此之大，因此不太可能从中获得任何好处。

##### 10.2.2.1 虚拟线性页表

在文档中，虚拟线性页表实现被称为*短格式虚拟哈希页表*（SF-VHPT）。它是 Linux 在 Itanium 上使用的默认 HPW 模型。

常见的解决方案是多级或分层页表，其中虚拟页号组成的位被用作页表中间级别的索引（参见第 9.2 节，三级页表）。虚拟地址空间的空区域在分层页表中根本不存在。与线性页表相比，对于（现实中的）紧密簇集和稀疏填充的地址空间，开销相对较小。主要的缺点是需要多次内存引用进行查找。

![分层页表](img/hierarchical-pt.svg)图 10.2.2.1.1 分层页表的示意图

在 64 位地址空间中，即使在第 6.3 节，虚拟地址转换中标识的 512~GiB 线性表也只占用 16 艾字节可用空间的 0.003%。因此，可以在虚拟地址空间的连续区域创建一个*虚拟线性页表*（VLPT）。

正如物理线性页表一样，在 TLB 缺失时，硬件使用虚拟页号从页表基址偏移。如果此条目有效，则读取转换并将其直接插入到 TLB 中。然而，对于 VLPT，转换条目的地址本身就是一个虚拟地址，因此存在这样一个可能性，即它所在的虚拟页不在 TLB 中。在这种情况下，会向操作系统引发一个*嵌套故障*。然后，软件必须通过将包含转换条目的页面映射到 VLPT 来纠正这个故障。

![Itanium 短格式 VHPT 的操作](img/ia64-short-format.svg)图 10.2.2.1.2 Itanium 短格式 VHPT 实现

如果操作系统保持一个分层页表，这个过程可以变得相当简单。分层页表的叶子页包含对地址连续区域的转换条目，因此可以通过 TLB 映射，如图 10.2.2.1.2，Itanium 短格式 VHPT 实现中所述来创建虚拟线性页表（VLPT）。

![Itanium PTE 条目格式](img/ia64-ptes.svg)图 10.2.2.1.3 Itanium PTE 条目格式

VLPT 的主要优势在于当应用程序对内存进行重复或连续访问时。考虑一下，对于虚拟连续内存的遍历，第一次故障会将一个包含转换条目的页面映射到虚拟线性页表中。对下一个虚拟页的后续访问将需要将下一个转换条目加载到 TLB 中，该条目现在在 VLPT 中可用，因此可以非常快速地加载，而不需要调用操作系统。总体而言，如果初始嵌套故障的成本在后续 HPW 命中中得到摊销，这将是一个优势。

主要缺点是 VLPT 现在需要 TLB 条目，这导致 TLB 压力增加。由于每个地址空间都需要自己的页表，当系统变得更加活跃时，开销变得更大。然而，任何 TLB 容量缺失的增加都应该通过高效的硬件遍历器的较低填充成本得到补偿。请注意，一个病态的情况可能会跳过`page_size` ÷ `translation_size`条目，导致重复的嵌套故障，但这是一个非常不可能的访问模式。

硬件页表期望以特定格式进行翻译条目，如图 10.2.2.1.3，Itanium PTE 条目格式左侧所示。VLPT 需要所谓的 8 字节*短格式*的翻译。如果操作系统要将其页表用作 VLPT 的后备（如在图 10.2.2.1.2，Itanium 短格式 VHPT 实现中所示），则必须使用此翻译格式。该架构描述了在此格式中有限数量的位被忽略，因此可供软件使用，但无法进行重大修改。

线性页表基于固定页面大小的想法。由于这意味着给定虚拟页的翻译不再位于一个常数偏移量，因此支持多个页面大小是有问题的。为了解决这个问题，地址空间的 8 个区域（图 10.2.1.1，Itanium 区域和保护键说明）中的每个区域都有一个单独的 VLPT，它只为该区域映射地址。可以为每个区域指定默认页面大小（实际上，在下面讨论的 Linux HugeTLB 中，一个区域被专门用于更大的页面）。然而，一个区域内的页面大小不能混合。

##### 10.2.2.2 虚拟哈希表

使用 TLB 条目以降低 TLB 填充成本，就像 SF-VHPT 所做的那样，可能或可能不是一种有效的权衡。Itanium 还实现了一个具有降低 TLB 开销潜力的*哈希页表*。在此方案中，处理器将虚拟地址*哈希*以找到连续表中的偏移量。

之前描述的物理线性页表可以被视为具有*完美*哈希函数的哈希页表，该函数永远不会产生冲突。然而，正如解释的那样，这需要巨大的连续物理内存区域的不切实际的权衡。然而，限制页表的内存需求提高了当两个虚拟地址哈希到相同的偏移时发生冲突的可能性。冲突的翻译需要一个*链*指针来构建一个包含替代可能条目的链表。要区分链表中的哪个条目是正确的，需要一个从传入的虚拟地址派生的*标签*。

每个翻译条目所需额外信息导致出现了*长格式*~VHPT（LF-VHPT）的别称。翻译条目增长到 32 字节，如图 10.2.2.1.3，Itanium PTE 条目格式右侧所示。

此方法的主要优势是全局哈希表可以通过单个 TLB 条目固定。由于所有进程共享该表，因此其扩展性应优于 SF-VHPT，在 SF-VHPT 中，每个进程需要越来越多的 TLB 条目来处理 VLPT 页面。然而，较大的条目对缓存不太友好；考虑我们可以在每个 32 字节的长期格式条目中放入四个 8 字节的短格式条目。Itanium 处理器上非常大的缓存可能有助于减轻这种影响。

SF-VHPT 的一个优点是操作系统可以将转换存储在分层页表中，并且只要硬件转换格式保持不变，就可以直接将叶页映射到 VLPT。使用 LF-VHPT 时，操作系统必须要么使用哈希表作为转换条目的主要来源，要么将哈希表作为其转换信息的缓存。将 LF-VHPT 的哈希表作为缓存存在一些次优性，因为会增加时间关键故障路径上的开销，然而，由于表格只需要一个 TLB 条目，因此也获得了一些优势。

</main>
