# 内联命名空间

内联命名空间旨在通过”版本”的概念，来实现库的演化。考虑如下代码：

```cpp
// 文件：V99.h
 inline namespace V99 {
         void f(int);     // 对 V98 版本进行改进
         void f(double);  // 新特性
         // …
 }
 // 文件：V98.h
 namespace V98 {
     void f(int);        // V98 版本只实现基本功能
     // …
 }
 // 文件：Mine.h
 namespace Mine {
 #include “V99.h”
 #include “V98.h”
 } 
```

上述命名空间 Mine 中同时包含了较新的版本(V99)以及早期的版本(V98)，如果你需要显式使用（某个版本的函数），你可以：

```cpp
#include “Mine.h”
using namespace Mine;
// …
V98::f(1);        // 早期版本
V99::f(1);        // 较新版本
f(1);            // 默认版本 
```

此处的要点在于，被 inline 修饰的内联命名空间，其内部所包含的所有类/函数/变量等声明，看起来就好像是直接在外围的命名空间中进行声明的一样。（译注：我们注意到，这里的 f(1)函数调用相当于显式调用 Mine::V99::f(1)，使用 inline 关键字定义的内联名字空间成为默认名字空间。 （就像内联函数一样，内联的名字空间被嵌入到它的外围名字空间，成为外围名字空间的一部分。 ）

inline 描述符是一个非常“静态(static)”及面向实现的设施，它由库的设计者选择在（某个版本 namespace 之前）放置，且一旦选定则库的所有使用者只能被动接受（译注：即命名空间的作者可以通过放置 inline 描述符来表示当前最新的命名空间是哪个，所以对用户来说，这个选择是“静态”的：用户无权判断哪个命名空间是最新的）。因此，Mine 命名空间的用户没法选择说：“我想要默认的命名空间为 V98，而非 V99”。

参考：

*   Standard 7.3.1 Namespace definition [7]-[9].

（翻译：dabaitu）