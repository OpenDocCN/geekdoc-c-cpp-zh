# 实现者应以什么顺序提供 C++11 特性？

# 实现者应以什么顺序提供 C++11 特性？

标准中并没有关于引入 C++0x 特性的顺序；它只是简单的列出了为了达到完整地 C++11 特性所需要做的事情。然而，如果实现者分阶段引入新的 C++0x 特性，我们也认为这是合理的。毕竟，我不会使用不支持的特性。所以，一个基于“易于提供”和“对多数人有用”的理念，是早期实现的关键原则。

*   没有功能特性的新库取决于新的语言特性，比如可变参数模板和常量表达式 constexpr。
*   简单且易于实现的特性将在细小但重要的地方帮助用户：
*   auto
*   enum class 枚举类
*   long long
*   nullptr 空指针
*   right brackets 右括号
*   static_assert 静态断言

帮助实现 C++11 标准库的语言特点：

*   常量表达式
*   初始化列表
*   一般的和统一的初始化 (包括 预防宽转窄)
*   右值引用
*   可变参数模板
*   标准库用到的所有特点

相关的并发特性：

*   memory model 内存模型
*   线程的本地化存储 thread_local
*   atomic types 原子类型
*   local types as template arguments 作为模板参数的局部类型
*   lambdas
*   标准库的完整支持
*   PODs

如果你看得仔细，你会发现我对很多语言特点（在引入这些特性的时间上）并没有看法。很自然地，我也希望这些特性能够被尽快地实现。但是，我并没有一个关于何时这些特性应该被实现的判断。显然，每一个 C++实现者都有自己的原则，所以我们不能期望他们步调一致，但是我希望他们可以稍微关注一下别人在做什么，这样可以让用户更早地开始他们的移植工作。

（翻译：nivo）