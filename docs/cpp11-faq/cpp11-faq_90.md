# 共享资源的智能指针——shared_ptr

# 共享资源的智能指针——shared_ptr

shared_ptr 被用来表示共享的拥有权。也就是说，当两段代码都需要访问一些数据，而它们又都没有独占该数据的所有权（从某种意义上来说就是该段代码负责销毁该对象）。这是我们就需要 shared_ptr。shared_ptr 是一种计数指针。当引用计数变为 0 时，shared_ptr 所指向的对象就会被删除。下面我们用一段代码来说明这点。

```cpp
void test()
{
    shared_ptr p1(new int);    // 计数是 1
    {
        shared_ptr p2(p1);    //计数是 2
        {
            shared_ptr p3(p1);    // 计数是 3
        }    //计数变为 2
    } //计数变为 1
}    // 在此，计数变为 0。同时 int 对象被删除 
```

现在来看一个更为实际的例子。在这个例子中，我们用指针指向图中的节点。一个需要解决的问题是当从一个节点上移除一个指针时并不知道时候还有其它指针指向这个节点。如果节点能够拥有一些资源，从而需要析构器采取一些行动（一个典型的例子就是文件句柄。当节点被检测到时，文件句柄相应的文件就会被关闭）。这样以来，通过 shared_ptr 就可以解决这个问题。你可以认为使用 shared_ptr 的目的和你使用垃圾回收器的目的是一样的。只是出处于经济性的考虑，你没有足够的垃圾，或者执行环境不允许那么做，或者所管理的资源不仅仅是内存（如文件句柄）。例如：

```cpp
struct Node {    // 注意：其它的节点也可能指向该节点
    shared_ptr left;
    shared_ptr right;
    File_handle f;
    // …
}; 
```

这里 Node 的析构器（隐式的析构器即可）删除了它的子节点。也就是说 Node 的析构器调用了 left 和 right 的析构器。因为 left 是一个 shared_ptr，所以当 left 是最后一个指向该 Node 的指针时，该节点将会被删除。处理 right 的方式和 left 的类似。f 的析构器将按照 f 的要求执行。

需要注意的是，当仅需要将一个指针从一个拥有者传个另一个时，你不应使用 shared_ptr。这是 unique_ptr 的用途。unique_ptr 会以更为小的开销来更好的实现这个功能。如果你曾经使用计数指针作为工厂函数的返回值或者类似的情形，可以考虑升级使用 unique_ptr 而不是 shared_ptr。

另外，不要不加思考地把指针替换为 shared_ptr 来防止内存泄露。shared_ptr 并不是万能的，而且使用它们的话也是需要一定的开销的：

*   环状的链式结构 shared_ptr 将会导致内存泄露（你需要一些逻辑上的复杂化来打破这个环。比如使用 weak_ptr）。
*   共享拥有权的对象一般比限定作用域的对象生存更久。从而将导致更高的平均资源使用时间。
*   在多线程环境中使用共享指针的代价非常大。这是因为你需要避免关于引用计数的数据竞争。
*   共享对象的析构器不会在预期的时间执行。
*   与非共享对象相比，在更新任何共享对象时，更容易犯算法或者逻辑上的错误。

shared_ptr 用于表示共享拥有权。然而共享拥有权并不是我的初衷。在我看来，一个更好的办法是为对象指明拥有者并且为对象定义一个可以预测的生存范围。

同时可参考：

*   the C++ draft: Shared_ptr (20.7.13.3)

（翻译：Yibo Zhu）