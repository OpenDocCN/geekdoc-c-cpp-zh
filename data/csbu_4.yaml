- en: <main class="calibre3">
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: Chapter 5. The Process
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章. 进程
- en: </main>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 1 What is a process?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 什么是进程？
- en: We are all familiar with the modern operating system running many tasks all
    at once or *multitasking*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都熟悉现代操作系统同时运行许多任务或*多任务处理*。
- en: We can think of each process as a bundle of elements kept by the kernel to keep
    track of all these running tasks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个进程视为内核保存的一组元素，用以跟踪所有这些正在运行的任务。
- en: </main>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 2 Elements of a process
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 进程的元素
- en: <picture>![The essential elements of a process; the process ID, memory, files
    and registers.](theprocess.svg)</picture>Figure 2.1 The Elements of a Process
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![进程的基本元素；进程ID、内存、文件和寄存器。](theprocess.svg)</picture>图2.1 进程的元素
- en: 2.1 Process ID
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 进程ID
- en: The *process ID* (or the PID) is assigned by the operating system and is unique
    to each running process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程ID*（或PID）由操作系统分配，并且对每个运行进程是唯一的。'
- en: 2.2 Memory
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 内存
- en: We will learn exactly how a process gets its memory in the following weeks --
    it is one of the most fundamental parts of how the operating system works. However,
    for now it is sufficient to know that each process gets its own section of memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几周里，我们将学习进程如何获得其内存——这是操作系统工作原理中最基本的组成部分之一。然而，现在我们只需要知道每个进程都有自己的内存部分。
- en: In this memory all the program code is stored, along with variables and any
    other allocated storage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个内存中存储了所有程序代码，以及变量和任何其他分配的存储空间。
- en: Parts of the memory can be shared between processes (called, not surprisingly
    *shared memory*). You will often see this called *System Five Shared Memory* (or
    SysV SHM) after the original implementation in an older operating system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的部分可以由进程共享（称为，不出所料的是*共享内存*）。你经常会看到在较老操作系统中原始实现之后，将其称为*系统五共享内存*（或SysV SHM）。
- en: Another important concept a process may utilise is that of *mmap*ing a file
    on disk to memory. This means that instead of having to open the file and use
    commands such as `read()` and `write()` the file looks as if it were any other
    type of RAM. `mmaped` areas have permissions such as read, write and execute which
    need to be kept track of. As we know, it is the job of the operating system to
    maintain security and stability, so it needs to check if a process tries to write
    to a read only area and return an error.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可能利用的另一个重要概念是将磁盘上的文件*mmap*到内存中。这意味着不需要打开文件并使用`read()`和`write()`等命令，文件看起来就像任何其他类型的RAM。`mmaped`区域具有读、写和执行等权限，需要跟踪。正如我们所知，维护安全和稳定是操作系统的职责，因此它需要检查进程是否尝试写入只读区域，并返回错误。
- en: 2.2.1 Code and Data
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1 代码和数据
- en: A process can be further divided into *code* and `data` sections. Program code
    and data should be kept separately since they require different permissions from
    the operating system and separation facilitates sharing of code (as you see later).
    The operating system needs to give program code permission to be read and executed,
    but generally not written to. On the other hand data (variables) require read
    and write permissions but should not be executableNot all architectures support
    this, however. This has lead to a wide range of security problems on many architectures..
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以进一步分为*代码*和`数据`部分。程序代码和数据应该分开存储，因为它们需要来自操作系统的不同权限，并且分离有助于代码的共享（正如你稍后看到的）。操作系统需要给予程序代码读取和执行的权限，但通常不写入。另一方面，数据（变量）需要读取和写入权限，但不应该可执行。然而，并非所有架构都支持这一点。这导致了许多架构上出现了广泛的安全问题。
- en: 2.2.2 The Stack
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2 栈
- en: One other very important part of a process is an area of memory called *the
    stack*. This can be considered part of the data section of a process, and is intimately
    involved in the execution of any program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的另一个非常重要的部分是称为*栈*的内存区域。这可以被认为是进程数据部分的一部分，并且与任何程序的执行密切相关。
- en: A stack is generic data structure that works exactly like a stack of plates;
    you can *push* an item (put a plate on top of a stack of plates), which then becomes
    the top item, or you can *pop* an item (take a plate off, exposing the previous
    plate).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种通用数据结构，其工作方式与盘子堆叠完全一样；你可以*push*一个项目（将盘子放在盘子堆的顶部），然后它成为顶部项目，或者你可以*pop*一个项目（取下盘子，露出下面的盘子）。
- en: Stacks are fundamental to function calls. Each time a function is called it
    gets a new `stack frame`. This is an area of memory which usually contains, at
    a minimum, the address to return to when complete, the input arguments to the
    function and space for local variables.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 栈对于函数调用是基本的。每次调用函数时，它都会获得一个新的`栈帧`。这是一个内存区域，通常至少包含完成时返回的地址、函数的输入参数以及局部变量的空间。
- en: By convention, stacks usually *grow down*Some architectures, such as PA-RISC
    from HP, have stacks that grow upwards. On some other architectures, such as IA64,
    there are other storage areas (the register backing store) that grow from the
    bottom toward the stack. . This means that the stack starts at a high address
    in memory and progressively gets lower.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，栈通常*向下增长*。一些架构，如惠普的PA-RISC，栈向上增长。在其他一些架构上，如IA64，有其他存储区域（寄存器后端存储）从底部向栈增长。这意味着栈从内存中的高地址开始，逐渐变低。
- en: <picture>![How the stack works with function calls. Note that the stack grows
    downwards, from high addresses in memory to low addresses.](stack.svg)</picture>Figure 2.2.2.1 The
    Stack
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![栈与函数调用的工作方式。注意栈向下增长，从内存中的高地址到低地址。](stack.svg)图2.2.2.1 栈'
- en: We can see how having a stack brings about many of the features of functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到拥有栈如何带来了许多函数的特性。
- en: Each function has its own copy of its input arguments. This is because each
    function is allocated a new stack frame with its arguments in a fresh area of
    memory.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数都有其输入参数的副本。这是因为每个函数都被分配了一个新的栈帧，其参数在一个新的内存区域中。
- en: This is the reason why a variable defined inside a function can not be seen
    by other functions. Global variables (which can be seen by any function) are kept
    in a separate area of data memory.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是为什么在函数内部定义的变量不能被其他函数看到的原因。全局变量（可以被任何函数看到）保存在数据内存的单独区域。
- en: This facilitates *recursive* calls. This means a function is free to call itself
    again, because a new stack frame will be created for all its local variables.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这促进了*递归*调用。这意味着一个函数可以自由地再次调用自己，因为将为所有局部变量创建一个新的栈帧。
- en: Each frame contains the address to return to. C only allows a single value to
    be returned from a function, so by convention this value is returned to the calling
    function in a specified register, rather than on the stack.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个帧都包含返回的地址。C语言只允许从函数返回单个值，因此按照惯例，这个值是通过指定的寄存器返回给调用函数的，而不是在栈上。
- en: Because each frame has a reference to the one before it, a debugger can "walk"
    backwards, following the pointers up the stack. From this it can produce a *stack
    trace* which shows you all functions that were called leading into this function.
    This is extremely useful for debugging.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为每个帧都有一个对之前帧的引用，调试器可以“向后走”，沿着栈上的指针向上跟踪。从这个角度来看，它可以生成一个*堆栈跟踪*，显示所有调用此函数之前调用的函数。这对于调试非常有用。
- en: You can see how the way functions works fits exactly into the nature of a stack.
    Any function can call any other function, which then becomes the up most function
    (put on top of the stack). Eventually that function will return to the function
    that called it (takes itself off the stack).
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到函数的工作方式如何完美地符合栈的本质。任何函数都可以调用任何其他函数，然后它成为最顶层的函数（放在栈顶）。最终，该函数将返回到调用它的函数（从栈中移除自己）。
- en: Stacks do make calling functions slower, because values must be moved out of
    registers and into memory. Some architectures allow arguments to be passed in
    registers directly; however to keep the semantics that each function gets a unique
    copy of each argument the registers must *rotate*.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈确实会使调用函数变慢，因为必须将值从寄存器移动到内存中。一些架构允许直接在寄存器中传递参数；然而，为了保持每个函数获得每个参数唯一副本的语义，寄存器必须*旋转*。
- en: You may have heard of the term a *stack overflow*. This is a common way of hacking
    a system by passing bogus values. If you as a programmer accept arbitrary input
    into a stack variable (say, reading from the keyboard or over the network) you
    need to explicitly say how big that data is going to be.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能听说过“*栈溢出*”这个术语。这是一种常见的通过传递虚假值来黑客攻击系统的方法。如果你作为一个程序员接受任意输入到栈变量中（比如从键盘读取或通过网络），你需要明确说明数据的大小。
- en: Allowing any amount of data unchecked will simply overwrite memory. Generally
    this leads to a crash, but some people realised that if they overwrote just enough
    memory to place a specific value in the return address part of the stack frame,
    when the function completed rather than returning to the correct place (where
    it was called from) they could make it return into the data they just sent. If
    that data contains binary executable code that hacks the system (e.g. starts a
    terminal for the user with root privileges) then your computer has been compromised.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许任意数量的数据未经检查就会简单地覆盖内存。通常这会导致崩溃，但有些人意识到，如果他们覆盖足够的内存来在栈帧的返回地址部分放置特定的值，当函数完成时，它不会返回到正确的位置（即它被调用的地方），而是可以使其返回到他们刚刚发送的数据中。如果这些数据包含可以篡改系统的二进制可执行代码（例如，以root权限为用户启动一个终端），那么你的计算机已经被入侵。
- en: This happens because the stack grows downwards, but data is read in "upwards"
    (i.e. from lower address to higher addresses).
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为栈向下增长，但数据是以“向上”的方式读取的（即从低地址到高地址）。
- en: There are several ways around this; firstly as a programmer you must ensure
    that you always check the amount of data you are receiving into a variable. The
    operating system can help to avoid this on behalf of the programmer by ensuring
    that the stack is marked as *not executable*; that is that the processor will
    not run any code, even if a malicious user tries to pass some into your program.
    Modern architectures and operating systems support this functionality.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题；首先，作为程序员，你必须确保你总是检查你接收到的变量中的数据量。操作系统可以通过确保栈被标记为*不可执行*来代表程序员避免这种情况；也就是说，处理器不会运行任何代码，即使恶意用户试图将一些代码传递到你的程序中。现代架构和操作系统支持这种功能。
- en: Stacks are ultimately managed by the compiler, as it is responsible for generating
    the program code. To the operating system the stack just looks like any other
    area of memory for the process.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈最终由编译器管理，因为它负责生成程序代码。对于操作系统来说，栈看起来就像进程的任何其他内存区域一样。
- en: To keep track of the current growth of the stack, the hardware defines a register
    as the *stack pointer*. The compiler (or the programmer, when writing in assembler)
    uses this register to keep track of the current top of the stack.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪栈的当前增长，硬件定义了一个寄存器作为*栈指针*。编译器（或当用汇编语言编写时程序员）使用这个寄存器来跟踪栈的当前顶部。
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 2.2.2.1 Stack pointer example
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2.2.2.1 栈指针示例
- en: Above we show a simple function allocating three variables on the stack. The
    disassembly illustrates the use of the stack pointer on the x86 architectureNote
    we used the special flag to gcc `-fomit-frame-pointer` which specifies that an
    extra register should *not* be used to keep a pointer to the start of the stack
    frame. Having this pointer helps debuggers to walk upwards through the stack frames,
    however it makes one less register available for other applications.. Firstly
    we allocate some space on the stack for our local variables. Since the stack grows
    down, we subtract from the value held in the stack pointer. The value 16 is a
    value large enough to hold our local variables, but may not be exactly the size
    required (for example with 3 4 byte `int` values we really only need 12 bytes,
    not 16) to keep alignment of the stack in memory on certain boundaries as the
    compiler requires.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们展示了一个简单的函数，在栈上分配了三个变量。反汇编代码说明了在x86架构上使用栈指针的情况。注意，我们使用了gcc的特殊标志`-fomit-frame-pointer`，该标志指定不应使用额外的寄存器来保持对栈帧开始的指针。这个指针有助于调试器向上遍历栈帧，然而它使得可用的寄存器数量减少了一个，这对于其他应用程序来说可能不太方便。首先，我们在栈上为我们的局部变量分配一些空间。由于栈向下增长，我们从栈指针中减去值。数值16足够容纳我们的局部变量，但可能不是所需的精确大小（例如，对于3个4字节的`int`值，我们实际上只需要12字节，而不是16）以保持栈在内存中特定边界上的对齐，因为编译器要求这样做。
- en: Then we move the values into the stack memory (and in a real function, use them).
    Finally, before returning to our parent function we "pop" the values off the stack
    by moving the stack pointer back to where it was before we started.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将值移动到栈内存中（在真实函数中，使用它们）。最后，在返回父函数之前，我们通过将栈指针移回到开始之前的位置来“弹出”栈上的值。
- en: 2.2.3 The Heap
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3 堆
- en: The heap is an area of memory that is managed by the process for on the fly
    memory allocation. This is for variables whose memory requirements are not known
    at compile time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是进程管理的内存区域，用于动态内存分配。这是对于在编译时不知道内存需求的变量。
- en: The bottom of the heap is known as the *brk*, so called for the system call
    which modifies it. By using the `brk` call to grow the area downwards the process
    can request the kernel allocate more memory for it to use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的底部被称为*brk*，这个名字来源于修改它的系统调用。通过使用`brk`调用向下扩展区域，进程可以请求内核为其分配更多的内存。
- en: The heap is most commonly managed by the `malloc` library call. This makes managing
    the heap easy for the programmer by allowing them to simply allocate and free
    (via the `free` call) heap memory. `malloc` can use schemes like a *buddy allocator*
    to manage the heap memory for the user. `malloc` can also be smarter about allocation
    and potentially use *anonymous mmaps* for extra process memory. This is where
    instead of mmaping a *file* into the process memory it directly maps an area of
    system RAM. This can be more efficient. Due to the complexity of managing memory
    correctly, it is very uncommon for any modern program to have a reason to call
    `brk` directly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 堆通常由`malloc`库函数管理。这使得程序员通过简单地分配和释放（通过`free`调用）堆内存来管理堆变得容易。`malloc`可以使用如*buddy
    allocator*这样的方案来管理用户的堆内存。`malloc`还可以在分配方面更加智能，并可能使用*匿名mmaps*来为进程提供额外的内存。这就是在将*mmap*文件映射到进程内存中而不是直接映射系统RAM区域的地方。这可能会更高效。由于正确管理内存的复杂性，任何现代程序直接调用`brk`的情况都非常罕见。
- en: 2.2.4 Memory Layout
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4 内存布局
- en: <picture>![A sample of how process memory is allocated.](memory-layout.svg)</picture>Figure 2.2.4.1 Process
    memory layout
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![如何分配进程内存的示例](memory-layout.svg)图2.2.4.1 进程内存布局'
- en: As we have seen a process has smaller areas of memory allocated to it, each
    with a specific purpose.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，进程被分配了较小的内存区域，每个区域都有特定的用途。
- en: An example of how the process is laid out in memory by the kernel is given above.
    Starting from the top, the kernel reserves itself some memory at the top of the
    process (we see with virtual memory how this memory is actually shared between
    all processes).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面给出了内核如何在内存中布局进程的一个例子。从顶部开始，内核在进程的顶部保留了一些内存（我们通过虚拟内存可以看到这些内存实际上是所有进程共享的）。
- en: Underneath that is room for `mmaped` files and libraries. Underneath that is
    the stack, and below that the heap.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面是`mmaped`文件和库的空间。再下面是栈，再下面是堆。
- en: At the bottom is the program image, as loaded from the executable file on disk.
    We take a closer look at the process of loading this data in later chapters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在最底层是程序映像，这是从磁盘上的可执行文件中加载的。我们将在后面的章节中更详细地探讨加载这些数据的过程。
- en: 2.3 File Descriptors
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 文件描述符
- en: In the first week we learnt about `stdin`, `stdout` and `stderr`; the default
    files given to each process. You will remember that these files always have the
    same file descriptor number (0,1,2 respectively).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一周，我们学习了`stdin`、`stdout`和`stderr`；每个进程都分配的默认文件。你们会记得，这些文件总是有相同的文件描述符号（分别是0、1、2）。
- en: Thus, file descriptors are kept by the kernel individually for each process.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内核为每个进程单独保留文件描述符。
- en: File descriptors also have permissions. For example, you may be able to read
    from a file but not write to it. When the file is opened, the operating system
    keeps a record of the processes permissions to that file in the file descriptor
    and doesn't allow the process to do anything it shouldn't.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符也有权限。例如，你可能能够从文件中读取但不能写入。当文件被打开时，操作系统会在文件描述符中记录进程对该文件的权限，并阻止进程执行它不应该做的事情。
- en: 2.4 Registers
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4 寄存器
- en: We know from the previous chapter that the processor essentially performs generally
    simple operations on values in registers. These values are read (and written)
    to memory -- we mentioned above that each process is allocated memory which the
    kernel keeps track of.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从上一章了解到，处理器本质上是在寄存器中的值上执行一些简单的操作。这些值会被读取（和写入）到内存中——我们上面提到，每个进程都会分配内存，内核会跟踪这些内存。
- en: So the other side of the equation is keeping track of the registers. When it
    comes time for the currently running process to give up the processor so another
    process can run, it needs to save its current state. Equally, we need to be able
    to restore this state when the process is given more time to run on the CPU. To
    do this the operating system needs to store a copy of the CPU registers to memory.
    When it is time for the process to run again, the operating system will copy the
    register values back from memory to the CPU registers and the process will be
    right back where it left off.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，等式的另一边是跟踪寄存器。当当前运行的进程需要放弃处理器以便另一个进程运行时，它需要保存其当前状态。同样，当进程在CPU上获得更多运行时间时，我们需要能够恢复此状态。为此，操作系统需要将CPU寄存器的副本存储到内存中。当进程再次运行时，操作系统将从内存中将寄存器值复制回CPU寄存器，进程将回到它离开的地方。
- en: 2.5 Kernel State
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5 内核状态
- en: Internally, the kernel needs to keep track of a number of elements for each
    process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内核需要为每个进程跟踪多个元素。
- en: 2.5.1 Process State
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1 进程状态
- en: Another important element for the operating system to keep track of is the process
    state. If the process is currently running it makes sense to have it in a *running*
    state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统需要跟踪的另一个重要元素是进程状态。如果进程当前正在运行，那么将其置于*运行*状态是有意义的。
- en: However, if the process has requested to read a file from disk we know from
    our memory hierarchy that this may take a significant amount of time. The process
    should give up its current execution to allow another process to run, but the
    kernel need not let the process run again until the data from the disk is available
    in memory. Thus it can mark the process as *disk wait* (or similar) until the
    data is ready.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果进程请求从磁盘读取文件，我们知道从我们的内存层次结构来看，这可能需要相当长的时间。进程应该放弃当前的执行以允许另一个进程运行，但内核不需要在磁盘上的数据可用在内存中之前让进程再次运行。因此，它可以标记进程为*磁盘等待*（或类似状态）直到数据准备好。
- en: 2.5.2 Priority
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2 优先级
- en: Some processes are more important than others, and get a higher priority. See
    the discussion on the scheduler below.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些进程比其他进程更重要，并具有更高的优先级。请参阅下面的调度器讨论。
- en: 2.5.3 Statistics
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.3 统计信息
- en: The kernel can keep statistics on each processes behaviour which can help it
    make decisions about how the process behaves; for example does it mostly read
    from disk or does it mostly do CPU intensive operations?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 内核可以跟踪每个进程的行为统计信息，这有助于它做出关于进程行为的决策；例如，它主要从磁盘读取还是主要进行CPU密集型操作？
- en: </main>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 3 Process Hierarchy
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 进程层次结构
- en: Whilst the operating system can run many processes at the same time, in fact
    it only ever directly starts one process called the *init* (short for initial)
    process. This isn't a particularly special process except that its PID is always
    0 and it will *always* be running.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然操作系统可以同时运行许多进程，但实际上它只直接启动一个名为*init*（简称初始）的进程。这个进程并不特别特殊，除了它的PID总是0，它将*始终*在运行。
- en: All other processes can be considered *children* of this initial process. Processes
    have a family tree just like any other; each process has a *parent* and can have
    many *siblings*, which are processes createdThe term *spawn* is often used when
    talking about parent processes creating children; as in "the process spawned a
    child". by the same parent.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他进程都可以被认为是这个初始进程的*孩子*。进程有一个家族树，就像任何其他东西一样；每个进程都有一个*父进程*，可以有许多*兄弟*，这些是由同一个父进程创建的进程。
- en: Certainly children can create more children and so on and so forth.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，孩子们可以创造更多的孩子，等等。
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 3.1 `pstree` example</main>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3.1 `pstree` 示例</main>
- en: <main class="calibre3">
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 4 Fork and Exec
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 分支和执行
- en: New processes are created by the two related interfaces `fork` and `exec`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 新进程是通过两个相关的接口`fork`和`exec`创建的。
- en: 4.1 Fork
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 分支
- en: When you come to metaphorical "fork in the road" you generally have two options
    to take, and your decision effects your future. Computer programs reach this fork
    in the road when they hit the `fork()` system call.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你来到比喻性的“分岔路口”时，你通常有两个选择，你的决定会影响你的未来。当计算机程序遇到`fork()`系统调用时，它们会达到这个“分岔路口”。
- en: At this point, the operating system will create a new process that is exactly
    the same as the parent process. This means all the state that was talked about
    previously is copied, including open files, register state and all memory allocations,
    which includes the program code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，操作系统将创建一个与父进程完全相同的新进程。这意味着之前提到的所有状态都被复制，包括打开的文件、寄存器状态以及所有内存分配，这包括程序代码。
- en: The return value from the system call is the only way the process can determine
    if it was the existing process or a new one. The return value to the parent process
    will be the Process ID (PID) of the child, whilst the child will get a return
    value of 0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用的返回值是进程确定它是否是现有进程或新进程的唯一方式。对父进程的返回值将是子进程的进程 ID (PID)，而子进程将得到返回值 0。
- en: At this point, we say the process has `forked` and we have the parent-child
    relationship as described above.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们说进程已经 `fork`，并且我们有上面描述的父子关系。
- en: 4.2 Exec
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 Exec
- en: Forking provides a way for an existing process to start a new one, but what
    about the case where the new process is not part of the same program as parent
    process? This is the case in the shell; when a user starts a command it needs
    to run in a new process, but it is unrelated to the shell.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork` 提供了一种方式，让现有进程可以启动一个新的进程，但如果是新进程不是父进程所属的同一程序呢？这在 shell 中就是这样；当用户启动一个需要在新进程中运行的命令时，它与
    shell 无关。'
- en: This is where the `exec` system call comes into play. `exec` will *replace*
    the contents of the currently running process with the information from a program
    binary.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `exec` 系统调用发挥作用的地方。`exec` 会 *替换* 当前运行进程的内容，用程序二进制文件中的信息来替换。
- en: Thus the process the shell follows when launching a new program is to firstly
    `fork`, creating a new process, and then `exec` (i.e. load into memory and execute)
    the program binary it is supposed to run.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，shell 启动新程序时遵循的进程是首先 `fork`，创建一个新进程，然后 `exec`（即加载到内存中并执行）它应该运行的程序二进制文件。
- en: 4.3 How Linux actually handles fork and exec
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 Linux 实际上如何处理 fork 和 exec
- en: 4.3.1  `clone`
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1 `clone`
- en: In the kernel, fork is actually implemented by a `clone` system call. This `clone`
    interfaces effectively provides a level of abstraction in how the Linux kernel
    can create processes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，`fork` 实际上是通过一个 `clone` 系统调用来实现的。这个 `clone` 接口有效地为 Linux 内核创建进程提供了一种抽象级别。
- en: '`clone` allows you to explicitly specify which parts of the new process are
    copied into the new process, and which parts are shared between the two processes.
    This may seem a bit strange at first, but allows us to easily implement *threads*
    with one very simple interface.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone` 允许你明确指定新进程的哪些部分被复制到新进程中，哪些部分在两个进程之间共享。这乍一看可能有点奇怪，但允许我们通过一个非常简单的接口轻松实现
    *线程*。'
- en: 4.3.1.1 Threads
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.3.1.1 线程
- en: While `fork` copies all of the attributes we mentioned above, imagine if everything
    was copied for the new process *except* for the memory. This means the parent
    and child share the same memory, which includes program code and data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `fork` 复制了我们提到的所有属性，但想象一下，如果除了内存之外的所有东西都被复制到新进程中会怎样。这意味着父进程和子进程共享相同的内存，包括程序代码和数据。
- en: <picture>![The memory (including program code and variables) of the process
    are shared by the threads, but each has its own kernel state, so they can be running
    different parts of the code at the same time.](threads.svg)</picture>Figure 4.3.1.1.1 Threads
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <picture>![进程的内存（包括程序代码和变量）由线程共享，但每个线程都有自己的内核状态，因此它们可以同时运行代码的不同部分。](threads.svg)</picture>图
    4.3.1.1.1 线程
- en: This hybrid child is called a *thread*. Threads have a number of advantages
    over where you might use *fork*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合子进程被称为 *线程*。线程相对于你可能使用的 *fork* 有许多优势
- en: Separate processes can not see each others memory. They can only communicate
    with each other via other system calls.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离的进程不能看到彼此的内存。它们只能通过其他系统调用来相互通信。
- en: Threads however, share the same memory. So you have the advantage of multiple
    processes, with the expense of having to use system calls to communicate between
    them.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，线程共享相同的内存。因此，你有了多进程的优势，但代价是需要使用系统调用来在它们之间进行通信。
- en: The problem that this raises is that threads can very easily step on each others
    toes. One thread might increment a variable, and another may decrease it without
    informing the first thread. These type of problems are called *concurrency problems*
    and they are many and varied.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这引发的问题是，线程可以非常容易地相互干扰。一个线程可能会增加一个变量，而另一个线程可能会减少它，而不通知第一个线程。这类问题被称为 *并发问题*，它们种类繁多。
- en: To help with this, there are userspace libraries that help programmers work
    with threads properly. The most common one is called `POSIX threads` or, as it
    more commonly referred to `pthreads`
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了帮助解决这个问题，有一些用户空间库可以帮助程序员正确地处理线程。最常见的一个叫做`POSIX threads`，或者更常见地称为`pthreads`。
- en: Switching processes is quite expensive, and one of the major expenses is keeping
    track of what memory each process is using. By sharing the memory this overhead
    is avoided and performance can be significantly increased.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程切换相当昂贵，其中主要开销之一是跟踪每个进程使用什么内存。通过共享内存，可以避免这种开销，性能可以显著提高。
- en: There are many different ways to implement threads. On the one hand, a userspace
    implementation could implement threads within a process without the kernel having
    any idea about it. The threads all look like they are running in a single process
    to the kernel.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实现线程的方法有很多种。一方面，用户空间实现可以在内核不知道的情况下在一个进程内实现线程。对内核来说，这些线程看起来就像是在单个进程中运行的。
- en: This is suboptimal mainly because the kernel is being withheld information about
    what is running in the system. It is the kernels job to make sure that the system
    resources are utilised in the best way possible, and if what the kernel thinks
    is a single process is actually running multiple threads it may make suboptimal
    decisions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是因为内核被隐瞒了关于系统中正在运行什么的信息。确保系统资源以最佳方式使用是内核的工作，如果内核认为是一个单独的进程实际上正在运行多个线程，它可能会做出次优决策。
- en: Thus the other method is that the kernel has full knowledge of the thread. Under
    Linux, this is established by making all processes able to share resources via
    the `clone` system call. Each thread still has associated kernel resources, so
    the kernel can take it into account when doing resource allocations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，另一种方法是内核对线程有完全的了解。在Linux中，这是通过使所有进程都能通过`clone`系统调用共享资源来实现的。每个线程仍然关联着内核资源，因此内核在分配资源时可以将其考虑在内。
- en: Other operating systems have a hybrid method, where some threads can be specified
    to run in userspace only ("hidden" from the kernel) and others might be a *light
    weight process*, a similar indication to the kernel that the processes is part
    of a thread group.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作系统采用了一种混合方法，其中一些线程可以指定仅在用户空间运行（“对内核隐藏”），而其他线程可能是一个*轻量级进程*，向内核表明该进程是线程组的一部分。
- en: 4.3.1.2 Copy on write
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 4.3.1.2 写时复制
- en: As we mentioned, copying the entire memory of one process to another when `fork`
    is called is an expensive operation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，当调用`fork`时，将一个进程的全部内存复制到另一个进程是一个昂贵的操作。
- en: One optimisation is called *copy on write*. This means that similar to threads
    above, the memory is actually shared, rather than copied, between the two processes
    when fork is called. If the processes are only going to be reading the memory,
    then actually copying the data is unnecessary.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一种优化称为*写时复制*。这意味着当调用fork时，内存实际上是共享的，而不是复制的，两个进程之间共享内存，而不是复制。如果进程只打算读取内存，那么实际复制数据是不必要的。
- en: However, when a process writes to its memory, it needs to be a private copy
    that is not shared. As the name suggests, copy on write optimises this by only
    doing the actual copy of the memory at the point when it is written to.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当一个进程向其内存写入时，它需要一个私有的副本，而不是共享的。正如其名称所暗示的，写时复制通过仅在写入时实际复制内存来优化这一点。
- en: Copy on write also has a big advantage for `exec`. Since `exec` will simply
    be overwriting all the memory with the new program, actually copying the memory
    would waste a lot of time. Copy on write saves us actually doing the copy.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 写时复制对`exec`也有很大的优势。由于`exec`将简单地用新程序覆盖所有内存，实际上复制内存会浪费很多时间。写时复制节省了我们实际进行复制的时间。
- en: 4.4 The init process
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 初始化进程
- en: We discussed the overall goal of the init process previously, and we are now
    in a position to understand how it works.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了init进程的整体目标，现在我们能够理解它是如何工作的。
- en: On boot the kernel starts the init process, which then forks and execs the systems
    boot scripts. These fork and exec more programs, eventually ending up forking
    a login process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导时，内核启动init进程，然后它进行分叉和执行系统引导脚本。这些分叉和执行更多的程序，最终导致分叉一个登录进程。
- en: The other job of the `init` process is "reaping". When a process calls `exit`
    with a return code, the parent usually wants to check this code to see if the
    child exited correctly or not.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`进程的另一个任务是“回收”。当一个进程以返回码调用`exit`时，父进程通常会检查这个代码，以查看子进程是否正确退出。'
- en: However, this exit code is part of the process which has just called `exit`.
    So the process is "dead" (e.g. not running) but still needs to stay around until
    the return code is collected. A process in this state is called a *zombie* (the
    traits of which you can contrast with a mystical zombie!)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个退出代码是刚刚调用 `exit` 的进程的一部分。因此，进程是 "dead"（例如，未运行），但仍然需要保留，直到收集到返回代码。处于这种状态的过程被称为
    *僵尸*（你可以将其特性与神秘的僵尸进行对比！）
- en: A process stays as a zombie until the parent collects the return code with the
    `wait` call. However, if the parent exits before collecting this return code,
    the zombie process is still around, waiting aimlessly to give its status to someone.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程会保持僵尸状态，直到父进程通过 `wait` 调用收集返回代码。然而，如果父进程在收集这个返回代码之前退出，僵尸进程仍然存在，无目的地等待向某人提供其状态。
- en: In this case, the zombie child will be *reparented* to the init process which
    has a special handler that *reaps* the return value. Thus the process is finally
    free and the descriptor can be removed from the kernels process table.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，僵尸子进程将被 *重新分配* 到具有特殊处理程序（用于 *回收* 返回值）的 init 进程。因此，进程最终是自由的，描述符可以从内核的进程表中移除。
- en: 4.4.1 Zombie example
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1 僵尸进程示例
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 4.4.1.1 Zombie example process
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.4.1.1 僵尸进程示例
- en: Above we create a zombie process. The parent process will sleep forever, whilst
    the child will exit after a few seconds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们创建了一个僵尸进程。父进程将永远休眠，而子进程将在几秒钟后退出。
- en: Below the code you can see the results of running the program. The parent process
    (16168) is in state `S` for sleep (as we expect) and the child is in state `Z`
    for zombie. The ps output also tells us that the process is `defunct` in the process
    description.The square brackets around the "z" of "zombie" are a little trick
    to remove the grep processes itself from the ps output. grep interprets everything
    between the square brackets as a character class, but because the process name
    will be "grep [z]ombie" (with the brackets) this will not match!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码下方，你可以看到程序运行的结果。父进程（16168）处于 `S` 睡眠状态（正如我们所预期的），而子进程处于 `Z` 僵尸状态。ps 输出还告诉我们，该进程在进程描述中是
    `defunct`（已终止）。围绕 "zombie" 中的 "z" 的方括号是一个小技巧，用于从 ps 输出中移除 grep 进程本身。grep 将方括号之间的所有内容解释为字符类，但由于进程名称将是
    "grep [z]ombie"（带有方括号），这不会匹配！
- en: </main>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 5 Context Switching
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 上下文切换
- en: Context switching refers to the process the kernel undertakes to switch from
    one process to another. XXX ?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换是指内核从一个进程切换到另一个进程的过程。XXX？
- en: </main>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 6 Scheduling
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 调度
- en: A running system has many processes, maybe even into the hundreds or thousands.
    The part of the kernel that keeps track of all these processes is called the *scheduler*
    because it schedules which process should be run next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的系统有许多进程，可能甚至达到数百或数千。内核中负责跟踪所有这些进程的部分被称为 *调度器*，因为它负责安排哪个进程应该被运行。
- en: Scheduling algorithms are many and varied. Most users have different goals relating
    to what they want their computer to do, so this affects scheduling decisions.
    For example, for a desktop PC you want to make sure that your graphical applications
    for your desktop are given plenty of time to run, even if system processes take
    a little longer. This will increase the responsiveness the user feels, as their
    actions will have more immediate responses. For a server, you might want your
    web server application to be given priority.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 调度算法种类繁多。大多数用户都有不同的目标，这些目标与他们的计算机想要执行的任务相关，这会影响调度决策。例如，对于台式电脑，你想要确保你的桌面图形应用程序有足够的时间运行，即使系统进程运行得稍微长一点。这将增加用户感受到的响应速度，因为他们的操作将得到更及时的响应。对于服务器，你可能希望你的网络服务器应用程序得到优先权。
- en: People are always coming up with new algorithms, and you can probably think
    of your own fairly easily. But there are a number of different components of scheduling.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 人们总是想出新的算法，你也许可以很容易地想到自己的算法。但是，调度有许多不同的组成部分。
- en: 6.1 Preemptive v co-operative scheduling
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1 预先调度与协作调度
- en: Scheduling strategies can broadly fall into two categories
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调度策略可以大致分为两大类
- en: '*Co-operative* scheduling is where the currently running process voluntarily
    gives up executing to allow another process to run. The obvious disadvantage of
    this is that the process may decide to never give up execution, probably because
    of a bug causing some form of infinite loop, and consequently nothing else can
    ever run.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*合作式*调度是当前运行的进程自愿放弃执行以允许另一个进程运行。这种方法的明显缺点是，进程可能决定永远不放弃执行，这可能是由于导致某种形式无限循环的bug，因此其他任何东西都无法运行。'
- en: '*Preemptive* scheduling is where the process is interrupted to stop it to allow
    another process to run. Each process gets a *time-slice* to run in; at the point
    of each context switch a timer will be reset and will deliver and interrupt when
    the time-slice is over.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*抢占式*调度是在中断进程以允许另一个进程运行时停止进程。每个进程都有一个运行的时间片；在每次上下文切换时，计时器将被重置，并在时间片结束时产生中断。'
- en: We know that the hardware handles the interrupt independently of the running
    process, and so at this point control will return to the operating system. At
    this point, the scheduler can decide which process to run next.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们知道硬件独立于运行中的进程处理中断，因此在这个点上控制将返回到操作系统。在这个点上，调度程序可以决定下一个要运行哪个进程。
- en: This is the type of scheduling used by all modern operating systems.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是所有现代操作系统使用的调度类型。
- en: 6.2 Realtime
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2 实时性
- en: Some processes need to know exactly how long their time-slice will be, and how
    long it will be before they get another time-slice to run. Say you have a system
    running a heart-lung machine; you don't want the next pulse to be delayed because
    something else decided to run in the system!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一些进程需要确切知道它们的时间片将持续多长时间，以及它们再次获得运行时间片之前需要等待多长时间。比如说，你有一个正在运行心肺机的系统；你不希望下一个脉冲被延迟，因为系统中的其他东西决定运行！
- en: Hard realtime systems make guarantees about scheduling decisions like the maximum
    amount of time a process will be interrupted before it can run again. They are
    often used in life critical applications like medical, aircraft and military applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 硬实时系统对调度决策做出保证，例如在进程再次运行之前可能被中断的最大时间量。它们通常用于生命攸关的应用，如医疗、航空和军事应用。
- en: Soft realtime is a variation on this, where guarantees aren't as strict but
    general system behaviour is predictable. Linux can be used like this, and it is
    often used in systems dealing with audio and video. If you are recording an audio
    stream, you don't want to be interrupted for long periods of time as you will
    loose audio data which can not be retrieved.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 软实时是对此的一种变体，其中保证不那么严格，但系统行为是可预测的。Linux可以像这样使用，并且通常用于处理音频和视频的系统。如果你正在录制音频流，你不想长时间中断，否则你会丢失无法恢复的音频数据。
- en: 6.3 Nice value
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3 nice值
- en: UNIX systems assign each process a *nice* value. The scheduler looks at the
    nice value and can give priority to those processes that have a higher "niceness".
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX系统为每个进程分配一个**nice**值。调度程序会查看这个nice值，并可以给那些具有更高“友好度”的进程优先权。
- en: 6.4 A brief look at the Linux Scheduler
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4 简要了解Linux调度程序
- en: The Linux scheduler has and is constantly undergoing many changes as new developers
    attempt to improve its behaviour.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Linux调度程序随着新开发人员尝试改进其行为而不断进行许多变化。
- en: The current scheduler is known as the O(1) scheduler, which refers to the property
    that no matter how many processes the scheduler has to choose from, it will choose
    the next one to run in a constant amount of time*Big-O* notation is a way of describing
    how long an algorithm takes to run given increasing inputs. If the algorithm takes
    twice as long to run for twice as much input, this is increasing linearly. If
    another algorithm takes four times as long to run given twice as much input, then
    it is increasing exponentially. Finally if it takes the same amount of time now
    matter how much input, then the algorithm runs in constant time. Intuitively you
    can see that the slower the algorithm grows for more input, the better it is.
    Computer science text books deal with algorithm analysis in more detail..
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当前调度程序被称为O(1)调度程序，这指的是无论调度程序需要从多少个进程中选择，它都会在恒定的时间内选择下一个要运行的进程。*Big-O*表示法是一种描述算法在给定增加输入时运行时间的方法。如果算法在两倍输入的情况下运行时间是原来的两倍，这是线性增加。如果另一个算法在两倍输入的情况下运行时间是原来的四倍，那么它是指数增加。最后，如果无论输入多少，算法运行时间都相同，那么算法是恒定时间的。直观上，你可以看到算法随着输入的增加而增长得越慢，它就越好。计算机科学教科书更详细地处理算法分析。
- en: Previous incarnations of the Linux scheduler used the concept of *goodness*
    to determine which process to run next. All possible tasks are kept on a *run
    queue*, which is simply a linked list of processes which the kernel knows are
    in a "runnable" state (i.e. not waiting on disk activity or otherwise asleep).
    The problem arises that to calculate the next process to run, every possible runnable
    process must have its goodness calculated and the one with the highest goodness
    ``wins''. You can see that for more tasks, it will take longer and longer to decide
    which processes will run next.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 调度器的先前版本使用 *良好度* 的概念来确定下一个要运行的进程。所有可能的任务都保存在一个 *运行队列* 中，它是一个简单的进程链表，内核知道这些进程处于
    "可运行" 状态（即不是在等待磁盘活动或以其他方式休眠）。问题在于，为了计算下一个要运行的进程，必须计算每个可能的可运行进程的 *良好度*，并且具有最高良好度的进程
    "获胜"。你可以看到，对于更多的任务，决定下一个要运行的进程将需要更长的时间。
- en: <picture>![A view of how the Linux scheduler manages processes.](o1queue.svg)</picture>Figure 6.4.1 The
    O(1) scheduler
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![Linux 调度器管理进程的视图](o1queue.svg)图 6.4.1 O(1) 调度器'
- en: In contrast, the O(1) scheduler uses a run queue structure as shown above. The
    run queue has a number of *buckets* in priority order and a bitmap that flags
    which buckets have processes available. Finding the next process to run is a matter
    of reading the bitmap to find the first bucket with processes, then picking the
    first process off that bucket's queue. The scheduler keeps two such structures,
    an *active* and *expired* array for processes that are runnable and those which
    have utilised their entire time slice respectively. These can be swapped by simply
    modifying pointers when all processes have had some CPU time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，O(1) 调度器使用上面所示的一种运行队列结构。运行队列按优先级顺序包含若干个 *桶*，以及一个位图来标记哪些桶中有可用的进程。找到下一个要运行的进程，就是读取位图以找到第一个包含进程的桶，然后从该桶的队列中选取第一个进程。调度器维护两个这样的结构，一个是
    *活动* 数组，用于可运行的进程；另一个是 *过期* 数组，用于已经使用完其整个时间片的进程。当所有进程都获得了一些 CPU 时间后，可以通过简单地修改指针来交换这些结构。
- en: The really interesting part, however, is how it is decided where in the run
    queue a process should go. Some of the things that need to be taken into account
    are the nice level, processor affinity (keeping processes tied to the processor
    they are running on, since moving a process to another CPU in a SMP system can
    be an expensive operation) and better support for identifying interactive programs
    (applications such as a GUI which may spend much time sleeping, waiting for user
    input, but when the user *does* get around to interacting with it wants a fast
    response).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真正有趣的部分是它如何决定进程在运行队列中的位置。需要考虑的一些因素包括优先级、处理器亲和性（将进程与其运行的处理器绑定在一起，因为在 SMP 系统中将进程移动到另一个
    CPU 可能是一个昂贵的操作）以及更好地识别交互式程序（例如 GUI 应用程序，这些程序可能花费大量时间休眠，等待用户输入，但当用户 *确实* 与其交互时，希望得到快速响应）。
- en: </main>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 7 The Shell
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 Shell
- en: On a UNIX system, the shell is the standard interface to handling processes
    on your system. Once the shell was the primary interface, however modern Linux
    systems have a GUI and provide a shell via a "terminal application" or similar.
    The primary job of the shell is to help the user handle starting, stopping and
    otherwise controlling processes running in the system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 系统中，shell 是处理系统上进程的标准接口。一旦 shell 成为主要的接口，尽管现代 Linux 系统提供了 GUI 并通过 "终端应用程序"
    或类似的方式提供 shell，但 shell 的主要任务仍然是帮助用户处理启动、停止以及控制系统中运行的进程。
- en: When you type a command at the prompt of the shell, it will `fork` a copy of
    itself and `exec` the command that you have specified.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 shell 提示符下输入一个命令时，它将 `fork` 出一个自身的副本并 `exec` 执行你指定的命令。
- en: The shell then, by default, waits for that process to finish running before
    returning to a prompt to start the whole process over again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，shell 默认会等待该进程运行完成，然后返回到提示符以重新开始整个过程。
- en: As an enhancement, the shell also allows you to *background* a job, usually
    by placing an `&` after the command name. This is simply a signal that the shell
    should fork and execute the command, but *not* wait for the command to complete
    before showing you the prompt again.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种增强，shell 还允许你将作业 *后台运行*，通常是在命令名称后放置一个 `&`。这只是一个信号，表明 shell 应该 `fork` 并执行命令，但在显示提示符之前不需要等待命令完成。
- en: The new process runs in the background, and the shell is ready waiting to start
    a new process should you desire. You can usually tell the shell to *foreground*
    a process, which means we do actually want to wait for it to finish.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 新的过程在后台运行，shell 已经准备好，等待您启动一个新的进程。您通常可以指示 shell 将进程 *前台化*，这意味着我们确实希望等待其完成。
- en: 'XXX : a bit of history about bourne shell'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: XXX：关于 bourne shell 的一些历史
- en: </main>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
- en: <main class="calibre3">
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <main class="calibre3">
- en: 8 Signals
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 信号
- en: Processes running in the system require a way to be told about events that influence
    them. On UNIX there is infrastructure between the kernel and processes called
    *signals* which allows a process to receive notification about events important
    to it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中运行的进程需要一种方式来告知它们受影响的事件。在 UNIX 中，内核和进程之间有一种称为 *信号* 的基础设施，它允许进程接收与其重要事件相关的通知。
- en: When a signal is sent to a process, the kernel invokes a *handler* which the
    process must register with the kernel to deal with that signal. A handler is simply
    a designed function in the code that has been written to specifically deal with
    interrupt. Often the signal will be sent from inside the kernel itself, however
    it is also common for one process to send a signal to another process (one form
    of *interprocess communication*). The signal handler gets called *asynchronously*;
    that is the currently running program is interrupted from what it is doing to
    process the signal event.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当向进程发送信号时，内核调用一个 *处理程序*，进程必须将其注册到内核以处理该信号。处理程序只是代码中设计用来专门处理中断的函数。通常，信号会从内核内部发送，然而，一个进程向另一个进程发送信号（一种
    *进程间通信* 的形式）也是很常见的。信号处理程序是 *异步调用* 的；也就是说，当前运行的程序会中断其正在执行的操作来处理信号事件。
- en: For example, one type of signal is an *interrupt* (defined in system headers
    as `SIGINT`) is delivered to the process when the `ctrl-c` combination is pressed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一种信号类型是 *中断*（在系统头文件中定义为 `SIGINT`），当按下 `ctrl-c` 组合键时，它被发送到进程。
- en: As a process uses the `read` system call to read input from the keyboard, the
    kernel will be watching the input stream looking for special characters. Should
    it see a `ctrl-c` it will jump into signal handling mode. The kernel will look
    to see if the process has registered a handler for this interrupt. If it has,
    then execution will be passed to that function where the function will *handle*
    it. Should the process have not registered a handler for this particular signal,
    then the kernel will take some default action. With `ctrl-c` the default action
    is to terminate the process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程使用 `read` 系统调用来从键盘读取输入时，内核会监视输入流，寻找特殊字符。如果它看到 `ctrl-c`，它将进入信号处理模式。内核会检查进程是否为这个中断注册了处理程序。如果有，则执行将传递到那个函数，该函数将
    *处理* 它。如果进程没有为这个特定的信号注册处理程序，那么内核将采取一些默认操作。对于 `ctrl-c`，默认操作是终止进程。
- en: A process can choose to ignore some signals, but other signals are not allowed
    to be ignored. For example, `SIGKILL` is the signal sent when a process should
    be terminated. The kernel will see that the process has been sent this signal
    and terminate the process from running, no questions asked. The process can not
    ask the kernel to ignore this signal, and the kernel is very careful about which
    process is allowed to send this signal to another process; you may only send it
    to processes owned by you unless you are the root user. You may have seen the
    command `kill -9`; this comes from the implementation `SIGKILL` signal. It is
    commonly known that `SIGKILL` is actually defined to be `0x9`, and so when specified
    as an argument to the `kill` program means that the process specified is going
    to be stopped immediately. Since the process can not choose to ignore or handle
    this signal, it is seen as an avenue of last resort, since the program will have
    no chance to clean up or exit cleanly. It is considered better to first send a
    `SIGTERM` (for terminate) to the process first, and if it has crashed or otherwise
    will not exit then resort to the `SIGKILL`. As a matter of convention, most programs
    will install a handler for `SIGHUP` (hangup -- a left over from days of serial
    terminals and modems) which will reload the program, perhaps to pick up changes
    in a configuration file or similar.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以选择忽略一些信号，但其他信号不允许被忽略。例如，`SIGKILL` 是当进程应该被终止时发送的信号。内核会看到进程已经收到了这个信号，并终止进程的运行，无需询问。进程不能请求内核忽略这个信号，内核非常小心地处理哪些进程被允许向其他进程发送这个信号；除非你是root用户，否则你只能向属于你的进程发送。你可能见过命令
    `kill -9`；这来自于 `SIGKILL` 信号的实现。众所周知，`SIGKILL` 实际上定义为 `0x9`，因此当作为 `kill` 程序的参数指定时，意味着指定的进程将被立即停止。由于进程不能选择忽略或处理这个信号，它被视为最后的手段，因为程序将没有机会清理或干净地退出。通常认为，首先向进程发送一个
    `SIGTERM`（用于终止），如果它崩溃或无法退出，再求助于 `SIGKILL` 是更好的做法。按照惯例，大多数程序都会安装一个处理 `SIGHUP`（挂起——来自串行终端和调制解调器时代的遗留问题）的处理程序，该处理程序将重新加载程序，可能是为了获取配置文件或类似文件的更改。
- en: If you have programmed on a Unix system you would be familiar with `segmentation
    faults` when you try to read or write to memory that has not been allocated to
    you. When the kernel notices that you are touching memory outside your allocation,
    it will send you the segmentation fault signal. Usually the process will not have
    a handler installed for this, and so the default action to terminate the program
    ensues (hence your program "crashes"). In some cases a program may install a handler
    for segmentation faults, although reasons for doing this are limited.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在 Unix 系统上编程，当你尝试读取或写入未分配给你的内存时，你会熟悉 `segmentation faults`。当内核注意到你在访问你分配之外的内存时，它会向你发送分段错误信号。通常，进程不会安装处理这个信号的处理程序，因此默认的操作是终止程序（这就是你的程序“崩溃”的原因）。在某些情况下，程序可能会安装一个处理分段错误的处理程序，尽管这样做的原因有限。
- en: This raises the question of what happens after the signal is received. Once
    the signal handler has finished running, control is returned to the process which
    continues on from where it left off.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了信号接收后的情况。一旦信号处理程序运行完成，控制权返回到进程，它从上次离开的地方继续执行。
- en: 8.1 Example
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1 示例
- en: The following simple program introduces a lot of signals to run!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的程序引入了许多信号来运行！
- en: '[PRE3]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 8.1.1 Signals Example
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8.1.1 信号示例
- en: We have simple program that simply defines a handler for the `SIGINT` signal,
    which is sent when the user presses `ctrl-c`. All the signals for the system are
    defined in `signal.h`, including the `signal` function which allows us to register
    the handling function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的程序，它简单地定义了一个处理 `SIGINT` 信号的处理程序，该信号是在用户按下 `ctrl-c` 时发送的。系统中所有的信号都在 `signal.h`
    中定义，包括 `signal` 函数，它允许我们注册处理函数。
- en: The program simply sits in a tight loop doing nothing until it quits. When we
    start the program, we try pressing `ctrl-c` to make it quit. Rather than taking
    the default action, or handler is invoked and we get the output as expected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 程序简单地坐在一个紧密的循环中什么也不做，直到它退出。当我们启动程序时，我们尝试按 `ctrl-c` 来使其退出。而不是采取默认操作，处理程序被调用，我们得到了预期的输出。
- en: We then press `ctrl-z` which sends a `SIGSTOP` which by default puts the process
    to sleep. This means it is not put in the queue for the scheduler to run and is
    thus dormant in the system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按 `ctrl-z` 发送一个 `SIGSTOP` 信号，默认情况下将进程置于休眠状态。这意味着它不会被放入调度器的队列中运行，因此在系统中是休眠的。
- en: As an illustration, we use the kill program to send the same signal from another
    terminal window. This is actually implemented with the `kill` system call, which
    takes a signal and PID to send to (this function is a little misnamed because
    not all signals do actually kill the process, as we are seeing, but the `signal`
    function was already taken to register the handler). As the process is stopped,
    the signal gets *queued* for the process. This means the kernel takes note of
    the signal and will deliver it when appropriate.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们使用`kill`程序从另一个终端窗口发送相同的信号。这实际上是通过`kill`系统调用来实现的，它接受一个信号和一个PID来发送（这个函数的名字有点误导，因为并非所有信号实际上都会杀死进程，正如我们所看到的，但`signal`函数已经被用来注册处理程序）。由于进程被停止，信号被*排队*等待处理。这意味着内核会注意这个信号，并在适当的时候传递它。
- en: At this point we wake the process up by using the command `fg`. This actually
    sends a `SIGCONT` signal to the process, which by default will wake the process
    back up. The kernel knows to put the process on the run queue and give it CPU
    time again. We see at this point the queued signal is delivered.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们通过使用命令`fg`唤醒进程。这实际上向进程发送了一个`SIGCONT`信号，默认情况下这将唤醒进程。内核知道将进程放入运行队列，并再次给它分配CPU时间。我们在这个时候看到队列中的信号被传递。
- en: In desperation to get rid of the program, we finally try `ctrl-\` which sends
    a `SIGQUIT` (abort) to the process. But if the process has aborted, where did
    the `Quit` output come from?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝望地想要摆脱程序的情况下，我们最终尝试使用`ctrl-\`发送一个`SIGQUIT`（中止）信号到进程。但如果进程已经中止，`Quit`输出是从哪里来的呢？
- en: You guessed it, more signals! When a parent child has a process that dies, it
    gets a `SIGCHLD` signal back. In this case the shell was the parent process and
    so it got the signal. Remember how we have the zombie process that needs to be
    reaped with the `wait` call to get the return code from the child process? Well
    another thing it also gives the parent is the signal number that the child may
    have died from. Thus the shell knows that child process died from a `SIGABRT`
    and as an informational service prints as much for the user (the same process
    happens to print out "Segmentation Fault" when the child process dies from a `SIGSEGV`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜对了，还有更多的信号！当一个父进程的子进程死亡时，它会收到一个`SIGCHLD`信号。在这种情况下，shell是父进程，因此它接收到了这个信号。还记得我们如何使用`wait`调用回收僵尸进程，并从子进程获取返回码吗？嗯，它还提供给父进程的是子进程可能死亡的原因的信号编号。因此，shell知道子进程是因为`SIGABRT`而死亡的，并且作为信息服务，它会向用户打印出尽可能多的信息（当子进程因为`SIGSEGV`而死亡时，这个进程也会打印出“Segmentation
    Fault”）。
- en: You can see how in even a simple program, around 5 different signals were used
    to communicate between processes and the kernel and keep things running. There
    are many other signals, but these are certainly amongst the most common. Most
    have system functions defined by the kernel, but there are a few signals reserved
    for users to use for their own purposes within their programs (`SIGUSR`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，即使在简单的程序中，也有大约5种不同的信号被用来在进程和内核之间进行通信，并保持程序的运行。还有很多其他的信号，但这些都无疑是其中最常见的一些。大多数信号都有内核定义的系统功能，但也有一些信号是为用户保留的，用户可以在自己的程序中用于自己的目的（`SIGUSR`）。
- en: </main>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: </main>
