- en: Rule of three/five/zero
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三/五/零规则
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/constructors/rule_of_three_five_zero.html](https://cel.cs.brown.edu/crp/idioms/constructors/rule_of_three_five_zero.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cel.cs.brown.edu/crp/idioms/constructors/rule_of_three_five_zero.html](https://cel.cs.brown.edu/crp/idioms/constructors/rule_of_three_five_zero.html)
- en: '[Rule of three](#rule-of-three)'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[三条规则](#rule-of-three)'
- en: In C++ the rule of three is a rule of thumb that if a class has a user-defined
    destructor, copy constructor or copy assignment operator, it probably should have
    all three.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，三条规则是一个经验法则，如果一个类有一个用户定义的析构函数、复制构造函数或复制赋值运算符，它可能应该有所有这三个。
- en: 'The corresponding rule for Rust is that if a type has a user-defined `Clone`
    or `Drop` implementation, it probably needs both. This is for the same reason
    as the rule of three in C++: if a type has a user-defined implementation for `Clone`
    or `Drop`, it is probably because the type manages a resource, and both `Clone`
    and `Drop` will need to take special actions for the resource.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Rust，相应的规则是，如果一个类型有用户定义的 `Clone` 或 `Drop` 实现，它可能需要两者。这是与 C++ 中的三条规则相同的原因：如果一个类型有用户定义的
    `Clone` 或 `Drop` 实现，这通常是因为该类型管理资源，`Clone` 和 `Drop` 都需要为资源执行特殊操作。
- en: '[Rule of five](#rule-of-five)'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[五条规则](#rule-of-five)'
- en: The rule of five in C++ states that if move semantics are needed for a type
    with a user-defined copy constructor or copy assignment operator, then a user-defined
    move constructor and move assignment should also be provided, because no implicit
    move constructor or move assignment operator will be generated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的五条规则指出，如果一个类型需要用户定义的复制构造函数或复制赋值运算符的移动语义，那么也应该提供用户定义的移动构造函数和移动赋值运算符，因为没有隐式的移动构造函数或移动赋值运算符会被生成。
- en: In Rust, this rule is not relevant because of the [difference in move semantics
    between C++ and Rust.](copy_and_move_constructors.html#move-constructors)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，由于 C++ 和 Rust 之间移动语义的差异，这条规则不适用。[差异在 C++ 和 Rust 之间的移动语义](copy_and_move_constructors.html#move-constructors)。
- en: '[Rule of zero](#rule-of-zero)'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[零规则](#rule-of-zero)'
- en: The rule of zero states that classes with user-defined copy/move constructors,
    assignment operators, and destructors should deal only with ownership, and other
    classes should not have those constructors or destructors. In practice, most classes
    should make use of types from the STL (`shared_ptr`, `vector`, etc.) for dealing
    with ownership concerns so that the implicitly defined copy and move constructors
    are sufficient.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 零规则指出，具有用户定义的复制/移动构造函数、赋值运算符和析构函数的类应仅处理所有权，其他类不应有这些构造函数或析构函数。在实践中，大多数类应使用 STL（`shared_ptr`、`vector`
    等）中的类型来处理所有权问题，这样隐式定义的复制和移动构造函数就足够了。
- en: In Rust, the same is true. See the list of Rust type equivalents for equivalents
    of C++ [smart pointer types](../type_equivalents.html#pointers) and equivalents
    of C++ [container types](../type_equivalents.html#containers).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，情况也是如此。请参阅 Rust 类型等价列表，以了解 C++ [智能指针类型](../type_equivalents.html#pointers)
    和 C++ [容器类型](../type_equivalents.html#containers) 的等价类型。
- en: One difference between C++ and Rust in applying the rule of zero is that in
    C++ `std::unique_ptr` can take a custom deleter, making it possible to use `std::unique_ptr`
    for wrapping raw pointers that require custom destruction logic. In Rust, the
    `Box` type is not parameterized in the same way. To accomplish the same goal,
    one instead must define a new type with a user-defined `Drop` implementation,
    as is done in [the example in the chapter on copy and move constructors](./copy_and_move_constructors.html#user-defined-constructors).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用零规则时，C++ 和 Rust 之间有一个区别是，在 C++ 中 `std::unique_ptr` 可以接受自定义的删除器，这使得可以使用 `std::unique_ptr`
    来包装需要自定义销毁逻辑的原始指针。在 Rust 中，`Box` 类型不是以相同的方式进行参数化的。为了达到相同的目标，必须定义一个新的类型，并实现用户定义的
    `Drop`，正如在[复制和移动构造函数章节中的示例](./copy_and_move_constructors.html#user-defined-constructors)中所做的那样。
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Rule
    of three/five/zero)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [点击此处为此页面提供反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Rule
    of three/five/zero)
