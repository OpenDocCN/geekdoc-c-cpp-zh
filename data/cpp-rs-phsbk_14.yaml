- en: Template classes, functions, and methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板类、函数和方法
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/data_modeling/templates.html](https://cel.cs.brown.edu/crp/idioms/data_modeling/templates.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cel.cs.brown.edu/crp/idioms/data_modeling/templates.html](https://cel.cs.brown.edu/crp/idioms/data_modeling/templates.html)
- en: The most common uses of templates in C++ are to define classes, methods, or
    functions that work for any type (or at least for any type that provides certain
    methods). This use case is common in the STL for container classes (such as `<vector>`)
    and for the algorithms library (`<algorithm>`).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++中模板最常见的用途是定义适用于任何类型（或至少适用于提供某些方法的任何类型）的类、方法或函数。这种用法在STL的容器类（如`<vector>`）和算法库（`<algorithm>`）中很常见。
- en: The following example defines a template for a directed graph represented as
    an adjacency list, where the graph is generic in the type of the labels on the
    nodes. Though the example shows a template class, the same comparisons with Rust
    apply to template methods and template functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个模板，用于表示为邻接表形式的定向图，其中图在节点标签的类型上是通用的。尽管示例展示了模板类，但与Rust的模板方法和模板函数相同的比较也适用于Rust。
- en: The same kind of reusable code can be created in Rust using generic types.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中演示的使用案例中，使用C++模板定义类和使用Rust泛型定义结构体之间的实际差异很少。当在C++中使用接受`typename`或`class`参数的模板时，可以在Rust中相应地使用类型参数。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
- en: 'adjacencies: Vec<Vec<usize>>,'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'adjacencies: Vec<Vec<usize>>,'
- en: 'node_labels: Vec<Label>,'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'node_labels: Vec<Label>,'
- en: '}'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: impl<Label> DirectedGraph<Label> {
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: impl<Label> DirectedGraph<Label> {
- en: pub fn new() -> Self {
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pub fn new() -> Self {
- en: DirectedGraph {
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: DirectedGraph {
- en: 'adjacencies: Vec::new(),'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'adjacencies: Vec::new(),'
- en: 'node_labels: Vec::new(),'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'node_labels: Vec::new(),'
- en: '}'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: pub fn add_node(
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pub fn add_node(
- en: '&mut self,'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&mut self,'
- en: 'label: Label,'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'label: Label,'
- en: ) -> usize {
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ) -> usize {
- en: self.adjacencies.push(Vec::new());
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.adjacencies.push(Vec::new());
- en: self.node_labels.push(label);
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.node_labels.push(label);
- en: self.num_nodes() - 1
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.num_nodes() - 1
- en: '}'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: pub fn add_edge(
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pub fn add_edge(
- en: '&mut self,'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '&mut self,'
- en: 'from: usize,'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'from: usize,'
- en: 'to: usize,'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'to: usize,'
- en: ) -> Result<(), &str> {
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ) -> Result<(), &str> {
- en: let num_nodes = self.num_nodes();
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: let num_nodes = self.num_nodes();
- en: if from >= num_nodes || to >= num_nodes {
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if from >= num_nodes || to >= num_nodes {
- en: Err("Node index out of range.")
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Err("Node index out of range.")
- en: '} else {'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: self.adjacencies[from].push(to);
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.adjacencies[from].push(to);
- en: Ok(())
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ok(())
- en: '}'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: pub fn num_nodes(&self) -> usize {
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pub fn num_nodes(&self) -> usize {
- en: self.node_labels.len()
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.node_labels.len()
- en: '}'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the use case demonstrated in the above example, there are few practical differences
    between using C++ template to define a class and using and Rust's generics to
    define a struct. Whenever one would use a template that takes a `typename` or
    `class` parameter in C++, one can instead take a type parameter in Rust.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中演示的使用案例中，使用C++模板定义类和使用Rust泛型定义结构体之间的实际差异很少。当在C++中使用接受`typename`或`class`参数的模板时，可以在Rust中相应地使用类型参数。
- en: '[Operations on the parameterized type](#operations-on-the-parameterized-type)'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[参数化类型的操作](#operations-on-the-parameterized-type)'
- en: The differences become more apparent when one attempts to perform operations
    on the values. The following code listing adds a method to get the smallest node
    in the graph to both the Rust and the C++ examples.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试对值执行操作时，差异变得更加明显。以下代码列表向Rust和C++示例中添加了一个获取图中最小节点的方法。
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
- en: 'adjacencies: Vec<Vec<usize>>, node_labels: Vec<Label>, }   impl<Label> DirectedGraph<Label>
    {'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'adjacencies: Vec<Vec<usize>>, node_labels: Vec<Label>, }   impl<Label> DirectedGraph<Label>
    {'
- en: 'pub fn new() -> Self { DirectedGraph { adjacencies: Vec::new(), node_labels:
    Vec::new(), } }   pub fn add_node( &mut self, label: Label, ) -> usize { self.adjacencies.push(Vec::new());
    self.node_labels.push(label); self.num_nodes() - 1 }   pub fn num_nodes(&self)
    -> usize { self.node_labels.len() }   pub fn add_edge( &mut self, from: usize,
    to: usize, ) -> Result<(), &str> { if from > self.num_nodes() || to > self.num_nodes()
    { Err("Node not in graph.") } else { self.adjacencies[from].push(to); Ok(()) }
    }    pub fn smallest_node(&self) -> Option<usize>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'pub fn new() -> Self { DirectedGraph { adjacencies: Vec::new(), node_labels:
    Vec::new(), } }   pub fn add_node( &mut self, label: Label, ) -> usize { self.adjacencies.push(Vec::new());
    self.node_labels.push(label); self.num_nodes() - 1 }   pub fn num_nodes(&self)
    -> usize { self.node_labels.len() }   pub fn add_edge( &mut self, from: usize,
    to: usize, ) -> Result<(), &str> { if from > self.num_nodes() || to > self.num_nodes()
    { Err("Node not in graph.") } else { self.adjacencies[from].push(to); Ok(()) }
    }    pub fn smallest_node(&self) -> Option<usize>'
- en: where
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: where
- en: 'Label: Ord,'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Label: Ord,'
- en: '{'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: // Matches the C++, but is not the idomatic
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 与C++匹配，但不是惯用的
- en: // implementation!
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // implementation!
- en: if self.node_labels.is_empty() {
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if self.node_labels.is_empty() {
- en: None
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: None
- en: '} else {'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: let mut least = &self.node_labels[0];
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: let mut least = &self.node_labels[0];
- en: let mut index = 0;
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: let mut index = 0;
- en: for i in 1..self.node_labels.len() {
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: for i in 1..self.node_labels.len() {
- en: if *least > self.node_labels[i] {
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if *least > self.node_labels[i] {
- en: least = &self.node_labels[i];
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: least = &self.node_labels[i];
- en: index = i;
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: index = i;
- en: '}'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: Some(index)
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Some(index)
- en: '}'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The major difference between these implementations is that in the C++ version
    the `>` operator or `operator>` method is used on the values without knowing whether
    the either is defined for the type. In the Rust version, there is a constraint
    requiring that the `Label` type implement the `Ord` trait. (See the chapter on
    [concepts, interfaces, and static dispatch](./concepts.html) for more details
    on Rust traits and how they relate to C++ concepts.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现之间的主要区别在于，在 C++ 版本中，`>` 操作符或 `operator>` 方法在不知道是否为该类型定义的情况下用于值。在 Rust 版本中，有一个约束要求
    `Label` 类型实现 `Ord` 特性。（有关 Rust 特性和它们如何与 C++ 概念相关的更多详细信息，请参阅[概念、接口和静态分发](./concepts.html)章节。）
- en: Unlike C++ templates, generic definitions in Rust are type checked at the point
    of definition rather than at the point of use. This means that for operations
    to be used on values with the type of a type parameter, the parameter has to be
    constrained to types that implement some trait. As can be seen in the above example,
    much like with C++ concepts and `requires`, the constraint can be required for
    individual methods rather than for the whole generic class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 模板不同，Rust 中的泛型定义在定义点而不是使用点进行类型检查。这意味着要对类型参数的类型进行约束，以便在值上使用操作。如上述示例所示，与
    C++ 概念和 `requires` 类似，约束可以要求对单个方法而不是整个泛型类进行要求。
- en: It is best practice in Rust to put the trait bounds on the specific things that
    require the bounds, in order to make the overall use of the types more flexible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，将特质的界限放在需要界限的具体事物上是一种最佳实践，以便使类型的整体使用更加灵活。
- en: As an aside, a more idiomatic implementation of `smallest_node` makes use of
    Rust's iterators. This style of implementation may take some getting used to for
    programmers more accustomed to implementations in the style used in the earlier
    example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，`smallest_node` 的更惯用实现利用了 Rust 的迭代器。这种实现风格可能需要程序员适应，尤其是那些更习惯于早期示例中使用的实现风格的程序员。
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { pub struct DirectedGraph<Label> {'
- en: 'adjacencies: Vec<Vec<usize>>, node_labels: Vec<Label>, }   impl<Label> DirectedGraph<Label>
    {'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'adjacencies: Vec<Vec<usize>>, node_labels: Vec<Label>, }   impl<Label> DirectedGraph<Label>
    {'
- en: 'pub fn new() -> Self { DirectedGraph { adjacencies: Vec::new(), node_labels:
    Vec::new(), } }   pub fn add_node( &mut self, label: Label, ) -> usize { self.adjacencies.push(Vec::new());
    self.node_labels.push(label); self.num_nodes() - 1 }   pub fn num_nodes(&self)
    -> usize { self.node_labels.len() }   pub fn add_edge( &mut self, from: usize,
    to: usize, ) -> Result<(), &str> { if from > self.num_nodes() || to > self.num_nodes()
    { Err("Node not in graph.") } else { self.adjacencies[from].push(to); Ok(()) }
    }    pub fn smallest_node(&self) -> Option<usize>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'pub fn new() -> Self { DirectedGraph { adjacencies: Vec::new(), node_labels:
    Vec::new(), } }   pub fn add_node( &mut self, label: Label, ) -> usize { self.adjacencies.push(Vec::new());
    self.node_labels.push(label); self.num_nodes() - 1 }   pub fn num_nodes(&self)
    -> usize { self.node_labels.len() }   pub fn add_edge( &mut self, from: usize,
    to: usize, ) -> Result<(), &str> { if from > self.num_nodes() || to > self.num_nodes()
    { Err("Node not in graph.") } else { self.adjacencies[from].push(to); Ok(()) }
    }    pub fn smallest_node(&self) -> Option<usize>'
- en: where
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: where
- en: 'Label: Ord,'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Label: Ord,'
- en: '{'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: self.node_labels
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.node_labels
- en: .iter()
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: .iter()
- en: .enumerate()
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: .enumerate()
- en: .map(|(i, l)| (l, i))
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: .map(|(i, l)| (l, i))
- en: .min()
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: .min()
- en: .map(|(_, i)| i)
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: .map(|(_, i)| i)
- en: '}'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An even more idiomatic implementation would make use of the [itertools crate](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.position_min).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 更为惯用的实现会利用 [itertools crate](https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.position_min)。
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[`constexpr` template parameters](#constexpr-template-parameters)'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`constexpr` 模板参数](#constexpr-template-parameters)'
- en: Rust also supports the equivalent of constexpr template parameters. For example,
    one can define a generic function that returns an array of consecutive integers
    starting from a specific value and whose size is determined at compile time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 还支持 `constexpr` 模板参数的等效功能。例如，可以定义一个泛型函数，该函数返回从特定值开始的连续整数数组，其大小在编译时确定。
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#![allow(unused)] fn main() { fn make_sequential_array<const N: usize>('
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { fn make_sequential_array<const N: usize>('
- en: 'start: i32,'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'start: i32,'
- en: ) -> [i32; N] {
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ) -> [i32; N] {
- en: std::array::from_fn(|i| start + i as i32)
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: std::array::from_fn(|i| start + i as i32)
- en: '}'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The corresponding idiomatic Rust function uses the helper `std::array::from_fn`
    to construct the array. `from_fn` itself takes as type parameters the element
    type and the constant. Those arguments are elided because Rust can infer them,
    because both are part of the type of the produced array.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的 Rust 函数使用辅助函数 `std::array::from_fn` 来构建数组。`from_fn` 本身将元素类型和常量作为类型参数。这些参数被省略，因为
    Rust 可以推断它们，因为它们都是产生数组类型的一部分。
- en: '[Rust''s `Self` type](#rusts-self-type)'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Rust 的 `Self` 类型](#rusts-self-type)'
- en: Within a Rust struct defintion, `impl` block, or `impl` trait block, there is
    a `Self` type that is in scope. The `Self` type is the type of the class being
    defined with all of the generic type parameters filled in. It can be useful to
    refer to this type especially in cases where there are many parameters that would
    otherwise have to be listed out.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 结构定义、`impl` 块或 `impl` 特质块内部，存在一个 `Self` 类型，该类型在作用域内。`Self` 类型是所有泛型类型参数都已填充的正在被定义的类的类型。在有许多参数且否则必须列出的情况下，引用此类型可能很有用。
- en: The `Self` type is necessary when defining generic traits to refer to the concrete
    implementing type. Because Rust does not have inheritance between concrete types
    and does not have method overriding, this is sufficient to avoid the need to pass
    the implementing type as a type parameter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义泛型特质时，`Self` 类型是必要的，以引用具体的实现类型。因为 Rust 在具体类型之间没有继承，也没有方法重写，所以这足以避免需要将实现类型作为类型参数传递。
- en: For examples of this, see the chapter on the [curiously reoccurring template
    pattern](../../patterns/crtp.html#method-chaining).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此的示例，请参阅 [古怪重复出现的模板模式](../../patterns/crtp.html#method-chaining) 章节。
- en: '[A note on type checking and type errors](#a-note-on-type-checking-and-type-errors)'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[关于类型检查和类型错误的说明](#a-note-on-type-checking-and-type-errors)'
- en: The checking of generic types at the point of definition rather than at the
    point of template expansion impacts when errors are detected and how they are
    reported. Some of this difference cannot be achieved by consistently using C++
    concepts to declare the operations required.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义点而不是模板展开点检查泛型类型会影响错误检测的时间和错误报告的方式。一些这种差异不能通过一致地使用 C++ 概念来声明所需的操作来实现。
- en: For example, one might accidentally make the `nodeLabels` member a vector of
    `size_t` instead of a vector of the label parameter. If all of the test cases
    for the graph used label types that were convertible to integers, the error would
    not be detected.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个人可能会不小心将 `nodeLabels` 成员变量做成 `size_t` 类型的向量而不是标签参数的向量。如果用于图的测试用例中使用的标签类型都可以转换为整数，则不会检测到错误。
- en: A similar Rust program fails to compile, even without a function that instantiates
    the generic structure with a concrete type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的 Rust 程序无法编译，即使没有实例化泛型结构的具体类型的函数。
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Despite the error, the C++ example compiles and passes the tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有错误，C++ 示例仍然可以编译并通过测试。
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even without test cases, the Rust example fails to compile and produces a message
    useful for identifying the error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有测试用例，Rust 示例也无法编译并产生用于识别错误的有用信息。
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Lifetimes parameters](#lifetimes-parameters)'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[生命周期参数](#lifetimes-parameters)'
- en: Rust's generics are also used for classes, methods, traits, and functions that
    are generic in the lifetimes of the references they manipulate. Unlike other type
    parameters, using a function with different lifetimes does not cause additional
    copies of the function to be generated in the compiled code, because lifetimes
    do not impact the runtime representation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的泛型也用于类、方法、特质和函数，这些函数在它们操作的引用的生命周期中是泛型的。与其他类型参数不同，使用具有不同生命周期的函数不会在编译代码中生成函数的额外副本，因为生命周期不会影响运行时表示。
- en: The chapter on concepts includes [examples of how lifetimes interact with Rust's
    generics](./concepts.html#generics-and-lifetimes).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 概念章节包括 [Rust 泛型与生命周期交互的示例](./concepts.html#generics-and-lifetimes)。
- en: '[Conditional compilation](#conditional-compilation)'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[条件编译](#conditional-compilation)'
- en: One significant difference between C++ templates and Rust generics is that C++
    templates are actually a more general purpose macro language, supporting things
    like conditional compilation (e.g., when used in conjunction with `if constexpr`,
    `requires`, or `std::enable_if`). Rust supports these use cases with its macro
    system, which differs significantly from C++. The most common use of the macro
    system, conditional compilation, is provided by [the `cfg` attribute and `cfg!`
    macro](https://doc.rust-lang.org/rust-by-example/attribute/cfg.html).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板与Rust泛型之间一个显著的区别是，C++模板实际上是一种更通用的宏语言，支持诸如条件编译（例如，与`if constexpr`、`requires`或`std::enable_if`结合使用时）等功能。Rust通过其宏系统支持这些用例，该系统与C++有显著不同。宏系统最常见的使用，即条件编译，由[`cfg`属性和`cfg!`宏](https://doc.rust-lang.org/rust-by-example/attribute/cfg.html)提供。
- en: The separation of conditional compilation from generics in Rust involves similar
    design considerations as the omission of [template specialization](./template_specialization.html)
    from Rust.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中将条件编译与泛型分离的设计考虑与从Rust中省略[模板特化](./template_specialization.html)的设计考虑相似。
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Template
    classes, functions, and methods)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [点击此处为我们提供关于此页面的反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=模板类、函数和方法)
