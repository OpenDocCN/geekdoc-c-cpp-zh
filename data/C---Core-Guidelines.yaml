- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分类：未分类
- en: 'date: 2026-01-06 18:01:40'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2026-01-06 18:01:40
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: C++ Core Guidelines
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 核心准则
- en: 来源：[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#s-profile](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#s-profile)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#s-profile](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#s-profile)
- en: Jul 8, 2025
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2025年7月8日
- en: 'Editors:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑者：
- en: '[Bjarne Stroustrup](https://www.stroustrup.com)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[比约恩·斯特劳斯特鲁普](https://www.stroustrup.com)'
- en: '[Herb Sutter](https://herbsutter.com/)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[赫布·萨特](https://herbsutter.com/)'
- en: This is a living document under continuous improvement. Had it been an open-source
    (code) project, this would have been release 0.8. Copying, use, modification,
    and creation of derivative works from this project is licensed under an MIT-style
    license. Contributing to this project requires agreeing to a Contributor License.
    See the accompanying [LICENSE](https://github.com/isocpp/CppCoreGuidelines/blob/master/LICENSE)
    file for details. We make this project available to “friendly users” to use, copy,
    modify, and derive from, hoping for constructive input.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个持续改进的活文档。如果它是一个开源（代码）项目，这将是一个0.8版本。从本项目复制、使用、修改和创建衍生作品受MIT风格许可协议的许可。向本项目贡献需要同意贡献者许可协议。有关详细信息，请参阅附带的[LICENSE](https://github.com/isocpp/CppCoreGuidelines/blob/master/LICENSE)文件。我们向“友好用户”提供此项目，以使用、复制、修改和衍生，希望得到建设性的反馈。
- en: Comments and suggestions for improvements are most welcome. We plan to modify
    and extend this document as our understanding improves and the language and the
    set of available libraries improve. When commenting, please note [the introduction](#s-introduction)
    that outlines our aims and general approach. The list of contributors is [here](#ss-ack).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎提出改进意见和评论。我们计划随着我们对语言和可用库的理解加深而修改和扩展此文档。在评论时，请注意[介绍](#s-introduction)，其中概述了我们的目标和一般方法。贡献者名单[在此](#ss-ack)。
- en: 'Problems:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：
- en: The sets of rules have not been completely checked for completeness, consistency,
    or enforceability.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则集尚未完全检查其完整性、一致性或可执行性。
- en: Triple question marks (???) mark known missing information.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三重问号（???)表示已知缺失信息。
- en: Update reference sections; many pre-C++11 sources are too old.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新参考部分；许多 C++11 之前的源代码过于陈旧。
- en: 'For a more-or-less up-to-date to-do list see: [To-do: Unclassified proto-rules](#s-unclassified).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新或更接近更新的待办事项列表请参阅：[待办：未分类原型规则](#s-unclassified)。
- en: 'You can [read an explanation of the scope and structure of this Guide](#s-abstract)
    or just jump straight in:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以[阅读关于本指南范围和结构的说明](#s-abstract)或直接进入：
- en: '[In: Introduction](#s-introduction)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍](#s-introduction)'
- en: '[P: Philosophy](#s-philosophy)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P：哲学](#s-philosophy)'
- en: '[I: Interfaces](#s-interfaces)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I：接口](#s-interfaces)'
- en: '[F: Functions](#s-functions)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F：函数](#s-functions)'
- en: '[C: Classes and class hierarchies](#s-class)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C：类和类层次](#s-class)'
- en: '[Enum: Enumerations](#s-enum)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Enum：枚举](#s-enum)'
- en: '[R: Resource management](#s-resource)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R：资源管理](#s-resource)'
- en: '[ES: Expressions and statements](#s-expr)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES：表达式和语句](#s-expr)'
- en: '[Per: Performance](#s-performance)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[性能](#s-performance)'
- en: '[CP: Concurrency and parallelism](#s-concurrency)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP：并发和并行](#s-concurrency)'
- en: '[E: Error handling](#s-errors)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[错误处理](#s-errors)'
- en: '[Con: Constants and immutability](#s-const)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[常量和不可变性](#s-const)'
- en: '[T: Templates and generic programming](#s-templates)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T：模板和泛型编程](#s-templates)'
- en: '[CPL: C-style programming](#s-cpl)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C风格编程](#s-cpl)'
- en: '[SF: Source files](#s-source)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF：源文件](#s-source)'
- en: '[SL: The Standard Library](#sl-the-standard-library)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL：标准库](#sl-the-standard-library)'
- en: 'Supporting sections:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 支持部分：
- en: '[A: Architectural ideas](#s-a)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A：架构思想](#s-a)'
- en: '[NR: Non-Rules and myths](#s-not)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR：非规则和神话](#s-not)'
- en: '[RF: References](#s-references)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF：参考](#s-references)'
- en: '[Pro: Profiles](#s-profile)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pro：配置文件](#s-profile)'
- en: '[GSL: Guidelines support library](#gsl-guidelines-support-library)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GSL：指南支持库](#gsl-guidelines-support-library)'
- en: '[NL: Naming and layout suggestions](#s-naming)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL：命名和布局建议](#s-naming)'
- en: '[FAQ: Answers to frequently asked questions](#s-faq)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[常见问题解答](#s-faq)'
- en: '[Appendix A: Libraries](#s-libraries)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录A：库](#s-libraries)'
- en: '[Appendix B: Modernizing code](#s-modernizing)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录B：代码现代化](#s-modernizing)'
- en: '[Appendix C: Discussion](#s-discussion)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录C：讨论](#s-discussion)'
- en: '[Appendix D: Supporting tools](#s-tools)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录D：支持工具](#s-tools)'
- en: '[Glossary](#s-glossary)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[术语表](#s-glossary)'
- en: '[To-do: Unclassified proto-rules](#s-unclassified)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[待办：未分类原型规则](#s-unclassified)'
- en: 'You can sample rules for specific language features:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以针对特定语言特性采样规则：
- en: 'assignment: [regular types](#rc-regular) – [prefer initialization](#rc-initialize)
    – [copy](#rc-copy-semantic) – [move](#rc-move-semantic) – [other operations](#rc-matched)
    – [default](#rc-eqdefault)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值：[常规类型](#rc-regular) – [优先初始化](#rc-initialize) – [复制](#rc-copy-semantic) –
    [移动](#rc-move-semantic) – [其他操作](#rc-matched) – [默认](#rc-eqdefault)
- en: '`class`: [data](#rc-org) – [invariant](#rc-struct) – [members](#rc-member)
    – [helpers](#rc-helper) – [concrete types](#ss-concrete) – [ctors, =, and dtors](#s-ctor)
    – [hierarchy](#ss-hier) – [operators](#ss-overload)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类`：[数据](#rc-org) – [不变性](#rc-struct) – [成员](#rc-member) – [辅助函数](#rc-helper)
    – [具体类型](#ss-concrete) – [构造函数、赋值运算符和析构函数](#s-ctor) – [层次结构](#ss-hier) – [操作符](#ss-overload)'
- en: '`concept`: [rules](#ss-concepts) – [in generic programming](#rt-raise) – [template
    arguments](#rt-concepts) – [semantics](#rt-low)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`概念`：[规则](#ss-concepts) – [泛型编程中](#rt-raise) – [模板参数](#rt-concepts) – [语义](#rt-low)'
- en: 'constructor: [invariant](#rc-struct) – [establish invariant](#rc-ctor) – [`throw`](#rc-throw)
    – [default](#rc-default0) – [not needed](#rc-default) – [`explicit`](#rc-explicit)
    – [delegating](#rc-delegating) – [`virtual`](#rc-ctor-virtual)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数：[不变性](#rc-struct) – [建立不变性](#rc-ctor) – [抛出](#rc-throw) – [默认](#rc-default0)
    – [不必要](#rc-default) – [显式](#rc-explicit) – [委托](#rc-delegating) – [虚](#rc-ctor-virtual)
- en: 'derived `class`: [when to use](#rh-domain) – [as interface](#rh-abstract) –
    [destructors](#rh-dtor) – [copy](#rh-copy) – [getters and setters](#rh-get) –
    [multiple inheritance](#rh-mi-interface) – [overloading](#rh-using) – [slicing](#rc-copy-virtual)
    – [`dynamic_cast`](#rh-dynamic_cast)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生 `类`：[何时使用](#rh-domain) – [作为接口](#rh-abstract) – [析构函数](#rh-dtor) – [复制](#rh-copy)
    – [获取器和设置器](#rh-get) – [多重继承](#rh-mi-interface) – [重载](#rh-using) – [切片](#rc-copy-virtual)
    – [`dynamic_cast`](#rh-dynamic_cast)
- en: 'destructor: [and constructors](#rc-matched) – [when needed?](#rc-dtor) – [must
    not fail](#rc-dtor-fail)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数：[和构造函数](#rc-matched) – [何时需要？](#rc-dtor) – [不能失败](#rc-dtor-fail)
- en: 'exception: [errors](#s-errors) – [`throw`](#re-throw) – [for errors only](#re-errors)
    – [`noexcept`](#re-noexcept) – [minimize `try`](#re-catch) – [what if no exceptions?](#re-no-throw-codes)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常：[错误](#s-errors) – [抛出](#re-throw) – [仅限错误](#re-errors) – [无异常](#re-noexcept)
    – [最小化 `try`](#re-catch) – [如果没有异常怎么办？](#re-no-throw-codes)
- en: '`for`: [range-for and for](#res-for-range) – [for and while](#res-for-while)
    – [for-initializer](#res-for-init) – [empty body](#res-empty) – [loop variable](#res-loop-counter)
    – [loop variable type ???](#res-???)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`：[range-for 和 for](#res-for-range) – [for 和 while](#res-for-while) – [for
    初始化器](#res-for-init) – [空体](#res-empty) – [循环变量](#res-loop-counter) – [循环变量类型
    ???](#res-???)'
- en: 'function: [naming](#rf-package) – [single operation](#rf-logical) – [no throw](#rf-noexcept)
    – [arguments](#rf-smart) – [argument passing](#rf-conventional) – [multiple return
    values](#rf-out-multi) – [pointers](#rf-return-ptr) – [lambdas](#rf-capture-vs-overload)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数：[命名](#rf-package) – [单一操作](#rf-logical) – [不抛出](#rf-noexcept) – [参数](#rf-smart)
    – [参数传递](#rf-conventional) – [多个返回值](#rf-out-multi) – [指针](#rf-return-ptr) – [lambda
    表达式](#rf-capture-vs-overload)
- en: '`inline`: [small functions](#rf-inline) – [in headers](#rs-inline)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`内联`：[小型函数](#rf-inline) – [在头文件中](#rs-inline)'
- en: 'initialization: [always](#res-always) – [prefer `{}`](#res-list) – [lambdas](#res-lambda-init)
    – [default member initializers](#rc-in-class-initializer) – [class members](#rc-initialize)
    – [factory functions](#rc-factory)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化：[总是](#res-always) – [优先使用 `{}`](#res-list) – [lambda 表达式](#res-lambda-init)
    – [默认成员初始化器](#rc-in-class-initializer) – [类成员](#rc-initialize) – [工厂函数](#rc-factory)
- en: 'lambda expression: [when to use](#ss-lambdas)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda 表达式：[何时使用](#ss-lambdas)
- en: 'operator: [conventional](#ro-conventional) – [avoid conversion operators](#ro-conversion)
    – [and lambdas](#ro-lambda)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符：[传统](#ro-conventional) – [避免转换操作符](#ro-conversion) – [和 lambda 表达式](#ro-lambda)
- en: '`public`, `private`, and `protected`: [information hiding](#rc-private) – [consistency](#rh-public)
    – [`protected`](#rh-protected)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`、`private` 和 `protected`：[信息隐藏](#rc-private) – [一致性](#rh-public) –
    [保护](#rh-protected)'
- en: '`static_assert`: [compile-time checking](#rp-compile-time) – [and concepts](#rt-check-class)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static_assert`：[编译时检查](#rp-compile-time) – [和概念](#rt-check-class)'
- en: '`struct`: [for organizing data](#rc-org) – [use if no invariant](#rc-struct)
    – [no private members](#rc-class)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct`：[用于组织数据](#rc-org) – [如果没有不变性则使用](#rc-struct) – [没有私有成员](#rc-class)'
- en: '`template`: [abstraction](#rt-raise) – [containers](#rt-cont) – [concepts](#rt-concepts)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模板`：[抽象](#rt-raise) – [容器](#rt-cont) – [概念](#rt-concepts)'
- en: '`unsigned`: [and signed](#res-mix) – [bit manipulation](#res-unsigned)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无符号`：[和有符号](#res-mix) – [位操作](#res-unsigned)'
- en: '`virtual`: [interfaces](#ri-abstract) – [not `virtual`](#rc-concrete) – [destructor](#rc-dtor-virtual)
    – [never fail](#rc-dtor-fail)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual`：[接口](#ri-abstract) – [非 `virtual`](#rc-concrete) – [析构函数](#rc-dtor-virtual)
    – [永不失败](#rc-dtor-fail)'
- en: 'You can look at design concepts used to express the rules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看用于表达规则的设计概念：
- en: 'assertion: ???'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言：???
- en: 'error: ???'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误：???
- en: 'exception: exception guarantee (???)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常：异常保证（???）
- en: 'failure: ???'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败：???
- en: 'invariant: ???'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变量：???
- en: 'leak: ???'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄漏：???
- en: 'library: ???'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库：???
- en: 'precondition: ???'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前置条件：???
- en: 'postcondition: ???'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后置条件：???
- en: 'resource: ???'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源：???
- en: Abstract
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This document is a set of guidelines for using C++ well. The aim of this document
    is to help people to use modern C++ effectively. By “modern C++” we mean effective
    use of the ISO C++ standard (currently C++20, but almost all of our recommendations
    also apply to C++17, C++14 and C++11). In other words, what would you like your
    code to look like in 5 years’ time, given that you can start now? In 10 years’
    time?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档是一套关于如何有效使用C++的指南。本文件的目的是帮助人们有效地使用现代C++。当我们说“现代C++”时，我们指的是有效使用ISO C++标准（目前为C++20，但我们的几乎所有建议也适用于C++17、C++14和C++11）。换句话说，如果你现在开始，你希望你的代码在5年后看起来是什么样子？在10年后呢？
- en: The guidelines are focused on relatively high-level issues, such as interfaces,
    resource management, memory management, and concurrency. Such rules affect application
    architecture and library design. Following the rules will lead to code that is
    statically type safe, has no resource leaks, and catches many more programming
    logic errors than is common in code today. And it will run fast – you can afford
    to do things right.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 指南主要关注相对高级的问题，例如接口、资源管理、内存管理和并发。这些规则会影响应用程序架构和库设计。遵循这些规则将导致代码在静态类型安全、没有资源泄漏，并且比现在常见的代码捕捉到更多的编程逻辑错误。而且它将运行得很快——你可以负担得起正确做事。
- en: We are less concerned with low-level issues, such as naming conventions and
    indentation style. However, no topic that can help a programmer is out of bounds.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对低级问题（如命名约定和缩进风格）不太关心。然而，任何可能帮助程序员的主题都不在界限之外。
- en: Our initial set of rules emphasizes safety (of various forms) and simplicity.
    They might very well be too strict. We expect to have to introduce more exceptions
    to better accommodate real-world needs. We also need more rules.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的一套规则强调安全性（各种形式）和简单性。它们可能非常严格。我们预计将需要引入更多例外情况，以更好地满足现实世界的需求。我们还需要更多的规则。
- en: You will find some of the rules contrary to your expectations or even contrary
    to your experience. If we haven’t suggested you change your coding style in any
    way, we have failed! Please try to verify or disprove rules! In particular, we’d
    really like to have some of our rules backed up with measurements or better examples.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现一些规则与你的预期甚至与你的经验相反。如果我们没有以任何方式建议你改变你的编码风格，那么我们就失败了！请尝试验证或反驳这些规则！特别是，我们非常希望有一些规则能够得到测量或更好的示例的支持。
- en: You will find some of the rules obvious or even trivial. Please remember that
    one purpose of a guideline is to help someone who is less experienced or coming
    from a different background or language to get up to speed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现一些规则很明显甚至很平凡。请记住，指南的一个目的是帮助那些经验较少或来自不同背景或语言的人快速上手。
- en: Many of the rules are designed to be supported by an analysis tool. Violations
    of rules will be flagged with references (or links) to the relevant rule. We do
    not expect you to memorize all the rules before trying to write code. One way
    of thinking about these guidelines is as a specification for tools that happens
    to be readable by humans.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 许多规则旨在由分析工具支持。违反规则将用引用（或链接）到相关规则来标记。我们不期望你在尝试编写代码之前记住所有规则。将这些指南视为一种工具规范，这种工具恰好可以由人类阅读，是一种思考这些指南的方式。
- en: The rules are meant for gradual introduction into a code base. We plan to build
    tools for that and hope others will too.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 规则旨在逐步引入到代码库中。我们计划为此构建工具，并希望其他人也会这样做。
- en: Comments and suggestions for improvements are most welcome. We plan to modify
    and extend this document as our understanding improves and the language and the
    set of available libraries improve.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '欢迎评论和建议。我们计划随着我们对语言和可用库的理解提高而修改和扩展这份文档。 '
- en: 'In: Introduction'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在：简介
- en: This is a set of core guidelines for modern C++ (currently C++20 and C++17)
    taking likely future enhancements and ISO Technical Specifications (TSs) into
    account. The aim is to help C++ programmers to write simpler, more efficient,
    more maintainable code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一套针对现代C++（目前为C++20和C++17）的核心指南，考虑到可能的未来增强和ISO技术规范（TS）。目标是帮助C++程序员编写更简单、更高效、更易于维护的代码。
- en: 'Introduction summary:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简介摘要：
- en: '[In.target: Target readership](#ss-readers)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[目标读者：目标读者](#ss-readers)'
- en: '[In.aims: Aims](#ss-aims)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[目标：目标](#ss-aims)'
- en: '[In.not: Non-aims](#ss-non)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[非目标：非目标](#ss-non)'
- en: '[In.force: Enforcement](#ss-force)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[In.force: 执法](#ss-force)'
- en: '[In.struct: The structure of this document](#ss-struct)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[In.struct: 本文档的结构](#ss-struct)'
- en: '[In.sec: Major sections](#ss-sec)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[In.sec: 主要部分](#ss-sec)'
- en: 'In.target: Target readership'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'In.target: 目标读者群体'
- en: All C++ programmers. This includes [programmers who might consider C](#s-cpl).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有C++程序员。这包括[可能考虑使用C的程序员](#s-cpl)。
- en: 'In.aims: Aims'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'In.aims: 目标'
- en: The purpose of this document is to help developers to adopt modern C++ (currently
    C++20 and C++17) and to achieve a more uniform style across code bases.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档的目的是帮助开发者采用现代C++（目前为C++20和C++17）并使代码库的风格更加统一。
- en: 'We do not suffer the delusion that every one of these rules can be effectively
    applied to every code base. Upgrading old systems is hard. However, we do believe
    that a program that uses a rule is less error-prone and more maintainable than
    one that does not. Often, rules also lead to faster/easier initial development.
    As far as we can tell, these rules lead to code that performs as well or better
    than older, more conventional techniques; they are meant to follow the zero-overhead
    principle (“what you don’t use, you don’t pay for” or “when you use an abstraction
    mechanism appropriately, you get at least as good performance as if you had handcoded
    using lower-level language constructs”). Consider these rules ideals for new code,
    opportunities to exploit when working on older code, and try to approximate these
    ideals as closely as feasible. Remember:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不抱有一种幻想，认为这些规则中的每一个都能有效地应用于每一个代码库。升级旧系统是困难的。然而，我们确实相信，使用规则的程序比不使用规则的程序更少出错，更容易维护。通常，规则也会导致更快/更简单的初始开发。据我们所知，这些规则产生的代码性能与较老、更传统的技术相当甚至更好；它们旨在遵循零开销原则（“你不使用的，你就不必支付”或“当你适当地使用抽象机制时，你至少能得到与使用底层语言结构手动编码相当的性能”）。将这些规则视为新代码的理想，当处理旧代码时是利用的机会，并尽可能接近这些理想。记住：
- en: 'In.0: Don’t panic!'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'In.0: 不要慌张！'
- en: Take the time to understand the implications of a guideline rule on your program.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 抽出时间来理解指南规则对你程序的影响。
- en: These guidelines are designed according to the “subset of superset” principle
    ([Stroustrup05](#Stroustrup05)). They do not simply define a subset of C++ to
    be used (for reliability, safety, performance, or whatever). Instead, they strongly
    recommend the use of a few simple “extensions” ([library components](#gsl-guidelines-support-library))
    that make the use of the most error-prone features of C++ redundant, so that they
    can be banned (in our set of rules).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南是根据“子集超集”原则设计的（[Stroustrup05](#Stroustrup05)）。它们并不简单地定义一个要使用的C++子集（为了可靠性、安全性、性能或其他）。相反，它们强烈推荐使用一些简单的“扩展”（[库组件](#gsl-guidelines-support-library)），这些扩展使得使用C++中最容易出错的特性变得多余，因此可以禁止（在我们的规则集中）。
- en: The rules emphasize static type safety and resource safety. For that reason,
    they emphasize possibilities for range checking, for avoiding dereferencing `nullptr`,
    for avoiding dangling pointers, and the systematic use of exceptions (via RAII).
    Partly to achieve that and partly to minimize obscure code as a source of errors,
    the rules also emphasize simplicity and the hiding of necessary complexity behind
    well-specified interfaces.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则强调静态类型安全和资源安全。因此，它们强调范围检查的可能性，避免解引用`nullptr`，避免悬垂指针，以及系统地使用异常（通过RAII）。部分是为了实现这一点，部分是为了最小化模糊代码作为错误来源，这些规则还强调了简洁性和将必要的复杂性隐藏在良好定义的接口之后。
- en: Many of the rules are prescriptive. We are uncomfortable with rules that simply
    state “don’t do that!” without offering an alternative. One consequence of that
    is that some rules can be supported only by heuristics, rather than precise and
    mechanically verifiable checks. Other rules articulate general principles. For
    these more general rules, more detailed and specific rules provide partial checking.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 许多规则是规定性的。我们不喜欢那些只是声明“不要那样做！”而不提供替代方案的规则。其后果之一是，一些规则只能通过启发式方法来支持，而不是精确和机械可验证的检查。其他规则阐述了一般原则。对于这些更一般的规则，更详细和具体的规则提供了部分检查。
- en: These guidelines address the core of C++ and its use. We expect that most large
    organizations, specific application areas, and even large projects will need further
    rules, possibly further restrictions, and further library support. For example,
    hard-real-time programmers typically can’t use free store (dynamic memory) freely
    and will be restricted in their choice of libraries. We encourage the development
    of such more specific rules as addenda to these core guidelines. Build your ideal
    small foundation library and use that, rather than lowering your level of programming
    to glorified assembly code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南针对C++的核心及其使用。我们预计大多数大型组织、特定应用领域甚至大型项目都需要进一步的规则、可能的进一步限制和进一步的库支持。例如，硬实时程序员通常不能自由使用自由存储（动态内存），并且在选择库方面会受到限制。我们鼓励开发此类更具体的规则，作为这些核心指南的补充。构建您理想的小型基础库并使用它，而不是降低您的编程水平到被美化的汇编代码。
- en: The rules are designed to allow [gradual adoption](#s-modernizing).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 规则旨在允许[逐步采用](#s-modernizing)。
- en: Some rules aim to increase various forms of safety while others aim to reduce
    the likelihood of accidents, many do both. The guidelines aimed at preventing
    accidents often ban perfectly legal C++. However, when there are two ways of expressing
    an idea and one has shown itself a common source of errors and the other has not,
    we try to guide programmers towards the latter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些规则旨在提高各种形式的安全性，而另一些规则旨在降低事故发生的可能性，许多规则两者兼具。旨在防止事故的指南通常禁止完全合法的C++。然而，当有两种表达一个想法的方式，其中一种已被证明是常见错误源而另一种没有时，我们试图引导程序员向后者靠拢。
- en: 'In.not: Non-aims'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'In.not: 非目标'
- en: The rules are not intended to be minimal or orthogonal. In particular, general
    rules can be simple, but unenforceable. Also, it is often hard to understand the
    implications of a general rule. More specialized rules are often easier to understand
    and to enforce, but without general rules, they would just be a long list of special
    cases. We provide rules aimed at helping novices as well as rules supporting expert
    use. Some rules can be completely enforced, but others are based on heuristics.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 规则并非旨在最小化或正交化。特别是，一般规则可以很简单，但难以执行。此外，通常很难理解一般规则的影响。更专业的规则通常更容易理解和执行，但没有一般规则，它们就只是一长串的特殊情况。我们提供旨在帮助新手的规则以及支持专家使用的规则。一些规则可以完全执行，但其他规则基于启发式方法。
- en: These rules are not meant to be read serially, like a book. You can browse through
    them using the links. However, their main intended use is to be targets for tools.
    That is, a tool looks for violations and the tool returns links to violated rules.
    The rules then provide reasons, examples of potential consequences of the violation,
    and suggested remedies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则并非旨在按顺序阅读，就像一本书一样。您可以通过链接浏览它们。然而，它们的主要用途是作为工具的目标。也就是说，工具会查找违规情况，并返回违反规则的链接。然后，规则会提供原因、违反潜在后果的示例以及建议的补救措施。
- en: These guidelines are not intended to be a substitute for a tutorial treatment
    of C++. If you need a tutorial for some given level of experience, see [the references](#s-references).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南并非旨在替代对C++的教程式处理。如果您需要某个特定经验水平的教程，请参阅[参考资料](#s-references)。
- en: 'This is not a guide on how to convert old C++ code to more modern code. It
    is meant to articulate ideas for new code in a concrete fashion. However, see
    [the modernization section](#s-modernizing) for some possible approaches to modernizing/rejuvenating/upgrading.
    Importantly, the rules support gradual adoption: It is typically infeasible to
    completely convert a large code base all at once.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是关于如何将旧C++代码转换为更现代代码的指南。它的目的是以具体的方式阐述新代码的想法。然而，请参阅[现代化部分](#s-modernizing)以了解一些可能的现代化/更新/升级方法。重要的是，规则支持逐步采用：通常不可能一次性完全转换大型代码库。
- en: These guidelines are not meant to be complete or exact in every language-technical
    detail. For the final word on language definition issues, including every exception
    to general rules and every feature, see the ISO C++ standard.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南并非旨在在每种语言的技术细节上完整或精确。关于语言定义问题的最终决定，包括所有一般规则的例外和每个特性，请参阅ISO C++标准。
- en: The rules are not intended to force you to write in an impoverished subset of
    C++. They are *emphatically* not meant to define a, say, Java-like subset of C++.
    They are not meant to define a single “one true C++” language. We value expressiveness
    and uncompromised performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 规则并非旨在强迫您使用C++的贫乏子集进行编写。它们绝对不是旨在定义一个类似Java的C++子集。它们不是旨在定义一个单一的“真正的C++”语言。我们重视表达性和无妥协的性能。
- en: The rules are not value-neutral. They are meant to make code simpler and more
    correct/safer than most existing C++ code, without loss of performance. They are
    meant to inhibit perfectly valid C++ code that correlates with errors, spurious
    complexity, and poor performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 规则并非价值中立。它们旨在使代码比大多数现有的C++代码更简单、更正确/更安全，而不会损失性能。它们旨在阻止与错误、虚假复杂性和较差性能相关的完全有效的C++代码。
- en: The rules are not precise to the point where a person (or machine) can follow
    them without thinking. The enforcement parts try to be that, but we would rather
    leave a rule or a definition a bit vague and open to interpretation than specify
    something precisely and wrong. Sometimes, precision comes only with time and experience.
    Design is not (yet) a form of Math.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 规则并不精确到一个人（或机器）可以无需思考就能遵循它们的地步。执行部分试图做到这一点，但我们更愿意让规则或定义保持一点模糊和开放性，而不是精确到错误的地步。有时，精确性只有通过时间和经验才能获得。设计（目前）不是一种数学形式。
- en: 'The rules are not perfect. A rule can do harm by prohibiting something that
    is useful in a given situation. A rule can do harm by failing to prohibit something
    that enables a serious error in a given situation. A rule can do a lot of harm
    by being vague, ambiguous, unenforceable, or by enabling every solution to a problem.
    It is impossible to completely meet the “do no harm” criteria. Instead, our aim
    is the less ambitious: “Do the most good for most programmers”; if you cannot
    live with a rule, object to it, ignore it, but don’t water it down until it becomes
    meaningless. Also, suggest an improvement.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 规则并不完美。一个规则可能会通过禁止在特定情况下有用的东西来造成伤害。一个规则可能会通过未能禁止在特定情况下导致严重错误的东西来造成伤害。一个规则可能会因为模糊、含糊不清、无法执行或允许解决问题的每个解决方案而造成很多伤害。完全满足“不造成伤害”的标准是不可能的。相反，我们的目标是更雄心勃勃的：“为大多数程序员做最多的好事”；如果你不能接受一个规则，就反对它，忽略它，但不要将其稀释到没有意义。同时，提出改进建议。
- en: 'In.force: Enforcement'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行：执行
- en: Rules with no enforcement are unmanageable for large code bases. Enforcement
    of all rules is possible only for a small weak set of rules or for a specific
    user community.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型代码库来说，没有执行的规则是无法管理的。只有一小部分弱规则或特定用户社区才能执行所有规则。
- en: But we want lots of rules, and we want rules that everybody can use.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但我们希望有很多规则，我们希望每个人都能使用这些规则。
- en: But different people have different needs.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但不同的人有不同的需求。
- en: But people don’t like to read lots of rules.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但人们不喜欢阅读很多规则。
- en: But people can’t remember many rules.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但人们无法记住很多规则。
- en: So, we need subsetting to meet a variety of needs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要子集来满足各种需求。
- en: But arbitrary subsetting leads to chaos.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但任意的子集会导致混乱。
- en: We want guidelines that help a lot of people, make code more uniform, and strongly
    encourage people to modernize their code. We want to encourage best practices,
    rather than leave all to individual choices and management pressures. The ideal
    is to use all rules; that gives the greatest benefits.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有指导方针，帮助很多人，使代码更加统一，并强烈鼓励人们更新他们的代码。我们希望鼓励最佳实践，而不是让所有事情都取决于个人选择和管理压力。理想的情况是使用所有规则；这会带来最大的好处。
- en: 'This adds up to quite a few dilemmas. We try to resolve those using tools.
    Each rule has an **Enforcement** section listing ideas for enforcement. Enforcement
    might be done by code review, by static analysis, by compiler, or by run-time
    checks. Wherever possible, we prefer “mechanical” checking (humans are slow, inaccurate,
    and bore easily) and static checking. Run-time checks are suggested only rarely
    where no alternative exists; we do not want to introduce “distributed bloat”.
    Where appropriate, we label a rule (in the **Enforcement** sections) with the
    name of groups of related rules (called “profiles”). A rule can be part of several
    profiles, or none. For a start, we have a few profiles corresponding to common
    needs (desires, ideals):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了相当多的困境。我们试图使用工具来解决这些问题。每个规则都有一个**执行**部分，列出了执行的想法。执行可能通过代码审查、静态分析、编译器或运行时检查来完成。尽可能的情况下，我们更喜欢“机械”检查（人类速度慢、不准确且容易感到无聊）和静态检查。只有在没有其他选择的情况下，才会建议进行运行时检查；我们不希望引入“分布式膨胀”。在适当的情况下，我们会在**执行**部分用相关规则组（称为“配置文件”）的名称标记规则。一个规则可以是多个配置文件的一部分，也可以不是。一开始，我们有几个与常见需求（愿望、理想）相对应的配置文件：
- en: '**type**: No type violations (reinterpreting a `T` as a `U` through casts,
    unions, or varargs)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：不允许类型违规（通过类型转换、联合或varargs将`T`重新解释为`U`）'
- en: '**bounds**: No bounds violations (accessing beyond the range of an array)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界**：不允许边界违规（访问数组范围之外）'
- en: '**lifetime**: No leaks (failing to `delete` or multiple `delete`) and no access
    to invalid objects (dereferencing `nullptr`, using a dangling reference).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期**：没有泄漏（未能`delete`或多次`delete`）和没有对无效对象的访问（解引用`nullptr`，使用悬垂引用）。'
- en: The profiles are intended to be used by tools, but also serve as an aid to the
    human reader. We do not limit our comment in the **Enforcement** sections to things
    we know how to enforce; some comments are mere wishes that might inspire some
    tool builder.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件旨在供工具使用，但也为人类读者提供帮助。我们在**执行**部分中不限制我们知道的可以执行的内容；一些评论只是愿望，可能会激发一些工具构建者的灵感。
- en: 'Tools that implement these rules shall respect the following syntax to explicitly
    suppress a rule:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些规则的工具应遵守以下语法以显式禁用规则：
- en: '[PRE0]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and optionally with a message (following usual C++11 standard attribute syntax):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地附带一条消息（遵循常用的 C++11 标准属性语法）：
- en: '[PRE1]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: where
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '`"tag"` is a string literal with the anchor name of the item where the Enforcement
    rule appears (e.g., for [C.134](#rh-public) it is “rh-public”), the name of a
    profile group-of-rules (“type”, “bounds”, or “lifetime”), or a specific rule in
    a profile ([type.4](#pro-type-cstylecast), or [bounds.2](#pro-bounds-arrayindex)).
    Any text that is not one of those should be rejected.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"tag"` 是一个字符串字面量，表示执行规则出现的项目的锚点名称（例如，对于 [C.134](#rh-public) 它是 “rh-public”），一个规则组（“类型”、“边界”或“生命周期”）的名称，或者配置文件中的特定规则（[type.4](#pro-type-cstylecast)，或
    [bounds.2](#pro-bounds-arrayindex)）。任何不属于这些的文本都应该被拒绝。'
- en: '`"message"` is a string literal'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"message"` 是一个字符串字面量'
- en: 'In.struct: The structure of this document'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'In.struct: 本文件的结构'
- en: 'Each rule (guideline, suggestion) can have several parts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每条规则（指南、建议）可以有多个部分：
- en: The rule itself – e.g., **no naked `new`**
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则本身 - 例如，**不允许裸`new`**
- en: A rule reference number – e.g., **C.7** (the 7th rule related to classes). Since
    the major sections are not inherently ordered, we use letters as the first part
    of a rule reference “number”. We leave gaps in the numbering to minimize “disruption”
    when we add or remove rules.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则引用编号 - 例如，**C.7**（与类相关的第7条规则）。由于主要部分本身没有内在的顺序，我们使用字母作为规则引用“编号”的第一部分。我们在编号中留下空缺，以最小化添加或删除规则时的“干扰”。
- en: '**Reason**s (rationales) – because programmers find it hard to follow rules
    they don’t understand'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原因**（理由） - 因为程序员发现难以遵循他们不理解的规定'
- en: '**Example**s – because rules are hard to understand in the abstract; can be
    positive or negative'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例** - 因为规则在抽象中难以理解；可以是积极的或消极的'
- en: '**Alternative**s – for “don’t do this” rules'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替代方案** - 对于“不要这样做”的规则'
- en: '**Exception**s – we prefer simple general rules. However, many rules apply
    widely, but not universally, so exceptions must be listed'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**例外** - 我们更喜欢简单的通用规则。然而，许多规则应用广泛，但并非普遍适用，因此必须列出例外'
- en: '**Enforcement** – ideas about how the rule might be checked “mechanically”'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行** - 关于如何“机械地”检查规则的想法'
- en: '**See also**s – references to related rules and/or further discussion (in this
    document or elsewhere)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参见** - 指向相关规则和/或进一步讨论（在本文件或其他地方）'
- en: '**Note**s (comments) – something that needs saying that doesn’t fit the other
    classifications'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注意**（注释）- 需要说明但不符合其他分类的内容'
- en: '**Discussion** – references to more extensive rationale and/or examples placed
    outside the main lists of rules'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**讨论** - 指向更广泛的理由和/或示例，这些示例放置在规则的主要列表之外'
- en: Some rules are hard to check mechanically, but they all meet the minimal criteria
    that an expert programmer can spot many violations without too much trouble. We
    hope that “mechanical” tools will improve with time to approximate what such an
    expert programmer notices. Also, we assume that the rules will be refined over
    time to make them more precise and checkable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些规则难以进行机械检查，但它们都满足专家程序员可以轻松发现许多违规的最小标准。我们希望“机械”工具会随着时间的推移而改进，以近似这样的专家程序员所注意到的。此外，我们假设规则会随着时间的推移而细化，使其更加精确和可检查。
- en: A rule is aimed at being simple, rather than carefully phrased to mention every
    alternative and special case. Such information is found in the **Alternative**
    paragraphs and the [Discussion](#s-discussion) sections. If you don’t understand
    a rule or disagree with it, please visit its **Discussion**. If you feel that
    a discussion is missing or incomplete, enter an [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)
    explaining your concerns and possibly a corresponding PR.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 规则旨在简单，而不是精心措辞以提及每个替代方案和特殊情况。此类信息可在**替代**段落和[讨论](#s-discussion)部分找到。如果您不理解某个规则或不同意它，请访问其**讨论**。如果您觉得讨论缺失或不完整，请提交一个[问题](https://github.com/isocpp/CppCoreGuidelines/issues)，说明您的担忧，并可能附上一个相应的PR。
- en: Examples are written to illustrate rules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例是为了说明规则而编写的。
- en: Examples are not intended to be production quality or to cover all tutorial
    dimensions. For example, many examples are language-technical and use names like
    `f`, `base`, and `x`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例并非旨在具有生产质量或涵盖所有教程维度。例如，许多示例是语言技术性的，并使用像`f`、`base`和`x`这样的名称。
- en: We try to ensure that “good” examples follow the Core Guidelines.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们试图确保“好的”示例遵循核心指南。
- en: Comments are often illustrating rules where they would be unnecessary and/or
    distracting in “real code.”
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释通常用于说明规则，在“真实代码”中它们可能是多余的，或者会分散注意力。
- en: We assume knowledge of the standard library. For example, we use plain `vector`
    rather than `std::vector`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设读者了解标准库。例如，我们使用普通的`vector`而不是`std::vector`。
- en: This is not a language manual. It is meant to be helpful, rather than complete,
    fully accurate on technical details, or a guide to existing code. Recommended
    information sources can be found in [the references](#s-references).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本语言手册。它的目的是提供帮助，而不是全面、完全准确的技术细节，或现有代码的指南。推荐的信息来源可以在[参考文献](#s-references)中找到。
- en: 'In.sec: Major sections'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'In.sec: 主要部分'
- en: '[In: Introduction](#s-introduction)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[In: 简介](#s-introduction)'
- en: '[P: Philosophy](#s-philosophy)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P: 哲学](#s-philosophy)'
- en: '[I: Interfaces](#s-interfaces)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I: 接口](#s-interfaces)'
- en: '[F: Functions](#s-functions)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F: 函数](#s-functions)'
- en: '[C: Classes and class hierarchies](#s-class)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C: 类和类层次](#s-class)'
- en: '[Enum: Enumerations](#s-enum)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Enum: 枚举](#s-enum)'
- en: '[R: Resource management](#s-resource)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R: 资源管理](#s-resource)'
- en: '[ES: Expressions and statements](#s-expr)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES: 表达式和语句](#s-expr)'
- en: '[Per: Performance](#s-performance)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per: 性能](#s-performance)'
- en: '[CP: Concurrency and parallelism](#s-concurrency)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP: 并发与并行](#s-concurrency)'
- en: '[E: Error handling](#s-errors)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E: 错误处理](#s-errors)'
- en: '[Con: Constants and immutability](#s-const)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Con: 常量和不可变性](#s-const)'
- en: '[T: Templates and generic programming](#s-templates)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T: 模板和泛型编程](#s-templates)'
- en: '[CPL: C-style programming](#s-cpl)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CPL: C风格编程](#s-cpl)'
- en: '[SF: Source files](#s-source)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF: 源文件](#s-source)'
- en: '[SL: The Standard Library](#sl-the-standard-library)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL: 标准库](#sl-the-standard-library)'
- en: 'Supporting sections:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 支持部分：
- en: '[A: Architectural ideas](#s-a)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A: 架构思想](#s-a)'
- en: '[NR: Non-Rules and myths](#s-not)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR: 非规则和神话](#s-not)'
- en: '[RF: References](#s-references)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF: 引用](#s-references)'
- en: '[Pro: Profiles](#s-profile)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pro: 配置文件](#s-profile)'
- en: '[GSL: Guidelines support library](#gsl-guidelines-support-library)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GSL: 指南支持库](#gsl-guidelines-support-library)'
- en: '[NL: Naming and layout suggestions](#s-naming)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL: 命名和布局建议](#s-naming)'
- en: '[FAQ: Answers to frequently asked questions](#s-faq)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FAQ: 常见问题解答](#s-faq)'
- en: '[Appendix A: Libraries](#s-libraries)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录A: 库](#s-libraries)'
- en: '[Appendix B: Modernizing code](#s-modernizing)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录B: 代码现代化](#s-modernizing)'
- en: '[Appendix C: Discussion](#s-discussion)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录C: 讨论](#s-discussion)'
- en: '[Appendix D: Supporting tools](#s-tools)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[附录D: 支持工具](#s-tools)'
- en: '[Glossary](#s-glossary)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Glossary](#s-glossary)'
- en: '[To-do: Unclassified proto-rules](#s-unclassified)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[To-do: 未分类的原型规则](#s-unclassified)'
- en: These sections are not orthogonal.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分不是正交的。
- en: Each section (e.g., “P” for “Philosophy”) and each subsection (e.g., “C.hier”
    for “Class Hierarchies (OOP)”) have an abbreviation for ease of searching and
    reference. The main section abbreviations are also used in rule numbers (e.g.,
    “C.11” for “Make concrete types regular”).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分（例如，“P”代表“哲学”）和每个子部分（例如，“C.hier”代表“类层次（面向对象）”）都有一个缩写，以便于搜索和引用。主要部分的缩写也用于规则编号（例如，“C.11”代表“使具体类型正规化”）。
- en: 'P: Philosophy'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'P: 哲学'
- en: The rules in this section are very general.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的规则非常通用。
- en: 'Philosophy rules summary:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 哲学规则摘要：
- en: '[P.1: Express ideas directly in code](#rp-direct)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.1: 直接在代码中表达思想](#rp-direct)'
- en: '[P.2: Write in ISO Standard C++](#rp-cplusplus)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.2: 使用ISO标准C++编写](#rp-cplusplus)'
- en: '[P.3: Express intent](#rp-what)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.3: 表达意图](#rp-what)'
- en: '[P.4: Ideally, a program should be statically type safe](#rp-typesafe)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.4: 理想情况下，程序应该是静态类型安全的](#rp-typesafe)'
- en: '[P.5: Prefer compile-time checking to run-time checking](#rp-compile-time)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.5: 优先使用编译时检查而不是运行时检查](#rp-compile-time)'
- en: '[P.6: What cannot be checked at compile time should be checkable at run time](#rp-run-time)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.6: 在编译时无法检查的内容应在运行时进行检查](#rp-run-time)'
- en: '[P.7: Catch run-time errors early](#rp-early)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.7: 早期捕获运行时错误](#rp-early)'
- en: '[P.8: Don’t leak any resources](#rp-leak)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.8: 不要泄露任何资源](#rp-leak)'
- en: '[P.9: Don’t waste time or space](#rp-waste)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.9: 不要浪费时间和空间](#rp-waste)'
- en: '[P.10: Prefer immutable data to mutable data](#rp-mutable)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.10: 优先使用不可变数据而不是可变数据](#rp-mutable)'
- en: '[P.11: Encapsulate messy constructs, rather than spreading through the code](#rp-library)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.11: 封装混乱的结构，而不是让它们散布在代码中](#rp-library)'
- en: '[P.12: Use supporting tools as appropriate](#rp-tools)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.12: 根据需要使用支持工具](#rp-tools)'
- en: '[P.13: Use support libraries as appropriate](#rp-lib)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[P.13: 根据需要使用支持库](#rp-lib)'
- en: Philosophical rules are generally not mechanically checkable. However, individual
    rules reflecting these philosophical themes are. Without a philosophical basis,
    the more concrete/specific/checkable rules lack rationale.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 哲学规则通常不是机械可检查的。然而，反映这些哲学主题的个别规则是。如果没有哲学基础，更具体、更具体、更可检查的规则就会缺乏理由。
- en: 'P.1: Express ideas directly in code'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'P.1: 直接在代码中表达想法'
- en: Reason
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Compilers don’t read comments (or design documents) and neither do many programmers
    (consistently). What is expressed in code has defined semantics and can (in principle)
    be checked by compilers and other tools.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不读取注释（或设计文档），许多程序员（一致地）也不这样做。代码中表达的内容具有定义良好的语义，并且（原则上）可以由编译器和其他工具进行检查。
- en: Example
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE2]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first declaration of `month` is explicit about returning a `Month` and about
    not modifying the state of the `Date` object. The second version leaves the reader
    guessing and opens more possibilities for uncaught bugs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`month`的第一个声明明确表示返回一个`Month`，并且不修改`Date`对象的状态。第二个版本让读者猜测，并打开了更多未捕获错误的可能。'
- en: Example, bad
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: 'This loop is a restricted form of `std::find`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环是`std::find`的一个受限形式：
- en: '[PRE3]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example, good
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: 'A much clearer expression of intent would be:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个意图表达得更清晰的形式：
- en: '[PRE4]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A well-designed library expresses intent (what is to be done, rather than just
    how something is being done) far better than direct use of language features.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的库比直接使用语言特性更能表达意图（要做什么，而不仅仅是如何做）。
- en: A C++ programmer should know the basics of the standard library, and use it
    where appropriate. Any programmer should know the basics of the foundation libraries
    of the project being worked on, and use them appropriately. Any programmer using
    these guidelines should know the [guidelines support library](#gsl-guidelines-support-library),
    and use it appropriately.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序员应该了解标准库的基础知识，并在适当的地方使用它。任何程序员都应该了解正在工作的项目的基础库的基本知识，并适当地使用它们。任何使用这些指南的程序员都应该了解[指南支持库](#gsl-guidelines-support-library)，并适当地使用它。
- en: Example
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE5]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A better approach is to be explicit about the meaning of the double (new speed
    or delta on old speed?) and the unit used:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是明确双精度浮点数的含义（新的速度还是旧的速度的增量？）以及使用的单位：
- en: '[PRE6]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We could have accepted a plain (unit-less) `double` as a delta, but that would
    have been error-prone. If we wanted both absolute speed and deltas, we would have
    defined a `Delta` type.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以接受一个普通的（无单位的）`double`作为增量，但那样会有错误风险。如果我们想要同时有绝对速度和增量，我们就会定义一个`Delta`类型。
- en: Enforcement
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Very hard in general.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，这非常困难。
- en: use `const` consistently (check if member functions modify their object; check
    if functions modify arguments passed by pointer or reference)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致地使用`const`（检查成员函数是否修改其对象；检查函数是否通过指针或引用修改参数）
- en: flag uses of casts (casts neuter the type system)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志使用类型转换（类型转换会削弱类型系统）
- en: detect code that mimics the standard library (hard)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测模仿标准库的代码（困难）
- en: 'P.2: Write in ISO Standard C++'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'P.2: 使用ISO标准C++'
- en: Reason
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This is a set of guidelines for writing ISO Standard C++.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一套编写ISO标准C++的指南。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are environments where extensions are necessary, e.g., to access system
    resources. In such cases, localize the use of necessary extensions and control
    their use with non-core Coding Guidelines. If possible, build interfaces that
    encapsulate the extensions so they can be turned off or compiled away on systems
    that do not support those extensions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些环境中，扩展是必要的，例如，为了访问系统资源。在这种情况下，将必要扩展的使用本地化，并使用非核心编码指南控制它们的使用。如果可能，构建封装扩展的接口，以便在不支持这些扩展的系统上关闭或编译掉它们。
- en: Extensions often do not have rigorously defined semantics. Even extensions that
    are common and implemented by multiple compilers might have slightly different
    behaviors and edge case behavior as a direct result of *not* having a rigorous
    standard definition. With sufficient use of any such extension, expected portability
    will be impacted.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展通常没有严格定义的语义。即使是常见并由多个编译器实现的扩展，也可能因为*没有*严格的标准化定义而具有略微不同的行为和边缘情况行为。充分使用任何此类扩展都会影响预期的可移植性。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Using valid ISO C++ does not guarantee portability (let alone correctness).
    Avoid dependence on undefined behavior (e.g., [undefined order of evaluation](#res-order))
    and be aware of constructs with implementation defined meaning (e.g., `sizeof(int)`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有效的 ISO C++ 不能保证可移植性（更不用说正确性）。避免依赖于未定义的行为（例如，[未定义的评估顺序](#res-order)）并注意具有实现定义意义的结构（例如，`sizeof(int)`）。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are environments where restrictions on use of standard C++ language or
    library features are necessary, e.g., to avoid dynamic memory allocation as required
    by aircraft control software standards. In such cases, control their (dis)use
    with an extension of these Coding Guidelines customized to the specific environment.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些环境中，对标准 C++ 语言或库特性的使用限制是必要的，例如，为了满足飞机控制软件标准的要求，避免动态内存分配。在这种情况下，使用针对特定环境的这些编码指南的扩展来控制它们的（不）使用。
- en: Enforcement
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Use an up-to-date C++ compiler (currently C++20 or C++17) with a set of options
    that do not accept extensions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新的 C++ 编译器（目前为 C++20 或 C++17）并设置一组不接受扩展的选项。
- en: 'P.3: Express intent'
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P.3：表达意图
- en: Reason
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Unless the intent of some code is stated (e.g., in names or comments), it is
    impossible to tell whether the code does what it is supposed to do.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确说明某些代码的意图（例如，在名称或注释中），则无法判断代码是否做了它应该做的事情。
- en: Example
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE7]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The intent of “just” looping over the elements of `v` is not expressed here.
    The implementation detail of an index is exposed (so that it might be misused),
    and `i` outlives the scope of the loop, which might or might not be intended.
    The reader cannot know from just this section of code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: “仅仅”遍历 `v` 元素的意图在这里没有表达出来。一个索引的实现细节被暴露（因此可能会被误用），并且 `i` 超出了循环的作用域，这可能是或可能不是预期的。读者仅从这段代码中无法得知。
- en: 'Better:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 更好：
- en: '[PRE8]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, there is no explicit mention of the iteration mechanism, and the loop
    operates on a reference to `const` elements so that accidental modification cannot
    happen. If modification is desired, say so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，没有明确提到迭代机制，循环操作的是 `const` 元素的引用，因此不可能发生意外修改。如果需要修改，请明确说明：
- en: '[PRE9]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For more details about for-statements, see [ES.71](#res-for-range). Sometimes
    better still, use a named algorithm. This example uses the `for_each` from the
    Ranges TS because it directly expresses the intent:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 for-语句的更多详细信息，请参阅 [ES.71](#res-for-range)。有时更好的做法是使用命名算法。此示例使用 Ranges TS
    中的 `for_each`，因为它直接表达了意图：
- en: '[PRE10]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last variant makes it clear that we are not interested in the order in which
    the elements of `v` are handled.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种变体清楚地表明，我们对处理 `v` 元素的顺序不感兴趣。
- en: A programmer should be familiar with
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该熟悉
- en: '[The guidelines support library](#gsl-guidelines-support-library)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指南支持库](#gsl-guidelines-support-library)'
- en: '[The ISO C++ Standard Library](#sl-the-standard-library)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ISO C++ 标准库](#sl-the-standard-library)'
- en: Whatever foundation libraries are used for the current project(s)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于当前项目（s）使用的任何基础库
- en: Note
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Alternative formulation: Say what should be done, rather than just how it should
    be done.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方案：说明应该做什么，而不仅仅是如何做。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some language constructs express intent better than others.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言结构比其他结构更好地表达了意图。
- en: Example
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'If two `int`s are meant to be the coordinates of a 2D point, say so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个 `int` 被用作二维点的坐标，请明确说明：
- en: '[PRE11]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Enforcement
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look for common patterns for which there are better alternatives
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找有更好替代方案的常见模式
- en: simple `for` loops vs. range-`for` loops
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的 `for` 循环与范围-`for` 循环
- en: '`f(T*, int)` interfaces vs. `f(span<T>)` interfaces'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f(T*, int)` 接口与 `f(span<T>)` 接口'
- en: loop variables in too large a scope
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围过大的循环变量
- en: naked `new` and `delete`
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸 `new` 和 `delete`
- en: functions with many parameters of built-in types
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有许多内置类型参数的函数
- en: There is a huge scope for cleverness and semi-automated program transformation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中存在大量巧妙和半自动化的程序转换空间。
- en: 'P.4: Ideally, a program should be statically type safe'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P.4：理想情况下，程序应该是静态类型安全的
- en: Reason
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Ideally, a program would be completely statically (compile-time) type safe.
    Unfortunately, that is not possible. Problem areas:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，程序应该是完全静态（编译时）类型安全的。不幸的是，这是不可能的。问题区域：
- en: unions
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合体
- en: casts
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: array decay
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组退化
- en: range errors
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围错误
- en: narrowing conversions
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 狭化转换
- en: Note
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: These areas are sources of serious problems (e.g., crashes and security violations).
    We try to provide alternative techniques.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些领域是严重问题的来源（例如，崩溃和安全违规）。我们试图提供替代技术。
- en: Enforcement
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'We can ban, restrain, or detect the individual problem categories separately,
    as required and feasible for individual programs. Always suggest an alternative.
    For example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分别禁止、限制或检测个别问题类别，具体取决于所需和可行的情况。始终建议一个替代方案。例如：
- en: unions – use `variant` (in C++17)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合体 - 使用 `variant`（在 C++17 中）。
- en: casts – minimize their use; templates can help
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换 - 最小化其使用；模板可以帮助
- en: array decay – use `span` (from the GSL)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组退化 - 使用 `span`（来自 GSL）。
- en: range errors – use `span`
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围错误 - 使用 `span`
- en: narrowing conversions – minimize their use and use `narrow` or `narrow_cast`
    (from the GSL) where they are necessary
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 狭化转换 - 最小化其使用，并在必要时使用 `narrow` 或 `narrow_cast`（来自 GSL）。
- en: 'P.5: Prefer compile-time checking to run-time checking'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P.5：优先考虑编译时检查而不是运行时检查
- en: Reason
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Code clarity and performance. You don’t need to write error handlers for errors
    caught at compile time.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清晰度和性能。你不需要为编译时捕获的错误编写错误处理器。
- en: Example
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE12]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This example fails to achieve what it is trying to achieve (because overflow
    is undefined) and should be replaced with a simple `static_assert`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子未能实现其试图实现的目标（因为溢出是未定义的），应该用简单的 `static_assert` 替换：
- en: '[PRE13]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Or better still just use the type system and replace `Int` with `int32_t`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的是直接使用类型系统，将 `Int` 替换为 `int32_t`。
- en: Example
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE14]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: better
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 更好
- en: '[PRE15]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Alternative formulation**: Don’t postpone to run time what can be done well
    at compile time.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：不要推迟到运行时可以很好地在编译时完成的事情。'
- en: Enforcement
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look for pointer arguments.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找指针参数。
- en: Look for run-time checks for range violations.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找运行时检查范围违规。
- en: 'P.6: What cannot be checked at compile time should be checkable at run time'
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P.6：编译时无法检查的内容应在运行时可检查
- en: Reason
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Leaving hard-to-detect errors in a program is asking for crashes and bad results.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中留下难以检测的错误是请求崩溃和不良结果。
- en: Note
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Ideally, we catch all errors (that are not errors in the programmer’s logic)
    at either compile time or run time. It is impossible to catch all errors at compile
    time and often not affordable to catch all remaining errors at run time. However,
    we should endeavor to write programs that in principle can be checked, given sufficient
    resources (analysis programs, run-time checks, machine resources, time).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们在编译时或运行时捕获所有错误（这些错误不是程序员逻辑中的错误）。在编译时捕获所有错误是不可能的，而且在运行时捕获所有剩余的错误通常是不划算的。然而，我们应该努力编写程序，在资源足够的情况下（分析程序、运行时检查、机器资源、时间），原则上可以进行检查。
- en: Example, bad
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE16]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, a crucial bit of information (the number of elements) has been so thoroughly
    “obscured” that static analysis is probably rendered infeasible and dynamic checking
    can be very difficult when `f()` is part of an ABI so that we cannot “instrument”
    that pointer. We could embed helpful information into the free store, but that
    requires global changes to a system and maybe to the compiler. What we have here
    is a design that makes error detection very hard.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一条关键信息（元素数量）被如此彻底地“隐藏”，以至于静态分析可能变得不可行，并且当 `f()` 是 ABI 的一部分时，动态检查可能非常困难，因为我们不能“仪器化”该指针。我们可以将有用的信息嵌入到自由存储中，但这需要对系统进行全局更改，也许还需要对编译器进行更改。我们这里有一个使错误检测非常困难的设计。
- en: Example, bad
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: 'We can of course pass the number of elements along with the pointer:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以传递元素数量以及指针：
- en: '[PRE17]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Passing the number of elements as an argument is better (and far more common)
    than just passing the pointer and relying on some (unstated) convention for knowing
    or discovering the number of elements. However (as shown), a simple typo can introduce
    a serious error. The connection between the two arguments of `f2()` is conventional,
    rather than explicit.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素数量作为参数传递比仅仅传递指针并依赖于某些（未声明的）约定来知道或发现元素数量更好（并且更常见）。然而（如所示），一个简单的打字错误可以引入严重的错误。`f2()`
    的两个参数之间的联系是传统的，而不是明确的。
- en: Also, it is implicit that `f2()` is supposed to `delete` its argument (or did
    the caller make a second mistake?).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，隐含的是 `f2()` 应该删除其参数（或者调用者是否犯了第二个错误？）。
- en: Example, bad
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: 'The standard library resource management pointers fail to pass the size when
    they point to an object:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库资源管理指针在指向对象时未能传递大小：
- en: '[PRE18]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'We need to pass the pointer and the number of elements as an integral object:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将指针和元素数量作为一个整体对象传递：
- en: '[PRE19]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This design carries the number of elements along as an integral part of an object,
    so that errors are unlikely and dynamic (run-time) checking is always feasible,
    if not always affordable.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计将元素的数量作为对象的一个组成部分，因此错误不太可能发生，并且动态（运行时）检查总是可行的，即使不一定总是负担得起。
- en: Example
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: How do we transfer both ownership and all information needed for validating
    use?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何转移所有权和验证使用所需的所有信息？
- en: '[PRE20]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: ???
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: show how possible checks are avoided by interfaces that pass polymorphic base
    classes around, when they actually know what they need? Or strings as “free-style”
    options
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过传递多态基类来避免接口中可能避免的检查？或者字符串作为“自由式”选项？
- en: Enforcement
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag (pointer, count)-style interfaces (this will flag a lot of examples that
    can’t be fixed for compatibility reasons)
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记（指针、计数）风格的接口（这将标记许多由于兼容性原因无法修复的示例）
- en: ???
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'P.7: Catch run-time errors early'
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'P.7: 早期捕获运行时错误'
- en: Reason
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoid “mysterious” crashes. Avoid errors leading to (possibly unrecognized)
    wrong results.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 避免出现“神秘”的崩溃。避免导致（可能未被识别）错误结果的错误。
- en: Example
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE21]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here we made a small error in `use1` that will lead to corrupted data or a
    crash. The (pointer, count)-style interface leaves `increment1()` with no realistic
    way of defending itself against out-of-range errors. If we could check subscripts
    for out of range access, then the error would not be discovered until `p[10]`
    was accessed. We could check earlier and improve the code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`use1`中犯了一个小错误，这将导致数据损坏或崩溃。`(指针，计数)`风格的接口让`increment1()`没有现实的方法来防御越界错误。如果我们能够检查子索引以进行越界访问，那么错误将不会在访问`p[10]`时被发现。我们可以更早地进行检查并改进代码：
- en: '[PRE22]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, `m <= n` can be checked at the point of call (early) rather than later.
    If all we had was a typo so that we meant to use `n` as the bound, the code could
    be further simplified (eliminating the possibility of an error):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`m <= n`可以在调用点（早期）进行检查，而不是稍后。如果我们只是有一个打字错误，所以我们的意图是使用`n`作为界限，代码可以进一步简化（消除错误的可能性）：
- en: '[PRE23]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example, bad
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Don’t repeatedly check the same value. Don’t pass structured data as strings:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复检查相同的值。不要将结构化数据作为字符串传递：
- en: '[PRE24]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The date is validated twice (by the `Date` constructor) and passed as a character
    string (unstructured data).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 日期被验证了两次（通过`Date`构造函数）并以字符字符串（非结构化数据）的形式传递。
- en: Example
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Excess checking can be costly. There are cases where checking early is inefficient
    because you might never need the value, or might only need part of the value that
    is more easily checked than the whole. Similarly, don’t add validity checks that
    change the asymptotic behavior of your interface (e.g., don’t add a `O(n)` check
    to an interface with an average complexity of `O(1)`).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 过度检查可能代价高昂。有些情况下，早期检查可能效率低下，因为你可能永远不需要该值，或者可能只需要部分值，这部分值比整个值更容易检查。同样，不要添加会改变你接口渐近行为的有效性检查（例如，不要向平均复杂度为`O(1)`的接口添加`O(n)`检查）。
- en: '[PRE25]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The physical law for a jet (`e * e < x * x + y * y + z * z`) is not an invariant
    because of the possibility for measurement errors.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于喷流（`e * e < x * x + y * y + z * z`）的物理定律不是不变的，因为存在测量误差的可能性。
- en: ???
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Enforcement
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: 'Look at pointers and arrays: Do range-checking early and not repeatedly'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看指针和数组：尽早进行范围检查，而不是反复检查
- en: 'Look at conversions: Eliminate or mark narrowing conversions'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看转换：消除或标记缩窄转换
- en: Look for unchecked values coming from input
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找来自输入的未检查的值
- en: Look for structured data (objects of classes with invariants) being converted
    into strings
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找结构化数据（具有不变性的类的对象）被转换为字符串
- en: ???
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'P.8: Don’t leak any resources'
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'P.8: 不要泄露任何资源'
- en: Reason
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Even a slow growth in resources will, over time, exhaust the availability of
    those resources. This is particularly important for long-running programs, but
    is an essential piece of responsible programming behavior.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 即使资源增长缓慢，随着时间的推移，也会耗尽这些资源的可用性。这对于长时间运行的程序尤为重要，但这是负责任编程行为的一个基本要素。
- en: Example, bad
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE26]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Prefer [RAII](#rr-raii):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 优先考虑[RAII](#rr-raii)：
- en: '[PRE27]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**See also**: [The resource management section](#s-resource)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**: [资源管理部分](#s-resource)'
- en: Note
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A leak is colloquially “anything that isn’t cleaned up.” The more important
    classification is “anything that can no longer be cleaned up.” For example, allocating
    an object on the heap and then losing the last pointer that points to that allocation.
    This rule should not be taken as requiring that allocations within long-lived
    objects must be returned during program shutdown. For example, relying on system
    guaranteed cleanup such as file closing and memory deallocation upon process shutdown
    can simplify code. However, relying on abstractions that implicitly clean up can
    be as simple, and often safer.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 泄露在口语中指的是“任何没有被清理的东西。” 更重要的分类是“任何不能再被清理的东西。” 例如，在堆上分配一个对象然后丢失指向该分配的最后一个指针。这条规则不应被理解为要求在程序关闭期间必须返回长生存期对象内的分配。例如，依赖于系统保证的清理，如文件关闭和进程关闭时的内存释放，可以简化代码。然而，依赖于隐式清理的抽象可能同样简单，并且通常更安全。
- en: Note
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Enforcing [the lifetime safety profile](#ss-lifetime) eliminates leaks. When
    combined with resource safety provided by [RAII](#rr-raii), it eliminates the
    need for “garbage collection” (by generating no garbage). Combine this with enforcement
    of [the type and bounds profiles](#ss-force) and you get complete type- and resource-safety,
    guaranteed by tools.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 强制执行[生存期安全配置文件](#ss-lifetime)消除了泄露。当与[RAII](#rr-raii)提供的资源安全相结合时，它消除了“垃圾收集”的需要（通过不产生垃圾）。结合对[类型和边界配置文件](#ss-force)的强制执行，你将获得完全的类型和资源安全性，由工具保证。
- en: Enforcement
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: 'Look at pointers: Classify them into non-owners (the default) and owners. Where
    feasible, replace owners with standard-library resource handles (as in the example
    above). Alternatively, mark an owner as such using `owner` from [the GSL](#gsl-guidelines-support-library).'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看指针：将它们分类为非所有者（默认）和所有者。在可行的情况下，用标准库的资源句柄（如上面的例子）替换所有者。或者，使用 [GSL](#gsl-guidelines-support-library)
    中的 `owner` 将所有者标记为所有者。
- en: Look for naked `new` and `delete`
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找裸露的 `new` 和 `delete`
- en: Look for known resource allocating functions returning raw pointers (such as
    `fopen`, `malloc`, and `strdup`)
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找返回原始指针的已知资源分配函数（如 `fopen`、`malloc` 和 `strdup`）
- en: 'P.9: Don’t waste time or space'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'P.9: 不要浪费时间和空间'
- en: Reason
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This is C++.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是 C++。
- en: Note
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Time and space that you spend well to achieve a goal (e.g., speed of development,
    resource safety, or simplification of testing) is not wasted. “Another benefit
    of striving for efficiency is that the process forces you to understand the problem
    in more depth.” - Alex Stepanov
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你为了实现目标（例如，开发速度、资源安全或测试简化）而投入的时间和空间是不会浪费的。“追求效率的另一个好处是，这个过程迫使你更深入地理解问题。” - Alex
    Stepanov
- en: Example, bad
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE28]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Yes, this is a caricature, but we have seen every individual mistake in production
    code, and worse. Note that the layout of `X` guarantees that at least 6 bytes
    (and most likely more) are wasted. The spurious definition of copy operations
    disables move semantics so that the return operation is slow (please note that
    the Return Value Optimization, RVO, is not guaranteed here). The use of `new`
    and `delete` for `buf` is redundant; if we really needed a local string, we should
    use a local `string`. There are several more performance bugs and gratuitous complication.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个讽刺，但我们已经看到了生产代码中的每一个错误，甚至更糟。请注意，`X` 的布局保证了至少浪费 6 个字节（并且很可能是更多）。虚假的复制操作定义禁用了移动语义，使得返回操作变慢（请注意，RVO（返回值优化）在这里并不保证）。对于
    `buf` 使用 `new` 和 `delete` 是多余的；如果我们真的需要一个局部字符串，我们应该使用一个局部的 `string`。还有几个更多的性能错误和多余的复杂性。
- en: Example, bad
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE29]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is actually an example from production code. We can see that in our condition
    we have `i < strlen(s)`. This expression will be evaluated on every iteration
    of the loop, which means that `strlen` must walk through string every loop to
    discover its length. While the string contents are changing, it’s assumed that
    `tolower` will not affect the length of the string, so it’s better to cache the
    length outside the loop and not incur that cost each iteration.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个来自生产代码的例子。我们可以看到，在我们的条件下，我们有 `i < strlen(s)`。这个表达式将在循环的每次迭代中被评估，这意味着
    `strlen` 必须在每次循环中遍历字符串以发现其长度。当字符串内容发生变化时，假设 `tolower` 不会影响字符串的长度，因此最好在循环外缓存长度，以避免每次迭代都产生这个成本。
- en: Note
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An individual example of waste is rarely significant, and where it is significant,
    it is typically easily eliminated by an expert. However, waste spread liberally
    across a code base can easily be significant and experts are not always as available
    as we would like. The aim of this rule (and the more specific rules that support
    it) is to eliminate most waste related to the use of C++ before it happens. After
    that, we can look at waste related to algorithms and requirements, but that is
    beyond the scope of these guidelines.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 单个浪费的例子很少是重要的，而且即使它很重要，通常也容易由专家消除。然而，在代码库中广泛传播的浪费可能会变得很重要，而且专家并不总是像我们希望的那样容易获得。本规则（以及支持它的更具体规则）的目标是在发生之前消除与C++使用相关的大多数浪费。之后，我们可以查看与算法和需求相关的浪费，但这超出了这些指南的范围。
- en: Enforcement
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Many more specific rules aim at the overall goals of simplicity and elimination
    of gratuitous waste.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 许多更具体的规则旨在实现简单性和消除不必要的浪费的整体目标。
- en: 'Flag an unused return value from a user-defined non-defaulted postfix `operator++`
    or `operator--` function. Prefer using the prefix form instead. (Note: “User-defined
    non-defaulted” is intended to reduce noise. Review this enforcement if it’s still
    too noisy in practice.)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记用户定义的非默认后缀`operator++`或`operator--`函数中的未使用返回值。优先使用前缀形式。（注意：“用户定义的非默认”旨在减少噪音。如果实践中仍然过于嘈杂，请审查此执法。）
- en: 'P.10: Prefer immutable data to mutable data'
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P.10：优先使用不可变数据而非可变数据
- en: Reason
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is easier to reason about constants than about variables. Something immutable
    cannot change unexpectedly. Sometimes immutability enables better optimization.
    You can’t have a data race on a constant.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量相比，常数更容易推理。不可变的事物不能意外地改变。有时不可变性可以启用更好的优化。你无法在常量上发生数据竞争。
- en: 'See [Con: Constants and immutability](#s-const)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[常量和不可变性](#s-const)
- en: 'P.11: Encapsulate messy constructs, rather than spreading through the code'
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P.11：封装杂乱的构造，而不是让其在代码中传播
- en: Reason
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Messy code is more likely to hide bugs and harder to write. A good interface
    is easier and safer to use. Messy, low-level code breeds more such code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 杂乱的代码更有可能隐藏错误，并且更难编写。良好的接口更容易且更安全地使用。杂乱的低级代码会滋生更多这样的代码。
- en: Example
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE30]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is low-level, verbose, and error-prone. For example, we “forgot” to test
    for memory exhaustion and assign new value to `sz`. Instead, we could use `vector`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种低级、冗长且容易出错的操作。例如，我们“忘记”测试内存耗尽并分配新的值给`sz`。相反，我们可以使用`vector`：
- en: '[PRE31]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The standards library and the GSL are examples of this philosophy. For example,
    instead of messing with the arrays, unions, cast, tricky lifetime issues, `gsl::owner`,
    etc., that are needed to implement key abstractions, such as `vector`, `span`,
    `lock_guard`, and `future`, we use the libraries designed and implemented by people
    with more time and expertise than we usually have. Similarly, we can and should
    design and implement more specialized libraries, rather than leaving the users
    (often ourselves) with the challenge of repeatedly getting low-level code well.
    This is a variant of the [subset of superset principle](#r0) that underlies these
    guidelines.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库和GSL是这种哲学的例子。例如，我们不是与数组、联合、类型转换、复杂的生命周期问题、`gsl::owner`等打交道，这些是实现关键抽象（如`vector`、`span`、`lock_guard`和`future`）所必需的，而是使用由比我们更有时间和专业知识的人设计和实现的库。同样，我们可以也应该设计和实现更多专门的库，而不是让用户（通常是我们自己）反复面对编写低级代码的挑战。这是这些指南背后的[子集超集原则](#r0)的一个变体。
- en: Enforcement
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look for “messy code” such as complex pointer manipulation and casting outside
    the implementation of abstractions.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找“杂乱代码”，例如在抽象实现之外的复杂指针操作和类型转换。
- en: 'P.12: Use supporting tools as appropriate'
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: P.12：根据需要使用辅助工具
- en: Reason
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: There are many things that are done better “by machine”. Computers don’t tire
    or get bored by repetitive tasks. We typically have better things to do than repeatedly
    do routine tasks.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多事情是“由机器”做得更好的。计算机不会因为重复性任务而感到疲倦或无聊。我们通常有比反复执行常规任务更好的事情要做。
- en: Example
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Run a static analyzer to verify that your code follows the guidelines you want
    it to follow.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 运行静态分析器以验证您的代码是否遵循您希望其遵循的指南。
- en: Note
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: See
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 查看
- en: '[Static analysis tools](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[静态分析工具](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis)'
- en: '[Concurrency tools](#rconc-tools)'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并发工具](#rconc-tools)'
- en: '[Testing tools](https://github.com/isocpp/CppCoreGuidelines/tree/master)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试工具](https://github.com/isocpp/CppCoreGuidelines/tree/master)'
- en: There are many other kinds of tools, such as source code repositories, build
    tools, etc., but those are beyond the scope of these guidelines.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的工具，例如源代码仓库、构建工具等，但这些超出了这些指南的范围。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful not to become dependent on over-elaborate or over-specialized tool
    chains. Those can make your otherwise portable code non-portable.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要过度依赖过于复杂或过于专业的工具链。这些工具链可能会使你的代码变得不可移植。
- en: 'P.13: Use support libraries as appropriate'
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'P.13: 根据需要使用支持库'
- en: Reason
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using a well-designed, well-documented, and well-supported library saves time
    and effort; its quality and documentation are likely to be greater than what you
    could do if the majority of your time must be spent on an implementation. The
    cost (time, effort, money, etc.) of a library can be shared over many users. A
    widely used library is more likely to be kept up-to-date and ported to new systems
    than an individual application. Knowledge of a widely-used library can save time
    on other/future projects. So, if a suitable library exists for your application
    domain, use it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计良好、文档齐全、支持良好的库可以节省时间和精力；其质量和文档可能比你花费大量时间在实现上所能做到的更好。库的成本（时间、精力、金钱等）可以由许多用户共享。广泛使用的库更有可能保持更新并移植到新的系统，而不是单个应用程序。对广泛使用的库的了解可以在其他/未来的项目中节省时间。因此，如果你的应用程序领域存在合适的库，请使用它。
- en: Example
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE32]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unless you are an expert in sorting algorithms and have plenty of time, this
    is more likely to be correct and to run faster than anything you write for a specific
    application. You need a reason not to use the standard library (or whatever foundational
    libraries your application uses) rather than a reason to use it.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是排序算法的专家并且有大量时间，否则这可能是更正确且运行速度更快的，比为特定应用程序编写的任何东西都要好。你需要一个不使用标准库（或你的应用程序使用的任何基础库）的理由，而不是使用它的理由。
- en: Note
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By default use
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 默认使用
- en: The [ISO C++ Standard Library](#sl-the-standard-library)
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ISO C++ 标准库](#sl-the-standard-library)'
- en: The [Guidelines Support Library](#gsl-guidelines-support-library)
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指南支持库](#gsl-guidelines-support-library)'
- en: Note
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If no well-designed, well-documented, and well-supported library exists for
    an important domain, maybe you should design and implement it, and then use it.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在设计良好、文档齐全、支持良好的库来处理一个重要领域，也许你应该设计和实现它，然后使用它。
- en: 'I: Interfaces'
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'I: 接口'
- en: An interface is a contract between two parts of a program. Precisely stating
    what is expected of a supplier of a service and a user of that service is essential.
    Having good (easy-to-understand, encouraging efficient use, not error-prone, supporting
    testing, etc.) interfaces is probably the most important single aspect of code
    organization.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是程序两个部分之间的合同。精确地说明对服务提供者和该服务的使用者期望的内容是至关重要的。拥有良好的（易于理解、鼓励高效使用、不易出错、支持测试等）接口可能是代码组织最重要的单个方面。
- en: 'Interface rule summary:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 接口规则摘要：
- en: '[I.1: Make interfaces explicit](#ri-explicit)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.1: 明确接口](#ri-explicit)'
- en: '[I.2: Avoid non-`const` global variables](#ri-global)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.2: 避免非 `const` 全局变量](#ri-global)'
- en: '[I.3: Avoid singletons](#ri-singleton)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.3: 避免单例](#ri-singleton)'
- en: '[I.4: Make interfaces precisely and strongly typed](#ri-typed)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.4: 使接口精确且强类型](#ri-typed)'
- en: '[I.5: State preconditions (if any)](#ri-pre)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.5: 状态前置条件（如果有）](#ri-pre)'
- en: '[I.6: Prefer `Expects()` for expressing preconditions](#ri-expects)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.6: 使用 `Expects()` 表达前置条件](#ri-expects)'
- en: '[I.7: State postconditions](#ri-post)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.7: 状态后置条件](#ri-post)'
- en: '[I.8: Prefer `Ensures()` for expressing postconditions](#ri-ensures)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.8: 使用 `Ensures()` 表达后置条件](#ri-ensures)'
- en: '[I.9: If an interface is a template, document its parameters using concepts](#ri-concepts)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.9: 如果一个接口是模板，使用概念文档其参数](#ri-concepts)'
- en: '[I.10: Use exceptions to signal a failure to perform a required task](#ri-except)'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.10: 使用异常来表示执行所需任务失败](#ri-except)'
- en: '[I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)](#ri-raw)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.11: 永远不要通过原始指针 (`T*`) 或引用 (`T&`) 转移所有权](#ri-raw)'
- en: '[I.12: Declare a pointer that must not be null as `not_null`](#ri-nullptr)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.12: 声明一个不能为空的指针为 `not_null`](#ri-nullptr)'
- en: '[I.13: Do not pass an array as a single pointer](#ri-array)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.13: 不要将数组作为单个指针传递](#ri-array)'
- en: '[I.22: Avoid complex initialization of global objects](#ri-global-init)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.22: 避免全局对象的复杂初始化](#ri-global-init)'
- en: '[I.23: Keep the number of function arguments low](#ri-nargs)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.23: 保持函数参数数量低](#ri-nargs)'
- en: '[I.24: Avoid adjacent parameters that can be invoked by the same arguments
    in either order with different meaning](#ri-unrelated)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.24: 避免相邻参数，这些参数可以以不同的顺序使用相同的参数调用，具有不同的意义](#ri-unrelated)'
- en: '[I.25: Prefer empty abstract classes as interfaces to class hierarchies](#ri-abstract)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.25: 优先使用空抽象类作为类层次结构的接口](#ri-abstract)'
- en: '[I.26: If you want a cross-compiler ABI, use a C-style subset](#ri-abi)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.26: 如果你想有一个交叉编译器ABI，请使用C样式子集](#ri-abi)'
- en: '[I.27: For stable library ABI, consider the Pimpl idiom](#ri-pimpl)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.27: 对于稳定的库ABI，考虑使用Pimpl习语](#ri-pimpl)'
- en: '[I.30: Encapsulate rule violations](#ri-encapsulate)'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[I.30: 封装规则违反](#ri-encapsulate)'
- en: '**See also**:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：'
- en: '[F: Functions](#s-functions)'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F: 函数](#s-functions)'
- en: '[C.concrete: Concrete types](#ss-concrete)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.concrete: 具体类型](#ss-concrete)'
- en: '[C.hier: Class hierarchies](#ss-hier)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.hier: 类层次结构](#ss-hier)'
- en: '[C.over: Overloading and overloaded operators](#ss-overload)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.over: 赋值和重载运算符](#ss-overload)'
- en: '[C.con: Containers and other resource handles](#ss-containers)'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.con: 容器和其他资源句柄](#ss-containers)'
- en: '[E: Error handling](#s-errors)'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E: 错误处理](#s-errors)'
- en: '[T: Templates and generic programming](#s-templates)'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T: 模板和泛型编程](#s-templates)'
- en: 'I.1: Make interfaces explicit'
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'I.1: 使接口明确'
- en: Reason
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Correctness. Assumptions not stated in an interface are easily overlooked and
    hard to test.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性。未在接口中声明的假设容易被忽视，并且难以测试。
- en: Example, bad
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Controlling the behavior of a function through a global (namespace scope) variable
    (a call mode) is implicit and potentially confusing. For example:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 通过全局（命名空间作用域）变量（一种调用模式）控制函数的行为是隐式的，并且可能令人困惑。例如：
- en: '[PRE33]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It will not be obvious to a caller that the meaning of two calls of `round(7.2)`
    might give different results.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可能不会明显地意识到两次调用`round(7.2)`的结果可能不同。
- en: Exception
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Sometimes we control the details of a set of operations by an environment variable,
    e.g., normal vs. verbose output or debug vs. optimized. The use of a non-local
    control is potentially confusing, but controls only implementation details of
    otherwise fixed semantics.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们通过环境变量控制一组操作的细节，例如，正常输出与详细输出或调试与优化。非局部控制的使用可能令人困惑，但它只控制其他固定语义的实现细节。
- en: Example, bad
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Reporting through non-local variables (e.g., `errno`) is easily ignored. For
    example:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 通过非局部变量（例如，`errno`）进行报告容易被忽视。例如：
- en: '[PRE34]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What if the connection goes down so that no logging output is produced? See
    I.???.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接断开，以至于没有产生日志输出怎么办？参见I.???。
- en: '**Alternative**: Throw an exception. An exception cannot be ignored.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：抛出异常。异常不能被忽视。'
- en: '**Alternative formulation**: Avoid passing information across an interface
    through non-local or implicit state. Note that non-`const` member functions pass
    information to other member functions through their object’s state.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：避免通过非局部或隐式状态在接口之间传递信息。请注意，非`const`成员函数通过其对象的状态将信息传递给其他成员函数。'
- en: '**Alternative formulation**: An interface should be a function or a set of
    functions. Functions can be function templates and sets of functions can be classes
    or class templates.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：接口应该是一个函数或一组函数。函数可以是函数模板，而函数集可以是类或类模板。'
- en: Enforcement
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) A function should not make control-flow decisions based on the values
    of variables declared at namespace scope.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）函数不应基于在命名空间作用域中声明的变量的值做出控制流决策。
- en: (Simple) A function should not write to variables declared at namespace scope.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）函数不应向在命名空间作用域中声明的变量写入。
- en: 'I.2: Avoid non-`const` global variables'
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'I.2: 避免非`const`全局变量'
- en: Reason
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Non-`const` global variables hide dependencies and make the dependencies subject
    to unpredictable changes.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 非`const`全局变量隐藏依赖关系，并使依赖关系容易受到不可预测的变化。
- en: Example
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE35]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Who else might modify `data`?
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 谁还可能修改`data`？
- en: '**Warning**: The initialization of global objects is not totally ordered. If
    you use a global object initialize it with a constant. Note that it is possible
    to get undefined initialization order even for `const` objects.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：全局对象的初始化不是完全有序的。如果你使用全局对象，请用常量初始化它。请注意，即使是`const`对象，也可能得到未定义的初始化顺序。'
- en: Exception
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: A global object is often better than a singleton.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象通常比单例更好。
- en: Note
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Global constants are useful.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 全局常量是有用的。
- en: Note
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The rule against global variables applies to namespace scope variables as well.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 对全局变量的规则也适用于命名空间作用域变量。
- en: '**Alternative**: If you use global (more generally namespace scope) data to
    avoid copying, consider passing the data as an object by reference to `const`.
    Another solution is to define the data as the state of some object and the operations
    as member functions.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：如果你使用全局（更一般地说，命名空间作用域）数据来避免复制，考虑通过引用将数据作为对象传递给`const`。另一个解决方案是将数据定义为某些对象的状态，将操作定义为成员函数。'
- en: '**Warning**: Beware of data races: If one thread can access non-local data
    (or data passed by reference) while another thread executes the callee, we can
    have a data race. Every pointer or reference to mutable data is a potential data
    race.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：小心数据竞争：如果一个线程可以在另一个线程执行被调用者时访问非局部数据（或通过引用传递的数据），我们可能会遇到数据竞争。每个指向可变数据的指针或引用都是一个潜在的数据竞争。'
- en: Using global pointers or references to access and change non-const, and otherwise
    non-global, data isn’t a better alternative to non-const global variables since
    that doesn’t solve the issues of hidden dependencies or potential race conditions.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局指针或引用来访问和更改非const数据，而不是使用非const全局变量，这不是更好的替代方案，因为这并不能解决隐藏依赖或潜在竞争条件的问题。
- en: Note
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot have a race condition on immutable data.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在不可变数据上产生竞争条件。
- en: '**References**: See the [rules for calling functions](#ss-call).'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考**：参见[调用函数的规则](#ss-call)。'
- en: Note
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The rule is “avoid”, not “don’t use.” Of course there will be (rare) exceptions,
    such as `cin`, `cout`, and `cerr`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是“避免”，而不是“不使用”。当然，会有（罕见的）例外，比如`cin`、`cout`和`cerr`。
- en: Enforcement
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) Report all non-`const` variables declared at namespace scope and global
    pointers/references to non-const data.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）报告在命名空间作用域声明的所有非`const`变量以及指向非const数据的全局指针/引用。
- en: 'I.3: Avoid singletons'
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.3：避免单例
- en: Reason
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Singletons are basically complicated global objects in disguise.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 单例基本上是伪装成复杂全局对象的。
- en: Example
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE36]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There are many variants of the singleton idea. That’s part of the problem.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式的变体有很多。这也是问题的一部分。
- en: Note
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t want a global object to change, declare it `const` or `constexpr`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想全局对象改变，声明它为`const`或`constexpr`。
- en: Exception
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例外
- en: 'You can use the simplest “singleton” (so simple that it is often not considered
    a singleton) to get initialization on first use, if any:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何，你可以使用最简单的“单例”（简单到通常不被认为是单例）来在首次使用时进行初始化：
- en: '[PRE37]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is one of the most effective solutions to problems related to initialization
    order. In a multi-threaded environment, the initialization of the static object
    does not introduce a race condition (unless you carelessly access a shared object
    from within its constructor).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决初始化顺序相关问题的最有效解决方案之一。在多线程环境中，静态对象的初始化不会引入竞争条件（除非你在构造函数中不小心访问了共享对象）。
- en: 'Note that the initialization of a local `static` does not imply a race condition.
    However, if the destruction of `X` involves an operation that needs to be synchronized
    we must use a less simple solution. For example:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，局部`static`的初始化并不隐含竞争条件。然而，如果`X`的销毁涉及需要同步的操作，我们必须使用更复杂的方法。例如：
- en: '[PRE38]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now someone must `delete` that object in some suitably thread-safe way. That’s
    error-prone, so we don’t use that technique unless
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在必须以某种适合线程安全的方式删除该对象。这是容易出错的，所以我们只有在
- en: '`myX` is in multi-threaded code,'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myX`位于多线程代码中，'
- en: that `X` object needs to be destroyed (e.g., because it releases a resource),
    and
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`对象需要被销毁（例如，因为它释放了资源），并且'
- en: '`X`’s destructor’s code needs to be synchronized.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`的析构函数代码需要同步。'
- en: If you, as many do, define a singleton as a class for which only one object
    is created, functions like `myX` are not singletons, and this useful technique
    is not an exception to the no-singleton rule.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像很多人一样，将单例定义为一个只创建一个对象的类，那么像`myX`这样的函数就不是单例，这种有用的技术也不是无单例规则的例外。
- en: Enforcement
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Very hard in general.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 通常很难。
- en: Look for classes with names that include `singleton`.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找名称中包含`singleton`的类。
- en: Look for classes for which only a single object is created (by counting objects
    or by examining constructors).
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找只创建一个对象的类（通过计数对象或检查构造函数）。
- en: If a class X has a public static function that contains a function-local static
    of the class’ type X and returns a pointer or reference to it, ban that.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类X有一个包含类类型X的函数局部静态的公共静态函数，并返回对其的指针或引用，则禁止这样做。
- en: 'I.4: Make interfaces precisely and strongly typed'
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.4：精确且强类型化接口
- en: Reason
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Types are the simplest and best documentation, improve legibility due to their
    well-defined meaning, and are checked at compile time. Also, precisely typed code
    is often optimized better.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是最简单、最好的文档，由于它们有明确的含义，因此提高了可读性，并且在编译时进行检查。此外，精确类型化的代码通常优化得更好。
- en: Example, don’t
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不要
- en: 'Consider:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE39]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Callers are unsure what types are allowed and if the data may be mutated as
    `const` is not specified. Note all pointer types implicitly convert to `void*`,
    so it is easy for callers to provide this value.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者不确定允许哪些类型，以及数据是否可能被 `const` 修改，因为未指定。注意所有指针类型隐式转换为 `void*`，因此调用者很容易提供这个值。
- en: The callee must `static_cast` data to an unverified type to use it. That is
    error-prone and verbose.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用者必须将数据 `static_cast` 到未经验证的类型才能使用它。这是有风险的，并且很冗长。
- en: Only use `const void*` for passing in data in designs that are indescribable
    in C++. Consider using a `variant` or a pointer to base instead.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在 C++ 中难以描述的设计中使用 `const void*` 来传递数据。考虑使用 `variant` 或基类指针。
- en: '**Alternative**: Often, a template parameter can eliminate the `void*` turning
    it into a `T*` or `T&`. For generic code these `T`s can be general or concept
    constrained template parameters.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：通常，模板参数可以消除 `void*`，将其转换为 `T*` 或 `T&`。对于通用代码，这些 `T` 可以是通用的或概念约束的模板参数。'
- en: Example, bad
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，坏
- en: 'Consider:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE40]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is clear that the caller is describing a rectangle, but it is unclear what
    parts they relate to. Also, an `int` can carry arbitrary forms of information,
    including values of many units, so we must guess about the meaning of the four
    `int`s. Most likely, the first two are an `x`,`y` coordinate pair, but what are
    the last two?
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，调用者描述了一个矩形，但它们所关联的部分并不清楚。此外，`int` 可以携带任意形式的信息，包括许多单位的值，因此我们必须猜测四个 `int`
    的含义。最可能的是前两个是 `x`、`y` 坐标对，但最后两个是什么？
- en: 'Comments and parameter names can help, but we could be explicit:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 注释和参数名称可以帮助，但我们可以更明确：
- en: '[PRE41]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Obviously, we cannot catch all errors through the static type system (e.g.,
    the fact that a first argument is supposed to be a top-left point is left to convention
    (naming and comments)).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们无法通过静态类型系统捕获所有错误（例如，第一个参数应该是左上角点的这一事实留给了惯例（命名和注释））。
- en: Example, bad
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，坏
- en: 'Consider:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE42]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The parameter types and their values do not communicate what settings are being
    specified or what those values mean.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类型及其值并没有传达出正在指定哪些设置或这些值的意义。
- en: 'This design is more explicit, safe and legible:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计更明确、更安全、更易读：
- en: '[PRE43]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For the case of a set of boolean values consider using a flags `enum`; a pattern
    that expresses a set of boolean values.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 对于布尔值集合的情况，考虑使用标志 `enum`；一种表示布尔值集合的模式。
- en: '[PRE44]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Example, bad
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，坏
- en: 'In the following example, it is not clear from the interface what `time_to_blink`
    means: Seconds? Milliseconds?'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，从接口中不清楚 `time_to_blink` 的含义：秒？毫秒？
- en: '[PRE45]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Example, good
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，好
- en: '`std::chrono::duration` types help making the unit of time duration explicit.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono::duration` 类型有助于使时间持续单位更明确。'
- en: '[PRE46]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The function can also be written in such a way that it will accept any time
    duration unit.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以写成可以接受任何时间单位。
- en: '[PRE47]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Enforcement
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: (Simple) Report the use of `void*` as a parameter or return type.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）报告使用 `void*` 作为参数或返回类型。
- en: (Simple) Report the use of more than one `bool` parameter.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）报告使用多个 `bool` 参数。
- en: (Hard to do well) Look for functions that use too many primitive type arguments.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （难以做好）寻找使用过多原始类型参数的函数。
- en: 'I.5: State preconditions (if any)'
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.5：状态先决条件（如果有）
- en: Reason
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Arguments have meaning that might constrain their proper use in the callee.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可能有意义，这可能会限制它们在调用者中的适当使用。
- en: Example
  id: totrans-575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: 'Consider:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE48]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here `x` must be non-negative. The type system cannot (easily and naturally)
    express that, so we must use other means. For example:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里 `x` 必须是非负的。类型系统无法（容易且自然地）表达这一点，因此我们必须使用其他手段。例如：
- en: '[PRE49]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Some preconditions can be expressed as assertions. For example:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 一些先决条件可以表示为断言。例如：
- en: '[PRE50]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Ideally, that `Expects(x >= 0)` should be part of the interface of `sqrt()`
    but that’s not easily done. For now, we place it in the definition (function body).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`Expects(x >= 0)` 应该是 `sqrt()` 函数接口的一部分，但这并不容易实现。目前，我们将其放在定义（函数体）中。
- en: '**References**: `Expects()` is described in [GSL](#gsl-guidelines-support-library).'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**：`Expects()` 在 [GSL](#gsl-guidelines-support-library) 中描述。'
- en: Note
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Prefer a formal specification of requirements, such as `Expects(p);`. If that
    is infeasible, use English text in comments, such as `// the sequence [p:q) is
    ordered using <`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 优先使用正式的需求规范，例如`Expects(p);`。如果不可行，则在注释中使用英文文本，例如`// the sequence [p:q) is ordered
    using <`。
- en: Note
  id: totrans-586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Most member functions have as a precondition that some class invariant holds.
    That invariant is established by a constructor and must be reestablished upon
    exit by every member function called from outside the class. We don’t need to
    mention it for each member function.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数成员函数都有一个先决条件，即某些类不变量成立。该不变量由构造函数建立，并且必须由从类外调用的每个成员函数在退出时重新建立。我们不需要为每个成员函数提及它。
- en: Enforcement
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Not enforceable)
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）
- en: '**See also**: The rules for passing pointers. ???'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：传递指针的规则。 ???'
- en: 'I.6: Prefer `Expects()` for expressing preconditions'
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.6：优先使用`Expects()`来表示预先条件
- en: Reason
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To make it clear that the condition is a precondition and to enable tool use.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 以清楚地表明条件是预先条件，并启用工具使用。
- en: Example
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE51]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Preconditions can be stated in many ways, including comments, `if`-statements,
    and `assert()`. This can make them hard to distinguish from ordinary code, hard
    to update, hard to manipulate by tools, and might have the wrong semantics (do
    you always want to abort in debug mode and check nothing in productions runs?).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 预先条件可以用多种方式陈述，包括注释、`if`语句和`assert()`。这可能会使它们难以与普通代码区分开来，难以更新，难以由工具操作，并且可能具有错误的语义（你总是在调试模式下终止并检查生产运行中的内容吗？）。
- en: Note
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Preconditions should be part of the interface rather than part of the implementation,
    but we don’t yet have the language facilities to do that. Once language support
    becomes available (e.g., see the [contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf))
    we will adopt the standard version of preconditions, postconditions, and assertions.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 预先条件应该是接口的一部分，而不是实现的一部分，但我们还没有语言功能来实现这一点。一旦语言支持变得可用（例如，参见[合同提案](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)），我们将采用预先条件、后置条件和断言的标准版本。
- en: Note
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`Expects()` can also be used to check a condition in the middle of an algorithm.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expects()`也可以用于在算法的中间检查条件。'
- en: Note
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: No, using `unsigned` is not a good way to sidestep the problem of [ensuring
    that a value is non-negative](#res-nonnegative).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 不，使用`unsigned`并不是绕过确保值非负（[确保值非负](#res-nonnegative)）问题的好方法。
- en: Enforcement
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Not enforceable) Finding the variety of ways preconditions can be asserted
    is not feasible. Warning about those that can be easily identified (`assert()`)
    has questionable value in the absence of a language facility.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）寻找预先条件可以声明的各种方式是不可行的。在没有语言功能的情况下，警告那些可以轻易识别的（`assert()`）具有可疑的价值。
- en: 'I.7: State postconditions'
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.7：声明后置条件
- en: Reason
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To detect misunderstandings about the result and possibly catch erroneous implementations.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测对结果的理解错误，并可能捕获错误的实现。
- en: Example, bad
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Consider:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE52]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we (incautiously) left out the precondition specification, so it is not
    explicit that height and width must be positive. We also left out the postcondition
    specification, so it is not obvious that the algorithm (`height * width`) is wrong
    for areas larger than the largest integer. Overflow can happen. Consider using:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们（不小心）省略了预先条件规范，因此并不明确高度和宽度必须是正数。我们也省略了后置条件规范，因此并不明显算法（`height * width`）对于大于最大整数的区域是错误的。可能会发生溢出。考虑使用：
- en: '[PRE53]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Example, bad
  id: totrans-614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Consider a famous security bug:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个著名的安全漏洞：
- en: '[PRE54]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There was no postcondition stating that the buffer should be cleared and the
    optimizer eliminated the apparently redundant `memset()` call:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 没有后置条件说明应该清除缓冲区，并且优化器消除了显然冗余的`memset()`调用：
- en: '[PRE55]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Postconditions are often informally stated in a comment that states the purpose
    of a function; `Ensures()` can be used to make this more systematic, visible,
    and checkable.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件通常在注释中以函数的目的来非正式地陈述；`Ensures()`可以用来使它更系统化、更可见和可检查。
- en: Note
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Postconditions are especially important when they relate to something that is
    not directly reflected in a returned result, such as a state of a data structure
    used.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件在它们与返回结果中未直接反映的事物相关时尤为重要，例如使用的数据结构的状态。
- en: Example
  id: totrans-623
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider a function that manipulates a `Record`, using a `mutex` to avoid race
    conditions:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个操作`Record`的函数，使用`mutex`来避免竞态条件：
- en: '[PRE56]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, we “forgot” to state that the `mutex` should be released, so we don’t
    know if the failure to ensure release of the `mutex` was a bug or a feature. Stating
    the postcondition would have made it clear:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们“忘记”声明应该释放`mutex`，因此我们不知道未能确保释放`mutex`是错误还是特性。声明后置条件将使情况变得明确：
- en: '[PRE57]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The bug is now obvious (but only to a human reading comments).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 现在错误很明显（但只有阅读注释的人类才能看出）。
- en: 'Better still, use [RAII](#rr-raii) to ensure that the postcondition (“the lock
    must be released”) is enforced in code:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地，使用 [RAII](#rr-raii) 确保后置条件（“锁必须释放”）在代码中得到执行：
- en: '[PRE58]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Ideally, postconditions are stated in the interface/declaration so that users
    can easily see them. Only postconditions related to the users can be stated in
    the interface. Postconditions related only to internal state belong in the definition/implementation.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，后置条件应在接口/声明中表述，以便用户可以轻松地看到它们。只有与用户相关的后置条件可以在接口中表述。仅与内部状态相关的后置条件属于定义/实现。
- en: Enforcement
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Not enforceable) This is a philosophical guideline that is infeasible to check
    directly in the general case. Domain specific checkers (like lock-holding checkers)
    exist for many toolchains.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）这是一个哲学性指南，在一般情况下难以直接检查。对于许多工具链存在特定领域的检查器（如持有锁的检查器）。
- en: 'I.8: Prefer `Ensures()` for expressing postconditions'
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.8：优先使用 `Ensures()` 表达后置条件
- en: Reason
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To make it clear that the condition is a postcondition and to enable tool use.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确条件是后置条件并启用工具使用。
- en: Example
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE59]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Postconditions can be stated in many ways, including comments, `if`-statements,
    and `assert()`. This can make them hard to distinguish from ordinary code, hard
    to update, hard to manipulate by tools, and might have the wrong semantics.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件可以用多种方式表述，包括注释、`if`-语句和`assert()`。这可能会使它们难以与普通代码区分开来，难以更新，难以被工具操作，并且可能具有错误的语义。
- en: '**Alternative**: Postconditions of the form “this resource must be released”
    are best expressed by [RAII](#rr-raii).'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：形式为“此资源必须释放”的后置条件最好用 [RAII](#rr-raii) 表达。'
- en: Note
  id: totrans-643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Ideally, that `Ensures` should be part of the interface, but that’s not easily
    done. For now, we place it in the definition (function body). Once language support
    becomes available (e.g., see the [contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf))
    we will adopt the standard version of preconditions, postconditions, and assertions.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`Ensures` 应该是接口的一部分，但这并不容易做到。目前，我们将其放在定义（函数体）中。一旦语言支持变得可用（例如，参见[合同提案](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)），我们将采用预置条件、后置条件和断言的标准版本。
- en: Enforcement
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Not enforceable) Finding the variety of ways postconditions can be asserted
    is not feasible. Warning about those that can be easily identified (`assert()`)
    has questionable value in the absence of a language facility.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）找到可以断言后置条件的多种方式是不可行的。在没有语言功能的情况下，警告那些可以轻易识别的（`assert()`）具有可疑的价值。
- en: 'I.9: If an interface is a template, document its parameters using concepts'
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.9：如果一个接口是模板，请使用概念来记录其参数
- en: Reason
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Make the interface precisely specified and compile-time checkable in the (not
    so distant) future.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在（不太遥远的）未来，使接口精确指定且可编译时检查。
- en: Example
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Use the C++20 style of requirements specification. For example:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++20 风格的需求规范。例如：
- en: '[PRE60]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**See also**: [Generic programming](#ss-gp) and [concepts](#ss-concepts).'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[泛型编程](#ss-gp) 和 [概念](#ss-concepts)。'
- en: Enforcement
  id: totrans-654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Warn if any non-variadic template parameter is not constrained by a concept
    (in its declaration or mentioned in a `requires` clause).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何非变长模板参数没有通过概念（在其声明中或在`requires`子句中提及）进行约束，则发出警告。
- en: 'I.10: Use exceptions to signal a failure to perform a required task'
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.10：使用异常来表示执行所需任务失败
- en: Reason
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It should not be possible to ignore an error because that could leave the system
    or a computation in an undefined (or unexpected) state. This is a major source
    of errors.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 它不应该可能忽略错误，因为这可能会使系统或计算处于未定义（或意外）的状态。这是错误的主要来源。
- en: Example
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE61]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: What is an error?
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是什么？
- en: 'An error means that the function cannot achieve its advertised purpose (including
    establishing postconditions). Calling code that ignores an error could lead to
    wrong results or undefined systems state. For example, not being able to connect
    to a remote server is not by itself an error: the server can refuse a connection
    for all kinds of reasons, so the natural thing is to return a result that the
    caller should always check. However, if failing to make a connection is considered
    an error, then a failure should throw an exception.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 错误意味着函数无法实现其宣称的目的（包括建立后置条件）。调用忽略错误的代码可能导致结果错误或系统状态未定义。例如，无法连接到远程服务器本身并不是错误：服务器可以出于各种原因拒绝连接，因此自然的事情是返回调用者应该始终检查的结果。然而，如果无法建立连接被视为错误，那么失败应该抛出异常。
- en: Exception
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Many traditional interface functions (e.g., UNIX signal handlers) use error
    codes (e.g., `errno`) to report what are really status codes, rather than errors.
    You don’t have a good alternative to using such, so calling these does not violate
    the rule.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 许多传统接口函数（例如，UNIX信号处理程序）使用错误代码（例如，`errno`）来报告实际上是状态代码，而不是错误。在这种情况下没有好的替代方案，因此调用这些函数并不违反规则。
- en: Alternative
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'If you can’t use exceptions (e.g., because your code is full of old-style raw-pointer
    use or because there are hard-real-time constraints), consider using a style that
    returns a pair of values:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能使用异常（例如，因为代码中充满了旧式原始指针使用或因为存在硬实时约束），考虑使用返回值对的风格：
- en: '[PRE62]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This style unfortunately leads to uninitialized variables. Since C++17 the
    “structured bindings” feature can be used to initialize variables directly from
    the return value:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格不幸地导致了未初始化的变量。自C++17起，可以使用“结构化绑定”功能直接从返回值初始化变量：
- en: '[PRE63]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t consider “performance” a valid reason not to use exceptions.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不认为“性能”是拒绝使用异常的有效理由。
- en: Often, explicit error checking and handling consume as much time and space as
    exception handling.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，显式错误检查和处理消耗的时间和空间与异常处理相当。
- en: Often, cleaner code yields better performance with exceptions (simplifying the
    tracing of paths through the program and their optimization).
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，更简洁的代码在异常情况下（简化程序路径的追踪及其优化）能带来更好的性能。
- en: A good rule for performance critical code is to move checking outside the [critical](#rper-critical)
    part of the code.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于性能关键代码，一个好的规则是将检查移出代码的[关键](#rper-critical)部分。
- en: In the longer term, more regular code gets better optimized.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从长远来看，更规范的代码会得到更好的优化。
- en: Always carefully [measure](#rper-measure) before making performance claims.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在做出性能声明之前，始终仔细[测量](#rper-measure)。
- en: '**See also**: [I.5](#ri-pre) and [I.7](#ri-post) for reporting precondition
    and postcondition violations.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[I.5](#ri-pre) 和 [I.7](#ri-post) 以报告先决条件和后置条件违规。'
- en: Enforcement
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Not enforceable) This is a philosophical guideline that is infeasible to check
    directly.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （不可强制执行）这是一个无法直接检查的哲学性指南。
- en: Look for `errno`.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找 `errno`。
- en: 'I.11: Never transfer ownership by a raw pointer (`T*`) or reference (`T&`)'
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.11：永远不要通过原始指针 (`T*`) 或引用 (`T&`) 转移所有权
- en: Reason
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If there is any doubt whether the caller or the callee owns an object, leaks
    or premature destruction will occur.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对调用者或被调用者是否拥有对象有任何疑问，将发生泄漏或过早销毁。
- en: Example
  id: totrans-685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE64]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Who deletes the returned `X`? The problem would be harder to spot if `compute`
    returned a reference. Consider returning the result by value (use move semantics
    if the result is large):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 谁删除返回的 `X`？如果 `compute` 返回一个引用，这个问题会更难发现。考虑通过值返回结果（如果结果很大，使用移动语义）：
- en: '[PRE65]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Alternative**: [Pass ownership](#rr-smartptrparam) using a “smart pointer”,
    such as `unique_ptr` (for exclusive ownership) and `shared_ptr` (for shared ownership).
    However, that is less elegant and often less efficient than returning the object
    itself, so use smart pointers only if reference semantics are needed.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：使用“智能指针”，如 `unique_ptr`（用于独占所有权）和 `shared_ptr`（用于共享所有权）来传递所有权。然而，这通常不如直接返回对象本身优雅且效率低，因此只有在需要引用语义时才使用智能指针。'
- en: '**Alternative**: Sometimes older code can’t be modified because of ABI compatibility
    requirements or lack of resources. In that case, mark owning pointers using `owner`
    from the [guidelines support library](#gsl-guidelines-support-library):'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：有时，由于ABI兼容性要求或资源不足，旧代码无法修改。在这种情况下，使用来自[指南支持库](#gsl-guidelines-support-library)的
    `owner` 标记拥有指针：'
- en: '[PRE66]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This tells analysis tools that `res` is an owner. That is, its value must be
    `delete`d or transferred to another owner, as is done here by the `return`.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉分析工具`res`是一个所有者。也就是说，它的值必须被`delete`或转移到另一个所有者，就像这里通过`return`所做的那样。
- en: '`owner` is used similarly in the implementation of resource handles.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner`在资源句柄的实现中类似使用。'
- en: Note
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Every object passed as a raw pointer (or iterator) is assumed to be owned by
    the caller, so that its lifetime is handled by the caller. Viewed another way:
    ownership transferring APIs are relatively rare compared to pointer-passing APIs,
    so the default is “no ownership transfer.”'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 每个作为原始指针（或迭代器）传递的对象都假定由调用者拥有，因此其生命周期由调用者处理。从另一个角度来看：与指针传递API相比，所有权转移API相对较少，因此默认为“不转移所有权”。
- en: '**See also**: [Argument passing](#rf-conventional), [use of smart pointer arguments](#rr-smartptrparam),
    and [value return](#rf-value-return).'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**：[参数传递](#rf-conventional)，[智能指针参数的使用](#rr-smartptrparam)，以及[值返回](#rf-value-return)。'
- en: Enforcement
  id: totrans-698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`. Suggest
    use of standard-library resource handle or use of `owner<T>`.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 在删除不是`owner<T>`的原始指针时发出警告。建议使用标准库资源句柄或使用`owner<T>`。
- en: (Simple) Warn on failure to either `reset` or explicitly `delete` an `owner`
    pointer on every code path.
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 在每个代码路径上未能`reset`或显式`delete`一个`owner`指针时发出警告。
- en: (Simple) Warn if the return value of `new` or a function call with an `owner`
    return value is assigned to a raw pointer or non-`owner` reference.
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 如果`new`或带有`owner`返回值的函数调用被赋值给原始指针或非`owner`引用，则发出警告。
- en: 'I.12: Declare a pointer that must not be null as `not_null`'
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.12：将必须不为空的指针声明为`not_null`
- en: Reason
  id: totrans-703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To help avoid dereferencing `nullptr` errors. To improve performance by avoiding
    redundant checks for `nullptr`.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助避免解引用`nullptr`错误。通过避免对`nullptr`进行冗余检查来提高性能。
- en: Example
  id: totrans-705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE67]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By stating the intent in source, implementers and tools can provide better diagnostics,
    such as finding some classes of errors through static analysis, and perform optimizations,
    such as removing branches and null tests.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在源代码中声明意图，实现者和工具可以提供更好的诊断，例如通过静态分析找到某些类别的错误，并执行优化，例如删除分支和空测试。
- en: Note
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`not_null` is defined in the [guidelines support library](#gsl-guidelines-support-library).'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '`not_null`在[指南支持库](#gsl-guidelines-support-library)中定义。'
- en: Note
  id: totrans-710
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The assumption that the pointer to `char` pointed to a C-style string (a zero-terminated
    string of characters) was still implicit, and a potential source of confusion
    and errors. Use `czstring` in preference to `const char*`.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 指针指向`char`的假设仍然隐含地指向C风格字符串（一个以空字符终止的字符序列），这可能是混淆和错误的一个潜在来源。优先使用`czstring`而不是`const
    char*`。
- en: '[PRE68]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note: `length()` is, of course, `std::strlen()` in disguise.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`length()`当然是以`std::strlen()`的形式出现的。
- en: Enforcement
  id: totrans-714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) ((Foundation)) If a function checks a pointer parameter against `nullptr`
    before access, on all control-flow paths, then warn it should be declared `not_null`.
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) ((基础)) 如果一个函数在访问之前对所有控制流路径上的指针参数进行`nullptr`检查，则警告它应该声明为`not_null`。
- en: (Complex) If a function with pointer return value ensures it is not `nullptr`
    on all return paths, then warn the return type should be declared `not_null`.
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (复杂) 如果一个具有指针返回值的函数确保在所有返回路径上都不是`nullptr`，则警告返回类型应该声明为`not_null`。
- en: 'I.13: Do not pass an array as a single pointer'
  id: totrans-717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.13：不要将数组作为单个指针传递
- en: Reason
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: (pointer, size)-style interfaces are error-prone. Also, a plain pointer (to
    array) must rely on some convention to allow the callee to determine the size.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: (指针，大小)-风格的接口容易出错。此外，一个普通的指针（到数组）必须依赖于某种约定，以便调用者能够确定大小。
- en: Example
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE69]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: What if there are fewer than `n` elements in the array pointed to by `q`? Then,
    we overwrite some probably unrelated memory. What if there are fewer than `n`
    elements in the array pointed to by `p`? Then, we read some probably unrelated
    memory. Either is undefined behavior and a potentially very nasty bug.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`q`指向的数组中的元素少于`n`个，会发生什么？那么，我们将覆盖一些可能无关的内存。如果`p`指向的数组中的元素少于`n`个，会发生什么？那么，我们将读取一些可能无关的内存。这两种情况都是未定义的行为，可能是非常糟糕的错误。
- en: Alternative
  id: totrans-724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'Consider using explicit spans:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用显式跨度：
- en: '[PRE70]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Example, bad
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Consider:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE71]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Passing `10` as the `n` argument might be a mistake: the most common convention
    is to assume `[0:n)` but that is nowhere stated. Worse is that the call of `draw()`
    compiled at all: there was an implicit conversion from array to pointer (array
    decay) and then another implicit conversion from `Circle` to `Shape`. There is
    no way that `draw()` can safely iterate through that array: it has no way of knowing
    the size of the elements.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `10` 作为 `n` 参数传递可能是一个错误：最常见的约定是假设 `[0:n)`，但这一点并未明确说明。更糟糕的是，`draw()` 的调用竟然编译成功：存在从数组到指针（数组衰减）的隐式转换，然后是从
    `Circle` 到 `Shape` 的另一个隐式转换。`draw()` 没有安全迭代该数组的方法：它无法知道元素的大小。
- en: '**Alternative**: Use a support class that ensures that the number of elements
    is correct and prevents dangerous implicit conversions. For example:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：使用支持类以确保元素数量正确，并防止危险的隐式转换。例如：'
- en: '[PRE72]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This `draw2()` passes the same amount of information to `draw()`, but makes
    the fact that it is supposed to be a range of `Circle`s explicit. See ???.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `draw2()` 将相同的信息传递给 `draw()`，但明确指出它应该是一个 `Circle` 的范围。见 ???。
- en: Exception
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Use `zstring` and `czstring` to represent C-style, zero-terminated strings.
    But when doing so, use `std::string_view` or `span<char>` from the [GSL](#gsl-guidelines-support-library)
    to prevent range errors.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `zstring` 和 `czstring` 来表示 C 风格的、以空字符结尾的字符串。但在此过程中，使用来自 [GSL](#gsl-guidelines-support-library)
    的 `std::string_view` 或 `span<char>` 以防止范围错误。
- en: Enforcement
  id: totrans-736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) ((Bounds)) Warn for any expression that would rely on implicit conversion
    of an array type to a pointer type. Allow exception for zstring/czstring pointer
    types.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）（边界）对于任何依赖于将数组类型隐式转换为指针类型的表达式进行警告。允许 zstring/czstring 指针类型的例外。
- en: (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer
    type that results in a value of pointer type. Allow exception for zstring/czstring
    pointer types.
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）（边界）对于任何导致指针类型值的指针类型表达式的算术运算进行警告。允许 zstring/czstring 指针类型的例外。
- en: 'I.22: Avoid complex initialization of global objects'
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.22：避免全局对象的复杂初始化
- en: Reason
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Complex initialization can lead to undefined order of execution.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的初始化可能导致执行顺序未定义。
- en: Example
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE73]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Since `x` and `y` are in different translation units the order of calls to `f()`
    and `g()` is undefined; one will access an uninitialized `const`. This shows that
    the order-of-initialization problem for global (namespace scope) objects is not
    limited to global *variables*.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `x` 和 `y` 在不同的翻译单元中，对 `f()` 和 `g()` 的调用顺序是未定义的；其中一个将访问未初始化的 `const`。这表明全局（命名空间范围）对象的初始化顺序问题不仅限于全局
    *变量*。
- en: Note
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Order of initialization problems become particularly difficult to handle in
    concurrent code. It is usually best to avoid global (namespace scope) objects
    altogether.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发代码中，初始化顺序问题变得特别难以处理。通常最好完全避免全局（命名空间范围）对象。
- en: Enforcement
  id: totrans-747
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag initializers of globals that call non-`constexpr` functions
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记调用非 `constexpr` 函数的全局初始化器
- en: Flag initializers of globals that access `extern` objects
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记访问 `extern` 对象的全局初始化器
- en: 'I.23: Keep the number of function arguments low'
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.23：保持函数参数数量低
- en: Reason
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Having many arguments opens opportunities for confusion. Passing lots of arguments
    is often costly compared to alternatives.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 参数过多会带来混淆的机会。与替代方案相比，传递大量参数通常成本较高。
- en: Discussion
  id: totrans-753
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The two most common reasons why functions have too many parameters are:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数过多最常见的两个原因是：
- en: '*Missing an abstraction.* There is an abstraction missing, so that a compound
    value is being passed as individual elements instead of as a single object that
    enforces an invariant. This not only expands the parameter list, but it leads
    to errors because the component values are no longer protected by an enforced
    invariant.'
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*缺少抽象。* 缺少抽象，因此复合值被作为单独的元素传递，而不是作为强制不变的单个对象。这不仅扩展了参数列表，而且由于组件值不再受到强制不变的保护，这会导致错误。'
- en: '*Violating “one function, one responsibility.”* The function is trying to do
    more than one job and should probably be refactored.'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*违反“一个函数，一个职责。”* 函数试图做更多的工作，可能需要重构。'
- en: Example
  id: totrans-757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'The standard-library `merge()` is at the limit of what we can comfortably handle:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的 `merge()` 函数是我们能舒适处理的极限：
- en: '[PRE74]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note that this is because of problem 1 above – missing abstraction. Instead
    of passing a range (abstraction), STL passed iterator pairs (unencapsulated component
    values).
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是因为上面的问题1——缺少抽象。STL不是传递范围（抽象），而是传递迭代器对（未封装的组件值）。
- en: 'Here, we have four template arguments and six function arguments. To simplify
    the most frequent and simplest uses, the comparison argument can be defaulted
    to `<`:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有四个模板参数和六个函数参数。为了简化最常见和最简单的用法，比较参数可以默认为`<`：
- en: '[PRE75]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This doesn’t reduce the total complexity, but it reduces the surface complexity
    presented to many users. To really reduce the number of arguments, we need to
    bundle the arguments into higher-level abstractions:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不减少总复杂性，但它减少了呈现给许多用户的表面复杂性。要真正减少参数数量，我们需要将参数捆绑到更高层次的抽象中：
- en: '[PRE76]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Grouping arguments into “bundles” is a general technique to reduce the number
    of arguments and to increase the opportunities for checking.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数组合成“包”是一种减少参数数量并增加检查机会的通用技术。
- en: 'Alternatively, we could use a standard library concept to define the notion
    of three types that must be usable for merging:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用标准库的概念来定义必须可用于合并的三种类型的概念：
- en: '[PRE77]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Example
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: The safety Profiles recommend replacing
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 安全配置文件建议替换
- en: '[PRE78]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: with
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: '[PRE79]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, using an abstraction has safety and robustness benefits, and naturally
    also reduces the number of parameters.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用抽象具有安全性和健壮性的好处，并且自然会减少参数的数量。
- en: Note
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: How many parameters are too many? Try to use fewer than four (4) parameters.
    There are functions that are best expressed with four individual parameters, but
    not many.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少参数太多？尽量使用少于四个（4）个参数。有一些函数最好用四个单独的参数表达，但不多。
- en: '**Alternative**: Use better abstraction: Group arguments into meaningful objects
    and pass the objects (by value or by reference).'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：使用更好的抽象：将参数组合成有意义的对象，并通过值或引用传递这些对象。'
- en: '**Alternative**: Use default arguments or overloads to allow the most common
    forms of calls to be done with fewer arguments.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：使用默认参数或重载来允许使用较少的参数执行最常见的调用形式。'
- en: Enforcement
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Warn when a function declares two iterators (including pointers) of the same
    type instead of a range or a view.
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个函数声明了两个相同类型的迭代器（包括指针）而不是范围或视图时，发出警告。
- en: (Not enforceable) This is a philosophical guideline that is infeasible to check
    directly.
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （不可强制执行）这是一个哲学性的指导方针，直接检查是不可行的。
- en: 'I.24: Avoid adjacent parameters that can be invoked by the same arguments in
    either order with different meaning'
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.24：避免相邻参数，这些参数可以通过不同的顺序以不同的意义调用
- en: Reason
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Adjacent arguments of the same type are easily swapped by mistake.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 相同类型的相邻参数很容易被错误地交换。
- en: Example, bad
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好
- en: 'Consider:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE80]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is a nasty variant of a K&R C-style interface. It is easy to reverse the
    “to” and “from” arguments.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个K&R C风格接口的讨厌变种。很容易颠倒“到”和“从”参数。
- en: 'Use `const` for the “from” argument:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 为“从”参数使用`const`：
- en: '[PRE81]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Exception
  id: totrans-790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'If the order of the parameters is not important, there is no problem:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的顺序不重要，则没有问题：
- en: '[PRE82]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Alternative
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'Don’t pass arrays as pointers, pass an object representing a range (e.g., a
    `span`):'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 不要传递数组作为指针，传递表示范围的对象（例如，`span`）：
- en: '[PRE83]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Alternative
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'Define a `struct` as the parameter type and name the fields for those parameters
    accordingly:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`struct`作为参数类型，并相应地命名这些参数的字段：
- en: '[PRE84]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This tends to make invocations of this clear to future readers, as the parameters
    are often filled in by name at the call site.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这往往使未来的读者对这种调用清晰，因为参数通常在调用位置按名称填充。
- en: Note
  id: totrans-800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Only the interface’s designer can adequately address the source of violations
    of this guideline.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 只有接口的设计者才能充分解决违反此指南的原因。
- en: Enforcement strategy
  id: totrans-802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法策略
- en: (Simple) Warn if two consecutive parameters share the same type.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）如果两个连续的参数具有相同的类型，则发出警告。
- en: We are still looking for a less-simple enforcement.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍在寻找一种不那么简单的强制执行方法。
- en: 'I.25: Prefer empty abstract classes as interfaces to class hierarchies'
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I.25：优先使用空抽象类作为类层次结构的接口
- en: Reason
  id: totrans-806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Abstract classes that are empty (have no non-static member data) are more likely
    to be stable than base classes with state.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 没有非静态成员数据的空抽象类比具有状态的基类更有可能稳定。
- en: Example, bad
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好
- en: You just knew that `Shape` would turn up somewhere :-)
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 你就知道`Shape`会出现在某个地方 :-)
- en: '[PRE85]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This will force every derived class to compute a center – even if that’s non-trivial
    and the center is never used. Similarly, not every `Shape` has a `Color`, and
    many `Shape`s are best represented without an outline defined as a sequence of
    `Point`s. Using an abstract class is better:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 这将迫使每个派生类都计算一个中心点——即使这并不简单，而且中心点从未被使用。同样，并非每个`Shape`都有`Color`，许多`Shape`最好不定义为一个由`Point`序列组成的轮廓。使用抽象类更好：
- en: '[PRE86]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Enforcement
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a pointer/reference to a class `C` is assigned to a pointer/reference
    to a base of `C` and the base class contains data members.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）如果将类`C`的指针/引用分配给`C`的基类的指针/引用，并且基类包含数据成员，则发出警告。
- en: 'I.26: If you want a cross-compiler ABI, use a C-style subset'
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'I.26: 如果你想有一个跨编译器的ABI，请使用C风格的子集'
- en: Reason
  id: totrans-816
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Different compilers implement different binary layouts for classes, exception
    handling, function names, and other implementation details.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 不同编译器为类、异常处理、函数名和其他实现细节实现不同的二进制布局。
- en: Exception
  id: totrans-818
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Common ABIs are emerging on some platforms freeing you from the more draconian
    restrictions.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的ABI（应用二进制接口）在一些平台上正在出现，这使你免受更严格的限制。
- en: Note
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: If you use a single compiler, you can use full C++ in interfaces. That might
    require recompilation after an upgrade to a new compiler version.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用单个编译器，你可以在接口中使用完整的C++。这可能需要在升级到新编译器版本后重新编译。
- en: Enforcement
  id: totrans-822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Not enforceable) It is difficult to reliably identify where an interface forms
    part of an ABI.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）可靠地识别接口形成ABI一部分的位置是困难的。
- en: 'I.27: For stable library ABI, consider the Pimpl idiom'
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'I.27: 对于稳定的库ABI，考虑使用Pimpl习语'
- en: Reason
  id: totrans-825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Because private data members participate in class layout and private member
    functions participate in overload resolution, changes to those implementation
    details require recompilation of all users of a class that uses them. A non-polymorphic
    interface class holding a pointer to implementation (Pimpl) can isolate the users
    of a class from changes in its implementation at the cost of an indirection.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 由于私有数据成员参与类布局，私有成员函数参与重载解析，因此对这些实现细节的更改需要重新编译使用它们的类的所有用户。一个持有实现指针（Pimpl）的非多态接口类可以通过间接调用的代价来隔离类的用户，使其免受其实施更改的影响。
- en: Example
  id: totrans-827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: interface (widget.h)
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 接口（widget.h）
- en: '[PRE87]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: implementation (widget.cpp)
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 实现（widget.cpp）
- en: '[PRE88]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Notes
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'See [GOTW #100](https://herbsutter.com/gotw/_100/) and [cppreference](https://en.cppreference.com/w/cpp/language/pimpl)
    for the trade-offs and additional implementation details associated with this
    idiom.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '请参阅[GOTW #100](https://herbsutter.com/gotw/_100/)和[cppreference](https://en.cppreference.com/w/cpp/language/pimpl)，了解与此习语相关的权衡和附加实现细节。'
- en: Enforcement
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Not enforceable) It is difficult to reliably identify where an interface forms
    part of an ABI.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）可靠地识别接口形成ABI一部分的位置是困难的。
- en: 'I.30: Encapsulate rule violations'
  id: totrans-836
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'I.30: 封装规则违规'
- en: Reason
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To keep code simple and safe. Sometimes, ugly, unsafe, or error-prone techniques
    are necessary for logical or performance reasons. If so, keep them local, rather
    than “infecting” interfaces so that larger groups of programmers have to be aware
    of the subtleties. Implementation complexity should, if at all possible, not leak
    through interfaces into user code.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码简单和安全。有时，出于逻辑或性能原因，需要使用丑陋、不安全或容易出错的技巧。如果是这样，请将它们本地化，而不是“感染”接口，这样更大的程序员群体就必须意识到这些细微差别。如果可能的话，实现复杂性不应泄露到用户代码中。
- en: Example
  id: totrans-839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Consider a program that, depending on some form of input (e.g., arguments to
    `main`), should consume input from a file, from the command line, or from standard
    input. We might write
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个程序，它根据某种形式的输入（例如，`main`的参数），应该从文件、命令行或标准输入中获取输入。我们可能会写
- en: '[PRE89]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This violated the rule [against uninitialized variables](#res-always), the rule
    against [ignoring ownership](#ri-raw), and the rule [against magic constants](#res-magic).
    In particular, someone has to remember to somewhere write
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 这违反了[未初始化变量](#res-always)的规则，违反了[忽略所有权](#ri-raw)的规则，以及违反了[魔法常量](#res-magic)的规则。特别是，有人必须记得在某个地方写下
- en: '[PRE90]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We could handle this particular example by using `unique_ptr` with a special
    deleter that does nothing for `cin`, but that’s complicated for novices (who can
    easily encounter this problem) and the example is an example of a more general
    problem where a property that we would like to consider static (here, ownership)
    needs infrequently be addressed at run time. The common, most frequent, and safest
    examples can be handled statically, so we don’t want to add cost and complexity
    to those. But we must also cope with the uncommon, less-safe, and necessarily
    more expensive cases. Such examples are discussed in [[Str15]](https://www.stroustrup.com/resource-model.pdf).
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用具有特殊删除器的 `unique_ptr` 来处理这个特定的例子，该删除器对 `cin` 不做任何事情，但这对于新手来说很复杂（他们很容易遇到这个问题），而且这个例子是一个更普遍问题的例子，其中我们希望考虑为静态（在这里，是所有权）的特性很少在运行时被处理。常见的、最频繁的、最安全的例子可以静态处理，所以我们不希望给这些例子增加成本和复杂性。但是，我们也必须应对不常见、不太安全且必然更昂贵的案例。这些例子在
    [[Str15]](https://www.stroustrup.com/resource-model.pdf) 中讨论。
- en: So, we write a class
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们编写一个类
- en: '[PRE91]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now, the dynamic nature of `istream` ownership has been encapsulated. Presumably,
    a bit of checking for potential errors would be added in real code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`istream` 所有权动态性质已经被封装。在真实代码中，可能会添加一些检查潜在错误的代码。
- en: Enforcement
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Hard, it is hard to decide what rule-breaking code is essential
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 困难，很难决定哪些违规代码是必要的
- en: Flag rule suppression that enable rule-violations to cross interfaces
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抑制标志规则，允许规则违规跨越接口
- en: 'F: Functions'
  id: totrans-851
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'F: 函数'
- en: A function specifies an action or a computation that takes the system from one
    consistent state to the next. It is the fundamental building block of programs.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指定一个动作或计算，它将系统从一个一致状态转换到下一个状态。它是程序的基本构建块。
- en: It should be possible to name a function meaningfully, to specify the requirements
    of its argument, and clearly state the relationship between the arguments and
    the result. An implementation is not a specification. Try to think about what
    a function does as well as about how it does it. Functions are the most critical
    part in most interfaces, so see the interface rules.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 应该能够有意义地命名一个函数，指定其参数的要求，并清楚地说明参数与结果之间的关系。实现不是规范。尝试思考函数做什么以及它是如何做的。函数是大多数接口中最关键的部分，因此请参阅接口规则。
- en: 'Function rule summary:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 函数规则摘要：
- en: 'Function definition rules:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义规则：
- en: '[F.1: “Package” meaningful operations as carefully named functions](#rf-package)'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.1: 将有意义的操作作为命名良好的函数“打包”](#rf-package)'
- en: '[F.2: A function should perform a single logical operation](#rf-logical)'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.2: 函数应该执行单个逻辑操作](#rf-logical)'
- en: '[F.3: Keep functions short and simple](#rf-single)'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.3: 保持函数简短和简单](#rf-single)'
- en: '[F.4: If a function might have to be evaluated at compile time, declare it
    `constexpr`](#rf-constexpr)'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.4: 如果一个函数可能需要在编译时评估，声明它为 `constexpr`](#rf-constexpr)'
- en: '[F.5: If a function is very small and time-critical, declare it inline](#rf-inline)'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.5: 如果一个函数非常小且时间关键，声明它为内联](#rf-inline)'
- en: '[F.6: If your function must not throw, declare it `noexcept`](#rf-noexcept)'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.6: 如果你的函数绝对不能抛出异常，声明它为 `noexcept`](#rf-noexcept)'
- en: '[F.7: For general use, take `T*` or `T&` arguments rather than smart pointers](#rf-smart)'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.7: 对于通用情况，使用 `T*` 或 `T&` 参数而不是智能指针](#rf-smart)'
- en: '[F.8: Prefer pure functions](#rf-pure)'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.8: 优先使用纯函数](#rf-pure)'
- en: '[F.9: Unused parameters should be unnamed](#rf-unused)'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.9: 未使用的参数应该是未命名的](#rf-unused)'
- en: '[F.10: If an operation can be reused, give it a name](#rf-name)'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.10: 如果一个操作可以被重用，给它起一个名字](#rf-name)'
- en: '[F.11: Use an unnamed lambda if you need a simple function object in one place
    only](#rf-lambda)'
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.11: 如果只需要一个简单的函数对象在一个地方，使用未命名的 lambda](#rf-lambda)'
- en: 'Parameter passing expression rules:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 参数传递表达式规则：
- en: '[F.15: Prefer simple and conventional ways of passing information](#rf-conventional)'
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.15: 优先使用简单和传统的信息传递方式](#rf-conventional)'
- en: '[F.16: For “in” parameters, pass cheaply-copied types by value and others by
    reference to `const`](#rf-in)'
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.16: 对于“输入”参数，通过值传递便宜复制的类型，通过 `const` 引用传递其他类型](#rf-in)'
- en: '[F.17: For “in-out” parameters, pass by reference to non-`const`](#rf-inout)'
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.17: 对于“输入-输出”参数，通过非 `const` 引用传递](#rf-inout)'
- en: '[F.18: For “will-move-from” parameters, pass by `X&&` and `std::move` the parameter](#rf-consume)'
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.18: 对于“将移动”参数，通过 `X&&` 传递，并使用 `std::move` 移动参数](#rf-consume)'
- en: '[F.19: For “forward” parameters, pass by `TP&&` and only `std::forward` the
    parameter](#rf-forward)'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.19: 对于“正向”参数，通过 `TP&&` 传递，并且只 `std::forward` 参数](#rf-forward)'
- en: '[F.20: For “out” output values, prefer return values to output parameters](#rf-out)'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.20: 对于“输出”输出值，优先使用返回值而不是输出参数](#rf-out)'
- en: '[F.21: To return multiple “out” values, prefer returning a struct](#rf-out-multi)'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.21: 要返回多个“输出”值，优先返回一个结构体](#rf-out-multi)'
- en: '[F.60: Prefer `T*` over `T&` when “no argument” is a valid option](#rf-ptr-ref)'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.60: 当“无参数”是一个有效选项时，优先使用 `T*` 而不是 `T&`](#rf-ptr-ref)'
- en: 'Parameter passing semantic rules:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 参数传递语义规则：
- en: '[F.22: Use `T*` or `owner<T*>` to designate a single object](#rf-ptr)'
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.22: 使用 `T*` 或 `owner<T*>` 来指定单个对象](#rf-ptr)'
- en: '[F.23: Use a `not_null<T>` to indicate that “null” is not a valid value](#rf-nullptr)'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.23: 使用 `not_null<T>` 来指示“null”不是一个有效值](#rf-nullptr)'
- en: '[F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence](#rf-range)'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.24: 使用 `span<T>` 或 `span_p<T>` 来指定半开序列](#rf-range)'
- en: '[F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string](#rf-zstring)'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.25: 使用 `zstring` 或 `not_null<zstring>` 来指定 C 风格字符串](#rf-zstring)'
- en: '[F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed](#rf-unique_ptr)'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.26: 使用 `unique_ptr<T>` 来转移需要指针的所有权](#rf-unique_ptr)'
- en: '[F.27: Use a `shared_ptr<T>` to share ownership](#rf-shared_ptr)'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.27: 使用 `shared_ptr<T>` 来共享所有权](#rf-shared_ptr)'
- en: 'Value return semantic rules:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 值返回语义规则：
- en: '[F.42: Return a `T*` to indicate a position (only)](#rf-return-ptr)'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.42: 返回 `T*` 来指示位置（仅限）](#rf-return-ptr)'
- en: '[F.43: Never (directly or indirectly) return a pointer or a reference to a
    local object](#rf-dangle)'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.43: 永远不要（直接或间接）返回局部对象的指针或引用](#rf-dangle)'
- en: '[F.44: Return a `T&` when copy is undesirable and “returning no object” isn’t
    needed](#rf-return-ref)'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.44: 当复制不希望发生且不需要“返回无对象”时返回 `T&`](#rf-return-ref)'
- en: '[F.45: Don’t return a `T&&`](#rf-return-ref-ref)'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.45: 不要返回 `T&&`](#rf-return-ref-ref)'
- en: '[F.46: `int` is the return type for `main()`](#rf-main)'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.46: `main()` 的返回类型为 `int`](#rf-main)'
- en: '[F.47: Return `T&` from assignment operators](#rf-assignment-op)'
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.47: 从赋值运算符返回 `T&`](#rf-assignment-op)'
- en: '[F.48: Don’t return `std::move(local)`](#rf-return-move-local)'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.48: 不要返回 `std::move(local)`](#rf-return-move-local)'
- en: '[F.49: Don’t return `const T`](#rf-return-const)'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.49: 不要返回 `const T`](#rf-return-const)'
- en: 'Other function rules:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数规则：
- en: '[F.50: Use a lambda when a function won’t do (to capture local variables, or
    to write a local function)](#rf-capture-vs-overload)'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.50: 当函数不足以使用时使用 lambda（用于捕获局部变量或编写局部函数）](#rf-capture-vs-overload)'
- en: '[F.51: Where there is a choice, prefer default arguments over overloading](#rf-default-args)'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.51: 在有选择的情况下，优先使用默认参数而不是重载](#rf-default-args)'
- en: '[F.52: Prefer capturing by reference in lambdas that will be used locally,
    including passed to algorithms](#rf-reference-capture)'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.52: 在本地使用且包括传递给算法的 lambda 中，优先捕获引用](#rf-reference-capture)'
- en: '[F.53: Avoid capturing by reference in lambdas that will be used non-locally,
    including returned, stored on the heap, or passed to another thread](#rf-value-capture)'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.53: 在非局部使用 lambda 时避免引用捕获，包括返回、存储在堆上或传递给另一个线程](#rf-value-capture)'
- en: '[F.54: When writing a lambda that captures `this` or any class data member,
    don’t use `[=]` default capture](#rf-this-capture)'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.54: 当编写捕获 `this` 或任何类数据成员的 lambda 时，不要使用 `[=]` 默认捕获](#rf-this-capture)'
- en: '[F.55: Don’t use `va_arg` arguments](#f-varargs)'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.55: 不要使用 `va_arg` 参数](#f-varargs)'
- en: '[F.56: Avoid unnecessary condition nesting](#f-nesting)'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.56: 避免不必要的条件嵌套](#f-nesting)'
- en: Functions have strong similarities to lambdas and function objects.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与 lambda 和函数对象有很强的相似性。
- en: '**See also**: [C.lambdas: Function objects and lambdas](#ss-lambdas)'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [C.lambdas: 函数对象和 lambda](#ss-lambdas)'
- en: 'F.def: Function definitions'
  id: totrans-902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'F.def: 函数定义'
- en: A function definition is a function declaration that also specifies the function’s
    implementation, the function body.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义是一个同时指定了函数实现和函数体的函数声明。
- en: 'F.1: “Package” meaningful operations as carefully named functions'
  id: totrans-904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'F.1: “封装”有意义的操作为精心命名的函数'
- en: Reason
  id: totrans-905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Factoring out common code makes code more readable, more likely to be reused,
    and limit errors from complex code. If something is a well-specified action, separate
    it out from its surrounding code and give it a name.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 将常用代码提取出来可以使代码更易于阅读，更可能被重用，并限制复杂代码中的错误。如果某项操作是明确指定的，则将其从周围代码中分离出来并给它一个名字。
- en: Example, don’t
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不要
- en: '[PRE92]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Almost everything is wrong with `read_and_print`. It reads, it writes (to a
    fixed `ostream`), it writes error messages (to a fixed `ostream`), it handles
    only `int`s. There is nothing to reuse, logically separate operations are intermingled
    and local variables are in scope after the end of their logical use. For a tiny
    example, this looks OK, but if the input operation, the output operation, and
    the error handling had been more complicated the tangled mess could become hard
    to understand.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有关于 `read_and_print` 的东西都是错误的。它读取，它写入（到一个固定的 `ostream`），它写入错误消息（到一个固定的 `ostream`），它只处理
    `int`。没有可以重用的东西，逻辑上分离的操作交织在一起，局部变量在其逻辑使用结束后仍在作用域内。对于一个微小的例子，这看起来还可以，但如果输入操作、输出操作和错误处理更加复杂，混乱的混乱可能难以理解。
- en: Note
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you write a non-trivial lambda that potentially can be used in more than
    one place, give it a name by assigning it to a (usually non-local) variable.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写了一个非平凡的lambda，它可能在多个地方使用，给它命名，通过将其分配给一个（通常是非局部）变量。
- en: Example
  id: totrans-912
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE93]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Naming that lambda breaks up the expression into its logical parts and provides
    a strong hint to the meaning of the lambda.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 给这个lambda命名将表达式分解为其逻辑部分，并为lambda的含义提供了强烈的提示。
- en: '[PRE94]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The shortest code is not always the best for performance or maintainability.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 最短的代码不一定是性能或可维护性最好的。
- en: Exception
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例外
- en: Loop bodies, including lambdas used as loop bodies, rarely need to be named.
    However, large loop bodies (e.g., dozens of lines or dozens of pages) can be a
    problem. The rule [Keep functions short and simple](#rf-single) implies “Keep
    loop bodies short.” Similarly, lambdas used as callback arguments are sometimes
    non-trivial, yet unlikely to be reusable.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体，包括用作循环体的lambda，很少需要命名。然而，大的循环体（例如，数十行或数十页）可能是一个问题。规则[保持函数简短和简单](#rf-single)意味着“保持循环体简短。”同样，用作回调参数的lambda有时可能非平凡，但不太可能重用。
- en: Enforcement
  id: totrans-919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: See [Keep functions short and simple](#rf-single)
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[保持函数简短和简单](#rf-single)
- en: Flag identical and very similar lambdas used in different places.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记在不同地方使用的相同和非常相似的lambda。
- en: 'F.2: A function should perform a single logical operation'
  id: totrans-922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.2：函数应执行单个逻辑操作
- en: Reason
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A function that performs a single operation is simpler to understand, test,
    and reuse.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 执行单个操作的函数更容易理解、测试和重用。
- en: Example
  id: totrans-925
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE95]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This is a monolith that is tied to a specific input and will never find another
    (different) use. Instead, break functions up into suitable logical parts and parameterize:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个绑定到特定输入的单一块，它永远不会找到另一个（不同的）用途。相反，将函数分解成合适的逻辑部分并进行参数化：
- en: '[PRE96]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'These can now be combined where needed:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 这些现在可以在需要的地方组合：
- en: '[PRE97]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If there was a need, we could further templatize `read()` and `print()` on
    the data type, the I/O mechanism, the response to errors, etc. Example:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有需要，我们可以进一步将 `read()` 和 `print()` 模板化，针对数据类型、I/O机制、错误响应等进行。例如：
- en: '[PRE98]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Enforcement
  id: totrans-934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Consider functions with more than one “out” parameter suspicious. Use return
    values instead, including `tuple` for multiple return values.
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑具有多个“输出”参数的函数可疑。使用返回值代替，包括 `tuple` 用于多个返回值。
- en: Consider “large” functions that don’t fit on one editor screen suspicious. Consider
    factoring such a function into smaller well-named suboperations.
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑那些不适合一个编辑器屏幕的“大”函数可疑。考虑将这些函数分解成更小的、有良好命名的子操作。
- en: Consider functions with 7 or more parameters suspicious.
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑具有7个或更多参数的函数可疑。
- en: 'F.3: Keep functions short and simple'
  id: totrans-938
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.3：保持函数简短和简单
- en: Reason
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Large functions are hard to read, more likely to contain complex code, and more
    likely to have variables in larger than minimal scopes. Functions with complex
    control structures are more likely to be long and more likely to hide logical
    errors
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 大函数难以阅读，更可能包含复杂的代码，并且更有可能在比最小作用域更大的范围内有变量。具有复杂控制结构的函数更有可能很长，并且更有可能隐藏逻辑错误。
- en: Example
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE99]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is too complex. How would you know if all possible alternatives have been
    correctly handled? Yes, it breaks other rules also.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 这太复杂了。你如何知道是否正确处理了所有可能的替代方案？是的，这也打破了其他规则。
- en: 'We can refactor:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构：
- en: '[PRE100]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note
  id: totrans-947
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: “It doesn’t fit on a screen” is often a good practical definition of “far too
    large.” One-to-five-line functions should be considered normal.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: “它不适合屏幕”通常是“过于庞大”的一个很好的实际定义。一行到五行的函数应被视为正常。
- en: Note
  id: totrans-949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Break large functions up into smaller cohesive and named functions. Small simple
    functions are easily inlined where the cost of a function call is significant.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 将大型函数拆分成更小、更紧密且命名的函数。当函数调用的成本较高时，小型简单函数可以轻松地内联。
- en: Enforcement
  id: totrans-951
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag functions that do not “fit on a screen.” How big is a screen? Try 60 lines
    by 140 characters; that’s roughly the maximum that’s comfortable for a book page.
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记那些“不适合屏幕”的函数。屏幕有多大？尝试60行乘以140个字符；这大约是舒适的书页的最大容量。
- en: Flag functions that are too complex. How complex is too complex? You could use
    cyclomatic complexity. Try “more than 10 logical paths through.” Count a simple
    switch as one path.
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记过于复杂的函数。多复杂才算复杂？你可以使用循环复杂度。尝试“超过10个逻辑路径”。将简单的switch视为一条路径。
- en: 'F.4: If a function might have to be evaluated at compile time, declare it `constexpr`'
  id: totrans-954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.4：如果一个函数可能需要在编译时进行评估，则声明它为`constexpr`
- en: Reason
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`constexpr` is needed to tell the compiler to allow compile-time evaluation.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`需要告诉编译器允许编译时评估。'
- en: Example
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'The (in)famous factorial:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: （不）著名的阶乘：
- en: '[PRE101]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This is C++14. For C++11, use a recursive formulation of `fac()`.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C++14。对于C++11，使用`fac()`的递归公式。
- en: Note
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`constexpr` does not guarantee compile-time evaluation; it just guarantees
    that the function can be evaluated at compile time for constant expression arguments
    if the programmer requires it or the compiler decides to do so to optimize.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`并不保证编译时评估；它只是保证如果程序员要求或编译器决定这样做以优化，则函数可以在编译时对常量表达式参数进行评估。'
- en: '[PRE102]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note
  id: totrans-964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t try to make all functions `constexpr`. Most computation is best done at
    run time.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图使所有函数都成为`constexpr`。大多数计算最好在运行时完成。
- en: Note
  id: totrans-966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Any API that might eventually depend on high-level run-time configuration or
    business logic should not be made `constexpr`. Such customization can not be evaluated
    by the compiler, and any `constexpr` functions that depended upon that API would
    have to be refactored or drop `constexpr`.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可能最终依赖于高级运行时配置或业务逻辑的API都不应该被声明为`constexpr`。这种定制无法由编译器评估，并且依赖于该API的任何`constexpr`函数都需要重构或放弃`constexpr`。
- en: Enforcement
  id: totrans-968
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Impossible and unnecessary. The compiler gives an error if a non-`constexpr`
    function is called where a constant is required.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能且不必要的。如果需要在常量表达式中调用非`constexpr`函数，编译器会报错。
- en: 'F.5: If a function is very small and time-critical, declare it `inline`'
  id: totrans-970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.5：如果一个函数非常小且时间关键，则声明它为`inline`
- en: Reason
  id: totrans-971
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Some optimizers are good at inlining without hints from the programmer, but
    don’t rely on it. Measure! Over the last 40 years or so, we have been promised
    compilers that can inline better than humans without hints from humans. We are
    still waiting. Specifying inline (explicitly, or implicitly when writing member
    functions inside a class definition) encourages the compiler to do a better job.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 一些优化器在没有程序员提示的情况下也能很好地内联，但不要依赖它。要测量！在过去的40年左右，我们一直被承诺编译器可以在没有人类提示的情况下比人类更好地内联。我们仍在等待。指定内联（显式地，或在类定义内部编写成员函数时隐式地）鼓励编译器做得更好。
- en: Example
  id: totrans-973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE103]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Exception
  id: totrans-975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Do not put an `inline` function in what is meant to be a stable interface unless
    you are certain that it will not change. An inline function is part of the ABI.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你确定它不会改变，否则不要将内联函数放入预期为稳定的接口中。内联函数是ABI的一部分。
- en: Note
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`constexpr` implies `inline`.'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`意味着`inline`。'
- en: Note
  id: totrans-979
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Member functions defined in-class are `inline` by default.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中定义的成员函数默认为`inline`。
- en: Exception
  id: totrans-981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Function templates (including member functions of class templates `A<T>::function()`
    and member function templates `A::function<T>()`) are normally defined in headers
    and therefore inline.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板（包括类模板`A<T>::function()`的成员函数和成员函数模板`A::function<T>()`）通常在头文件中定义，因此是内联的。
- en: Note
  id: totrans-983
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Consider making functions out of line if they are more than three statements
    and can be declared out of line (such as class member functions).
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数超过三个语句并且可以声明为非内联（例如类成员函数），考虑将其声明为非内联。
- en: 'F.6: If your function must not throw, declare it `noexcept`'
  id: totrans-985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.6：如果你的函数不能抛出异常，则声明它为`noexcept`
- en: Reason
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If an exception is not supposed to be thrown, the program cannot be assumed
    to cope with the error and should be terminated as soon as possible. Declaring
    a function `noexcept` helps optimizers by reducing the number of alternative execution
    paths. It also speeds up the exit after failure.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不应该抛出异常，程序不能假设能够处理错误，而应该尽快终止。声明函数为`noexcept`有助于优化器通过减少替代执行路径的数量。它也加快了失败后的退出速度。
- en: Example
  id: totrans-988
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Put `noexcept` on every function written completely in C or in any other language
    without exceptions. The C++ Standard Library does that implicitly for all functions
    in the C Standard Library.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全用C语言或任何其他没有异常的语言编写的每个函数上使用`noexcept`。C++标准库对所有C标准库中的函数都隐式地做了这一点。
- en: Note
  id: totrans-990
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`constexpr` functions can throw when evaluated at run time, so you might need
    conditional `noexcept` for some of those.'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`函数在运行时评估时可能会抛出异常，因此你可能需要对其中的一些使用条件`noexcept`。'
- en: Example
  id: totrans-992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'You can use `noexcept` even on functions that can throw:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在可以抛出异常的函数上也可以使用`noexcept`：
- en: '[PRE104]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If `collect()` runs out of memory, the program crashes. Unless the program is
    crafted to survive memory exhaustion, that might be just the right thing to do;
    `terminate()` might generate suitable error log information (but after memory
    runs out it is hard to do anything clever).
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`collect()`运行时内存不足，程序会崩溃。除非程序被设计成能够生存内存耗尽，否则这可能是正确的事情；`terminate()`可能会生成合适的错误日志信息（但在内存耗尽后很难做任何聪明的事情）。
- en: Note
  id: totrans-996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You must be aware of the execution environment that your code is running when
    deciding whether to tag a function `noexcept`, especially because of the issue
    of throwing and allocation. Code that is intended to be perfectly general (like
    the standard library and other utility code of that sort) needs to support environments
    where a `bad_alloc` exception could be handled meaningfully. However, most programs
    and execution environments cannot meaningfully handle a failure to allocate, and
    aborting the program is the cleanest and simplest response to an allocation failure
    in those cases. If you know that your application code cannot respond to an allocation
    failure, it could be appropriate to add `noexcept` even on functions that allocate.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否标记函数为`noexcept`时，你必须意识到你的代码正在运行的执行环境，特别是由于抛出和分配的问题。旨在完全通用的代码（如标准库和其他类似类型的实用代码）需要支持可以有意义地处理`bad_alloc`异常的环境。然而，大多数程序和执行环境无法有意义地处理分配失败，在这些情况下，终止程序是对分配失败的最干净、最简单的响应。如果你知道你的应用程序代码无法响应分配失败，那么在分配函数上添加`noexcept`可能是合适的。
- en: 'Put another way: In most programs, most functions can throw (e.g., because
    they use `new`, call functions that do, or use library functions that report failure
    by throwing), so don’t just sprinkle `noexcept` all over the place without considering
    whether the possible exceptions can be handled.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是：在大多数程序中，大多数函数都可以抛出（例如，因为它们使用了`new`，调用了会抛出的函数，或者使用了通过抛出报告失败的库函数），所以不要不加考虑地在所有地方随意添加`noexcept`，而应该考虑可能的异常是否可以被处理。
- en: '`noexcept` is most useful (and most clearly correct) for frequently used, low-level
    functions.'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`对于常用、低级函数最有用（并且最明显正确）。'
- en: Note
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Destructors, `swap` functions, move operations, and default constructors should
    never throw. See also [C.44](#rc-default00).
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数、`swap`函数、移动操作和默认构造函数永远不应该抛出异常。参见[C.44](#rc-default00)。
- en: Note
  id: totrans-1002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Care must be taken on base virtual functions and functions part of a public
    interface because declaring a function `noexcept` is establishing a guarantee
    that all current and future implementations must abide by. For virtual function,
    all overriders must also be `noexcept` and removing `noexcept` from a function
    could break calling functions.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基类虚函数和公共接口中的函数，必须小心处理，因为声明函数为`noexcept`是在建立一个保证，即所有当前和未来的实现都必须遵守。对于虚函数，所有重写者也必须是`noexcept`，从函数中移除`noexcept`可能会破坏调用函数。
- en: Enforcement
  id: totrans-1004
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (hard) Flag low-level functions that are not `noexcept`, yet cannot throw.
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （困难）标记那些不是`noexcept`但也不能抛出异常的低级函数。
- en: Flag throwing `swap`, `move`, destructors, and default constructors.
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记抛出`swap`、`move`、析构函数和默认构造函数。
- en: 'F.7: For general use, take `T*` or `T&` arguments rather than smart pointers'
  id: totrans-1007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.7：对于通用用途，使用`T*`或`T&`作为参数，而不是智能指针
- en: Reason
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Passing a smart pointer transfers or shares ownership and should only be used
    when ownership semantics are intended. A function that does not manipulate lifetime
    should take raw pointers or references instead.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能指针传递转移或共享所有权，并且仅在打算使用所有权语义时使用。不操作生命周期的函数应使用原始指针或引用。
- en: Passing by smart pointer restricts the use of a function to callers that use
    smart pointers. A function that needs a `widget` should be able to accept any
    `widget` object, not just ones whose lifetimes are managed by a particular kind
    of smart pointer.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 通过智能指针传递限制了函数的使用范围，只能由使用智能指针的调用者使用。需要`widget`的函数应该能够接受任何`widget`对象，而不仅仅是那些由特定类型的智能指针管理的生命周期。
- en: Passing a shared smart pointer (e.g., `std::shared_ptr`) implies a run-time
    cost.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 传递共享智能指针（例如，`std::shared_ptr`）意味着存在运行时成本。
- en: Example
  id: totrans-1012
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE105]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Example, bad
  id: totrans-1014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE106]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Example, good
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE107]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note
  id: totrans-1018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We can catch many common cases of dangling pointers statically (see [lifetime
    safety profile](#ss-lifetime)). Function arguments naturally live for the lifetime
    of the function call, and so have fewer lifetime problems.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以静态地捕获许多悬挂指针的常见情况（参见[生命周期安全性配置文件](#ss-lifetime)）。函数参数自然地存在于函数调用期间的生命周期中，因此生命周期问题较少。
- en: Enforcement
  id: totrans-1020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: '(Simple) Warn if a function takes a parameter of a smart pointer type (that
    overloads `operator->` or `operator*`) that is copyable but the function only
    calls any of: `operator*`, `operator->` or `get()`. Suggest using a `T*` or `T&`
    instead.'
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果函数接受一个可复制的智能指针类型（重载`operator->`或`operator*`）的参数，但该函数只调用任何：`operator*`、`operator->`或`get()`，则发出警告。建议使用`T*`或`T&`。
- en: Flag a parameter of a smart pointer type (a type that overloads `operator->`
    or `operator*`) that is copyable/movable but never copied/moved from in the function
    body, and that is never modified, and that is not passed along to another function
    that could do so. That means the ownership semantics are not used. Suggest using
    a `T*` or `T&` instead.
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个可复制/可移动的智能指针类型（重载`operator->`或`operator*`的类型）的参数，该参数在函数体中从未被复制/移动过，也从未被修改，并且未传递给另一个可能执行此操作的函数。这意味着没有使用所有权语义。建议使用`T*`或`T&`。
- en: '**See also**:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：'
- en: '[Prefer `T*` over `T&` when “no argument” is a valid option](#rf-ptr-ref)'
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[当“无参数”是有效选项时，优先使用`T*`而不是`T&`](#rf-ptr-ref)'
- en: '[Smart pointer rule summary](#rr-summary-smartptrs)'
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[智能指针规则摘要](#rr-summary-smartptrs)'
- en: 'F.8: Prefer pure functions'
  id: totrans-1026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.8：优先使用纯函数
- en: Reason
  id: totrans-1027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Pure functions are easier to reason about, sometimes easier to optimize (and
    even parallelize), and sometimes can be memoized.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数更容易推理，有时更容易优化（甚至并行化），有时可以缓存。
- en: Example
  id: totrans-1029
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE108]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Enforcement
  id: totrans-1031
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Not possible.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能。
- en: 'F.9: Unused parameters should be unnamed'
  id: totrans-1033
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.9：未使用的参数应未命名
- en: Reason
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Suppression of unused parameter warnings.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。抑制未使用参数警告。
- en: Example
  id: totrans-1036
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE109]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Note
  id: totrans-1038
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Allowing parameters to be unnamed was introduced in the early 1980s to address
    this problem.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 允许参数未命名是在20世纪80年代初引入的，以解决此问题。
- en: 'If parameters are conditionally unused, declare them with the `[[maybe_unused]]`
    attribute. For example:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数在条件性未使用的情况下，请使用`[[maybe_unused]]`属性进行声明。例如：
- en: '[PRE110]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Enforcement
  id: totrans-1042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag named unused parameters.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 标记未使用的参数。
- en: 'F.10: If an operation can be reused, give it a name'
  id: totrans-1044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.10：如果操作可以重用，请给它命名
- en: Reason
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Documentation, readability, opportunity for reuse.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 文档，可读性，重用机会。
- en: Example
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE111]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: There is a useful function lurking here (case insensitive string comparison),
    as there often is when lambda arguments get large.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的函数（不区分大小写的字符串比较），就像Lambda参数变得很大时经常发生的那样。
- en: '[PRE112]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Or maybe (if you prefer to avoid the implicit name binding to n):'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 或者（如果你更喜欢避免隐式名称绑定到n）：
- en: '[PRE113]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Note
  id: totrans-1053
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: whether functions, lambdas, or operators.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是函数、Lambda还是运算符。
- en: Exception
  id: totrans-1055
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Lambdas logically used only locally, such as an argument to `for_each` and similar
    control flow algorithms.
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在局部逻辑上使用的Lambda，例如`for_each`和类似的控制流算法的参数。
- en: Lambdas as [initializers](#???)
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda作为[初始化器](#???)
- en: Enforcement
  id: totrans-1058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (hard) flag similar lambdas
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （困难）标记类似的Lambda
- en: ???
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'F.11: Use an unnamed lambda if you need a simple function object in one place
    only'
  id: totrans-1061
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.11：如果只需要一个简单的函数对象，请使用未命名的Lambda
- en: Reason
  id: totrans-1062
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That makes the code concise and gives better locality than alternatives.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更加简洁，并且比替代方案提供了更好的局部性。
- en: Example
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE114]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Exception
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Naming a lambda can be useful for clarity even if it is used only once.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Lambda只使用一次，命名Lambda也可以提高清晰度。
- en: Enforcement
  id: totrans-1068
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Look for identical and near identical lambdas (to be replaced with named functions
    or named lambdas).
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找相同或几乎相同的lambda（将被替换为命名函数或命名lambda）。
- en: 'F.call: Parameter passing'
  id: totrans-1070
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'F.call: 参数传递'
- en: There are a variety of ways to pass parameters to a function and to return values.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以将参数传递给函数并返回值。
- en: 'F.15: Prefer simple and conventional ways of passing information'
  id: totrans-1072
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'F.15: 倾向于使用简单和传统的信息传递方式'
- en: Reason
  id: totrans-1073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using “unusual and clever” techniques causes surprises, slows understanding
    by other programmers, and encourages bugs. If you really feel the need for an
    optimization beyond the common techniques, measure to ensure that it really is
    an improvement, and document/comment because the improvement might not be portable.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“不寻常且巧妙”的技术会导致意外，减慢其他程序员的理解速度，并鼓励错误。如果您真的觉得需要超越常见技术的优化，请测量以确保它确实是一个改进，并记录/注释，因为改进可能不可移植。
- en: The following tables summarize the advice in the following Guidelines, F.16-21.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了以下指南中的建议，F.16-21。
- en: 'Normal parameter passing:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 正常参数传递：
- en: '![Normal parameter passing table](img/3da0440d953b29de9a982d019489c414.png
    "Normal parameter passing")'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
  zh: '![正常参数传递表](img/3da0440d953b29de9a982d019489c414.png "正常参数传递")'
- en: 'Advanced parameter passing:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 高级参数传递：
- en: '![Advanced parameter passing table](img/557ced2b30827f817e7baf2767426d75.png
    "Advanced parameter passing")'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![高级参数传递表](img/557ced2b30827f817e7baf2767426d75.png "高级参数传递")'
- en: Use the advanced techniques only after demonstrating need, and document that
    need in a comment.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在证明需要后使用高级技术，并在注释中记录该需求。
- en: For passing sequences of characters see [String](#ss-string).
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传递字符序列，请参阅[String](#ss-string)。
- en: Exception
  id: totrans-1082
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: To express shared ownership using `shared_ptr` types, rather than following
    guidelines F.16-21, follow [R.34](#rr-sharedptrparam-owner), [R.35](#rr-sharedptrparam),
    and [R.36](#rr-sharedptrparam-const).
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`shared_ptr`类型表达共享所有权，而不是遵循F.16-21指南，请遵循[R.34](#rr-sharedptrparam-owner)、[R.35](#rr-sharedptrparam)和[R.36](#rr-sharedptrparam-const)。
- en: 'F.16: For “in” parameters, pass cheaply-copied types by value and others by
    reference to `const`'
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'F.16: 对于“in”参数，通过值传递便宜复制的类型，通过引用传递到`const`'
- en: Reason
  id: totrans-1085
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Both let the caller know that a function will not modify the argument, and both
    allow initialization by rvalues.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都让调用者知道函数不会修改参数，并且两者都允许通过右值进行初始化。
- en: What is “cheap to copy” depends on the machine architecture, but two or three
    words (doubles, pointers, references) are usually best passed by value. When copying
    is cheap, nothing beats the simplicity and safety of copying, and for small objects
    (up to two or three words) it is also faster than passing by reference because
    it does not require an extra indirection to access from the function.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: “便宜复制”取决于机器架构，但通常最好通过值传递两到三个单词（双精度浮点数、指针、引用）。当复制便宜时，没有什么能比复制的简单性和安全性更好，对于小型对象（多达两到三个单词）来说，它也比通过引用传递更快，因为它不需要额外的间接访问来从函数中访问。
- en: Example
  id: totrans-1088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE115]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'For advanced uses (only), where you really need to optimize for rvalues passed
    to “input-only” parameters:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅用于高级用途的情况，您确实需要优化传递给“仅输入”参数的右值：
- en: If the function is going to unconditionally move from the argument, take it
    by `&&`. See [F.18](#rf-consume).
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数将要无条件地从参数移动，则通过`&&`获取。参见[F.18](#rf-consume)。
- en: If the function is going to keep a locally modifiable copy of the argument only
    for its own local use, taking it by value is fine.
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数只为自己的局部使用而保留参数的局部可修改副本，则通过值获取是合适的。
- en: If the function is going to keep a copy of the argument to pass to another destination
    (to another function, or store in a non-local location), in addition to passing
    by `const&` (for lvalues), add an overload that passes the parameter by `&&` (for
    rvalues) and in the body `std::move`s it to its destination. Essentially this
    overloads a “will-move-from”; see [F.18](#rf-consume).
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数将要保留对参数的副本以传递到另一个目的地（传递到另一个函数或存储在非局部位置），除了通过`const&`（对于左值）传递外，还应添加一个通过`&&`（对于右值）传递的过载，并在函数体中使用`std::move`将其移动到目的地。本质上这是对“将要移动”的过载；参见[F.18](#rf-consume)。
- en: In special cases, such as multiple “input + copy” parameters, consider using
    perfect forwarding. See [F.19](#rf-forward).
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特殊情况下，例如多个“输入+复制”参数，考虑使用完美前向。参见[F.19](#rf-forward)。
- en: Example
  id: totrans-1095
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE116]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Avoid “esoteric techniques” such as passing arguments as `T&&` “for efficiency”.
    Most rumors about performance advantages from passing by `&&` are false or brittle
    (but see [F.18](#rf-consume) and [F.19](#rf-forward)).
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用“晦涩的技术”如将参数作为 `T&&` “为了效率”传递。关于通过 `&&` 传递性能优势的大多数传言都是错误的或脆弱的（但参见 [F.18](#rf-consume)
    和 [F.19](#rf-forward)）。
- en: Notes
  id: totrans-1098
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: A reference can be assumed to refer to a valid object (language rule). There
    is no (legitimate) “null reference.” If you need the notion of an optional value,
    use a pointer, `std::optional`, or a special value used to denote “no value.”
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 可以假设引用指向一个有效的对象（语言规则）。不存在（合法的）“空引用”。如果你需要可选值的观念，请使用指针、`std::optional` 或用于表示“无值”的特殊值。
- en: Enforcement
  id: totrans-1100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) ((Foundation)) Warn when a parameter being passed by value has a size
    greater than `2 * sizeof(void*)`. Suggest using a reference to `const` instead.
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 当通过值传递的参数的大小大于 `2 * sizeof(void*)` 时发出警告。建议使用 `const` 引用。
- en: (Simple) ((Foundation)) Warn when a parameter passed by reference to `const`
    has a size less or equal than `2 * sizeof(void*)`. Suggest passing by value instead.
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 当将引用传递给 `const` 的参数的大小小于或等于 `2 * sizeof(void*)` 时发出警告。建议使用值传递。
- en: (Simple) ((Foundation)) Warn when a parameter passed by reference to `const`
    is `move`d.
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 当将引用传递给 `const` 的参数移动时发出警告。
- en: Exception
  id: totrans-1104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: To express shared ownership using `shared_ptr` types, follow [R.34](#rr-sharedptrparam-owner)
    or [R.36](#rr-sharedptrparam-const), depending on whether or not the function
    unconditionally takes a reference to the argument.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `shared_ptr` 类型表达共享所有权，根据函数是否无条件接受参数的引用，遵循 [R.34](#rr-sharedptrparam-owner)
    或 [R.36](#rr-sharedptrparam-const)。
- en: 'F.17: For “in-out” parameters, pass by reference to non-`const`'
  id: totrans-1106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.17：对于“输入输出”参数，通过非 `const` 引用传递
- en: Reason
  id: totrans-1107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This makes it clear to callers that the object is assumed to be modified.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得调用者清楚地知道对象假定会被修改。
- en: Example
  id: totrans-1109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE117]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Note
  id: totrans-1111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'Some user-defined and standard library types, such as `span<T>` or the iterators
    are [cheap to copy](#rf-in) and may be passed by value, while doing so has mutable
    (in-out) reference semantics:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户定义的标准库类型，如 `span<T>` 或迭代器，[复制成本低](#rf-in) 并且可以通过值传递，而这样做具有可变（输入输出）引用语义：
- en: '[PRE118]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'A `T&` argument can pass information into a function as well as out of it.
    Thus `T&` could be an in-out-parameter. That can in itself be a problem and a
    source of errors:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `T&` 参数可以既将信息传递给函数，也可以从函数中传出。因此 `T&` 可以是一个输入输出参数。这本身可能就是一个问题，也是错误的一个来源：
- en: '[PRE119]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Here, the writer of `g()` is supplying a buffer for `f()` to fill, but `f()`
    simply replaces it (at a somewhat higher cost than a simple copy of the characters).
    A bad logic error can happen if the writer of `g()` incorrectly assumes the size
    of the `buffer`.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`g()` 的编写者提供了一个缓冲区供 `f()` 填充，但 `f()` 简单地替换了它（比简单复制字符的成本要高一些）。如果 `g()` 的编写者错误地假设了
    `buffer` 的大小，可能会发生逻辑错误。
- en: Enforcement
  id: totrans-1118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Moderate) ((Foundation)) Warn about functions regarding reference to non-`const`
    parameters that do *not* write to them.
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （中等）((基础)) 警告关于不写入它们的非 `const` 参数引用的函数。
- en: (Simple) ((Foundation)) Warn when a non-`const` parameter being passed by reference
    is `move`d.
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 当通过引用传递的非 `const` 参数被移动时发出警告。
- en: 'F.18: For “will-move-from” parameters, pass by `X&&` and `std::move` the parameter'
  id: totrans-1121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.18：对于“将要移动”的参数，通过 `X&&` 传递参数并使用 `std::move`。
- en: Reason
  id: totrans-1122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'It’s efficient and eliminates bugs at the call site: `X&&` binds to rvalues,
    which requires an explicit `std::move` at the call site if passing an lvalue.'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 这既高效又消除了调用点的错误：`X&&` 绑定到右值，如果传递左值，则需要在调用点显式使用 `std::move`。
- en: Example
  id: totrans-1124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE120]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note that the `std::move(v)` makes it possible for `store_somewhere()` to leave
    `v` in a moved-from state. [That could be dangerous](#rc-move-semantic).
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::move(v)` 使得 `store_somewhere()` 能够将 `v` 留在移动后的状态。[这可能是危险的](#rc-move-semantic)。
- en: Exception
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Unique owner types that are move-only and cheap-to-move, such as `unique_ptr`,
    can also be passed by value which is simpler to write and achieves the same effect.
    Passing by value does generate one extra (cheap) move operation, but prefer simplicity
    and clarity first.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一所有者类型，如 `unique_ptr`，是移动只读且移动成本低，也可以通过值传递，这更简单易写，并达到相同的效果。通过值传递确实会生成一个额外的（低成本）移动操作，但首先考虑简洁和清晰。
- en: 'For example:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE121]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Exception
  id: totrans-1131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: If the “will-move-from” parameter is a `shared_ptr` follow [R.34](#rr-sharedptrparam-owner)
    and pass the `shared_ptr` by value.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“将要移动”的参数是 `shared_ptr`，则遵循 [R.34](#rr-sharedptrparam-owner) 并通过值传递 `shared_ptr`。
- en: Enforcement
  id: totrans-1133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all `X&&` parameters (where `X` is not a template type parameter name)
    where the function body uses them without `std::move`.
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有`X&&`参数（其中`X`不是模板类型参数名称），在函数体中使用它们而不使用`std::move`。
- en: Flag access to moved-from objects.
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记对已移动对象的访问。
- en: Don’t conditionally move from objects
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要有条件地从对象移动
- en: 'F.19: For “forward” parameters, pass by `TP&&` and only `std::forward` the
    parameter'
  id: totrans-1137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.19：对于“转发”参数，通过`TP&&`传递，并且只使用`std::forward`传递参数
- en: Reason
  id: totrans-1138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If the object is to be passed onward to other code and not directly used by
    this function, we want to make this function agnostic to the argument `const`-ness
    and rvalue-ness.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是让这个函数将对象传递给其他代码而不是直接使用，我们希望这个函数对参数的`const`属性和右值属性不敏感。
- en: In that case, and only that case, make the parameter `TP&&` where `TP` is a
    template type parameter – it both *ignores* and *preserves* `const`-ness and rvalue-ness.
    Therefore any code that uses a `TP&&` is implicitly declaring that it itself doesn’t
    care about the variable’s `const`-ness and rvalue-ness (because it is ignored),
    but that intends to pass the value onward to other code that does care about `const`-ness
    and rvalue-ness (because it is preserved). When used as a parameter `TP&&` is
    safe because any temporary objects passed from the caller will live for the duration
    of the function call. A parameter of type `TP&&` should essentially always be
    passed onward via `std::forward` in the body of the function.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，并且只有那种情况下，将参数设为`TP&&`，其中`TP`是一个模板类型参数 – 它既*忽略*也*保留* `const`属性和右值属性。因此，任何使用`TP&&`的代码都隐式地声明它自己不关心变量的`const`属性和右值属性（因为它被忽略了），但意图将值传递给其他代码，这些代码关心`const`属性和右值属性（因为它被保留了）。当用作参数`TP&&`时是安全的，因为任何从调用者传递的临时对象将存在于函数调用的整个过程中。在函数体中，类型为`TP&&`的参数应该基本上总是通过`std::forward`传递。
- en: Example
  id: totrans-1141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Usually you forward the entire parameter (or parameter pack, using `...`) exactly
    once on every static control flow path:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会在每个静态控制流路径上恰好一次转发整个参数（或参数包，使用`...`）：
- en: '[PRE122]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Example
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Sometimes you may forward a composite parameter piecewise, each subobject once
    on every static control flow path:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要分部分地转发复合参数，每个子对象在每个静态控制流路径上一次：
- en: '[PRE123]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Enforcement
  id: totrans-1147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag a function that takes a `TP&&` parameter (where `TP` is a template type
    parameter name) and does anything with it other than `std::forward`ing it exactly
    once on every static path, or `std::forward`ing it more than once but qualified
    with a different data member exactly once on every static path.
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个接受`TP&&`参数（其中`TP`是模板类型参数名称）的函数，并且除了在每条静态路径上恰好一次使用`std::forward`之外，对它做任何其他操作，或者在每个静态路径上多次使用`std::forward`，但恰好一次使用不同的数据成员进行限定。
- en: 'F.20: For “out” output values, prefer return values to output parameters'
  id: totrans-1149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.20：对于“输出”输出值，优先使用返回值而不是输出参数
- en: Reason
  id: totrans-1150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A return value is self-documenting, whereas an `&` could be either in-out or
    out-only and is liable to be misused.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是自我说明的，而`&`可以是输入输出或仅输出，并且容易误用。
- en: This includes large objects like standard containers that use implicit move
    operations for performance and to avoid explicit memory management.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括像标准容器这样的大型对象，它们使用隐式移动操作以提高性能并避免显式内存管理。
- en: If you have multiple values to return, [use a tuple](#rf-out-multi) or similar
    multi-member type.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多值要返回，[使用元组](#rf-out-multi)或类似的多成员类型。
- en: Example
  id: totrans-1154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE124]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Note
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A `struct` of many (individually cheap-to-move) elements might be in aggregate
    expensive to move.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含许多（单独移动成本低）元素的`struct`可能整体移动成本很高。
- en: Exceptions
  id: totrans-1158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: For non-concrete types, such as types in an inheritance hierarchy, return the
    object by `unique_ptr` or `shared_ptr`.
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非具体类型，例如继承层次结构中的类型，通过`unique_ptr`或`shared_ptr`返回对象。
- en: If a type is expensive to move (e.g., `array<BigTrivial>`), consider allocating
    it on the free store and return a handle (e.g., `unique_ptr`), or passing it in
    a reference to non-`const` target object to fill (to be used as an out-parameter).
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型移动成本很高（例如，`array<BigTrivial>`），考虑在自由存储上分配它并返回一个句柄（例如，`unique_ptr`），或者通过非`const`目标对象的引用传递它以填充（用作输出参数）。
- en: 'To reuse an object that carries capacity (e.g., `std::string`, `std::vector`)
    across multiple calls to the function in an inner loop: [treat it as an in/out
    parameter and pass by reference](#rf-out-multi).'
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在内部循环的多次函数调用中重用携带容量的对象（例如，`std::string`，`std::vector`）：[将其作为输入/输出参数并通过引用传递](#rf-out-multi)。
- en: Example
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Assuming that `Matrix` has move operations (possibly by keeping its elements
    in a `std::vector`):'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Matrix`有移动操作（可能通过将其元素保存在`std::vector`中）：
- en: '[PRE125]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Note
  id: totrans-1165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The return value optimization doesn’t handle the assignment case, but the move
    assignment does.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值优化不处理赋值情况，但移动赋值可以。
- en: Example
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE126]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Enforcement
  id: totrans-1169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag reference to non-`const` parameters that are not read before being written
    to and are a type that could be cheaply returned; they should be “out” return
    values.
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记在写入之前未读取的非 `const` 参数的引用，并且是可能以低成本返回的类型；它们应该是“输出”返回值。
- en: 'F.21: To return multiple “out” values, prefer returning a struct'
  id: totrans-1171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.21：为了返回多个“输出”值，首选返回一个结构体
- en: Reason
  id: totrans-1172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A return value is self-documenting as an “output-only” value. Note that C++
    does have multiple return values, by convention of using tuple-like types (`struct`,
    `array`, `tuple`, etc.), possibly with the extra convenience of structured bindings
    (C++17) at the call site. Prefer using a named `struct` if possible. Otherwise,
    a `tuple` is useful in variadic templates.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值作为一个“仅输出”值是自我文档化的。请注意，C++确实有多个返回值，这是通过使用类似元组的类型（`struct`、`array`、`tuple`
    等）的惯例实现的，可能在调用站点提供了额外的便利（C++17）。如果可能，首选使用命名的 `struct`。否则，`tuple` 在变长模板中很有用。
- en: Example
  id: totrans-1174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE127]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'C++98’s standard library used this style in places, by returning `pair` in
    some functions. For example, given a `set<string> my_set`, consider:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: C++98 的标准库在某些地方使用了这种风格，通过在某些函数中返回 `pair`。例如，给定一个 `set<string> my_set`，考虑：
- en: '[PRE128]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'With C++17 we are able to use “structured bindings” to give each member a name:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++17 的推出，我们能够使用“结构化绑定”为每个成员命名：
- en: '[PRE129]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: A `struct` with meaningful names is more common in modern C++. See for example
    `ranges::min_max_result`, `from_chars_result`, and others.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 C++ 中，使用具有意义名称的 `struct` 更为常见。例如 `ranges::min_max_result`、`from_chars_result`
    以及其他。
- en: Exception
  id: totrans-1181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'Sometimes, we need to pass an object to a function to manipulate its state.
    In such cases, passing the object by reference [`T&`](#rf-inout) is usually the
    right technique. Explicitly passing an in-out parameter back out again as a return
    value is often not necessary. For example:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要将一个对象传递给函数以操作其状态。在这种情况下，通过引用 `T&` 传递对象通常是正确的技术。将输入输出参数显式地作为返回值传递通常是不必要的。例如：
- en: '[PRE130]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Here, both `s` and `in` are used as in-out parameters. We pass `in` by (non-`const`)
    reference to be able to manipulate its state. We pass `s` to avoid repeated allocations.
    By reusing `s` (passed by reference), we allocate new memory only when we need
    to expand `s`’s capacity. This technique is sometimes called the “caller-allocated
    out” pattern and is particularly useful for types, such as `string` and `vector`,
    that need to do free store allocations.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s` 和 `in` 都被用作输入输出参数。我们通过（非 `const`）引用传递 `in` 以便能够操作其状态。我们传递 `s` 以避免重复分配。通过重用
    `s`（通过引用传递），我们仅在需要扩展 `s` 的容量时分配新内存。这种技术有时被称为“调用者分配输出”模式，对于需要做内存分配的类型，如 `string`
    和 `vector`，特别有用。
- en: 'To compare, if we passed out all values as return values, we would write something
    like this:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果我们传递所有值作为返回值，我们会写出类似这样的代码：
- en: '[PRE131]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We consider that significantly less elegant with significantly less performance.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这比显著更优雅，性能也显著更低。
- en: For a truly strict reading of this rule (F.21), the exception isn’t really an
    exception because it relies on in-out parameters, rather than the plain out parameters
    mentioned in the rule. However, we prefer to be explicit, rather than subtle.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这条规则（F.21）的真正严格解读，异常实际上并不是异常，因为它依赖于输入输出参数，而不是规则中提到的普通输出参数。然而，我们更喜欢明确，而不是微妙。
- en: Note
  id: totrans-1189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In most cases, it is useful to return a specific, user-defined type. For example:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，返回一个特定的、用户定义的类型是有用的。例如：
- en: '[PRE132]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The overly generic `pair` and `tuple` should be used only when the value returned
    represents independent entities rather than an abstraction.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 过于通用的 `pair` 和 `tuple` 应仅在使用返回值代表独立实体而非抽象时使用。
- en: Another option is to use `optional<T>` or `expected<T, error_code>`, rather
    than `pair` or `tuple`. When used appropriately these types convey more information
    about what the members mean than `pair<T, bool>` or `pair<T, error_code>` do.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 `optional<T>` 或 `expected<T, error_code>`，而不是 `pair` 或 `tuple`。当适当使用这些类型时，它们比
    `pair<T, bool>` 或 `pair<T, error_code>` 传达了更多关于成员含义的信息。
- en: Note
  id: totrans-1194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'When the object to be returned is initialized from local variables that are
    expensive to copy, explicit `move` may be helpful to avoid copying:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 当要返回的对象是从昂贵的局部变量初始化时，显式 `move` 可能有助于避免复制：
- en: '[PRE133]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Alternatively,
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，
- en: '[PRE134]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Note this is different from the `return move(...)` anti-pattern from [ES.56](#res-move).
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这与 [ES.56](#res-move) 中的 `return move(...)` 反模式不同。
- en: Enforcement
  id: totrans-1200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Output parameters should be replaced by return values. An output parameter is
    one that the function writes to, invokes a non-`const` member function, or passes
    on as a non-`const`.
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出参数应替换为返回值。输出参数是指函数写入的参数，调用非 `const` 成员函数，或作为非 `const` 传递的参数。
- en: '`pair` or `tuple` return types should be replaced by `struct`, if possible.
    In variadic templates, `tuple` is often unavoidable.'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pair` 或 `tuple` 返回类型应尽可能替换为 `struct`。在变长模板中，`tuple` 往往是不可避免的。'
- en: 'F.60: Prefer `T*` over `T&` when “no argument” is a valid option'
  id: totrans-1203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.60：当“无参数”是一个有效选项时，优先使用 `T*` 而不是 `T&`
- en: Reason
  id: totrans-1204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A pointer (`T*`) can be a `nullptr` and a reference (`T&`) cannot, there is
    no valid “null reference”. Sometimes having `nullptr` as an alternative to indicated
    “no object” is useful, but if it is not, a reference is notationally simpler and
    might yield better code.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指针 (`T*`) 可以是 `nullptr`，而一个引用 (`T&`) 不能，没有有效的“空引用”。有时将 `nullptr` 作为表示“无对象”的替代品是有用的，但如果没有，引用在记法上更简单，可能产生更好的代码。
- en: Example
  id: totrans-1206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE135]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note
  id: totrans-1208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible, but not valid C++ to construct a reference that is essentially
    a `nullptr` (e.g., `T* p = nullptr; T& r = *p;`). That error is very uncommon.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能，但不是有效的 C++ 构造一个本质上为 `nullptr` 的引用（例如，`T* p = nullptr; T& r = *p;`）。这种错误非常罕见。
- en: Note
  id: totrans-1210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you prefer the pointer notation (`->` and/or `*` vs. `.`), `not_null<T*>`
    provides the same guarantee as `T&`.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢指针表示法（`->` 和/或 `*` 与 `.`），`not_null<T*>` 提供与 `T&` 相同的保证。
- en: Enforcement
  id: totrans-1212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag ???
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志 ???
- en: 'F.22: Use `T*` or `owner<T*>` to designate a single object'
  id: totrans-1214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.22：使用 `T*` 或 `owner<T*>` 来指定单个对象
- en: Reason
  id: totrans-1215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Readability: it makes the meaning of a plain pointer clear. Enables significant
    tool support.'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性：它使普通指针的含义清晰。启用重要的工具支持。
- en: Note
  id: totrans-1217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In traditional C and C++ code, plain `T*` is used for many weakly-related purposes,
    such as:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 C 和 C++ 代码中，`T*` 被用于许多弱相关的目的，例如：
- en: Identify a (single) object (not to be deleted by this function)
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别一个（单个）对象（此函数不会删除）
- en: Point to an object allocated on the free store (and delete it later)
  id: totrans-1220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向在自由存储上分配的对象（稍后删除）
- en: Hold the `nullptr`
  id: totrans-1221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持 `nullptr`
- en: Identify a C-style string (zero-terminated array of characters)
  id: totrans-1222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别一个 C 风格的字符串（以 null 结尾的字符数组）
- en: Identify an array with a length specified separately
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别一个具有单独指定长度的数组
- en: Identify a location in an array
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别数组中的一个位置
- en: This makes it hard to understand what the code does and is supposed to do. It
    complicates checking and tool support.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得理解代码的功能和预期功能变得困难，并增加了检查和工具支持复杂性。
- en: Example
  id: totrans-1226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE136]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: better
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 更好
- en: '[PRE137]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Note
  id: totrans-1230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`owner<T*>` represents ownership, `zstring` represents a C-style string.'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner<T*>` 表示所有权，`zstring` 表示 C 风格的字符串。'
- en: '**Also**: Assume that a `T*` obtained from a smart pointer to `T` (e.g., `unique_ptr<T>`)
    points to a single element.'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '**此外**：假设从 `T` 的智能指针（例如，`unique_ptr<T>`）获得的 `T*` 指向单个元素。'
- en: '**See also**: [Support library](#gsl-guidelines-support-library)'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[支持库](#gsl-guidelines-support-library)'
- en: '**See also**: [Do not pass an array as a single pointer](#ri-array)'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[不要将数组作为单个指针传递](#ri-array)'
- en: Enforcement
  id: totrans-1235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) ((Bounds)) Warn for any arithmetic operation on an expression of pointer
    type that results in a value of pointer type.
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）（（界限））警告任何在指针类型表达式上进行的算术运算，如果结果为指针类型值。
- en: 'F.23: Use a `not_null<T>` to indicate that “null” is not a valid value'
  id: totrans-1237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.23：使用 `not_null<T>` 来指示“null”不是一个有效值
- en: Reason
  id: totrans-1238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Clarity. A function with a `not_null<T>` parameter makes it clear that the caller
    of the function is responsible for any `nullptr` checks that might be necessary.
    Similarly, a function with a return value of `not_null<T>` makes it clear that
    the caller of the function does not need to check for `nullptr`.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰性。具有 `not_null<T>` 参数的函数使调用者清楚，调用者需要执行可能必要的任何 `nullptr` 检查。同样，具有 `not_null<T>`
    返回值的函数使调用者清楚，调用者不需要检查 `nullptr`。
- en: Example
  id: totrans-1240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '`not_null<T*>` makes it obvious to a reader (human or machine) that a test
    for `nullptr` is not necessary before dereference. Additionally, when debugging,
    `owner<T*>` and `not_null<T>` can be instrumented to check for correctness.'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '`not_null<T*>` 使读者（无论是人类还是机器）明显看出，在解引用之前不需要进行 `nullptr` 测试。此外，在调试时，`owner<T*>`
    和 `not_null<T>` 可以被配置为检查正确性。'
- en: 'Consider:'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE138]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: When I call `length(p)` should I check if `p` is `nullptr` first? Should the
    implementation of `length()` check if `p` is `nullptr`?
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我调用 `length(p)` 时，我应该首先检查 `p` 是否为 `nullptr` 吗？`length()` 的实现应该检查 `p` 是否为 `nullptr`
    吗？
- en: '[PRE139]'
  id: totrans-1245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Note
  id: totrans-1246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A `not_null<T*>` is assumed not to be the `nullptr`; a `T*` might be the `nullptr`;
    both can be represented in memory as a `T*` (so no run-time overhead is implied).
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '`not_null<T*>` 假设不是 `nullptr`；`T*` 可能是 `nullptr`；两者都可以在内存中以 `T*` 的形式表示（因此没有运行时开销）。'
- en: Note
  id: totrans-1248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: '`not_null` is not just for built-in pointers. It works for `unique_ptr`, `shared_ptr`,
    and other pointer-like types.'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '`not_null` 不仅适用于内置指针。它适用于 `unique_ptr`、`shared_ptr` 和其他类似指针的类型。'
- en: Enforcement
  id: totrans-1250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a raw pointer is dereferenced without being tested against
    `nullptr` (or equivalent) within a function, suggest it is declared `not_null`
    instead.
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果在函数中未将原始指针与 `nullptr`（或等效）进行比较就解引用，则发出警告，建议将其声明为 `not_null`。
- en: (Simple) Error if a raw pointer is sometimes dereferenced after first being
    tested against `nullptr` (or equivalent) within the function and sometimes is
    not.
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果在函数中首先将原始指针与 `nullptr`（或等效）进行比较，然后有时会解引用，有时不会，则发生错误。
- en: (Simple) Warn if a `not_null` pointer is tested against `nullptr` within a function.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果在函数中将 `not_null` 指针与 `nullptr` 进行比较，则发出警告。
- en: 'F.24: Use a `span<T>` or a `span_p<T>` to designate a half-open sequence'
  id: totrans-1254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.24：使用 `span<T>` 或 `span_p<T>` 来指定半开序列
- en: Reason
  id: totrans-1255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Informal/non-explicit ranges are a source of errors.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式/非显式范围是错误的一个来源。
- en: Example
  id: totrans-1257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE140]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Note
  id: totrans-1259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Ranges are extremely common in C++ code. Typically, they are implicit and their
    correct use is very hard to ensure. In particular, given a pair of arguments `(p,
    n)` designating an array `[p:p+n)`, it is in general impossible to know if there
    really are `n` elements to access following `*p`. `span<T>` and `span_p<T>` are
    simple helper classes designating a `[p:q)` range and a range starting with `p`
    and ending with the first element for which a predicate is true, respectively.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 范围在 C++ 代码中非常常见。通常，它们是隐式的，并且正确使用它们非常难以保证。特别是，给定一对参数 `(p, n)`，它指定了一个数组 `[p:p+n)`，通常无法知道在
    `*p` 之后是否真的有 `n` 个元素可以访问。`span<T>` 和 `span_p<T>` 是简单的辅助类，分别表示 `[p:q)` 范围和从 `p`
    开始并以第一个使谓词为真的元素结束的范围。
- en: Example
  id: totrans-1261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: A `span` represents a range of elements, but how do we manipulate elements of
    that range?
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `span` 表示一系列元素的范围，但我们如何操作该范围中的元素？
- en: '[PRE141]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Note
  id: totrans-1264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: A `span<T>` object does not own its elements and is so small that it can be
    passed by value.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '`span<T>` 对象不拥有其元素，因此它非常小，可以按值传递。'
- en: Passing a `span` object as an argument is exactly as efficient as passing a
    pair of pointer arguments or passing a pointer and an integer count.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `span` 对象作为参数传递与传递一对指针参数或传递指针和整数计数一样高效。
- en: '**See also**: [Support library](#gsl-guidelines-support-library)'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[支持库](#gsl-guidelines-support-library)'
- en: Enforcement
  id: totrans-1268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Complex) Warn where accesses to pointer parameters are bounded by other parameters
    that are integral types and suggest they could use `span` instead.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: （复杂）如果对指针参数的访问受其他参数（整型）的限制，则发出警告，并建议它们可以使用 `span` 代替。
- en: 'F.25: Use a `zstring` or a `not_null<zstring>` to designate a C-style string'
  id: totrans-1270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.25：使用 `zstring` 或 `not_null<zstring>` 来指定 C 风格的字符串
- en: Reason
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'C-style strings are ubiquitous. They are defined by convention: zero-terminated
    arrays of characters. We must distinguish C-style strings from a pointer to a
    single character or an old-fashioned pointer to an array of characters.'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: C 风格的字符串无处不在。它们由约定定义：以零结尾的字符数组。我们必须区分 C 风格的字符串与指向单个字符的指针或旧式的指向字符数组的指针。
- en: If you don’t need null termination, use `string_view`.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要空终止符，请使用 `string_view`。
- en: Example
  id: totrans-1274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE142]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: When I call `length(s)` should I check if `s` is `nullptr` first? Should the
    implementation of `length()` check if `p` is `nullptr`?
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我调用 `length(s)` 时，我应该首先检查 `s` 是否为 `nullptr` 吗？`length()` 的实现应该检查 `p` 是否为 `nullptr`
    吗？
- en: '[PRE143]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note
  id: totrans-1279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: '`zstring` does not represent ownership.'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '`zstring` 不表示所有权。'
- en: '**See also**: [Support library](#gsl-guidelines-support-library)'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[支持库](#gsl-guidelines-support-library)'
- en: 'F.26: Use a `unique_ptr<T>` to transfer ownership where a pointer is needed'
  id: totrans-1282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.26：使用 `unique_ptr<T>` 传递需要指针的所有权
- en: Reason
  id: totrans-1283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using `unique_ptr` is the cheapest way to pass a pointer safely.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unique_ptr` 是安全传递指针成本最低的方式。
- en: '**See also**: [C.50](#rc-factory) regarding when to return a `shared_ptr` from
    a factory.'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[C.50](#rc-factory) 关于何时从工厂返回 `shared_ptr`。'
- en: Example
  id: totrans-1286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE144]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note
  id: totrans-1288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: You need to pass a pointer rather than an object if what you are transferring
    is an object from a class hierarchy that is to be used through an interface (base
    class).
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要传递一个对象，该对象来自一个将通过接口（基类）使用的类层次结构，则需要传递一个指针而不是对象。
- en: Enforcement
  id: totrans-1290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a function returns a locally allocated raw pointer. Suggest
    using either `unique_ptr` or `shared_ptr` instead.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）如果函数返回局部分配的原始指针，则发出警告。建议使用`unique_ptr`或`shared_ptr`。
- en: 'F.27: Use a `shared_ptr<T>` to share ownership'
  id: totrans-1292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'F.27: 使用`shared_ptr<T>`来共享所有权'
- en: Reason
  id: totrans-1293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using `std::shared_ptr` is the standard way to represent shared ownership. That
    is, the last owner deletes the object.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::shared_ptr`是表示共享所有权的标准方式。也就是说，最后一个所有者删除对象。
- en: Example
  id: totrans-1295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE145]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note
  id: totrans-1297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Prefer a `unique_ptr` over a `shared_ptr` if there is never more than one owner
    at a time. `shared_ptr` is for shared ownership.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一次只有一个所有者，则优先使用`unique_ptr`而不是`shared_ptr`。`shared_ptr`用于共享所有权。
- en: Note that pervasive use of `shared_ptr` has a cost (atomic operations on the
    `shared_ptr`’s reference count have a measurable aggregate cost).
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，广泛使用`shared_ptr`是有代价的（对`shared_ptr`引用计数的原子操作有一个可测量的总成本）。
- en: Alternative
  id: totrans-1300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Have a single object own the shared object (e.g. a scoped object) and destroy
    that (preferably implicitly) when all users have completed.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 让单个对象拥有共享对象（例如，一个作用域对象），并在所有用户完成时（最好隐式地）销毁它。
- en: Enforcement
  id: totrans-1302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Not enforceable) This is a too complex pattern to reliably detect.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）这是一个过于复杂的模式，无法可靠地检测。
- en: 'F.42: Return a `T*` to indicate a position (only)'
  id: totrans-1304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'F.42: 返回`T*`来指示位置（仅限）'
- en: Reason
  id: totrans-1305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That’s what pointers are good for. Returning a `T*` to transfer ownership is
    a misuse.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是指针的作用所在。返回`T*`以转移所有权是一种误用。
- en: Example
  id: totrans-1307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE146]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If it isn’t the `nullptr`, the pointer returned by `find` indicates a `Node`
    holding `s`. Importantly, that does not imply a transfer of ownership of the pointed-to
    object to the caller.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不是`nullptr`，则`find`返回的指针表示一个持有`s`的`Node`。重要的是，这并不暗示指向的对象的所有权转移到调用者。
- en: Note
  id: totrans-1310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Positions can also be transferred by iterators, indices, and references. A reference
    is often a superior alternative to a pointer [if there is no need to use `nullptr`](#rf-ptr-ref)
    or [if the object referred to should not change](#s-const).
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 位置也可以通过迭代器、索引和引用进行转移。如果没有必要使用`nullptr`，引用通常是比指针更好的替代方案[如果不需要使用`nullptr`](#rf-ptr-ref)或[如果引用的对象不应该改变](#s-const)。
- en: Note
  id: totrans-1312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Do not return a pointer to something that is not in the caller’s scope; see
    [F.43](#rf-dangle).
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 不要返回指向不在调用者作用域内的对象的指针；参见[F.43](#rf-dangle)。
- en: '**See also**: [discussion of dangling pointer prevention](#???)'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[悬垂指针预防讨论](#???)'
- en: Enforcement
  id: totrans-1315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag `delete`, `std::free()`, etc. applied to a plain `T*`. Only owners should
    be deleted.
  id: totrans-1316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`delete`、`std::free()`等标志应用于普通的`T*`。只有所有者应该被删除。
- en: Flag `new`, `malloc()`, etc. assigned to a plain `T*`. Only owners should be
    responsible for deletion.
  id: totrans-1317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`new`、`malloc()`等标志分配给普通的`T*`。只有所有者应该负责删除。
- en: 'F.43: Never (directly or indirectly) return a pointer or a reference to a local
    object'
  id: totrans-1318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'F.43: 永远（直接或间接）不返回指向局部对象的指针或引用'
- en: Reason
  id: totrans-1319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid the crashes and data corruption that can result from the use of such
    a dangling pointer.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用此类悬垂指针可能导致的崩溃和数据损坏。
- en: Example, bad
  id: totrans-1321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: 'After the return from a function its local objects no longer exist:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回后，其局部对象不再存在：
- en: '[PRE147]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Here on one popular implementation I got the output:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我得到了一个流行实现的输出：
- en: '[PRE148]'
  id: totrans-1325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: I expected that because the call of `g()` reuses the stack space abandoned by
    the call of `f()` so `*p` refers to the space now occupied by `gx`.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计因为`g()`的调用重新使用了`f()`的调用所放弃的栈空间，所以`*p`现在指向`gx`所占据的空间。
- en: Imagine what would happen if `fx` and `gx` were of different types.
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，如果`fx`和`gx`是不同类型会发生什么。
- en: Imagine what would happen if `fx` or `gx` was a type with an invariant.
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，如果`fx`或`gx`是一个具有不变性的类型会发生什么。
- en: Imagine what would happen if that dangling pointer was passed around among a
    larger set of functions.
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，如果那个悬垂指针在更大的函数集中传递会发生什么。
- en: Imagine what a cracker could do with that dangling pointer.
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下，黑客可以用那个悬垂指针做什么。
- en: Fortunately, most (all?) modern compilers catch and warn against this simple
    case.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数（所有？）现代编译器都会捕获并警告这种简单情况。
- en: Note
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This applies to references as well:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于引用：
- en: '[PRE149]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note
  id: totrans-1335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This applies only to non-`static` local variables. All `static` variables are
    (as their name indicates) statically allocated, so that pointers to them cannot
    dangle.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅适用于非`static`局部变量。所有`static`变量（正如其名称所示）都是静态分配的，因此指向它们的指针不会悬垂。
- en: Example, bad
  id: totrans-1337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: 'Not all examples of leaking a pointer to a local variable are that obvious:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有泄露局部变量指针的示例都那么明显：
- en: '[PRE150]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Here I managed to read the location abandoned by the call of `f`. The pointer
    stored in `glob` could be used much later and cause trouble in unpredictable ways.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我设法读取了 `f` 调用放弃的位置。存储在 `glob` 中的指针可以在很久以后使用，并以不可预测的方式引起麻烦。
- en: Note
  id: totrans-1341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The address of a local variable can be “returned”/leaked by a return statement,
    by a `T&` out-parameter, as a member of a returned object, as an element of a
    returned array, and more.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量的地址可以通过返回语句、“T&”输出参数、作为返回对象的成员、作为返回数组的元素等方式“返回”/泄露。
- en: Note
  id: totrans-1343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Similar examples can be constructed “leaking” a pointer from an inner scope
    to an outer one; such examples are handled equivalently to leaks of pointers out
    of a function.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 可以构建类似的例子“泄露”指针从内部作用域到外部作用域；这些例子被等效地处理为函数外的指针泄露。
- en: A slightly different variant of the problem is placing pointers in a container
    that outlives the objects pointed to.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 将指针放置在超出其指向的对象的生命周期的容器中是问题的另一种轻微变体。
- en: '**See also**: Another way of getting dangling pointers is [pointer invalidation](#???).
    It can be detected/prevented with similar techniques.'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：另一种获得悬垂指针的方法是[指针失效](#???)。它可以使用类似的技术检测/预防。'
- en: Enforcement
  id: totrans-1347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Compilers tend to catch return of reference to locals and could in many cases
    catch return of pointers to locals.
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器倾向于捕获对局部变量的引用返回和可能在许多情况下捕获对局部变量的指针返回。
- en: Static analysis can catch many common patterns of the use of pointers indicating
    positions (thus eliminating dangling pointers)
  id: totrans-1349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析可以捕获许多指针位置使用模式的常见模式（从而消除悬垂指针）
- en: 'F.44: Return a `T&` when copy is undesirable and “returning no object” isn’t
    needed'
  id: totrans-1350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.44：当复制不希望发生且不需要“返回无对象”时返回 `T&`
- en: Reason
  id: totrans-1351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The language guarantees that a `T&` refers to an object, so that testing for
    `nullptr` isn’t necessary.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 语言保证 `T&` 指向一个对象，因此不需要测试 `nullptr`。
- en: '**See also**: The return of a reference must not imply transfer of ownership:
    [discussion of dangling pointer prevention](#???) and [discussion of ownership](#???).'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：返回引用不得暗示所有权的转移：[关于悬垂指针预防的讨论](#???)和[关于所有权的讨论](#???).'
- en: Example
  id: totrans-1354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE151]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Enforcement
  id: totrans-1356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag functions where no `return` expression could yield `nullptr`.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 标记那些没有 `return` 表达式可能返回 `nullptr` 的函数。
- en: 'F.45: Don’t return a `T&&`'
  id: totrans-1358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.45：不要返回 `T&&`
- en: Reason
  id: totrans-1359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s asking to return a reference to a destroyed temporary object. An `&&` is
    a magnet for temporary objects.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是请求返回一个指向已销毁临时对象的引用。`&&` 是临时对象的磁铁。
- en: Example
  id: totrans-1361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'A returned rvalue reference goes out of scope at the end of the full expression
    to which it is returned:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的右值引用在其返回的表达式结束时超出作用域：
- en: '[PRE152]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: This kind of use is a frequent source of bugs, often incorrectly reported as
    a compiler bug. An implementer of a function should avoid setting such traps for
    users.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法是bug的常见来源，通常错误地报告为编译器bug。函数的实现者应避免为用户设置此类陷阱。
- en: The [lifetime safety profile](#ss-lifetime) will (when completely implemented)
    catch such problems.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '[生命周期安全性配置文件](#ss-lifetime)（当完全实现时）将捕获此类问题。'
- en: Example
  id: totrans-1366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Returning an rvalue reference is fine when the reference to the temporary is
    being passed “downward” to a callee; then, the temporary is guaranteed to outlive
    the function call (see [F.18](#rf-consume) and [F.19](#rf-forward)). However,
    it’s not fine when passing such a reference “upward” to a larger caller scope.
    For passthrough functions that pass in parameters (by ordinary reference or by
    perfect forwarding) and want to return values, use simple `auto` return type deduction
    (not `auto&&`).
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 当临时对象的引用被“向下”传递给调用者时，返回右值引用是好的；然后，临时对象保证在函数调用之后仍然存在（参见[F.18](#rf-consume)和[F.19](#rf-forward)）。然而，当将此类引用“向上”传递给更大的调用者作用域时，则不是好的。对于传递参数（通过普通引用或完美转发）并希望返回值的passthrough函数，使用简单的`auto`返回类型推导（而不是`auto&&`）。
- en: 'Assume that `F` returns by value:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `F` 通过值返回：
- en: '[PRE153]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Better:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 更好：
- en: '[PRE154]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Exception
  id: totrans-1372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: '`std::move` and `std::forward` do return `&&`, but they are just casts – used
    by convention only in expression contexts where a reference to a temporary object
    is passed along within the same expression before the temporary is destroyed.
    We don’t know of any other good examples of returning `&&`.'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::move` 和 `std::forward` 确实返回 `&&`，但它们只是类型转换——通常只在表达式中使用，在这种表达式中，在临时对象被销毁之前，临时对象的引用在同一个表达式中被传递。我们不知道其他任何返回
    `&&` 的好例子。'
- en: Enforcement
  id: totrans-1374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag any use of `&&` as a return type, except in `std::move` and `std::forward`.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何作为返回类型的 `&&` 标记出来，除了在 `std::move` 和 `std::forward` 中。
- en: 'F.46: `int` is the return type for `main()`'
  id: totrans-1376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.46：`int` 是 `main()` 的返回类型
- en: Reason
  id: totrans-1377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s a language rule, but violated through “language extensions” so often that
    it is worth mentioning. Declaring `main` (the one global `main` of a program)
    `void` limits portability.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个语言规则，但经常通过“语言扩展”来违反，因此值得提及。将`main`（程序的一个全局`main`）声明为`void`限制了可移植性。
- en: Example
  id: totrans-1379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE155]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Note
  id: totrans-1381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We mention this only because of the persistence of this error in the community.
    Note that despite its non-void return type, the main function does not require
    an explicit return statement.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以提到这一点，是因为这种错误在社区中持续存在。请注意，尽管主函数具有非void返回类型，但它不需要显式返回语句。
- en: Enforcement
  id: totrans-1383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: The compiler should do it
  id: totrans-1384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器应该这样做
- en: If the compiler doesn’t do it, let tools flag it
  id: totrans-1385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编译器不做，让工具标记它
- en: 'F.47: Return `T&` from assignment operators'
  id: totrans-1386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.47：从赋值运算符返回`T&`
- en: Reason
  id: totrans-1387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The convention for operator overloads (especially on concrete types) is for
    `operator=(const T&)` to perform the assignment and then return (non-`const`)
    `*this`. This ensures consistency with standard-library types and follows the
    principle of “do as the ints do.”
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于操作符重载（尤其是在具体类型上）的约定是，`operator=(const T&)`执行赋值然后返回（非`const`）`*this`。这确保了与标准库类型的兼容性，并遵循了“像整数那样做”的原则。
- en: Note
  id: totrans-1389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Historically there was some guidance to make the assignment operator return
    `const T&`. This was primarily to avoid code of the form `(a = b) = c` – such
    code is not common enough to warrant violating consistency with standard types.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，有一些指导建议使赋值运算符返回`const T&`。这主要是为了避免形式为`(a = b) = c`的代码——这样的代码并不常见，不足以违反与标准类型的兼容性。
- en: Example
  id: totrans-1391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE156]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Enforcement
  id: totrans-1393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: This should be enforced by tooling by checking the return type (and return value)
    of any assignment operator.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该通过工具通过检查任何赋值运算符的返回类型（和返回值）来强制执行。
- en: 'F.48: Don’t `return std::move(local)`'
  id: totrans-1395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.48：不要`return std::move(local)`
- en: Reason
  id: totrans-1396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Returning a local variable implicitly moves it anyway. An explicit `std::move`
    is always a pessimization, because it prevents Return Value Optimization (RVO),
    which can eliminate the move completely.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式返回局部变量仍然会移动它。显式使用`std::move`总是次优的，因为它阻止了返回值优化（RVO），这可以完全消除移动操作。
- en: Example, bad
  id: totrans-1398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE157]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Example, good
  id: totrans-1400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE158]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Enforcement
  id: totrans-1402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: This should be enforced by tooling by checking the return expression.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该通过工具通过检查返回表达式来强制执行。
- en: 'F.49: Don’t return `const T`'
  id: totrans-1404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.49：不要返回`const T`
- en: Reason
  id: totrans-1405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is not recommended to return a `const` value. Such older advice is now obsolete;
    it does not add value, and it interferes with move semantics.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议返回`const`值。这种过时的建议现在已经过时了；它没有增加价值，并且会干扰移动语义。
- en: Example
  id: totrans-1407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE159]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The argument for adding `const` to a return value is that it prevents (very
    rare) accidental access to a temporary. The argument against is that it prevents
    (very frequent) use of move semantics.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 将`const`添加到返回值中的论点是它防止（非常罕见的）对临时对象的意外访问。反对的论点是它阻止（非常频繁的）使用移动语义。
- en: '**See also**: [F.20, the general item about “out” output values](#rf-out)'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[F.20，关于“out”输出值的一般性说明](#rf-out)'
- en: Enforcement
  id: totrans-1411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: 'Flag returning a `const` value. To fix: Remove `const` to return a non-`const`
    value instead.'
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记返回`const`值。修复方法：移除`const`以返回非`const`值。
- en: 'F.50: Use a lambda when a function won’t do (to capture local variables, or
    to write a local function)'
  id: totrans-1413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.50：当函数不起作用时使用lambda（捕获局部变量或编写局部函数）
- en: Reason
  id: totrans-1414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Functions can’t capture local variables or be defined at local scope; if you
    need those things, prefer a lambda where possible, and a handwritten function
    object where not. On the other hand, lambdas and function objects don’t overload;
    if you need to overload, prefer a function (the workarounds to make lambdas overload
    are ornate). If either will work, prefer writing a function; use the simplest
    tool necessary.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不能捕获局部变量或定义在局部作用域中；如果需要这些功能，尽可能使用lambda，如果不行，则使用手写的函数对象。另一方面，lambda和函数对象不重载；如果需要重载，则优先使用函数（使lambda重载的折衷方案很复杂）。如果两者都可以工作，则优先编写函数；使用最简单的工具。
- en: Example
  id: totrans-1416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE160]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Exception
  id: totrans-1418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Generic lambdas offer a concise way to write function templates and so can be
    useful even when a normal function template would do equally well with a little
    more syntax. This advantage will probably disappear in the future once all functions
    gain the ability to have Concept parameters.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型lambda提供了一种简洁地编写函数模板的方法，因此即使在正常函数模板也能很好地工作的情况下，它也可能是有用的。这种优势在未来一旦所有函数都获得了拥有概念参数的能力后可能会消失。
- en: Enforcement
  id: totrans-1420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Warn on use of a named non-generic lambda (e.g., `auto x = [](int i) { /*...*/;
    };`) that captures nothing and appears at global scope. Write an ordinary function
    instead.
  id: totrans-1421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告：当使用无捕获内容的命名非泛型lambda（例如，`auto x = [](int i) { /*...*/; };`）且出现在全局作用域时。请改写为普通函数。
- en: 'F.51: Where there is a choice, prefer default arguments over overloading'
  id: totrans-1422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.51：在有选择的情况下，优先使用默认参数而不是重载
- en: Reason
  id: totrans-1423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Default arguments simply provide alternative interfaces to a single implementation.
    There is no guarantee that a set of overloaded functions all implement the same
    semantics. The use of default arguments can avoid code replication.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数只是为单个实现提供替代接口。不能保证一组重载函数都实现相同的语义。使用默认参数可以避免代码重复。
- en: Note
  id: totrans-1425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is a choice between using default argument and overloading when the alternatives
    are from a set of arguments of the same types. For example:'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 当替代方案来自同一类型参数集时，在使用默认参数和重载之间有选择。例如：
- en: '[PRE161]'
  id: totrans-1427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: as opposed to
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 相反
- en: '[PRE162]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'There is not a choice when a set of functions are used to do a semantically
    equivalent operation to a set of types. For example:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 当一组函数用于执行与一组类型语义等效的操作时，没有选择余地。例如：
- en: '[PRE163]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: See also
  id: totrans-1432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参见
- en: '[Default arguments for virtual functions](#rh-virtual-default-arg)'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '[虚拟函数的默认参数](#rh-virtual-default-arg)'
- en: Enforcement
  id: totrans-1434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Warn on an overload set where the overloads have a common prefix of parameters
    (e.g., `f(int)`, `f(int, const string&)`, `f(int, const string&, double)`). (Note:
    Review this enforcement if it’s too noisy in practice.)'
  id: totrans-1435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告：当重载集的重载函数具有参数的共同前缀时（例如，`f(int)`，`f(int, const string&)`，`f(int, const string&,
    double)`）。（注意：如果实际中过于嘈杂，请审查此执法。）
- en: 'F.52: Prefer capturing by reference in lambdas that will be used locally, including
    passed to algorithms'
  id: totrans-1436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.52：在将用于本地的lambda（包括传递给算法）中，优先按引用捕获
- en: Reason
  id: totrans-1437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: For efficiency and correctness, you nearly always want to capture by reference
    when using the lambda locally. This includes when writing or calling parallel
    algorithms that are local because they join before returning.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了效率和正确性，在本地使用lambda时，几乎总是想按引用捕获。这包括当编写或调用局部并行算法时，因为它们在返回之前会连接。
- en: Discussion
  id: totrans-1439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The efficiency consideration is that most types are cheaper to pass by reference
    than by value.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 效率考虑是大多数类型按引用传递比按值传递更便宜。
- en: The correctness consideration is that many calls want to perform side effects
    on the original object at the call site (see example below). Passing by value
    prevents this.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性考虑是许多调用希望在调用位置对原始对象执行副作用（见下例）。按值传递可以防止这种情况。
- en: Note
  id: totrans-1442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, there is no simple way to capture by reference to `const` to
    get the efficiency for a local call but also prevent side effects.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有简单的方法可以通过引用捕获`const`来获得局部调用的高效性，同时防止副作用。
- en: Example
  id: totrans-1444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Here, a large object (a network message) is passed to an iterative algorithm,
    and it is not efficient or correct to copy the message (which might not be copyable):'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个大型对象（一个网络消息）被传递给一个迭代算法，复制消息（可能不可复制）既不高效也不正确：
- en: '[PRE164]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Example
  id: totrans-1447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: This is a simple three-stage parallel pipeline. Each `stage` object encapsulates
    a worker thread and a queue, has a `process` function to enqueue work, and in
    its destructor automatically blocks waiting for the queue to empty before ending
    the thread.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的三阶段并行管道。每个`stage`对象封装了一个工作线程和一个队列，有一个`process`函数用于入队工作，并在其析构函数中自动阻塞等待队列清空后再结束线程。
- en: '[PRE165]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Enforcement
  id: totrans-1450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag a lambda that captures by reference, but is used other than locally within
    the function scope or passed to a function by reference. (Note: This rule is an
    approximation, but does flag passing by pointer as those are more likely to be
    stored by the callee, writing to a heap location accessed via a parameter, returning
    the lambda, etc. The Lifetime rules will also provide general rules that flag
    escaping pointers and references including via lambdas.)'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 标记一个按引用捕获的lambda，但除了在函数作用域内本地使用或通过引用传递给函数之外。 （注意：此规则是一个近似值，但确实标记了通过指针传递，因为这些更有可能被调用者存储，通过参数写入堆位置，返回lambda等。生命周期规则也将提供一般规则，标记通过lambda逃逸的指针和引用。）
- en: 'F.53: Avoid capturing by reference in lambdas that will be used non-locally,
    including returned, stored on the heap, or passed to another thread'
  id: totrans-1452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.53：避免在将用于非本地的lambda中按引用捕获，包括返回、存储在堆上或传递给另一个线程
- en: Reason
  id: totrans-1453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Pointers and references to locals shouldn’t outlive their scope. Lambdas that
    capture by reference are just another place to store a reference to a local object,
    and shouldn’t do so if they (or a copy) outlive the scope.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量的指针和引用不应超出其作用域。捕获引用的 lambda 只是一个存储局部对象引用的地方，并且如果它们（或其副本）超出作用域，则不应这样做。
- en: Example, bad
  id: totrans-1455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE166]'
  id: totrans-1456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Example, good
  id: totrans-1457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE167]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Note
  id: totrans-1459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If a non-local pointer must be captured, consider using `unique_ptr`; this handles
    both lifetime and synchronization.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须捕获非局部指针，考虑使用 `unique_ptr`；这处理了生命周期和同步。
- en: If the `this` pointer must be captured, consider using `[*this]` capture, which
    creates a copy of the entire object.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须捕获 `this` 指针，考虑使用 `[*this]` 捕获，它创建整个对象的副本。
- en: Enforcement
  id: totrans-1462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn when capture-list contains a reference to a locally declared variable
  id: totrans-1463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）当捕获列表包含对局部声明的变量的引用时发出警告
- en: (Complex) Flag when capture-list contains a reference to a locally declared
    variable and the lambda is passed to a non-`const` and non-local context
  id: totrans-1464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （复杂）当捕获列表包含对局部声明的变量的引用，并且 lambda 被传递到非 `const` 和非局部上下文时发出警告
- en: 'F.54: When writing a lambda that captures `this` or any class data member,
    don’t use `[=]` default capture'
  id: totrans-1465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.54：在编写捕获 `this` 或任何类数据成员的 lambda 时，不要使用 `[=]` 默认捕获
- en: Reason
  id: totrans-1466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s confusing. Writing `[=]` in a member function appears to capture by value,
    but actually captures data members by reference because it actually captures the
    invisible `this` pointer by value. If you meant to do that, write `this` explicitly.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人困惑。在成员函数中写入 `[=]` 似乎是通过值捕获，但实际上是通过引用捕获数据成员，因为它实际上是通过值捕获不可见的 `this` 指针。如果你是那个意思，请明确写出
    `this`。
- en: Example
  id: totrans-1468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE168]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Note
  id: totrans-1470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you intend to capture a copy of all class data members, consider C++17 `[*this]`.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算捕获所有类数据成员的副本，考虑使用 C++17 的 `[*this]`。
- en: Enforcement
  id: totrans-1472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag any lambda capture-list that specifies a capture-default of `[=]` and also
    captures `this` (whether explicitly or via the default capture and a use of `this`
    in the body)
  id: totrans-1473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记任何指定捕获默认为 `[=]` 并捕获 `this`（无论是显式还是通过默认捕获和在主体中使用 `this`）的 lambda 捕获列表。
- en: 'F.55: Don’t use `va_arg` arguments'
  id: totrans-1474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.55：不要使用 `va_arg` 参数
- en: Reason
  id: totrans-1475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Reading from a `va_arg` assumes that the correct type was actually passed. Passing
    to varargs assumes the correct type will be read. This is fragile because it cannot
    generally be enforced to be safe in the language and so relies on programmer discipline
    to get it right.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `va_arg` 读取假设实际上传递了正确的类型。传递给 varargs 假设将读取正确的类型。这是脆弱的，因为它通常不能在语言中强制执行为安全，因此依赖于程序员遵守纪律以正确执行。
- en: Example
  id: totrans-1477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE169]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Alternatives
  id: totrans-1479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: overloading
  id: totrans-1480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载
- en: variadic templates
  id: totrans-1481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变模板
- en: '`variant` arguments'
  id: totrans-1482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variant` 参数'
- en: '`initializer_list` (homogeneous)'
  id: totrans-1483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initializer_list`（同质）'
- en: Note
  id: totrans-1484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Declaring a `...` parameter is sometimes useful for techniques that don’t involve
    actual argument passing, notably to declare “take-anything” functions so as to
    disable “everything else” in an overload set or express a catchall case in a template
    metaprogram.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `...` 参数有时对不涉及实际参数传递的技术很有用，特别是为了声明“接受任何东西”的函数，以便在重载集中禁用“其他所有内容”，或在模板元程序中表达一个通配情况。
- en: Enforcement
  id: totrans-1486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Issue a diagnostic for using `va_list`, `va_start`, or `va_arg`.
  id: totrans-1487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对使用 `va_list`、`va_start` 或 `va_arg` 发出诊断。
- en: 'Issue a diagnostic for passing an argument to a vararg parameter of a function
    that does not offer an overload for a more specific type in the position of the
    vararg. To fix: Use a different function, or `[[suppress("type")]]`.'
  id: totrans-1488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向一个没有为 vararg 参数提供更具体类型重载的函数传递参数时，发出诊断。修复方法：使用不同的函数，或 `[[suppress("type")]]`。
- en: 'F.56: Avoid unnecessary condition nesting'
  id: totrans-1489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F.56：避免不必要的条件嵌套
- en: Reason
  id: totrans-1490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Shallow nesting of conditions makes the code easier to follow. It also makes
    the intent clearer. Strive to place the essential code at outermost scope, unless
    this obscures intent.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 条件嵌套较浅使代码更容易理解。它还使意图更清晰。努力将关键代码放在最外层作用域，除非这会模糊意图。
- en: Example
  id: totrans-1492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Use a guard-clause to take care of exceptional cases and return early.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 使用保护子句来处理异常情况并尽早返回。
- en: '[PRE170]'
  id: totrans-1494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Example
  id: totrans-1495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE171]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Enforcement
  id: totrans-1497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag a redundant `else`. Flag a function whose body is simply a conditional
    statement enclosing a block.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 标记冗余的 `else`。标记一个其主体仅包含一个包含块的条件语句的函数。
- en: 'C: Classes and class hierarchies'
  id: totrans-1499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C：类和类层次结构
- en: A class is a user-defined type, for which a programmer can define the representation,
    operations, and interfaces. Class hierarchies are used to organize related classes
    into hierarchical structures.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个用户定义的类型，程序员可以定义其表示、操作和接口。类层次结构用于将相关类组织成层次结构。
- en: 'Class rule summary:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 类规则摘要：
- en: '[C.1: Organize related data into structures (`struct`s or `class`es)](#rc-org)'
  id: totrans-1502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.1: 将相关数据组织成结构（`struct`s或`class`es）](#rc-org)'
- en: '[C.2: Use `class` if the class has an invariant; use `struct` if the data members
    can vary independently](#rc-struct)'
  id: totrans-1503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.2: 如果类有一个不变量，则使用`class`；如果数据成员可以独立变化，则使用`struct`](#rc-struct)'
- en: '[C.3: Represent the distinction between an interface and an implementation
    using a class](#rc-interface)'
  id: totrans-1504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.3: 使用类来表示接口和实现之间的区别](#rc-interface)'
- en: '[C.4: Make a function a member only if it needs direct access to the representation
    of a class](#rc-member)'
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.4: 只有当函数需要直接访问类的表示时，才将其作为成员函数](#rc-member)'
- en: '[C.5: Place helper functions in the same namespace as the class they support](#rc-helper)'
  id: totrans-1506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.5: 将辅助函数放置在与它们支持的类相同的命名空间中](#rc-helper)'
- en: '[C.7: Don’t define a class or enum and declare a variable of its type in the
    same statement](#rc-standalone)'
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.7: 不要在同一语句中定义一个类或枚举并声明其类型的变量](#rc-standalone)'
- en: '[C.8: Use `class` rather than `struct` if any member is non-public](#rc-class)'
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.8: 如果任何成员是非公共的，则使用`class`而不是`struct`](#rc-class)'
- en: '[C.9: Minimize exposure of members](#rc-private)'
  id: totrans-1509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.9: 最小化成员的暴露](#rc-private)'
- en: 'Subsections:'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 子节：
- en: '[C.concrete: Concrete types](#ss-concrete)'
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.concrete: 具体类型](#ss-concrete)'
- en: '[C.ctor: Constructors, assignments, and destructors](#s-ctor)'
  id: totrans-1512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.ctor: 构造函数、赋值和析构函数](#s-ctor)'
- en: '[C.con: Containers and other resource handles](#ss-containers)'
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.con: 容器和其它资源句柄](#ss-containers)'
- en: '[C.lambdas: Function objects and lambdas](#ss-lambdas)'
  id: totrans-1514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.lambdas: 函数对象和lambda表达式](#ss-lambdas)'
- en: '[C.hier: Class hierarchies (OOP)](#ss-hier)'
  id: totrans-1515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.hier: 类层次结构（面向对象编程）](#ss-hier)'
- en: '[C.over: Overloading and overloaded operators](#ss-overload)'
  id: totrans-1516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.over: 赋值和重载运算符](#ss-overload)'
- en: '[C.union: Unions](#ss-union)'
  id: totrans-1517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.union: 联合](#ss-union)'
- en: 'C.1: Organize related data into structures (`struct`s or `class`es)'
  id: totrans-1518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.1: 将相关数据组织成结构（`struct`s或`class`es）'
- en: Reason
  id: totrans-1519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Ease of comprehension. If data is related (for fundamental reasons), that fact
    should be reflected in code.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 理解的容易性。如果数据相关（出于基本原因），这一事实应在代码中得到反映。
- en: Example
  id: totrans-1521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE172]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Note
  id: totrans-1523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A simple class without virtual functions implies no space or time overhead.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有虚拟函数的简单类意味着没有空间或时间开销。
- en: Note
  id: totrans-1525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: From a language perspective `class` and `struct` differ only in the default
    visibility of their members.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 从语言的角度来看，`class`和`struct`的不同之处仅在于它们成员的默认可见性。
- en: Enforcement
  id: totrans-1527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Probably impossible. Maybe a heuristic looking for data items used together
    is possible.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不可能。可能有一个启发式方法来寻找一起使用的数据项是可能的。
- en: 'C.2: Use `class` if the class has an invariant; use `struct` if the data members
    can vary independently'
  id: totrans-1529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.2: 如果类有一个不变量，则使用`class`；如果数据成员可以独立变化，则使用`struct`'
- en: Reason
  id: totrans-1530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Ease of comprehension. The use of `class` alerts the programmer
    to the need for an invariant. This is a useful convention.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。理解的容易性。使用`class`提醒程序员需要不变量。这是一个有用的约定。
- en: Note
  id: totrans-1532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An invariant is a logical condition for the members of an object that a constructor
    must establish for the public member functions to assume. After the invariant
    is established (typically by a constructor) every member function can be called
    for the object. An invariant can be stated informally (e.g., in a comment) or
    more formally using `Expects`.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量是对象成员的逻辑条件，构造函数必须建立这些条件，以便公共成员函数可以假定。在建立不变量（通常由构造函数完成）之后，可以调用对象的每个成员函数。不变量可以非正式地陈述（例如，在注释中）或更正式地使用`Expects`。
- en: If all data members can vary independently of each other, no invariant is possible.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有数据成员都可以相互独立地变化，则不可能存在不变量。
- en: Example
  id: totrans-1535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE173]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'but:'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 但：
- en: '[PRE174]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Note
  id: totrans-1539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If a class has any `private` data, a user cannot completely initialize an object
    without the use of a constructor. Hence, the class definer will provide a constructor
    and must specify its meaning. This effectively means the definer needs to define
    an invariant.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类有任何`私有`数据，用户不能在不使用构造函数的情况下完全初始化一个对象。因此，类定义者将提供一个构造函数，并必须指定其含义。这意味着定义者需要定义一个不变量。
- en: '**See also**:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：'
- en: '[define a class with private data as `class`](#rc-class)'
  id: totrans-1542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用`class`定义具有私有数据的类](#rc-class)'
- en: '[Prefer to place the interface first in a class](#rl-order)'
  id: totrans-1543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在类中首先放置接口](#rl-order)'
- en: '[minimize exposure of members](#rc-private)'
  id: totrans-1544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[最小化成员的暴露](#rc-private)'
- en: '[Avoid `protected` data](#rh-protected)'
  id: totrans-1545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[避免使用`protected`数据](#rh-protected)'
- en: Enforcement
  id: totrans-1546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Look for `struct`s with all data private and `class`es with public members.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找所有数据为私有的`struct`s和具有公共成员的`class`es。
- en: 'C.3: Represent the distinction between an interface and an implementation using
    a class'
  id: totrans-1548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.3: 使用类来表示接口和实现之间的区别'
- en: Reason
  id: totrans-1549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An explicit distinction between interface and implementation improves readability
    and simplifies maintenance.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口和实现之间进行明确的区分可以提高可读性并简化维护。
- en: Example
  id: totrans-1551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE175]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: For example, we can now change the representation of a `Date` without affecting
    its users (recompilation is likely, though).
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们现在可以改变`Date`的表示，而不会影响其用户（尽管可能需要重新编译）。
- en: Note
  id: totrans-1554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Using a class in this way to represent the distinction between interface and
    implementation is of course not the only way. For example, we can use a set of
    declarations of freestanding functions in a namespace, an abstract base class,
    or a function template with concepts to represent an interface. The most important
    issue is to explicitly distinguish between an interface and its implementation
    “details.” Ideally, and typically, an interface is far more stable than its implementation(s).
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类以这种方式来表示接口和实现之间的区别当然不是唯一的方法。例如，我们可以在命名空间中使用一组独立函数的声明，一个抽象基类，或者一个带有概念的函数模板来表示接口。最重要的是明确区分接口及其实现“细节”。理想情况下，通常，接口比其实现（们）更稳定。
- en: Enforcement
  id: totrans-1556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: ???
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.4: Make a function a member only if it needs direct access to the representation
    of a class'
  id: totrans-1558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.4: 只有当函数需要直接访问类的表示时，才将其作为类的成员'
- en: Reason
  id: totrans-1559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Less coupling than with member functions, fewer functions that can cause trouble
    by modifying object state, reduces the number of functions that need to be modified
    after a change in representation.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 与成员函数相比，耦合度更低，可以修改对象状态的函数更少，减少了在表示更改后需要修改的函数数量。
- en: Example
  id: totrans-1561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE176]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The “helper functions” have no need for direct access to the representation
    of a `Date`.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: “辅助函数”不需要直接访问`Date`的表示。
- en: Note
  id: totrans-1564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This rule becomes even better if C++ gets [“uniform function call”](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf).
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C++得到[“统一函数调用”](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf)，这个规则会变得更好。
- en: Exception
  id: totrans-1566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: The language requires `virtual` functions to be members, and not all `virtual`
    functions directly access data. In particular, members of an abstract class rarely
    do.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 语言要求`virtual`函数是成员，并且并非所有`virtual`函数都直接访问数据。特别是，抽象类的成员很少这样做。
- en: Note [multi-methods](https://web.archive.org/web/20200605021759/https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf).
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[多方法](https://web.archive.org/web/20200605021759/https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf)。
- en: Exception
  id: totrans-1569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: The language requires operators `=`, `()`, `[]`, and `->` to be members.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 语言要求操作符`=`, `()`, `[]`, 和 `->`是成员。
- en: Exception
  id: totrans-1571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'An overload set could have some members that do not directly access `private`
    data:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 重载集可能有一些成员不直接访问`private`数据：
- en: '[PRE177]'
  id: totrans-1573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Exception
  id: totrans-1574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'Similarly, a set of functions could be designed to be used in a chain:'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以设计一组函数用于链式调用：
- en: '[PRE178]'
  id: totrans-1576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Typically, some but not all of such functions directly access `private` data.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这类函数中的一些但不是所有直接访问`private`数据。
- en: Enforcement
  id: totrans-1578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Look for non-`virtual` member functions that do not touch data members directly.
    The snag is that many member functions that do not need to touch data members
    directly do.
  id: totrans-1579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找不直接接触数据成员的`non-`virtual`成员函数。问题是许多不需要直接接触数据成员的成员函数。
- en: Ignore `virtual` functions.
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略`virtual`函数。
- en: Ignore functions that are part of an overload set out of which at least one
    function accesses `private` members.
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略那些至少有一个函数访问`private`成员的重载集的函数。
- en: Ignore functions returning `this`.
  id: totrans-1582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略返回`this`的函数。
- en: 'C.5: Place helper functions in the same namespace as the class they support'
  id: totrans-1583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.5: 将辅助函数放置在与它们支持的类相同的命名空间中'
- en: Reason
  id: totrans-1584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A helper function is a function (usually supplied by the writer of a class)
    that does not need direct access to the representation of the class, yet is seen
    as part of the useful interface to the class. Placing them in the same namespace
    as the class makes their relationship to the class obvious and allows them to
    be found by argument dependent lookup.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数是一个函数（通常由类的编写者提供），它不需要直接访问类的表示，但被视为类有用接口的一部分。将它们放置在与类相同的命名空间中使得它们与类的关系明显，并允许通过参数依赖查找找到它们。
- en: Example
  id: totrans-1586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE179]'
  id: totrans-1587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Note
  id: totrans-1588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is especially important for [overloaded operators](#ro-namespace).
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于[重载操作符](#ro-namespace)尤为重要。
- en: Enforcement
  id: totrans-1590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag global functions taking argument types from a single namespace.
  id: totrans-1591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记接受单个命名空间参数的全局函数。
- en: 'C.7: Don’t define a class or enum and declare a variable of its type in the
    same statement'
  id: totrans-1592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.7: 不要在同一语句中定义一个类或枚举并声明其类型的变量'
- en: Reason
  id: totrans-1593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Mixing a type definition and the definition of another entity in the same declaration
    is confusing and unnecessary.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一声明中将类型定义与另一个实体的定义混合在一起是令人困惑且不必要的。
- en: Example, bad
  id: totrans-1595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE180]'
  id: totrans-1596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Example, good
  id: totrans-1597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE181]'
  id: totrans-1598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Enforcement
  id: totrans-1599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag if the `}` of a class or enumeration definition is not followed by a `;`.
    The `;` is missing.
  id: totrans-1600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记类或枚举定义的`}`后面没有跟一个`;`。`;`丢失了。
- en: 'C.8: Use `class` rather than `struct` if any member is non-public'
  id: totrans-1601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.8: 如果任何成员不是公共的，则使用`class`而不是`struct`'
- en: Reason
  id: totrans-1602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. To make it clear that something is being hidden/abstracted. This
    is a useful convention.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。为了清楚地表明某事物正在被隐藏/抽象。这是一个有用的约定。
- en: Example, bad
  id: totrans-1604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE182]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: There is nothing wrong with this code as far as the C++ language rules are concerned,
    but nearly everything is wrong from a design perspective. The private data is
    hidden far from the public data. The data is split in different parts of the class
    declaration. Different parts of the data have different access. All of this decreases
    readability and complicates maintenance.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 就C++语言规则而言，这段代码没有问题，但从设计角度来看，几乎一切都错了。私有数据被隐藏在公共数据很远的地方。数据被分散在类声明的不同部分。数据的不同部分有不同的访问权限。所有这些都降低了可读性并复杂化了维护。
- en: Note
  id: totrans-1607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Prefer to place the interface first in a class, [see NL.16](#rl-order).
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于将接口首先放置在类中，[参见NL.16](#rl-order)。
- en: Enforcement
  id: totrans-1609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag classes declared with `struct` if there is a `private` or `protected` member.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`private`或`protected`成员，则标记使用`struct`声明的类。
- en: 'C.9: Minimize exposure of members'
  id: totrans-1611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.9: 最小化成员的暴露'
- en: Reason
  id: totrans-1612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Encapsulation. Information hiding. Minimize the chance of unintended access.
    This simplifies maintenance.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 封装。信息隐藏。最小化意外访问的机会。这简化了维护。
- en: Example
  id: totrans-1614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE183]'
  id: totrans-1615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Whatever we do in the `//`-part, an arbitrary user of a `pair` can arbitrarily
    and independently change its `a` and `b`. In a large code base, we cannot easily
    find which code does what to the members of `pair`. This might be exactly what
    we want, but if we want to enforce a relation among members, we need to make them
    `private` and enforce that relation (invariant) through constructors and member
    functions. For example:'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们在`//`部分做什么，任意用户都可以任意独立地更改`pair`的`a`和`b`。在一个大型代码库中，我们很难找到哪些代码对`pair`的成员做了什么。这可能是我们想要的，但如果我们想强制成员之间的关系，我们需要将它们声明为`private`并通过构造函数和成员函数强制执行这种关系（不变性）。例如：
- en: '[PRE184]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Note
  id: totrans-1618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If the set of direct users of a set of variables cannot be easily determined,
    the type or usage of that set cannot be (easily) changed/improved. For `public`
    and `protected` data, that’s usually the case.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组变量的直接用户集合不容易确定，那么该集合的类型或使用方式就不能（容易）改变/改进。对于`public`和`protected`数据，通常是这样的情况。
- en: Example
  id: totrans-1620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'A class can provide two interfaces to its users. One for derived classes (`protected`)
    and one for general users (`public`). For example, a derived class might be allowed
    to skip a run-time check because it has already guaranteed correctness:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以为其用户提供两个接口。一个用于派生类（`protected`）和一个用于一般用户（`public`）。例如，派生类可能被允许跳过运行时检查，因为它已经保证了正确性：
- en: '[PRE185]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Note
  id: totrans-1623
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[`protected` data is a bad idea](#rh-protected).'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: '[将`protected`数据视为不良做法](#rh-protected)。'
- en: Note
  id: totrans-1625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Prefer the order `public` members before `protected` members before `private`
    members; see [NL.16](#rl-order).
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于将`public`成员放在`protected`成员之前，再将`private`成员放在最后；参见[NL.16](#rl-order)。
- en: Enforcement
  id: totrans-1627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: '[Flag protected data](#rh-protected).'
  id: totrans-1628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[标记受保护的成员](#rh-protected)。'
- en: Flag mixtures of `public` and `private` data
  id: totrans-1629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`public`和`private`数据的混合
- en: 'C.concrete: Concrete types'
  id: totrans-1630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'C.concrete: 具体类型'
- en: 'Concrete type rule summary:'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型规则摘要：
- en: '[C.10: Prefer concrete types over class hierarchies](#rc-concrete)'
  id: totrans-1632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.10: 优先使用具体类型而不是类层次结构](#rc-concrete)'
- en: '[C.11: Make concrete types regular](#rc-regular)'
  id: totrans-1633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.11: 使具体类型正规化](#rc-regular)'
- en: '[C.12: Don’t make data members `const` or references in a copyable or movable
    type](#rc-constref)'
  id: totrans-1634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.12: 不要在可复制或可移动类型中将数据成员声明为`const`或引用](#rc-constref)'
- en: 'C.10: Prefer concrete types over class hierarchies'
  id: totrans-1635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.10: 优先使用具体类型而不是类层次结构'
- en: Reason
  id: totrans-1636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'A concrete type is fundamentally simpler than a type in a class hierarchy:
    easier to design, easier to implement, easier to use, easier to reason about,
    smaller, and faster. You need a reason (use cases) for using a hierarchy.'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型在本质上比类层次结构中的类型简单：更容易设计、更容易实现、更容易使用、更容易推理、更小、更快。你需要一个理由（用例）来使用层次结构。
- en: Example
  id: totrans-1638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE186]'
  id: totrans-1639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: If a class is part of a hierarchy, we (in real code if not necessarily in small
    examples) must manipulate its objects through pointers or references. That implies
    more memory overhead, more allocations and deallocations, and more run-time overhead
    to perform the resulting indirections.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类是层次结构的一部分，我们（在真实代码中如果不是在小示例中）必须通过指针或引用来操作其对象。这暗示了更多的内存开销、更多的分配和释放，以及更多的运行时开销来执行结果间接操作。
- en: Note
  id: totrans-1641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Concrete types can be stack-allocated and be members of other classes.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型可以栈分配，并成为其他类的成员。
- en: Note
  id: totrans-1643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The use of indirection is fundamental for run-time polymorphic interfaces. The
    allocation/deallocation overhead is not (that’s just the most common case). We
    can use a base class as the interface of a scoped object of a derived class. This
    is done where dynamic allocation is prohibited (e.g. hard-real-time) and to provide
    a stable interface to some kinds of plug-ins.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 使用间接引用对于运行时多态接口是基本的。分配/释放开销并不是（这只是最常见的情况）。我们可以使用基类作为派生类作用域对象的接口。这通常在动态分配被禁止的地方（例如，硬实时）以及为了提供对某些类型插件的稳定接口时进行。
- en: Enforcement
  id: totrans-1645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.11: Make concrete types regular'
  id: totrans-1647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.11：使具体类型常规
- en: Reason
  id: totrans-1648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Regular types are easier to understand and reason about than types that are
    not regular (irregularities require extra effort to understand and use).
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 常规类型比非常规类型（不规则性需要额外的努力来理解和使用）更容易理解和推理。
- en: The C++ built-in types are regular, and so are standard-library classes such
    as `string`, `vector`, and `map`. Concrete classes without assignment and equality
    can be defined, but they are (and should be) rare.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: C++的内置类型是常规的，标准库类如`string`、`vector`和`map`也是如此。可以定义没有赋值和相等运算符的具体类，但它们（并且应该是）很少见。
- en: Example
  id: totrans-1651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE187]'
  id: totrans-1652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: In particular, if a concrete type is copyable, prefer to also give it an equality
    comparison operator, and ensure that `a = b` implies `a == b`.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果一个具体类型是可复制的，最好也提供一个相等比较运算符，并确保`a = b`意味着`a == b`。
- en: Note
  id: totrans-1654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For structs intended to be shared with C code, defining `operator==` may not
    be feasible.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 对于打算与C代码共享的结构，定义`operator==`可能不可行。
- en: Note
  id: totrans-1656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Handles for resources that cannot be cloned, e.g., a `scoped_lock` for a `mutex`,
    are concrete types but typically cannot be copied (instead, they can usually be
    moved), so they can’t be regular; instead, they tend to be move-only.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法克隆的资源句柄，例如，用于互斥锁的`scoped_lock`，它们是具体类型，但通常不能复制（相反，它们通常可以移动），因此它们不是常规的；相反，它们倾向于只可移动。
- en: Enforcement
  id: totrans-1658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.12: Don’t make data members `const` or references in a copyable or movable
    type'
  id: totrans-1660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.12：不要在可复制或可移动类型中将数据成员设置为`const`或引用
- en: Reason
  id: totrans-1661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`const` and reference data members are not useful in a copyable or movable
    type, and make such types difficult to use by making them at least partly uncopyable/unmovable
    for subtle reasons.'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`和引用数据成员在可复制或可移动类型中不是很有用，并且会使这些类型难以使用，因为它们至少部分不可复制/不可移动，原因微妙。'
- en: Example; bad
  id: totrans-1663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例；不好
- en: '[PRE188]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The `const` and `&` data members make this class “only-sort-of-copyable” – copy-constructible
    but not copy-assignable.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`和`&`数据成员使这个类“只有部分可复制” – 可复制构造但不可复制赋值。'
- en: Note
  id: totrans-1666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you need a member to point to something, use a pointer (raw or smart, and
    `gsl::not_null` if it should not be null) instead of a reference.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个成员指向某物，请使用指针（原始或智能的，如果它不应为空，则使用`gsl::not_null`）而不是引用。
- en: Enforcement
  id: totrans-1668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag a data member that is `const`, `&`, or `&&` in a type that has any copy
    or move operation.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有任何复制或移动操作的类型中标记为`const`、`&`或`&&`的数据成员。
- en: 'C.ctor: Constructors, assignments, and destructors'
  id: totrans-1670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.ctor：构造函数、赋值运算符和析构函数
- en: 'These functions control the lifecycle of objects: creation, copy, move, and
    destruction. Define constructors to guarantee and simplify initialization of classes.'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数控制对象的生命周期：创建、复制、移动和销毁。定义构造函数以确保并简化类的初始化。
- en: 'These are *default operations*:'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是*默认操作*：
- en: 'a default constructor: `X()`'
  id: totrans-1673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数：`X()`
- en: 'a copy constructor: `X(const X&)`'
  id: totrans-1674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制构造函数：`X(const X&)`
- en: 'a copy assignment: `operator=(const X&)`'
  id: totrans-1675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制赋值运算符：`operator=(const X&)`
- en: 'a move constructor: `X(X&&)`'
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动构造函数：`X(X&&)`
- en: 'a move assignment: `operator=(X&&)`'
  id: totrans-1677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动赋值运算符：`operator=(X&&)`
- en: 'a destructor: `~X()`'
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数：`~X()`
- en: By default, the compiler defines each of these operations if it is used, but
    the default can be suppressed.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器会在使用时定义这些操作，但默认值可以被抑制。
- en: The default operations are a set of related operations that together implement
    the lifecycle semantics of an object. By default, C++ treats classes as value-like
    types, but not all types are value-like.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 默认操作是一组相关操作，共同实现对象的生存周期语义。默认情况下，C++将类视为类似值的类型，但并非所有类型都类似值。
- en: 'Set of default operations rules:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 默认操作集合规则：
- en: '[C.20: If you can avoid defining any default operations, do](#rc-zero)'
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.20: 如果可以避免定义任何默认操作，则这样做](#rc-zero)'
- en: '[C.21: If you define or `=delete` any copy, move, or destructor function, define
    or `=delete` them all](#rc-five)'
  id: totrans-1683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.21: 如果你定义或`=delete`任何复制、移动或析构函数，则定义或`=delete`它们所有](#rc-five)'
- en: '[C.22: Make default operations consistent](#rc-matched)'
  id: totrans-1684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.22: 使默认操作保持一致](#rc-matched)'
- en: 'Destructor rules:'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数规则：
- en: '[C.30: Define a destructor if a class needs an explicit action at object destruction](#rc-dtor)'
  id: totrans-1686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.30: 如果类在对象销毁时需要执行显式操作，则定义析构函数](#rc-dtor)'
- en: '[C.31: All resources acquired by a class must be released by the class’s destructor](#rc-dtor-release)'
  id: totrans-1687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.31: 类获取的所有资源都必须由类的析构函数释放](#rc-dtor-release)'
- en: '[C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether
    it might be owning](#rc-dtor-ptr)'
  id: totrans-1688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.32: 如果一个类有一个原始指针（`T*`）或引用（`T&`），考虑它是否可能是拥有的](#rc-dtor-ptr)'
- en: '[C.33: If a class has an owning pointer member, define a destructor](#rc-dtor-ptr2)'
  id: totrans-1689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.33: 如果一个类有一个拥有指针成员，则定义一个析构函数](#rc-dtor-ptr2)'
- en: '[C.35: A base class destructor should be either public and virtual, or protected
    and non-virtual](#rc-dtor-virtual)'
  id: totrans-1690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.35: 基类析构函数应该是公有和虚的，或者保护和非虚的](#rc-dtor-virtual)'
- en: '[C.36: A destructor must not fail](#rc-dtor-fail)'
  id: totrans-1691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.36: 析构函数必须不失败](#rc-dtor-fail)'
- en: '[C.37: Make destructors `noexcept`](#rc-dtor-noexcept)'
  id: totrans-1692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.37: 使析构函数`noexcept`](#rc-dtor-noexcept)'
- en: 'Constructor rules:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数规则：
- en: '[C.40: Define a constructor if a class has an invariant](#rc-ctor)'
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.40: 如果类有一个不变量，则定义构造函数](#rc-ctor)'
- en: '[C.41: A constructor should create a fully initialized object](#rc-complete)'
  id: totrans-1695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.41: 构造函数应该创建一个完全初始化的对象](#rc-complete)'
- en: '[C.42: If a constructor cannot construct a valid object, throw an exception](#rc-throw)'
  id: totrans-1696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.42: 如果构造函数无法构造一个有效的对象，则抛出异常](#rc-throw)'
- en: '[C.43: Ensure that a copyable class has a default constructor](#rc-default0)'
  id: totrans-1697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.43: 确保可复制的类有一个默认构造函数](#rc-default0)'
- en: '[C.44: Prefer default constructors to be simple and non-throwing](#rc-default00)'
  id: totrans-1698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.44: 优先使用简单且不抛出异常的默认构造函数](#rc-default00)'
- en: '[C.45: Don’t define a default constructor that only initializes data members;
    use member initializers instead](#rc-default)'
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.45: 不要定义只初始化数据成员的默认构造函数；使用成员初始化器代替](#rc-default)'
- en: '[C.46: By default, declare single-argument constructors `explicit`](#rc-explicit)'
  id: totrans-1700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.46: 默认情况下，声明单参数构造函数为`explicit`](#rc-explicit)'
- en: '[C.47: Define and initialize data members in the order of member declaration](#rc-order)'
  id: totrans-1701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.47: 按成员声明的顺序定义和初始化数据成员](#rc-order)'
- en: '[C.48: Prefer default member initializers to member initializers in constructors
    for constant initializers](#rc-in-class-initializer)'
  id: totrans-1702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.48: 优先使用构造函数中的默认成员初始化器而不是常量初始化器中的成员初始化器](#rc-in-class-initializer)'
- en: '[C.49: Prefer initialization to assignment in constructors](#rc-initialize)'
  id: totrans-1703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.49: 优先在构造函数中使用初始化而不是赋值](#rc-initialize)'
- en: '[C.50: Use a factory function if you need “virtual behavior” during initialization](#rc-factory)'
  id: totrans-1704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.50: 如果在初始化期间需要“虚拟行为”，则使用工厂函数](#rc-factory)'
- en: '[C.51: Use delegating constructors to represent common actions for all constructors
    of a class](#rc-delegating)'
  id: totrans-1705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.51: 使用委托构造函数来表示类中所有构造函数的常见操作](#rc-delegating)'
- en: '[C.52: Use inheriting constructors to import constructors into a derived class
    that does not need further explicit initialization](#rc-inheriting)'
  id: totrans-1706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.52: 使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类](#rc-inheriting)'
- en: 'Copy and move rules:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 复制和移动规则：
- en: '[C.60: Make copy assignment non-`virtual`, take the parameter by `const&`,
    and return by non-`const&`](#rc-copy-assignment)'
  id: totrans-1708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.60: 使复制赋值非`virtual`，通过`const&`接收参数，并通过非`const&`返回](#rc-copy-assignment)'
- en: '[C.61: A copy operation should copy](#rc-copy-semantic)'
  id: totrans-1709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.61: 复制操作应该复制](#rc-copy-semantic)'
- en: '[C.62: Make copy assignment safe for self-assignment](#rc-copy-self)'
  id: totrans-1710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.62: 使复制赋值对自赋值安全](#rc-copy-self)'
- en: '[C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and
    return by non-`const&`](#rc-move-assignment)'
  id: totrans-1711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.63: 将移动赋值操作设置为非`virtual`，通过`&&`接收参数，并通过非`const&`返回](#rc-move-assignment)'
- en: '[C.64: A move operation should move and leave its source in a valid state](#rc-move-semantic)'
  id: totrans-1712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.64: 移动操作应该移动并使其源处于有效状态](#rc-move-semantic)'
- en: '[C.65: Make move assignment safe for self-assignment](#rc-move-self)'
  id: totrans-1713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.65: 使移动赋值对自赋值安全](#rc-move-self)'
- en: '[C.66: Make move operations `noexcept`](#rc-move-noexcept)'
  id: totrans-1714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.66: 使移动操作 `noexcept`](#rc-move-noexcept)'
- en: '[C.67: A polymorphic class should suppress public copy/move](#rc-copy-virtual)'
  id: totrans-1715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.67: 多态类应抑制公共拷贝/移动](#rc-copy-virtual)'
- en: 'Other default operations rules:'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 其他默认操作规则：
- en: '[C.80: Use `=default` if you have to be explicit about using the default semantics](#rc-eqdefault)'
  id: totrans-1717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.80: 如果必须明确使用默认语义，请使用 `=default`](#rc-eqdefault)'
- en: '[C.81: Use `=delete` when you want to disable default behavior (without wanting
    an alternative)](#rc-delete)'
  id: totrans-1718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.81: 当你想禁用默认行为（而不想有替代方案）时，请使用 `=delete`](#rc-delete)'
- en: '[C.82: Don’t call virtual functions in constructors and destructors](#rc-ctor-virtual)'
  id: totrans-1719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.82: 不要在构造函数和析构函数中调用虚函数](#rc-ctor-virtual)'
- en: '[C.83: For value-like types, consider providing a `noexcept` swap function](#rc-swap)'
  id: totrans-1720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.83: 对于值类型，考虑提供一个 `noexcept` 交换函数](#rc-swap)'
- en: '[C.84: A `swap` must not fail](#rc-swap-fail)'
  id: totrans-1721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.84: `swap` 必须不失败](#rc-swap-fail)'
- en: '[C.85: Make `swap` `noexcept`](#rc-swap-noexcept)'
  id: totrans-1722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.85: 使 `swap` `noexcept`](#rc-swap-noexcept)'
- en: '[C.86: Make `==` symmetric with respect of operand types and `noexcept`](#rc-eq)'
  id: totrans-1723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.86: 使 `==` 在操作数类型和 `noexcept` 方面对称](#rc-eq)'
- en: '[C.87: Beware of `==` on base classes](#rc-eq-base)'
  id: totrans-1724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.87: 注意基类上的 `==`](#rc-eq-base)'
- en: '[C.89: Make a `hash` `noexcept`](#rc-hash)'
  id: totrans-1725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.89: 使 `hash` `noexcept`](#rc-hash)'
- en: '[C.90: Rely on constructors and assignment operators, not memset and memcpy](#rc-memset)'
  id: totrans-1726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.90: 依赖于构造函数和赋值运算符，而不是 memset 和 memcpy](#rc-memset)'
- en: 'C.defop: Default Operations'
  id: totrans-1727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'C.defop: 默认操作'
- en: By default, the language supplies the default operations with their default
    semantics. However, a programmer can disable or replace these defaults.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，语言为默认操作提供了默认语义。然而，程序员可以禁用或替换这些默认值。
- en: 'C.20: If you can avoid defining default operations, do'
  id: totrans-1729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.20: 如果可以避免定义默认操作，则执行'
- en: Reason
  id: totrans-1730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s the simplest and gives the cleanest semantics.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单且语义最清晰的。
- en: Example
  id: totrans-1732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE189]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Since `std::map` and `string` have all the special functions, no further work
    is needed.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `std::map` 和 `string` 都有所有特殊函数，不需要进一步工作。
- en: Note
  id: totrans-1735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is known as “the rule of zero”.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为“零法则”。
- en: Enforcement
  id: totrans-1737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Not enforceable) While not enforceable, a good static analyzer can detect patterns
    that indicate a possible improvement to meet this rule. For example, a class with
    a (pointer, size) pair of members and a destructor that `delete`s the pointer
    could probably be converted to a `vector`.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: （不可强制执行）虽然不可强制执行，但一个好的静态分析器可以检测出指示可能改进以符合此规则的模式。例如，一个具有（指针，大小）成员对和析构函数删除指针的类可能可以转换为
    `vector`。
- en: 'C.21: If you define or `=delete` any copy, move, or destructor function, define
    or `=delete` them all'
  id: totrans-1739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.21: 如果你定义或 `=delete` 任何拷贝、移动或析构函数，定义或 `=delete` 它们所有'
- en: Reason
  id: totrans-1740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The semantics of copy, move, and destruction are closely related, so if one
    needs to be declared, the odds are that others need consideration too.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 拷贝、移动和析构的语义密切相关，因此如果需要声明其中一个，那么其他也需要考虑的可能性很大。
- en: Declaring any copy/move/destructor function, even as `=default` or `=delete`,
    will suppress the implicit declaration of a move constructor and move assignment
    operator. Declaring a move constructor or move assignment operator, even as `=default`
    or `=delete`, will cause an implicitly generated copy constructor or implicitly
    generated copy assignment operator to be defined as deleted. So as soon as any
    of these are declared, the others should all be declared to avoid unwanted effects
    like turning all potential moves into more expensive copies, or making a class
    move-only.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 声明任何拷贝/移动/析构函数，即使是 `=default` 或 `=delete`，都将抑制移动构造函数和移动赋值运算符的隐式声明。声明移动构造函数或移动赋值运算符，即使是
    `=default` 或 `=delete`，都将导致隐式生成的拷贝构造函数或隐式生成的拷贝赋值运算符被定义为已删除。因此，一旦声明了这些中的任何一个，其他所有都应该声明，以避免产生不希望的效果，如将所有可能的移动转换为更昂贵的拷贝，或者使类成为仅移动的。
- en: Example, bad
  id: totrans-1743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE190]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Given that “special attention” was needed for the destructor (here, to deallocate),
    the likelihood that the implicitly-defined copy and move assignment operators
    will be correct is low (here, we would get double deletion).
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要“特别关注”析构函数（此处，用于释放资源），隐式定义的拷贝和移动赋值运算符很可能不正确（此处，我们将得到双重删除）。
- en: Note
  id: totrans-1746
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is known as “the rule of five.”
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为“五法则”。
- en: Note
  id: totrans-1748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you want a default implementation (while defining another), write `=default`
    to show you’re doing so intentionally for that function. If you don’t want a generated
    default function, suppress it with `=delete`.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提供一个默认实现（同时定义另一个），写`=default`以表明你故意为此函数这样做。如果你不希望生成默认函数，则使用`=delete`来抑制它。
- en: Example, good
  id: totrans-1750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: When a destructor needs to be declared just to make it `virtual`, it can be
    defined as defaulted.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 当析构函数需要声明只是为了使其`virtual`时，它可以定义为默认的。
- en: '[PRE191]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'To prevent slicing as per [C.67](#rc-copy-virtual), make the copy and move
    operations protected or `=delete`d, and add a `clone`:'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止切片，根据[C.67](#rc-copy-virtual)，使复制和移动操作受保护或`=delete`，并添加一个`clone`：
- en: '[PRE192]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Defining only the move operations or only the copy operations would have the
    same effect here, but stating the intent explicitly for each special member makes
    it more obvious to the reader.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 仅定义移动操作或仅定义复制操作在这里会产生相同的效果，但为每个特殊成员明确声明意图会使读者更容易理解。
- en: Note
  id: totrans-1756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Compilers enforce much of this rule and ideally warn about any violation.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器强制执行大部分这些规则，并在理想情况下警告任何违规行为。
- en: Note
  id: totrans-1758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Relying on an implicitly generated copy operation in a class with a destructor
    is deprecated.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有析构函数的类中依赖于隐式生成的复制操作已被弃用。
- en: Note
  id: totrans-1760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Writing these functions can be error-prone. Note their argument types:'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这些函数可能会出错。注意它们的参数类型：
- en: '[PRE193]'
  id: totrans-1762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: A minor mistake (such as a misspelling, leaving out a `const`, using `&` instead
    of `&&`, or leaving out a special function) can lead to errors or warnings. To
    avoid the tedium and the possibility of errors, try to follow the [rule of zero](#rc-zero).
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小错误（如拼写错误、省略`const`、使用`&`而不是`&&`或省略特殊函数）可能导致错误或警告。为了避免乏味和错误的可能性，尽量遵循[零规则](#rc-zero)。
- en: Enforcement
  id: totrans-1764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) A class should have a declaration (even a `=delete` one) for either
    all or none of the copy/move/destructor functions.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）一个类应该为所有或没有复制/移动/析构函数声明（即使是一个`=delete`声明）。
- en: 'C.22: Make default operations consistent'
  id: totrans-1766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.22：使默认操作保持一致
- en: Reason
  id: totrans-1767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The default operations are conceptually a matched set. Their semantics are interrelated.
    Users will be surprised if copy/move construction and copy/move assignment do
    logically different things. Users will be surprised if constructors and destructors
    do not provide a consistent view of resource management. Users will be surprised
    if copy and move don’t reflect the way constructors and destructors work.
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 默认操作在概念上是一组匹配的集合。它们的语义是相互关联的。如果复制/移动构造和复制/移动赋值在逻辑上做不同的事情，用户会感到惊讶。如果构造函数和析构函数不提供资源管理的统一视图，用户会感到惊讶。如果复制和移动没有反映构造函数和析构函数的工作方式，用户会感到惊讶。
- en: Example, bad
  id: totrans-1769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE194]'
  id: totrans-1770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: These operations disagree about copy semantics. This will lead to confusion
    and bugs.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作对复制语义有不同意见。这将导致混淆和错误。
- en: Enforcement
  id: totrans-1772
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Complex) A copy/move constructor and the corresponding copy/move assignment
    operator should write to the same data members at the same level of dereference.
  id: totrans-1773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （复杂）复制/移动构造函数和相应的复制/移动赋值运算符应该写入同一级别的同一数据成员。
- en: (Complex) Any data members written in a copy/move constructor should also be
    initialized by all other constructors.
  id: totrans-1774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （复杂）任何在复制/移动构造函数中编写的成员数据也应该由所有其他构造函数初始化。
- en: (Complex) If a copy/move constructor performs a deep copy of a data member,
    then the destructor should modify the data member.
  id: totrans-1775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （复杂）如果复制/移动构造函数对数据成员执行深拷贝，则析构函数应修改该数据成员。
- en: (Complex) If a destructor is modifying a data member, that data member should
    be written in any copy/move constructors or assignment operators.
  id: totrans-1776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （复杂）如果析构函数正在修改数据成员，则该数据成员应该在任何复制/移动构造函数或赋值运算符中编写。
- en: 'C.dtor: Destructors'
  id: totrans-1777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'C.dtor: 析构函数'
- en: “Does this class need a destructor?” is a surprisingly insightful design question.
    For most classes the answer is “no” either because the class holds no resources
    or because destruction is handled by [the rule of zero](#rc-zero); that is, its
    members can take care of themselves as concerns destruction. If the answer is
    “yes”, much of the design of the class follows (see [the rule of five](#rc-five)).
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: “这个类需要析构函数吗？”是一个令人惊讶的见解设计问题。对于大多数类，答案是“不”，要么是因为类不持有资源，要么是因为销毁由[零规则](#rc-zero)处理；也就是说，其成员可以自己处理销毁问题。如果答案是“是”，则类的许多设计都遵循（参见[五规则](#rc-five))。
- en: 'C.30: Define a destructor if a class needs an explicit action at object destruction'
  id: totrans-1779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.30：如果类需要在对象销毁时执行显式操作，则定义一个析构函数
- en: Reason
  id: totrans-1780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A destructor is implicitly invoked at the end of an object’s lifetime. If the
    default destructor is sufficient, use it. Only define a non-default destructor
    if a class needs to execute code that is not already part of its members’ destructors.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数在对象的寿命结束时隐式调用。如果默认析构函数足够，就使用它。只有当类需要执行其成员析构函数中尚未包含的代码时，才定义非默认析构函数。
- en: Example
  id: totrans-1782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE195]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The whole purpose of `final_action` is to get a piece of code (usually a lambda)
    executed upon destruction.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: '`final_action` 的整个目的就是在析构时执行一段代码（通常是lambda表达式）。'
- en: Note
  id: totrans-1785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two general categories of classes that need a user-defined destructor:'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 需要用户定义析构函数的类通常分为两大类：
- en: A class with a resource that is not already represented as a class with a destructor,
    e.g., a `vector` or a transaction class.
  id: totrans-1787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有未作为具有析构函数的类表示的资源（例如，`vector` 或事务类）的类。
- en: A class that exists primarily to execute an action upon destruction, such as
    a tracer or `final_action`.
  id: totrans-1788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要用于在析构时执行某个动作的类，例如跟踪器或 `final_action`。
- en: Example, bad
  id: totrans-1789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE196]'
  id: totrans-1790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The default destructor does it better, more efficiently, and can’t get it wrong.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 默认析构函数做得更好，更高效，而且不会出错。
- en: Enforcement
  id: totrans-1792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look for likely “implicit resources”, such as pointers and references. Look
    for classes with destructors even though all their data members have destructors.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找可能的“隐式资源”，例如指针和引用。寻找即使所有数据成员都有析构函数的类。
- en: 'C.31: All resources acquired by a class must be released by the class’s destructor'
  id: totrans-1794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.31：一个类获取的所有资源都必须由该类的析构函数释放
- en: Reason
  id: totrans-1795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Prevention of resource leaks, especially in error cases.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 防止资源泄露，尤其是在错误情况下。
- en: Note
  id: totrans-1797
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For resources represented as classes with a complete set of default operations,
    this happens automatically.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表示为具有完整默认操作的类的资源，这会自动发生。
- en: Example
  id: totrans-1799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE197]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '`X`’s `ifstream` implicitly closes any file it might have open upon destruction
    of its `X`.'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: '`X` 的 `ifstream` 在其 `X` 析构时隐式关闭任何可能打开的文件。'
- en: Example, bad
  id: totrans-1802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE198]'
  id: totrans-1803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '`X2` might leak a file handle.'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: '`X2` 可能会泄漏文件句柄。'
- en: Note
  id: totrans-1805
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: What about a socket that won’t close? A destructor, close, or cleanup operation
    [should never fail](#rc-dtor-fail). If it does nevertheless, we have a problem
    that has no really good solution. For starters, the writer of a destructor does
    not know why the destructor is called and cannot “refuse to act” by throwing an
    exception. See [discussion](#sd-never-fail). To make the problem worse, many “close/release”
    operations are not retryable. Many have tried to solve this problem, but no general
    solution is known. If at all possible, consider failure to close/clean up a fundamental
    design error and terminate.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个不会关闭的套接字怎么办？析构函数、关闭或清理操作 [永远不应该失败](#rc-dtor-fail)。如果它确实失败了，我们有一个没有真正好解决方案的问题。首先，析构函数的编写者不知道析构函数为什么被调用，并且不能通过抛出异常来“拒绝行动”。参见
    [讨论](#sd-never-fail)。为了使问题更糟，许多“关闭/释放”操作是不可重试的。许多人试图解决这个问题，但还没有找到通用的解决方案。如果可能的话，考虑关闭/清理失败是一个基本的设计错误，并终止。
- en: Note
  id: totrans-1807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A class can hold pointers and references to objects that it does not own. Obviously,
    such objects should not be `delete`d by the class’s destructor. For example:'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以持有它不拥有的对象的指针和引用。显然，这样的对象不应该由类的析构函数 `delete`。例如：
- en: '[PRE199]'
  id: totrans-1809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Here `p` refers to `pp` but does not own it.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里 `p` 指的是 `pp` 但并不拥有它。
- en: Enforcement
  id: totrans-1811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) If a class has pointer or reference members that are owners (e.g.,
    deemed owners by using `gsl::owner`), then they should be referenced in its destructor.
  id: totrans-1812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果一个类有指针或引用成员是所有者（例如，通过使用 `gsl::owner` 被认为是所有者），那么它们应该在析构函数中引用。
- en: (Hard) Determine if pointer or reference members are owners when there is no
    explicit statement of ownership (e.g., look into the constructors).
  id: totrans-1813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （困难）在没有明确声明所有权的情况下（例如，查看构造函数），确定指针或引用成员是否是所有者。
- en: 'C.32: If a class has a raw pointer (`T*`) or reference (`T&`), consider whether
    it might be owning'
  id: totrans-1814
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.32：如果一个类有一个原始指针 (`T*`) 或引用 (`T&`)，考虑它是否可能是所有者
- en: Reason
  id: totrans-1815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: There is a lot of code that is non-specific about ownership.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多代码在所有权方面并不明确。
- en: Example
  id: totrans-1817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE200]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The only way to determine ownership may be code analysis.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 确定所有权的唯一方法可能是代码分析。
- en: Note
  id: totrans-1820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Ownership should be clear in new code (and refactored legacy code) according
    to [R.20](#rr-owner) for owning pointers and [R.3](#rr-ptr) for non-owning pointers.
    References should never own [R.4](#rr-ref).
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 根据R.20 [R.20](#rr-owner) 对于拥有指针和R.3 [R.3](#rr-ptr) 对于非拥有指针，新代码（以及重构后的遗留代码）中的所有权应该是明确的。引用永远不应该拥有
    [R.4](#rr-ref)。
- en: Enforcement
  id: totrans-1822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look at the initialization of raw member pointers and member references and
    see if an allocation is used.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 查看原始成员指针和成员引用的初始化，看看是否使用了分配。
- en: 'C.33: If a class has an owning pointer member, define a destructor'
  id: totrans-1824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.33：如果一个类有一个拥有指针成员，则定义一个析构函数
- en: Reason
  id: totrans-1825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An owned object must be `delete`d upon destruction of the object that owns it.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 当拥有它的对象被销毁时，必须对拥有的对象进行`delete`操作。
- en: Example
  id: totrans-1827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: A pointer member could represent a resource. [A `T*` should not do so](#rr-ptr),
    but in older code, that’s common. Consider a `T*` a possible owner and therefore
    suspect.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 指针成员可以表示资源。[一个`T*`不应该这样做](#rr-ptr)，但在旧代码中，这是常见的。将`T*`视为可能的拥有者，因此要怀疑。
- en: '[PRE201]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Note that if you define a destructor, you must define or delete [all default
    operations](#rc-five):'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你定义了一个析构函数，你必须定义或删除[所有默认操作](#rc-five)：
- en: '[PRE202]'
  id: totrans-1831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The default copy operation will just copy the `p1.p` into `p2.p` leading to
    a double destruction of `p1.p`. Be explicit about ownership:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的复制操作只会将`p1.p`复制到`p2.p`中，从而导致`p1.p`的双重销毁。请明确指出所有权：
- en: '[PRE203]'
  id: totrans-1833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Note
  id: totrans-1834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Often the simplest way to get a destructor is to replace the pointer with a
    smart pointer (e.g., `std::unique_ptr`) and let the compiler arrange for proper
    destruction to be done implicitly.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 获取析构函数最简单的方法通常是替换指针为智能指针（例如，`std::unique_ptr`），并让编译器安排隐式地进行适当的销毁。
- en: Note
  id: totrans-1836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Why not just require all owning pointers to be “smart pointers”? That would
    sometimes require non-trivial code changes and might affect ABIs.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不要求所有拥有指针的都使用“智能指针”？这有时需要非平凡的代码更改，可能会影响ABIs。
- en: Enforcement
  id: totrans-1838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: A class with a pointer data member is suspect.
  id: totrans-1839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有指针数据成员的类是可疑的。
- en: A class with an `owner<T>` should define its default operations.
  id: totrans-1840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`owner<T>`的类应该定义其默认操作。
- en: 'C.35: A base class destructor should be either public and virtual, or protected
    and non-virtual'
  id: totrans-1841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.35：基类的析构函数应该是公有的和虚的，或者受保护的和非虚的
- en: Reason
  id: totrans-1842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To prevent undefined behavior. If the destructor is public, then calling code
    can attempt to destroy a derived class object through a base class pointer, and
    the result is undefined if the base class’s destructor is non-virtual. If the
    destructor is protected, then calling code cannot destroy through a base class
    pointer and the destructor does not need to be virtual; it does need to be protected,
    not private, so that derived destructors can invoke it. In general, the writer
    of a base class does not know the appropriate action to be done upon destruction.
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止未定义行为。如果析构函数是公有的，那么调用代码可以通过基类指针尝试销毁派生类对象，如果基类的析构函数是非虚的，则结果将是未定义的。如果析构函数是受保护的，那么调用代码不能通过基类指针进行销毁，并且析构函数不需要是虚的；它确实需要是受保护的，而不是私有的，这样派生类的析构函数才能调用它。一般来说，基类的编写者不知道在销毁时应该采取适当的行动。
- en: Discussion
  id: totrans-1844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: See [this in the Discussion section](#sd-dtor).
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 见[讨论部分中的此内容](#sd-dtor)。
- en: Example, bad
  id: totrans-1846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE204]'
  id: totrans-1847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Note
  id: totrans-1848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A virtual function defines an interface to derived classes that can be used
    without looking at the derived classes. If the interface allows destroying, it
    should be safe to do so.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数定义了一个接口，该接口可以用于派生类，而无需查看派生类。如果接口允许销毁，那么这样做应该是安全的。
- en: Note
  id: totrans-1850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A destructor must be non-private or it will prevent using the type:'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数必须不是私有的，否则将阻止使用该类型：
- en: '[PRE205]'
  id: totrans-1852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Exception
  id: totrans-1853
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'We can imagine one case where you could want a protected virtual destructor:
    When an object of a derived type (and only of such a type) should be allowed to
    destroy *another* object (not itself) through a pointer to base. We haven’t seen
    such a case in practice, though.'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一种情况，你可能想要一个受保护的虚析构函数：当一个派生类型的对象（仅限于这种类型）应该允许通过指向基的指针销毁*另一个*对象（而不是自身）。尽管我们在实践中没有看到这样的案例。
- en: Enforcement
  id: totrans-1855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: A class with any virtual functions should have a destructor that is either public
    and virtual or else protected and non-virtual.
  id: totrans-1856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何具有虚函数的类都应该有一个既是公有的又是虚的，或者既是受保护的又是非虚的析构函数。
- en: If a class inherits publicly from a base class, the base class should have a
    destructor that is either public and virtual or else protected and non-virtual.
  id: totrans-1857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类公开继承自基类，则基类应该有一个既是公有的又是虚的析构函数，或者既是受保护的又是非虚的。
- en: 'C.36: A destructor must not fail'
  id: totrans-1858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.36：析构函数不能失败
- en: Reason
  id: totrans-1859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: In general we do not know how to write error-free code if a destructor should
    fail. The standard library requires that all classes it deals with have destructors
    that do not exit by throwing.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果析构函数应该失败，我们不知道如何编写无错误的代码。标准库要求它处理的类都有不通过抛出退出其析构函数的析构函数。
- en: Example
  id: totrans-1861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE206]'
  id: totrans-1862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Note
  id: totrans-1863
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Many have tried to devise a fool-proof scheme for dealing with failure in destructors.
    None have succeeded to come up with a general scheme. This can be a real practical
    problem: For example, what about a socket that won’t close? The writer of a destructor
    does not know why the destructor is called and cannot “refuse to act” by throwing
    an exception. See [discussion](#sd-never-fail). To make the problem worse, many
    “close/release” operations are not retryable. If at all possible, consider failure
    to close/clean up a fundamental design error and terminate.'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人试图设计一种万无一失的方案来处理析构函数中的失败。没有人成功提出一个通用的方案。这可能是一个真正的实际问题：例如，如果套接字无法关闭怎么办？析构函数的编写者不知道析构函数为什么被调用，并且不能通过抛出异常来“拒绝行动”。参见[讨论](#sd-never-fail)。使问题更糟的是，许多“关闭/释放”操作是不可重试的。如果可能的话，考虑关闭/清理失败是一个基本的设计错误，并终止程序。
- en: Note
  id: totrans-1865
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Declare a destructor `noexcept`. That will ensure that it either completes normally
    or terminates the program.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 声明析构函数为`noexcept`。这将确保它要么正常完成，要么终止程序。
- en: Note
  id: totrans-1867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If a resource cannot be released and the program must not fail, try to signal
    the failure to the rest of the system somehow (maybe even by modifying some global
    state and hope something will notice and be able to take care of the problem).
    Be fully aware that this technique is special-purpose and error-prone. Consider
    the “my connection will not close” example. Probably there is a problem at the
    other end of the connection and only a piece of code responsible for both ends
    of the connection can properly handle the problem. The destructor could send a
    message (somehow) to the responsible part of the system, consider that to have
    closed the connection, and return normally.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源无法释放且程序不能失败，尝试以某种方式向系统的其余部分发出失败信号（也许甚至通过修改某些全局状态并希望有人会注意到并能够处理这个问题）。请充分意识到这种技术是专门用途且容易出错的。考虑“我的连接不会关闭”的例子。可能连接的另一端存在问题，只有负责连接两端的代码才能正确处理这个问题。析构函数可以通过某种方式向系统的责任部分发送消息，认为连接已经关闭，并正常返回。
- en: Note
  id: totrans-1869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If a destructor uses operations that could fail, it can catch exceptions and
    in some cases still complete successfully (e.g., by using a different clean-up
    mechanism from the one that threw an exception).
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 如果析构函数使用了可能会失败的操作，它可以捕获异常，并在某些情况下仍然可以成功完成（例如，通过使用与抛出异常的操作不同的清理机制）。
- en: Enforcement
  id: totrans-1871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: (Simple) A destructor should be declared `noexcept` if it could throw.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 如果析构函数可能会抛出异常，则应该声明为`noexcept`。
- en: 'C.37: Make destructors `noexcept`'
  id: totrans-1873
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.37: 使析构函数`noexcept`'
- en: Reason
  id: totrans-1874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '[A destructor must not fail](#rc-dtor-fail). If a destructor tries to exit
    with an exception, it’s a bad design error and the program had better terminate.'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: '[析构函数不得失败](#rc-dtor-fail)。如果析构函数尝试通过异常退出，这是一个设计错误，程序最好终止。'
- en: Note
  id: totrans-1876
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A destructor (either user-defined or compiler-generated) is implicitly declared
    `noexcept` (independently of what code is in its body) if all of the members of
    its class have `noexcept` destructors. By explicitly marking destructors `noexcept`,
    an author guards against the destructor becoming implicitly `noexcept(false)`
    through the addition or modification of a class member.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个析构函数的所有成员都具有`noexcept`析构函数，则析构函数（无论是用户定义的还是编译器生成的）会隐式声明为`noexcept`（与其体内的代码无关）。通过显式标记析构函数为`noexcept`，作者可以防止析构函数通过添加或修改类成员而隐式地变为`noexcept(false)`。
- en: Example
  id: totrans-1878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Not all destructors are noexcept by default; one throwing member poisons the
    whole class hierarchy
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有析构函数默认都是noexcept；一个抛出异常的成员函数会污染整个类层次结构
- en: '[PRE207]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: So, if in doubt, declare a destructor noexcept.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有疑问，应该声明析构函数为noexcept。
- en: Note
  id: totrans-1882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Why not then declare all destructors noexcept? Because that would in many cases
    – especially simple cases – be distracting clutter.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不将所有析构函数都声明为noexcept呢？因为在许多情况下——尤其是简单情况下——这会分散注意力，造成混乱。
- en: Enforcement
  id: totrans-1884
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: (Simple) A destructor should be declared `noexcept` if it could throw.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 如果析构函数可能会抛出异常，则应该声明为`noexcept`。
- en: 'C.ctor: Constructors'
  id: totrans-1886
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'C.ctor: 构造函数'
- en: A constructor defines how an object is initialized (constructed).
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数定义了对象是如何初始化（构造）的。
- en: 'C.40: Define a constructor if a class has an invariant'
  id: totrans-1888
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.40: 如果一个类有不变性，则定义构造函数'
- en: Reason
  id: totrans-1889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That’s what constructors are for.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是构造函数的作用所在。
- en: Example
  id: totrans-1891
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE208]'
  id: totrans-1892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: It is often a good idea to express the invariant as an `Ensures` on the constructor.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将不变性表达为构造函数上的`Ensures`是一个好主意。
- en: Note
  id: totrans-1894
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A constructor can be used for convenience even if a class does not have an
    invariant. For example:'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个类没有不变性，构造函数也可以用于方便。例如：
- en: '[PRE209]'
  id: totrans-1896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Note
  id: totrans-1897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The C++11 initializer list rule eliminates the need for many constructors.
    For example:'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的初始化列表规则消除了许多构造函数的需求。例如：
- en: '[PRE210]'
  id: totrans-1899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The `Rec2` constructor is redundant. Also, the default for `int` would be better
    done as a [default member initializer](#rc-in-class-initializer).
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rec2`构造函数是多余的。此外，对于`int`类型的默认值，最好使用[默认成员初始化](#rc-in-class-initializer)。'
- en: '**See also**: [construct valid object](#rc-complete) and [constructor throws](#rc-throw).'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [构造有效对象](#rc-complete) 和 [构造函数抛出异常](#rc-throw)。'
- en: Enforcement
  id: totrans-1902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag classes with user-defined copy operations but no constructor (a user-defined
    copy is a good indicator that the class has an invariant)
  id: totrans-1903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记具有用户定义的复制操作但没有构造函数的类（用户定义的复制是类具有不变性的良好指标）
- en: 'C.41: A constructor should create a fully initialized object'
  id: totrans-1904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.41：构造函数应该创建一个完全初始化的对象
- en: Reason
  id: totrans-1905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A constructor establishes the invariant for a class. A user of a class should
    be able to assume that a constructed object is usable.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数为类建立不变性。类的用户应该能够假设一个构造的对象是可以使用的。
- en: Example, bad
  id: totrans-1907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE211]'
  id: totrans-1908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Compilers do not read comments.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不读取注释。
- en: Exception
  id: totrans-1910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: If a valid object cannot conveniently be constructed by a constructor, [use
    a factory function](#rc-factory).
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法方便地通过构造函数构造一个有效对象，[使用工厂函数](#rc-factory)。
- en: Enforcement
  id: totrans-1912
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Every constructor should initialize every data member (either explicitly,
    via a delegating ctor call or via default construction).
  id: totrans-1913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 每个构造函数都应该初始化每个数据成员（无论是通过委托构造函数调用还是通过默认构造）。
- en: (Unknown) If a constructor has an `Ensures` contract, try to see if it holds
    as a postcondition.
  id: totrans-1914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (未知) 如果构造函数有一个`Ensures`合同，尝试查看它是否作为后置条件成立。
- en: Note
  id: totrans-1915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If a constructor acquires a resource (to create a valid object), that resource
    should be [released by the destructor](#rc-dtor-release). The idiom of having
    constructors acquire resources and destructors release them is called [RAII](#rr-raii)
    (“Resource Acquisition Is Initialization”).
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数获取资源（以创建一个有效对象），则该资源应该由[析构函数释放](#rc-dtor-release)。构造函数获取资源而析构函数释放它们的习语称为[RAII](#rr-raii)（“资源获取即初始化”）。
- en: 'C.42: If a constructor cannot construct a valid object, throw an exception'
  id: totrans-1917
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.42：如果构造函数无法构造一个有效对象，则抛出异常
- en: Reason
  id: totrans-1918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Leaving behind an invalid object is asking for trouble.
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 留下一个无效对象是自找麻烦。
- en: Example
  id: totrans-1920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE212]'
  id: totrans-1921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Example, bad
  id: totrans-1922
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE213]'
  id: totrans-1923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Note
  id: totrans-1924
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For a variable definition (e.g., on the stack or as a member of another object)
    there is no explicit function call from which an error code could be returned.
    Leaving behind an invalid object and relying on users to consistently check an
    `is_valid()` function before use is tedious, error-prone, and inefficient.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变量定义（例如，在栈上或作为另一个对象的成员），没有显式的函数调用可以返回错误代码。留下一个无效对象并依赖用户在使用前始终检查`is_valid()`函数是繁琐的、容易出错的，并且效率低下。
- en: Exception
  id: totrans-1926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: There are domains, such as some hard-real-time systems (think airplane controls)
    where (without additional tool support) exception handling is not sufficiently
    predictable from a timing perspective. There the `is_valid()` technique must be
    used. In such cases, check `is_valid()` consistently and immediately to simulate
    [RAII](#rr-raii).
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些领域，例如某些硬实时系统（例如飞机控制），在没有额外工具支持的情况下，异常处理在时间方面不可预测。在那里，必须使用`is_valid()`技术。在这种情况下，始终并立即检查`is_valid()`以模拟[RAII](#rr-raii)。
- en: Alternative
  id: totrans-1928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: If you feel tempted to use some “post-constructor initialization” or “two-stage
    initialization” idiom, try not to do that. If you really have to, look at [factory
    functions](#rc-factory).
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到想要使用一些“后构造初始化”或“两阶段初始化”习语，尽量不要这样做。如果你真的必须这样做，看看[工厂函数](#rc-factory)。
- en: Note
  id: totrans-1930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: One reason people have used `init()` functions rather than doing the initialization
    work in a constructor has been to avoid code replication. [Delegating constructors](#rc-delegating)
    and [default member initialization](#rc-in-class-initializer) do that better.
    Another reason has been to delay initialization until an object is needed; the
    solution to that is often [not to declare a variable until it can be properly
    initialized](#res-init).
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 人们使用`init()`函数而不是在构造函数中执行初始化工作的一个原因是为了避免代码重复。[委托构造函数](#rc-delegating)和[默认成员初始化](#rc-in-class-initializer)做得更好。另一个原因是为了延迟初始化直到需要对象；解决这个问题的方法通常是[不在可以正确初始化之前声明变量](#res-init)。
- en: Enforcement
  id: totrans-1932
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.43: Ensure that a copyable class has a default constructor'
  id: totrans-1934
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.43：确保可复制类有一个默认构造函数
- en: Reason
  id: totrans-1935
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That is, ensure that if a concrete class is copyable it also satisfies the rest
    of “semiregular.”
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 即，确保如果具体类是可复制的，它也满足“半正规”的其他要求。
- en: Many language and library facilities rely on default constructors to initialize
    their elements, e.g. `T a[10]` and `std::vector<T> v(10)`. A default constructor
    often simplifies the task of defining a suitable [moved-from state](#???) for
    a type that is also copyable.
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言和库功能依赖于默认构造函数来初始化它们的元素，例如 `T a[10]` 和 `std::vector<T> v(10)`。默认构造函数通常简化了为也是可复制的类型定义合适的
    [已移动状态](#???) 的任务。
- en: Example
  id: totrans-1938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE214]'
  id: totrans-1939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: The default constructor is only auto-generated if there is no user-declared
    constructor, hence it’s impossible to initialize the vector `vd1` in the example
    above. The absence of a default value can cause surprises for users and complicate
    its use, so if one can be reasonably defined, it should be.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数仅在不存在用户声明的构造函数时才会自动生成，因此在上面的示例中无法初始化向量 `vd1`。默认值的缺失可能会给用户带来惊喜并使使用变得复杂，因此如果可以合理地定义，则应该定义。
- en: '`Date` is chosen to encourage thought: There is no “natural” default date (the
    big bang is too far back in time to be useful for most people), so this example
    is non-trivial. `{0, 0, 0}` is not a valid date in most calendar systems, so choosing
    that would be introducing something like floating-point’s `NaN`. However, most
    realistic `Date` classes have a “first date” (e.g. January 1, 1970 is popular),
    so making that the default is usually trivial.'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date` 是为了鼓励思考而选择的：没有“自然”的默认日期（大爆炸发生在太早以前，对大多数人来说没有用），因此这个例子是非平凡的。`{0, 0, 0}`
    在大多数日历系统中不是一个有效的日期，因此选择它就像引入了类似浮点数的 `NaN`。然而，大多数现实的 `Date` 类都有一个“第一个日期”（例如，1970年1月1日很受欢迎），因此将其作为默认值通常是微不足道的。'
- en: '[PRE215]'
  id: totrans-1942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Note
  id: totrans-1943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A class with members that all have default constructors implicitly gets a default
    constructor:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成员都具有默认构造函数的类的默认构造函数隐式获得：
- en: '[PRE216]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Beware that built-in types are not properly default constructed:'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，内置类型并没有正确地进行默认构造：
- en: '[PRE217]'
  id: totrans-1947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Statically allocated objects of built-in types are by default initialized to
    `0`, but local built-in variables are not. Beware that your compiler might default
    initialize local built-in variables, whereas an optimized build will not. Thus,
    code like the example above might appear to work, but it relies on undefined behavior.
    Assuming that you want initialization, an explicit default initialization can
    help:'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配的内置类型对象默认初始化为 `0`，但局部内置变量不是。注意，您的编译器可能会默认初始化局部内置变量，而优化构建则不会。因此，上面的示例代码可能看起来可以工作，但它依赖于未定义的行为。假设您想要初始化，显式默认初始化可能会有所帮助：
- en: '[PRE218]'
  id: totrans-1949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Notes
  id: totrans-1950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Classes that don’t have a reasonable default construction are usually not copyable
    either, so they don’t fall under this guideline.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 没有合理默认构造的类通常也不可复制，因此它们不适用于此指南。
- en: 'For example, a base class should not be copyable, and so does not necessarily
    need a default constructor:'
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，基类不应该可复制，因此不一定需要默认构造函数：
- en: '[PRE219]'
  id: totrans-1953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'A class that must acquire a caller-provided resource during construction often
    cannot have a default constructor, but it does not fall under this guideline because
    such a class is usually not copyable anyway:'
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造过程中必须获取调用者提供的资源的类通常不能有默认构造函数，但它不适用于此指南，因为此类通常也不可复制：
- en: '[PRE220]'
  id: totrans-1955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'A class that has a “special state” that must be handled separately from other
    states by member functions or users causes extra work (and most likely more errors).
    Such a type can naturally use the special state as a default constructed value,
    whether or not it is copyable:'
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有“特殊状态”的类，该状态必须通过成员函数或用户与其他状态分开处理，这会导致额外的工作（并且很可能会出现更多错误）。这种类型可以自然地将特殊状态用作默认构造值，无论它是否可复制：
- en: '[PRE221]'
  id: totrans-1957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Similar special-state types that are copyable, such as copyable smart pointers
    that have the special state “==nullptr”, should use the special state as their
    default constructed value.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 类似可复制的特殊状态类型，例如具有特殊状态“==nullptr”的可复制智能指针，应使用特殊状态作为它们的默认构造值。
- en: However, it is preferable to have a default constructor default to a meaningful
    state such as `std::string`s `""` and `std::vector`s `{}`.
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好让默认构造函数默认到一个有意义的初始状态，例如 `std::string`s 的 `""` 和 `std::vector`s 的 `{}`。
- en: Enforcement
  id: totrans-1960
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag classes that are copyable by `=` without a default constructor
  id: totrans-1961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可通过 `=` 复制但没有默认构造函数的标志类
- en: Flag classes that are comparable with `==` but not copyable
  id: totrans-1962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可与 `==` 比较但不可复制的标志类
- en: 'C.44: Prefer default constructors to be simple and non-throwing'
  id: totrans-1963
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.44：优先考虑简单且非抛出异常的默认构造函数
- en: Reason
  id: totrans-1964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Being able to set a value to “the default” without operations that might fail
    simplifies error handling and reasoning about move operations.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不进行可能失败的操作的情况下将值设置为“默认值”简化了错误处理和对移动操作的推理。
- en: Example, problematic
  id: totrans-1966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，有问题的
- en: '[PRE222]'
  id: totrans-1967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: This is nice and general, but setting a `Vector0` to empty after an error involves
    an allocation, which might fail. Also, having a default `Vector` represented as
    `{new T[0], 0, 0}` seems wasteful. For example, `Vector0<int> v[100]` costs 100
    allocations.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好且很通用，但在错误发生后将 `Vector0` 设置为空涉及到分配，可能会失败。此外，将默认 `Vector` 表示为 `{new T[0], 0,
    0}` 似乎很浪费。例如，`Vector0<int> v[100]` 成本为 100 次分配。
- en: Example
  id: totrans-1969
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE223]'
  id: totrans-1970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Using `{nullptr, nullptr, nullptr}` makes `Vector1{}` cheap, but a special case
    and implies run-time checks. Setting a `Vector1` to empty after detecting an error
    is trivial.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `{nullptr, nullptr, nullptr}` 使得 `Vector1{}` 成本低廉，但这是一个特殊情况，并暗示了运行时检查。在检测到错误后将
    `Vector1` 设置为空是微不足道的。
- en: Enforcement
  id: totrans-1972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag throwing default constructors
  id: totrans-1973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记抛出默认构造函数
- en: 'C.45: Don’t define a default constructor that only initializes data members;
    use default member initializers instead'
  id: totrans-1974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.45: 不要定义仅初始化数据成员的默认构造函数；使用默认成员初始化器代替'
- en: Reason
  id: totrans-1975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using default member initializers lets the compiler generate the function for
    you. The compiler-generated function can be more efficient.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认成员初始化器可以让编译器为你生成函数。编译器生成的函数可能更高效。
- en: Example, bad
  id: totrans-1977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE224]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Example
  id: totrans-1979
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE225]'
  id: totrans-1980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Enforcement
  id: totrans-1981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) Flag if a default constructor’s explicit member initializer is a constant,
    and recommend that the constant should be written as a data member initializer
    instead.
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 如果默认构造函数的显式成员初始化器是一个常量，则标记该常量，并建议将常量作为数据成员初始化器来编写。
- en: 'C.46: By default, declare single-argument constructors explicit'
  id: totrans-1983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.46: 默认情况下，声明单参数构造函数为 `explicit`'
- en: Reason
  id: totrans-1984
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid unintended conversions.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外的转换。
- en: Example, bad
  id: totrans-1986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE226]'
  id: totrans-1987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Exception
  id: totrans-1988
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'If you really want an implicit conversion from the constructor argument type
    to the class type, don’t use `explicit`:'
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想要从构造函数参数类型到类类型的隐式转换，不要使用 `explicit`：
- en: '[PRE227]'
  id: totrans-1990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '**See also**: [Discussion of implicit conversions](#ro-conversion)'
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [隐式转换的讨论](#ro-conversion)'
- en: Note
  id: totrans-1992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Copy and move constructors should not be made `explicit` because they do not
    perform conversions. Explicit copy/move constructors make passing and returning
    by value difficult.
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数和移动构造函数不应声明为 `explicit`，因为它们不执行转换。显式复制/移动构造函数使按值传递和返回变得困难。
- en: Enforcement
  id: totrans-1994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) Single-argument constructors should be declared `explicit`. Good single
    argument non-`explicit` constructors are rare in most code bases. Warn for all
    that are not on a “positive list”.
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 单参数构造函数应声明为 `explicit`。大多数代码库中很少见好的非 `explicit` 单参数构造函数。对于不在“正面列表”上的所有这些函数发出警告。
- en: 'C.47: Define and initialize data members in the order of member declaration'
  id: totrans-1996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.47: 按成员声明的顺序定义和初始化数据成员'
- en: Reason
  id: totrans-1997
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To minimize confusion and errors. That is the order in which the initialization
    happens (independent of the order of member initializers).
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化混淆和错误。这是初始化发生的顺序（独立于成员初始化器的顺序）。
- en: Example, bad
  id: totrans-1999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE228]'
  id: totrans-2000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Enforcement
  id: totrans-2001
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) A member initializer list should mention the members in the same order
    they are declared.
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 成员初始化列表应按成员声明的顺序提及成员。
- en: '**See also**: [Discussion](#sd-order)'
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [讨论](#sd-order)'
- en: 'C.48: Prefer default member initializers to member initializers in constructors
    for constant initializers'
  id: totrans-2004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.48: 对于常量初始化，优先使用默认成员初始化器而不是构造函数中的成员初始化器'
- en: Reason
  id: totrans-2005
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Makes it explicit that the same value is expected to be used in all constructors.
    Avoids repetition. Avoids maintenance problems. It leads to the shortest and most
    efficient code.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 明确指出所有构造函数中预期使用相同的值。避免重复。避免维护问题。这导致最短且最有效的代码。
- en: Example, bad
  id: totrans-2007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE229]'
  id: totrans-2008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: How would a maintainer know whether `j` was deliberately uninitialized (probably
    a bad idea anyway) and whether it was intentional to give `s` the default value
    `""` in one case and `qqq` in another (almost certainly a bug)? The problem with
    `j` (forgetting to initialize a member) often happens when a new member is added
    to an existing class.
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 维护者如何知道 `j` 是故意未初始化的（可能无论如何都是个坏主意）以及是否故意在一种情况下给 `s` 赋予默认值 `""`，而在另一种情况下赋予 `qqq`（几乎肯定是一个错误）？与
    `j`（忘记初始化成员）相关的问题通常发生在向现有类添加新成员时。
- en: Example
  id: totrans-2010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE230]'
  id: totrans-2011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '**Alternative**: We can get part of the benefits from default arguments to
    constructors, and that is not uncommon in older code. However, that is less explicit,
    causes more arguments to be passed, and is repetitive when there is more than
    one constructor:'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**: 我们可以从构造函数的默认参数中获得部分好处，这在旧代码中并不少见。然而，这不太明确，会导致传递更多参数，并且当有多个构造函数时，会重复：'
- en: '[PRE231]'
  id: totrans-2013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Enforcement
  id: totrans-2014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) Every constructor should initialize every data member (either explicitly,
    via a delegating ctor call or via default construction).
  id: totrans-2015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）每个构造函数都应该初始化每个数据成员（无论是显式地通过委托构造函数调用还是通过默认构造）。
- en: (Simple) Default arguments to constructors suggest a default member initializer
    might be more appropriate.
  id: totrans-2016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）构造函数的默认参数表明可能更适合使用默认成员初始化器。
- en: 'C.49: Prefer initialization to assignment in constructors'
  id: totrans-2017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.49: 在构造函数中优先使用初始化而不是赋值'
- en: Reason
  id: totrans-2018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An initialization explicitly states that initialization, rather than assignment,
    is done and can be more elegant and efficient. Prevents “use before set” errors.
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 明确初始化而不是赋值可以更优雅、更高效。防止“使用前设置”错误。
- en: Example, good
  id: totrans-2020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE232]'
  id: totrans-2021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Example, bad
  id: totrans-2022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，更糟
- en: '[PRE233]'
  id: totrans-2023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Example, better still
  id: totrans-2024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，更好
- en: 'Instead of those `const char*`s we could use C++17 `std::string_view` or `gsl::span<char>`
    as [a more general way to present arguments to a function](#rstr-view):'
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用C++17的`std::string_view`或`gsl::span<char>`来代替那些`const char*`，作为[向函数呈现参数的更通用方式](#rstr-view)：
- en: '[PRE234]'
  id: totrans-2026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'C.50: Use a factory function if you need “virtual behavior” during initialization'
  id: totrans-2027
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.50: 如果在初始化期间需要“虚拟行为”，请使用工厂函数'
- en: Reason
  id: totrans-2028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If the state of a base class object must depend on the state of a derived part
    of the object, we need to use a virtual function (or equivalent) while minimizing
    the window of opportunity to misuse an imperfectly constructed object.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基类对象的状态必须依赖于对象派生部分的状态，我们需要使用虚拟函数（或等效的），同时最小化误用不完整构造对象的机会窗口。
- en: Note
  id: totrans-2030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The return type of the factory should normally be `unique_ptr` by default; if
    some uses are shared, the caller can `move` the `unique_ptr` into a `shared_ptr`.
    However, if the factory author knows that all uses of the returned object will
    be shared uses, return `shared_ptr` and use `make_shared` in the body to save
    an allocation.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数的返回类型通常应该是`unique_ptr`，默认情况下；如果某些使用是共享的，调用者可以将`unique_ptr`移动到`shared_ptr`。然而，如果工厂作者知道所有返回对象的用途都是共享的，则返回`shared_ptr`并在函数体中使用`make_shared`以节省分配。
- en: Example, bad
  id: totrans-2032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，更糟
- en: '[PRE235]'
  id: totrans-2033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Example
  id: totrans-2034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE236]'
  id: totrans-2035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '`make_shared` requires that the constructor is public. By requiring a protected
    `Token` the constructor cannot be publicly called anymore, so we avoid an incompletely
    constructed object escaping into the wild. By providing the factory function `create()`,
    we make construction (on the free store) convenient.'
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_shared`要求构造函数是公共的。通过要求受保护的`Token`，构造函数不能再公开调用，因此我们避免了未完全构造的对象逃逸到野外。通过提供工厂函数`create()`，我们使构造（在自由存储上）变得方便。'
- en: Note
  id: totrans-2037
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Conventional factory functions allocate on the free store, rather than on the
    stack or in an enclosing object.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 传统工厂函数在自由存储上分配，而不是在栈或封装对象中。
- en: '**See also**: [Discussion](#sd-factory)'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**: [讨论](#sd-factory)'
- en: 'C.51: Use delegating constructors to represent common actions for all constructors
    of a class'
  id: totrans-2040
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.51: 使用委托构造函数来表示类中所有构造函数的常见操作'
- en: Reason
  id: totrans-2041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid repetition and accidental differences.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复和意外的差异。
- en: Example, bad
  id: totrans-2043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，更糟
- en: '[PRE237]'
  id: totrans-2044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: The common action gets tedious to write and might accidentally not be common.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 常见操作编写起来很繁琐，可能会意外地不常见。
- en: Example
  id: totrans-2046
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE238]'
  id: totrans-2047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '**See also**: If the “repeated action” is a simple initialization, consider
    [a default member initializer](#rc-in-class-initializer).'
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**: 如果“重复操作”是一个简单的初始化，请考虑[默认成员初始化器](#rc-in-class-initializer)。'
- en: Enforcement
  id: totrans-2049
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Moderate) Look for similar constructor bodies.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: （适度）寻找类似的构造函数体。
- en: 'C.52: Use inheriting constructors to import constructors into a derived class
    that does not need further explicit initialization'
  id: totrans-2051
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.52: 使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类'
- en: Reason
  id: totrans-2052
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you need those constructors for a derived class, re-implementing them is
    tedious and error-prone.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要派生类的这些构造函数，重新实现它们既繁琐又容易出错。
- en: Example
  id: totrans-2054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '`std::vector` has a lot of tricky constructors, so if I want my own `vector`,
    I don’t want to reimplement them:'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`有很多棘手的构造函数，所以如果我想有自己的`vector`，我不想重新实现它们：'
- en: '[PRE239]'
  id: totrans-2056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Example, bad
  id: totrans-2057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，更糟
- en: '[PRE240]'
  id: totrans-2058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Enforcement
  id: totrans-2059
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Make sure that every member of the derived class is initialized.
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: 确保派生类的每个成员都被初始化。
- en: 'C.copy: Copy and move'
  id: totrans-2061
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.copy：复制和移动
- en: Concrete types should generally be copyable, but interfaces in a class hierarchy
    should not. Resource handles might or might not be copyable. Types can be defined
    to move for logical as well as performance reasons.
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型通常应该是可复制的，但类层次结构中的接口不应该。资源句柄可能可复制也可能不可复制。类型可以定义为移动，出于逻辑和性能原因。
- en: 'C.60: Make copy assignment non-`virtual`, take the parameter by `const&`, and
    return by non-`const&`'
  id: totrans-2063
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.60：使复制赋值非 `virtual`，通过 `const&` 接收参数，并通过非 `const&` 返回
- en: Reason
  id: totrans-2064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is simple and efficient. If you want to optimize for rvalues, provide an
    overload that takes an `&&` (see [F.18](#rf-consume)).
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单且高效。如果你想要优化右值引用，提供一个接受 `&&` 的重载（见 [F.18](#rf-consume)）。
- en: Example
  id: totrans-2066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE241]'
  id: totrans-2067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Note
  id: totrans-2068
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `swap` implementation technique offers the [strong guarantee](#Abrahams01).
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 实现技术提供了 [强保证](#Abrahams01)。'
- en: Example
  id: totrans-2070
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'But what if you can get significantly better performance by not making a temporary
    copy? Consider a simple `Vector` intended for a domain where assignment of large,
    equal-sized `Vector`s is common. In this case, the copy of elements implied by
    the `swap` implementation technique could cause an order of magnitude increase
    in cost:'
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你可以通过不创建临时副本来获得显著更好的性能，该怎么办？考虑一个简单的 `Vector`，它适用于一个大型、等大小的 `Vector` 赋值很常见的领域。在这种情况下，`swap`
    实现技术隐含的元素复制可能会使成本增加一个数量级：
- en: '[PRE242]'
  id: totrans-2072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: By writing directly to the target elements, we will get only [the basic guarantee](#Abrahams01)
    rather than the strong guarantee offered by the `swap` technique. Beware of [self-assignment](#rc-copy-self).
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接写入目标元素，我们只会得到 [基本保证](#Abrahams01)，而不是 `swap` 技术提供的强保证。注意 [自赋值](#rc-copy-self)。
- en: '**Alternatives**: If you think you need a `virtual` assignment operator, and
    understand why that’s deeply problematic, don’t call it `operator=`. Make it a
    named function like `virtual void assign(const Foo&)`. See [copy constructor vs.
    `clone()`](#rc-copy-virtual).'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：如果你认为你需要一个 `virtual` 赋值运算符，并且理解这为什么会非常成问题，不要将其命名为 `operator=`。可以将其做成一个命名函数，如
    `virtual void assign(const Foo&)`。见 [复制构造函数与 `clone()`](#rc-copy-virtual)。'
- en: Enforcement
  id: totrans-2075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) An assignment operator should not be virtual. Here be dragons!
  id: totrans-2076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 赋值运算符不应该为虚函数。这里可能有龙！
- en: (Simple) An assignment operator should return `T&` to enable chaining, not alternatives
    like `const T&` which interfere with composability and putting objects in containers.
  id: totrans-2077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 赋值运算符应该返回 `T&` 以启用链式调用，而不是像 `const T&` 这样的替代方案，它会干扰组合性和将对象放入容器中。
- en: (Moderate) An assignment operator should (implicitly or explicitly) invoke all
    base and member assignment operators. Look at the destructor to determine if the
    type has pointer semantics or value semantics.
  id: totrans-2078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (适度) 赋值运算符应该（隐式或显式地）调用所有基类和成员赋值运算符。查看析构函数以确定类型是否具有指针语义或值语义。
- en: 'C.61: A copy operation should copy'
  id: totrans-2079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.61：复制操作应该复制
- en: Reason
  id: totrans-2080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That is the generally assumed semantics. After `x = y`, we should have `x ==
    y`. After a copy `x` and `y` can be independent objects (value semantics, the
    way non-pointer built-in types and the standard-library types work) or refer to
    a shared object (pointer semantics, the way pointers work).
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是假设的语义。在 `x = y` 之后，我们应该有 `x == y`。在复制之后，`x` 和 `y` 可以是独立对象（值语义，非指针内置类型和标准库类型的工作方式）或引用共享对象（指针语义，指针的工作方式）。
- en: Example
  id: totrans-2082
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE243]'
  id: totrans-2083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Example
  id: totrans-2084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE244]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Note
  id: totrans-2086
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Prefer value semantics unless you are building a “smart pointer”. Value semantics
    is the simplest to reason about and what the standard-library facilities expect.
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在构建“智能指针”，否则请优先使用值语义。值语义是最容易推理的，并且标准库设施也期望如此。
- en: Enforcement
  id: totrans-2088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Not enforceable)
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: (不可强制执行)
- en: 'C.62: Make copy assignment safe for self-assignment'
  id: totrans-2090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.62：使复制赋值对自赋值安全
- en: Reason
  id: totrans-2091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If `x = x` changes the value of `x`, people will be surprised and bad errors
    will occur (often including leaks).
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x = x` 改变了 `x` 的值，人们会感到惊讶，并且会发生错误（通常包括泄漏）。
- en: Example
  id: totrans-2093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'The standard-library containers handle self-assignment elegantly and efficiently:'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库容器优雅且高效地处理自赋值：
- en: '[PRE245]'
  id: totrans-2095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Note
  id: totrans-2096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The default assignment generated from members that handle self-assignment correctly
    handles self-assignment.
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 从正确处理自赋值的成员生成的默认赋值也正确处理自赋值。
- en: '[PRE246]'
  id: totrans-2098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Note
  id: totrans-2099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can handle self-assignment by explicitly testing for self-assignment, but
    often it is faster and more elegant to cope without such a test (e.g., [using
    `swap`](#rc-swap)).
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过显式检查自赋值来处理自赋值，但通常不进行这种测试会更快速且更优雅（例如，[使用 `swap`](#rc-swap)）。
- en: '[PRE247]'
  id: totrans-2101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'This is obviously safe and apparently efficient. However, what if we do one
    self-assignment per million assignments? That’s about a million redundant tests
    (but since the answer is essentially always the same, the computer’s branch predictor
    will guess right essentially every time). Consider:'
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是安全的，并且看起来很高效。然而，如果我们每百万次赋值中就进行一次自赋值呢？那大约有一百万个冗余测试（但由于答案基本上总是相同的，计算机的分支预测器几乎每次都能猜对）。考虑：
- en: '[PRE248]'
  id: totrans-2103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '`std::string` is safe for self-assignment and so are `int`. All the cost is
    carried by the (rare) case of self-assignment.'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string` 对自赋值是安全的，`int` 也是如此。所有成本都由（罕见的）自赋值情况承担。'
- en: Enforcement
  id: totrans-2105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Assignment operators should not contain the pattern `if (this == &a)
    return *this;` ???
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 赋值运算符不应包含模式 `if (this == &a) return *this;` ???
- en: 'C.63: Make move assignment non-`virtual`, take the parameter by `&&`, and return
    by non-`const&`'
  id: totrans-2107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.63: 使移动赋值非 `virtual`，通过 `&&` 接收参数，并通过非 `const&` 返回'
- en: Reason
  id: totrans-2108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is simple and efficient.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单且高效。
- en: '**See**: [The rule for copy-assignment](#rc-copy-assignment).'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**：[复制赋值的规则](#rc-copy-assignment)。'
- en: Enforcement
  id: totrans-2111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Equivalent to what is done for [copy-assignment](#rc-copy-assignment).
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于为 [复制赋值](#rc-copy-assignment) 所做的操作。
- en: (Simple) An assignment operator should not be virtual. Here be dragons!
  id: totrans-2113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 赋值运算符不应是虚拟的。这里可能有龙！
- en: (Simple) An assignment operator should return `T&` to enable chaining, not alternatives
    like `const T&` which interfere with composability and putting objects in containers.
  id: totrans-2114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 赋值运算符应该返回 `T&` 以便实现链式赋值，而不是像 `const T&` 这样的替代品，它会干扰组合性和将对象放入容器中。
- en: (Moderate) A move assignment operator should (implicitly or explicitly) invoke
    all base and member move assignment operators.
  id: totrans-2115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (适度) 移动赋值运算符应该（隐式或显式地）调用所有基类和成员移动赋值运算符。
- en: 'C.64: A move operation should move and leave its source in a valid state'
  id: totrans-2116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.64: 移动操作应移动并使其源处于有效状态'
- en: Reason
  id: totrans-2117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That is the generally assumed semantics. After `y = std::move(x)` the value
    of `y` should be the value `x` had and `x` should be in a valid state.
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是假设的语义。在 `y = std::move(x)` 之后，`y` 的值应该是 `x` 之前拥有的值，而 `x` 应该处于有效状态。
- en: Example
  id: totrans-2119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE249]'
  id: totrans-2120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Note
  id: totrans-2121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Ideally, that moved-from should be the default value of the type. Ensure that
    unless there is an exceptionally good reason not to. However, not all types have
    a default value and for some types establishing the default value can be expensive.
    The standard requires only that the moved-from object can be destroyed. Often,
    we can easily and cheaply do better: The standard library assumes that it is possible
    to assign to a moved-from object. Always leave the moved-from object in some (necessarily
    specified) valid state.'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，移动后的值应该是类型的默认值。确保除非有特别好的理由不这样做。然而，并非所有类型都有默认值，并且对于某些类型，建立默认值可能很昂贵。标准只要求移动后的对象可以被销毁。通常，我们可以轻松且低成本地做得更好：标准库假设可以赋值给移动后的对象。始终将移动后的对象保持在某种（必要指定的）有效状态。
- en: Note
  id: totrans-2123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unless there is an exceptionally strong reason not to, make `x = std::move(y);
    y = z;` work with the conventional semantics.
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特别强烈的理由不这样做，否则应使 `x = std::move(y); y = z;` 与传统语义兼容。
- en: Enforcement
  id: totrans-2125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Not enforceable) Look for assignments to members in the move operation. If
    there is a default constructor, compare those assignments to the initializations
    in the default constructor.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: (不可强制执行) 在移动操作中寻找成员的赋值。如果有默认构造函数，将这些赋值与默认构造函数中的初始化进行比较。
- en: 'C.65: Make move assignment safe for self-assignment'
  id: totrans-2127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.65: 使移动赋值对自赋值安全'
- en: Reason
  id: totrans-2128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If `x = x` changes the value of `x`, people will be surprised and bad errors
    can occur. However, people don’t usually directly write a self-assignment that
    turns into a move, but it can occur. However, `std::swap` is implemented using
    move operations so if you accidentally do `swap(a, b)` where `a` and `b` refer
    to the same object, failing to handle self-move could be a serious and subtle
    error.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x = x` 改变了 `x` 的值，人们会感到惊讶，并可能发生错误。然而，人们通常不会直接编写变成移动的自赋值，但它可能发生。然而，`std::swap`
    是通过移动操作实现的，所以如果你不小心执行 `swap(a, b)` 而其中 `a` 和 `b` 指向同一个对象，未能处理自移动可能是一个严重且微妙错误。
- en: Example
  id: totrans-2130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE250]'
  id: totrans-2131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: The one-in-a-million argument against `if (this == &a) return *this;` tests
    from the discussion of [self-assignment](#rc-copy-self) is even more relevant
    for self-move.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [自赋值](#rc-copy-self) 讨论的 `if (this == &a) return *this;` 测试对于自移动来说甚至更加相关。
- en: Note
  id: totrans-2133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There is no known general way of avoiding an `if (this == &a) return *this;`
    test for a move assignment and still getting a correct answer (i.e., after `x
    = x` the value of `x` is unchanged).
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 没有已知的一般方法可以避免对移动赋值进行 `if (this == &a) return *this;` 测试，同时仍然得到正确的结果（即 `x = x`
    后，`x` 的值保持不变）。
- en: Note
  id: totrans-2135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The ISO standard guarantees only a “valid but unspecified” state for the standard-library
    containers. Apparently this has not been a problem in about 10 years of experimental
    and production use. Please contact the editors if you find a counter example.
    The rule here is more caution and insists on complete safety.
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 标准仅保证标准库容器处于“有效但未指定”的状态。显然，在过去的10年实验和生产使用中，这并没有成为问题。如果你找到一个反例，请与编辑联系。这里的规则是更加谨慎并坚持完全的安全性。
- en: Example
  id: totrans-2137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Here is a way to move a pointer without a test (imagine it as code in the implementation
    a move assignment):'
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一种在不进行测试的情况下移动指针的方法（想象成移动赋值的实现代码）：
- en: '[PRE251]'
  id: totrans-2139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Enforcement
  id: totrans-2140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Moderate) In the case of self-assignment, a move assignment operator should
    not leave the object holding pointer members that have been `delete`d or set to
    `nullptr`.
  id: totrans-2141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （适度）在自我赋值的情况下，移动赋值运算符不应该留下持有已 `delete` 或设置为 `nullptr` 的指针成员的对象。
- en: (Not enforceable) Look at the use of standard-library container types (incl.
    `string`) and consider them safe for ordinary (not life-critical) uses.
  id: totrans-2142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （不可强制执行）查看标准库容器类型（包括 `string`）的使用，并考虑它们在普通（非生命关键）使用中的安全性。
- en: 'C.66: Make move operations `noexcept`'
  id: totrans-2143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.66：使移动操作 `noexcept`
- en: Reason
  id: totrans-2144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A throwing move violates most people’s reasonable assumptions. A non-throwing
    move will be used more efficiently by standard-library and language facilities.
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常的移动操作违反了大多数人的合理假设。非抛出异常的移动操作将更有效地被标准库和语言设施使用。
- en: Example
  id: totrans-2146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE252]'
  id: totrans-2147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: These operations do not throw.
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作不会抛出异常。
- en: Example, bad
  id: totrans-2149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE253]'
  id: totrans-2150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: This `Vector2` is not just inefficient, but since a vector copy requires allocation,
    it can throw.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Vector2` 不仅效率低下，而且由于向量拷贝需要分配，它可能会抛出异常。
- en: Enforcement
  id: totrans-2152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Simple) A move operation should be marked `noexcept`.
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）移动操作应该标记为 `noexcept`。
- en: 'C.67: A polymorphic class should suppress public copy/move'
  id: totrans-2154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.67：多态类应该抑制公共拷贝/移动
- en: Reason
  id: totrans-2155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'A *polymorphic class* is a class that defines or inherits at least one virtual
    function. It is likely that it will be used as a base class for other derived
    classes with polymorphic behavior. If it is accidentally passed by value, with
    the implicitly generated copy constructor and assignment, we risk slicing: only
    the base portion of a derived object will be copied, and the polymorphic behavior
    will be corrupted.'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *多态类* 是一个定义或继承至少一个虚函数的类。它很可能会被用作具有多态行为的其他派生类的基类。如果它意外地按值传递，使用隐式生成的拷贝构造函数和赋值，我们可能会遇到切片：派生对象的基部分将被复制，多态行为将被破坏。
- en: If the class has no data, `=delete` the copy/move functions. Otherwise, make
    them protected.
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类没有数据，则删除拷贝/移动函数。否则，使它们成为受保护的。
- en: Example, bad
  id: totrans-2158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE254]'
  id: totrans-2159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Example
  id: totrans-2160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE255]'
  id: totrans-2161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Note
  id: totrans-2162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you need to create deep copies of polymorphic objects, use `clone()` functions:
    see [C.130](#rh-copy).'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建多态对象的深拷贝，请使用 `clone()` 函数：参见 [C.130](#rh-copy)。
- en: Exception
  id: totrans-2164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Classes that represent exception objects need both to be polymorphic and copy-constructible.
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 表示异常对象的类需要既是多态的又是可拷贝构造的。
- en: Enforcement
  id: totrans-2166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag a polymorphic class with a public copy operation.
  id: totrans-2167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记具有公共拷贝操作的多态类。
- en: Flag an assignment of polymorphic class objects.
  id: totrans-2168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记多态类对象的赋值为异常。
- en: 'C.other: Other default operation rules'
  id: totrans-2169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.其他：其他默认操作规则
- en: 'In addition to the operations for which the language offers default implementations,
    there are a few operations that are so foundational that specific rules for their
    definition are needed: comparisons, `swap`, and `hash`.'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语言提供的默认实现的操作之外，还有一些基础性操作需要特定的定义规则：比较、`swap` 和 `hash`。
- en: 'C.80: Use `=default` if you have to be explicit about using the default semantics'
  id: totrans-2171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.80：如果你必须明确使用默认语义，请使用 `=default`
- en: Reason
  id: totrans-2172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The compiler is more likely to get the default semantics right and you cannot
    implement these functions better than the compiler.
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器更有可能正确地得到默认语义，并且你不能比编译器更好地实现这些函数。
- en: Example
  id: totrans-2174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE256]'
  id: totrans-2175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Because we defined the destructor, we must define the copy and move operations.
    The `= default` is the best and simplest way of doing that.
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 因为定义了析构函数，我们必须定义拷贝和移动操作。使用 `= default` 是最简单和最直接的方法。
- en: Example, bad
  id: totrans-2177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE257]'
  id: totrans-2178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Writing out the bodies of the copy and move operations is verbose, tedious,
    and error-prone. A compiler does it better.
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: 编写复制和移动操作的实现体是冗长、乏味且容易出错的。编译器做得更好。
- en: Enforcement
  id: totrans-2180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: (Moderate) The body of a user-defined operation should not have the same semantics
    as the compiler-generated version, because that would be redundant.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: （适度）用户定义操作的正文不应与编译器生成的版本具有相同的语义，因为这将是多余的。
- en: 'C.81: Use `=delete` when you want to disable default behavior (without wanting
    an alternative)'
  id: totrans-2182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.81：当您想禁用默认行为（而不想有替代方案）时使用 `=delete`
- en: Reason
  id: totrans-2183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: In a few cases, a default operation is not desirable.
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，默认操作是不希望的。
- en: Example
  id: totrans-2185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE258]'
  id: totrans-2186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Example
  id: totrans-2187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'A `unique_ptr` can be moved, but not copied. To achieve that its copy operations
    are deleted. To avoid copying it is necessary to `=delete` its copy operations
    from lvalues:'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 可以移动，但不能复制。为了实现这一点，其复制操作被删除。为了避免复制，需要从左值中删除其复制操作：`=delete`：'
- en: '[PRE259]'
  id: totrans-2189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Note that deleted functions should be public.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已删除的函数应该是公共的。
- en: Enforcement
  id: totrans-2191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: The elimination of a default operation is (should be) based on the desired semantics
    of the class. Consider such classes suspect, but maintain a “positive list” of
    classes where a human has asserted that the semantics is correct.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: 删除默认操作（应该是）基于类的期望语义。考虑这样的类是可疑的，但维护一个“正面列表”，其中人类已经断言语义是正确的。
- en: 'C.82: Don’t call virtual functions in constructors and destructors'
  id: totrans-2193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.82：不要在构造函数和析构函数中调用虚拟函数
- en: Reason
  id: totrans-2194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The function called will be that of the object constructed so far, rather than
    a possibly overriding function in a derived class. This can be most confusing.
    Worse, a direct or indirect call to an unimplemented pure virtual function from
    a constructor or destructor results in undefined behavior.
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的函数将是已构造的对象的函数，而不是派生类中可能重写的函数。这可能会非常令人困惑。更糟糕的是，从构造函数或析构函数中直接或间接调用未实现的纯虚拟函数会导致未定义行为。
- en: Example, bad
  id: totrans-2196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE260]'
  id: totrans-2197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Note that calling a specific explicitly qualified function is not a virtual
    call even if the function is `virtual`.
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使函数是 `virtual`，显式指定函数的调用也不是虚拟调用。
- en: '**See also** [factory functions](#rc-factory) for how to achieve the effect
    of a call to a derived class function without risking undefined behavior.'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅** [工厂函数](#rc-factory) 了解如何在不冒未定义行为风险的情况下实现调用派生类函数的效果。'
- en: Note
  id: totrans-2200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There is nothing inherently wrong with calling virtual functions from constructors
    and destructors. The semantics of such calls is type safe. However, experience
    shows that such calls are rarely needed, easily confuse maintainers, and become
    a source of errors when used by novices.
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 从构造函数和析构函数中调用虚拟函数本身并没有固有的错误。此类调用的语义是类型安全的。然而，经验表明，此类调用很少需要，很容易使维护者困惑，并且当新手使用时，会成为一个错误源。
- en: Enforcement
  id: totrans-2202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag calls of virtual functions from constructors and destructors.
  id: totrans-2203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从构造函数和析构函数中调用虚拟函数的标志调用。
- en: 'C.83: For value-like types, consider providing a `noexcept` swap function'
  id: totrans-2204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.83：对于值类型，考虑提供一个 `noexcept` 交换函数
- en: Reason
  id: totrans-2205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A `swap` can be handy for implementing a number of idioms, from smoothly moving
    objects around to implementing assignment easily to providing a guaranteed commit
    function that enables strongly error-safe calling code. Consider using swap to
    implement copy assignment in terms of copy construction. See also [destructors,
    deallocation, and swap must never fail](#re-never-fail).
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 对于实现许多习惯用法很有用，从平滑地移动对象到轻松实现赋值，再到提供保证提交功能的函数，该功能使强错误安全调用代码成为可能。考虑使用 `swap`
    来实现基于复制构造的复制赋值。另请参阅[析构函数、分配和交换必须永不失败](#re-never-fail)。'
- en: Example, good
  id: totrans-2207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE261]'
  id: totrans-2208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Providing a non-member `swap` function in the same namespace as your type for
    callers’ convenience.
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: 为调用者提供同一命名空间中的非成员 `swap` 函数，以方便调用。
- en: '[PRE262]'
  id: totrans-2210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Enforcement
  id: totrans-2211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Non-trivially copyable types should provide a member swap or a free swap overload.
  id: totrans-2212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制性非平凡的类型应提供成员交换或非成员交换重载。
- en: (Simple) When a class has a `swap` member function, it should be declared `noexcept`.
  id: totrans-2213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）当一个类有一个 `swap` 成员函数时，它应该声明为 `noexcept`。
- en: 'C.84: A `swap` function must not fail'
  id: totrans-2214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.84：`swap` 函数必须不失败
- en: Reason
  id: totrans-2215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`swap` is widely used in ways that are assumed never to fail and programs cannot
    easily be written to work correctly in the presence of a failing `swap`. The standard-library
    containers and algorithms will not work correctly if a swap of an element type
    fails.'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 被广泛用于假设永远不会失败的方式，并且程序无法轻松编写以在 `swap` 失败的情况下正确工作。如果元素类型的交换失败，标准库容器和算法将无法正常工作。'
- en: Example, bad
  id: totrans-2217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE263]'
  id: totrans-2218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: This is not just slow, but if a memory allocation occurs for the elements in
    `tmp`, this `swap` could throw and would make STL algorithms fail if used with
    them.
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅速度慢，而且如果 `tmp` 中的元素发生内存分配，这个 `swap` 可能会抛出异常，如果与 STL 算法一起使用，会导致算法失败。
- en: Enforcement
  id: totrans-2220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) When a class has a `swap` member function, it should be declared `noexcept`.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 当一个类有一个 `swap` 成员函数时，它应该被声明为 `noexcept`。
- en: 'C.85: Make `swap` `noexcept`'
  id: totrans-2222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.85: 将 `swap` 声明为 `noexcept`'
- en: Reason
  id: totrans-2223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '[A `swap` must not fail](#rc-swap-fail). If a `swap` tries to exit with an
    exception, it’s a bad design error and the program had better terminate.'
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: '[必须保证 `swap` 不失败](#rc-swap-fail)。如果 `swap` 尝试通过异常退出，这是一个设计错误，程序最好终止。'
- en: Enforcement
  id: totrans-2225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) When a class has a `swap` member function, it should be declared `noexcept`.
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: (简单) 当一个类有一个 `swap` 成员函数时，它应该被声明为 `noexcept`。
- en: 'C.86: Make `==` symmetric with respect to operand types and `noexcept`'
  id: totrans-2227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.86: 使 `==` 在操作数类型上对称且 `noexcept`'
- en: Reason
  id: totrans-2228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Asymmetric treatment of operands is surprising and a source of errors where
    conversions are possible. `==` is a fundamental operation and programmers should
    be able to use it without fear of failure.
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 对操作数的不对称处理令人惊讶，并且是可能发生转换的错误来源。`==` 是一个基本操作，程序员应该能够无后顾之忧地使用它。
- en: Example
  id: totrans-2230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE264]'
  id: totrans-2231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Example, bad
  id: totrans-2232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE265]'
  id: totrans-2233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '`B`’s comparison accepts conversions for its second operand, but not its first.'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 的比较接受第二个操作数的转换，但不接受第一个操作数。'
- en: Note
  id: totrans-2235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: If a class has a failure state, like `double`’s `NaN`, there is a temptation
    to make a comparison against the failure state throw. The alternative is to make
    two failure states compare equal and any valid state compare false against the
    failure state.
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类有失败状态，比如 `double` 的 `NaN`，可能会诱使将比较操作应用于失败状态时抛出异常。另一种选择是使两个失败状态比较相等，任何有效状态与失败状态比较都返回假。
- en: Note
  id: totrans-2237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'This rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`,
    and `>=`.'
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则适用于所有常见的比较运算符：`!=`, `<`, `<=`, `>`, 和 `>=`。
- en: Enforcement
  id: totrans-2239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag an `operator==()` for which the argument types differ; same for other
    comparison operators: `!=`, `<`, `<=`, `>`, and `>=`.'
  id: totrans-2240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个操作数类型不同的 `operator==()`；其他比较运算符也是如此：`!=`, `<`, `<=`, `>`, 和 `>=`.
- en: 'Flag member `operator==()`s; same for other comparison operators: `!=`, `<`,
    `<=`, `>`, and `>=`.'
  id: totrans-2241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记成员 `operator==()`；其他比较运算符也是如此：`!=`, `<`, `<=`, `>`, 和 `>=`.
- en: 'C.87: Beware of `==` on base classes'
  id: totrans-2242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.87: 谨慎使用基类上的 `==`'
- en: Reason
  id: totrans-2243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is really hard to write a foolproof and useful `==` for a hierarchy.
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 为层次结构编写一个无懈可击且有用的 `==` 非常困难。
- en: Example, bad
  id: totrans-2245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE266]'
  id: totrans-2246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '`B`’s comparison accepts conversions for its second operand, but not its first.'
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 的比较接受第二个操作数的转换，但不接受第一个操作数。'
- en: '[PRE267]'
  id: totrans-2248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Of course there are ways of making `==` work in a hierarchy, but the naive approaches
    do not scale.
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然有方法使 `==` 在层次结构中工作，但简单方法并不适用。
- en: Note
  id: totrans-2250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'This rule applies to all the usual comparison operators: `!=`, `<`, `<=`, `>`,
    `>=`, and `<=>`.'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则适用于所有常见的比较运算符：`!=`, `<`, `<=`, `>`, `>=`, 和 `<=>`.
- en: Enforcement
  id: totrans-2252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag a virtual `operator==()`; same for other comparison operators: `!=`, `<`,
    `<=`, `>`, `>=`, and `<=>`.'
  id: totrans-2253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个虚拟 `operator==()`；其他比较运算符也是如此：`!=`, `<`, `<=`, `>`, `>=`, 和 `<=>`.
- en: 'C.89: Make a `hash` `noexcept`'
  id: totrans-2254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.89: 使 `hash` 成为 `noexcept`'
- en: Reason
  id: totrans-2255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Users of hashed containers use hash indirectly and don’t expect simple access
    to throw. It’s a standard-library requirement.
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希容器用户间接使用哈希，并且不期望简单的访问会抛出异常。这是一个标准库要求。
- en: Example, bad
  id: totrans-2257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE268]'
  id: totrans-2258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: If you have to define a `hash` specialization, try simply to let it combine
    standard-library `hash` specializations with `^` (xor). That tends to work better
    than “cleverness” for non-specialists.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须定义 `hash` 特化，尝试简单地让它结合标准库的 `hash` 特化与 `^` (异或)。这通常比“巧妙”的方法对非专家来说效果更好。
- en: Enforcement
  id: totrans-2260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag throwing `hash`es.
  id: totrans-2261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记抛出 `hash`。
- en: 'C.90: Rely on constructors and assignment operators, not `memset` and `memcpy`'
  id: totrans-2262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.90: 依赖于构造函数和赋值运算符，而不是 `memset` 和 `memcpy`'
- en: Reason
  id: totrans-2263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'The standard C++ mechanism to construct an instance of a type is to call its
    constructor. As specified in guideline [C.41](#rc-complete): a constructor should
    create a fully initialized object. No additional initialization, such as by `memcpy`,
    should be required. A type will provide a copy constructor and/or copy assignment
    operator to appropriately make a copy of the class, preserving the type’s invariants.
    Using memcpy to copy a non-trivially copyable type has undefined behavior. Frequently
    this results in slicing, or data corruption.'
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++构建类型实例的机制是调用其构造函数。如指南[C.41](#rc-complete)所述：构造函数应创建一个完全初始化的对象。不需要额外的初始化，例如通过`memcpy`。类型将提供一个复制构造函数和/或复制赋值运算符，以适当地复制类，并保持类型的不变性。使用`memcpy`复制非平凡可复制的类型具有未定义的行为。这通常会导致切片或数据损坏。
- en: Example, good
  id: totrans-2265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE269]'
  id: totrans-2266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Example, bad
  id: totrans-2267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE270]'
  id: totrans-2268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: This is type-unsafe and overwrites the vtable.
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型不安全，会覆盖虚表。
- en: Example, bad
  id: totrans-2270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE271]'
  id: totrans-2271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: This is also type-unsafe and overwrites the vtable.
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是类型不安全的，会覆盖虚表。
- en: Enforcement
  id: totrans-2273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag passing a non-trivially-copyable type to `memset` or `memcpy`.
  id: totrans-2274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志传递非平凡可复制的类型到`memset`或`memcpy`。
- en: 'C.con: Containers and other resource handles'
  id: totrans-2275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.con：容器和其他资源句柄
- en: A container is an object holding a sequence of objects of some type; `std::vector`
    is the archetypical container. A resource handle is a class that owns a resource;
    `std::vector` is the typical resource handle; its resource is its sequence of
    elements.
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个包含某些类型对象序列的对象；`std::vector`是典型的容器。资源句柄是一个拥有资源的类；`std::vector`是典型的资源句柄；其资源是其元素序列。
- en: 'Summary of container rules:'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 容器规则摘要：
- en: '[C.100: Follow the STL when defining a container](#rcon-stl)'
  id: totrans-2278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.100：定义容器时遵循STL](#rcon-stl)'
- en: '[C.101: Give a container value semantics](#rcon-val)'
  id: totrans-2279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.101：为容器提供值语义](#rcon-val)'
- en: '[C.102: Give a container move operations](#rcon-move)'
  id: totrans-2280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.102：为容器提供移动操作](#rcon-move)'
- en: '[C.103: Give a container an initializer list constructor](#rcon-init)'
  id: totrans-2281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.103：为容器提供一个初始化列表构造函数](#rcon-init)'
- en: '[C.104: Give a container a default constructor that sets it to empty](#rcon-empty)'
  id: totrans-2282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.104：为容器提供一个默认构造函数，将其设置为空](#rcon-empty)'
- en: ???
  id: totrans-2283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: '[C.109: If a resource handle has pointer semantics, provide `*` and `->`](#rcon-ptr)'
  id: totrans-2284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.109：如果资源句柄具有指针语义，提供`*`和`->`](#rcon-ptr)'
- en: '**See also**: [Resources](#s-resource)'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[资源](#s-resource)'
- en: 'C.100: Follow the STL when defining a container'
  id: totrans-2286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.100：定义容器时遵循STL
- en: Reason
  id: totrans-2287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The STL containers are familiar to most C++ programmers and a fundamentally
    sound design.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器对大多数C++程序员来说都很熟悉，并且设计基础良好。
- en: Note
  id: totrans-2289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are of course other fundamentally sound design styles and sometimes reasons
    to depart from the style of the standard library, but in the absence of a solid
    reason to differ, it is simpler and easier for both implementers and users to
    follow the standard.
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他基本良好的设计风格，有时也有理由偏离标准库的风格，但在没有充分理由不同的情况下，对实施者和用户来说，遵循标准更简单、更容易。
- en: In particular, `std::vector` and `std::map` provide useful relatively simple
    models.
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`std::vector`和`std::map`提供了有用的相对简单的模型。
- en: Example
  id: totrans-2292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE272]'
  id: totrans-2293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Here, the STL style is followed, but incompletely. That’s not uncommon. Provide
    only as much functionality as makes sense for a specific container. The key is
    to define the conventional constructors, assignments, destructors, and iterators
    (as meaningful for the specific container) with their conventional semantics.
    From that base, the container can be expanded as needed. Here, special constructors
    from `std::vector` were added.
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，遵循STL风格，但并不完整。这并不罕见。只为特定容器提供有意义的函数。关键是定义传统的构造函数、赋值、析构函数和迭代器（对特定容器有意义）及其传统语义。从这个基础出发，容器可以根据需要扩展。在这里，添加了来自`std::vector`的特殊构造函数。
- en: Enforcement
  id: totrans-2295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.101: Give a container value semantics'
  id: totrans-2297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.101：为容器提供值语义
- en: Reason
  id: totrans-2298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Regular objects are simpler to think and reason about than irregular ones. Familiarity.
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 正规对象比不规则对象更容易思考和推理。熟悉性。
- en: Note
  id: totrans-2300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If meaningful, make a container `Regular` (the concept). In particular, ensure
    that an object compares equal to its copy.
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有意义，使容器成为`Regular`（概念）。特别是，确保对象与其副本相等。
- en: Example
  id: totrans-2302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE273]'
  id: totrans-2303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Enforcement
  id: totrans-2304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.102: Give a container move operations'
  id: totrans-2306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.102：为容器提供移动操作
- en: Reason
  id: totrans-2307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Containers tend to get large; without a move constructor and a copy constructor
    an object can be expensive to move around, thus tempting people to pass pointers
    to it around and getting into resource management problems.
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 容器往往会变得很大；如果没有移动构造函数和复制构造函数，对象移动起来可能会很昂贵，因此诱使人们传递指向它的指针，从而陷入资源管理问题。
- en: Example
  id: totrans-2309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE274]'
  id: totrans-2310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: A user can reasonably assume that returning a standard-like container is cheap.
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以合理地假设返回标准容器是廉价的。
- en: Enforcement
  id: totrans-2312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.103: Give a container an initializer list constructor'
  id: totrans-2314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.103：给容器提供一个初始化列表构造函数
- en: Reason
  id: totrans-2315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: People expect to be able to initialize a container with a set of values. Familiarity.
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 人们期望能够使用一组值来初始化一个容器。熟悉。
- en: Example
  id: totrans-2317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE275]'
  id: totrans-2318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Enforcement
  id: totrans-2319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.104: Give a container a default constructor that sets it to empty'
  id: totrans-2321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.104：给容器提供一个默认构造函数，将其设置为空
- en: Reason
  id: totrans-2322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To make it `Regular`.
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: 使其“常规”。
- en: Example
  id: totrans-2324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE276]'
  id: totrans-2325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Enforcement
  id: totrans-2326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.109: If a resource handle has pointer semantics, provide `*` and `->`'
  id: totrans-2328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.109：如果资源句柄具有指针语义，提供`*`和`->`
- en: Reason
  id: totrans-2329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That’s what is expected from pointers. Familiarity.
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是指针所期望的。熟悉。
- en: Example
  id: totrans-2331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE277]'
  id: totrans-2332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Enforcement
  id: totrans-2333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.lambdas: Function objects and lambdas'
  id: totrans-2335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.lambdas：函数对象和lambda
- en: A function object is an object supplying an overloaded `()` so that you can
    call it. A lambda expression (colloquially often shortened to “a lambda”) is a
    notation for generating a function object. Function objects should be cheap to
    copy (and therefore [passed by value](#rf-in)).
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象是一个提供重载的 `()` 的对象，这样你就可以调用它。lambda 表达式（口语中常简称为“lambda”）是生成函数对象的表示法。函数对象应该易于复制（因此[按值传递](#rf-in)）。
- en: 'Summary:'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要：
- en: '[F.10: If an operation can be reused, give it a name](#rf-name)'
  id: totrans-2338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.10：如果一个操作可以被重用，给它起一个名字](#rf-name)'
- en: '[F.11: Use an unnamed lambda if you need a simple function object in one place
    only](#rf-lambda)'
  id: totrans-2339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.11：如果只需要在单个位置使用简单的函数对象，使用未命名的lambda](#rf-lambda)'
- en: '[F.50: Use a lambda when a function won’t do (to capture local variables, or
    to write a local function)](#rf-capture-vs-overload)'
  id: totrans-2340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.50：当函数不起作用时使用lambda（捕获局部变量或编写局部函数）](#rf-capture-vs-overload)'
- en: '[F.52: Prefer capturing by reference in lambdas that will be used locally,
    including passed to algorithms](#rf-reference-capture)'
  id: totrans-2341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.52：在将用于局部位置的lambda中优先捕获引用，包括传递给算法](#rf-reference-capture)'
- en: '[F.53: Avoid capturing by reference in lambdas that will be used non-locally,
    including returned, stored on the heap, or passed to another thread](#rf-value-capture)'
  id: totrans-2342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.53：避免在将用于非局部位置的lambda中捕获引用，包括返回、存储在堆上或传递给另一个线程](#rf-value-capture)'
- en: '[ES.28: Use lambdas for complex initialization, especially of `const` variables](#res-lambda-init)'
  id: totrans-2343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.28：使用lambda进行复杂初始化，特别是`const`变量的初始化](#res-lambda-init)'
- en: 'C.hier: Class hierarchies (OOP)'
  id: totrans-2344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.hier：类层次结构（面向对象编程）
- en: A class hierarchy is constructed to represent a set of hierarchically organized
    concepts (only). Typically base classes act as interfaces. There are two major
    uses for hierarchies, often named implementation inheritance and interface inheritance.
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 类层次结构被构建来表示一组具有层次组织结构的概念（仅限）。通常基类充当接口。层次结构有两个主要用途，通常称为实现继承和接口继承。
- en: 'Class hierarchy rule summary:'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: 类层次结构规则摘要：
- en: '[C.120: Use class hierarchies to represent concepts with inherent hierarchical
    structure (only)](#rh-domain)'
  id: totrans-2347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.120：使用类层次结构来表示具有固有层次结构的概念（仅限）](#rh-domain)'
- en: '[C.121: If a base class is used as an interface, make it a pure abstract class](#rh-abstract)'
  id: totrans-2348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.121：如果基类用作接口，则使其成为纯抽象类](#rh-abstract)'
- en: '[C.122: Use abstract classes as interfaces when complete separation of interface
    and implementation is needed](#rh-separation)'
  id: totrans-2349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.122：当需要完全分离接口和实现时，使用抽象类作为接口](#rh-separation)'
- en: 'Designing rules for classes in a hierarchy summary:'
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: 设计类层次结构中的类规则摘要：
- en: '[C.126: An abstract class typically doesn’t need a user-written constructor](#rh-abstract-ctor)'
  id: totrans-2351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.126：一个抽象类通常不需要用户编写的构造函数](#rh-abstract-ctor)'
- en: '[C.127: A class with a virtual function should have a virtual or protected
    destructor](#rh-dtor)'
  id: totrans-2352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.127：具有虚函数的类应具有虚析构函数或保护析构函数](#rh-dtor)'
- en: '[C.128: Virtual functions should specify exactly one of `virtual`, `override`,
    or `final`](#rh-override)'
  id: totrans-2353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.128：虚函数应指定`virtual`、`override`或`final`之一](#rh-override)'
- en: '[C.129: When designing a class hierarchy, distinguish between implementation
    inheritance and interface inheritance](#rh-kind)'
  id: totrans-2354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.129：在设计类层次结构时，区分实现继承和接口继承](#rh-kind)'
- en: '[C.130: For making deep copies of polymorphic classes prefer a virtual `clone`
    function instead of public copy construction/assignment](#rh-copy)'
  id: totrans-2355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.130: 对于多态类的深拷贝，优先使用虚拟 `clone` 函数而不是公共复制构造函数/赋值操作](#rh-copy)'
- en: '[C.131: Avoid trivial getters and setters](#rh-get)'
  id: totrans-2356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.131: 避免平凡的获取器和设置器](#rh-get)'
- en: '[C.132: Don’t make a function `virtual` without reason](#rh-virtual)'
  id: totrans-2357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.132: 没有理由不要使函数 `virtual`](#rh-virtual)'
- en: '[C.133: Avoid `protected` data](#rh-protected)'
  id: totrans-2358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.133: 避免使用 `protected` 数据](#rh-protected)'
- en: '[C.134: Ensure all non-`const` data members have the same access level](#rh-public)'
  id: totrans-2359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.134: 确保所有非 `const` 数据成员具有相同的访问级别](#rh-public)'
- en: '[C.135: Use multiple inheritance to represent multiple distinct interfaces](#rh-mi-interface)'
  id: totrans-2360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.135: 使用多重继承来表示多个不同的接口](#rh-mi-interface)'
- en: '[C.136: Use multiple inheritance to represent the union of implementation attributes](#rh-mi-implementation)'
  id: totrans-2361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.136: 使用多重继承来表示实现属性的并集](#rh-mi-implementation)'
- en: '[C.137: Use `virtual` bases to avoid overly general base classes](#rh-vbase)'
  id: totrans-2362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.137: 使用 `virtual` 基类来避免过于通用的基类](#rh-vbase)'
- en: '[C.138: Create an overload set for a derived class and its bases with `using`](#rh-using)'
  id: totrans-2363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.138: 使用 `using` 为派生类及其基类创建一个重载集](#rh-using)'
- en: '[C.139: Use `final` on classes sparingly](#rh-final)'
  id: totrans-2364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.139: 适度使用 `final` 在类上](#rh-final)'
- en: '[C.140: Do not provide different default arguments for a virtual function and
    an overrider](#rh-virtual-default-arg)'
  id: totrans-2365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.140: 不要为虚函数和覆盖者提供不同的默认参数](#rh-virtual-default-arg)'
- en: 'Accessing objects in a hierarchy rule summary:'
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中访问对象的规则总结：
- en: '[C.145: Access polymorphic objects through pointers and references](#rh-poly)'
  id: totrans-2367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.145: 通过指针和引用访问多态对象](#rh-poly)'
- en: '[C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable](#rh-dynamic_cast)'
  id: totrans-2368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.146: 在类层次结构导航不可避免时使用 `dynamic_cast`](#rh-dynamic_cast)'
- en: '[C.147: Use `dynamic_cast` to a reference type when failure to find the required
    class is considered an error](#rh-ref-cast)'
  id: totrans-2369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.147: 当找不到所需类被视为错误时，使用 `dynamic_cast` 到引用类型](#rh-ref-cast)'
- en: '[C.148: Use `dynamic_cast` to a pointer type when failure to find the required
    class is considered a valid alternative](#rh-ptr-cast)'
  id: totrans-2370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.148: 当找不到所需类被视为有效替代时，使用 `dynamic_cast` 到指针类型](#rh-ptr-cast)'
- en: '[C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects
    created using `new`](#rh-smart)'
  id: totrans-2371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.149: 使用 `unique_ptr` 或 `shared_ptr` 来避免忘记删除使用 `new` 创建的对象](#rh-smart)'
- en: '[C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s](#rh-make_unique)'
  id: totrans-2372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.150: 使用 `make_unique()` 构造 `unique_ptr` 拥有的对象](#rh-make_unique)'
- en: '[C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s](#rh-make_shared)'
  id: totrans-2373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.151: 使用 `make_shared()` 来构造 `shared_ptr` 拥有的对象](#rh-make_shared)'
- en: '[C.152: Never assign a pointer to an array of derived class objects to a pointer
    to its base](#rh-array)'
  id: totrans-2374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.152: 永远不要将派生类对象的数组指针赋值给基类指针](#rh-array)'
- en: '[C.153: Prefer virtual function to casting](#rh-use-virtual)'
  id: totrans-2375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.153: 优先使用虚函数而不是类型转换](#rh-use-virtual)'
- en: 'C.120: Use class hierarchies to represent concepts with inherent hierarchical
    structure (only)'
  id: totrans-2376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.120: 使用类层次结构来表示具有固有层次结构的概念（仅限）'
- en: Reason
  id: totrans-2377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Direct representation of ideas in code eases comprehension and maintenance.
    Make sure the idea represented in the base class exactly matches all derived types
    and there is not a better way to express it than using the tight coupling of inheritance.
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中对思想的直接表示简化了理解和维护。确保基类中代表的思想与所有派生类型完全匹配，并且没有比使用继承的紧密耦合更好的表达方式。
- en: Do *not* use inheritance when simply having a data member will do. Usually this
    means that the derived type needs to override a base virtual function or needs
    access to a protected member.
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在只需有一个数据成员的情况下使用继承。通常这意味着派生类型需要覆盖基类的虚拟函数或需要访问受保护的成员。
- en: Example
  id: totrans-2380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE278]'
  id: totrans-2381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Example, bad
  id: totrans-2382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: Do *not* represent non-hierarchical domain concepts as class hierarchies.
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将非层次化领域概念表示为类层次结构。
- en: '[PRE279]'
  id: totrans-2384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Here most overriding classes cannot implement most of the functions required
    in the interface well. Thus the base class becomes an implementation burden. Furthermore,
    the user of `Container` cannot rely on the member functions actually performing
    meaningful operations reasonably efficiently; it might throw an exception instead.
    Thus users have to resort to run-time checking and/or not using this (over)general
    interface in favor of a particular interface found by a run-time type inquiry
    (e.g., a `dynamic_cast`).
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，大多数覆盖类无法很好地实现接口中所需的大部分函数。因此，基类变成了实现负担。此外，`Container` 的用户不能依赖成员函数实际上以合理高效的方式执行有意义操作；它可能会抛出异常。因此，用户不得不求助于运行时检查和/或避免使用这个（过度）通用的接口，转而使用通过运行时类型查询找到的特定接口（例如，`dynamic_cast`）。
- en: Enforcement
  id: totrans-2386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Look for classes with lots of members that do nothing but throw.
  id: totrans-2387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找具有大量成员但只是抛出异常的类。
- en: 'Flag every use of a non-public base class `B` where the derived class `D` does
    not override a virtual function or access a protected member in `B`, and `B` is
    not one of the following: empty, a template parameter or parameter pack of `D`,
    a class template specialized with `D`.'
  id: totrans-2388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有使用非公共基类 `B` 的位置，其中派生类 `D` 没有重写虚拟函数或访问 `B` 中的受保护成员，并且 `B` 不是以下之一：空类、`D` 的模板参数或参数包、使用
    `D` 特化的类模板。
- en: 'C.121: If a base class is used as an interface, make it a pure abstract class'
  id: totrans-2389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.121：如果基类用作接口，则使其成为纯抽象类
- en: Reason
  id: totrans-2390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A class is more stable (less brittle) if it does not contain data. Interfaces
    should normally be composed entirely of public pure virtual functions and a default/empty
    virtual destructor.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类不包含数据，则更稳定（更不易碎）。接口通常应完全由公共纯虚函数和一个默认/空虚析构函数组成。
- en: Example
  id: totrans-2392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE280]'
  id: totrans-2393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Example, bad
  id: totrans-2394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE281]'
  id: totrans-2395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: The `Derived` is `delete`d through its `Goof` interface, so its `string` is
    leaked. Give `Goof` a virtual destructor and all is well.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: '`Derived` 通过其 `Goof` 接口被 `delete`，因此其 `string` 被泄漏。给 `Goof` 一个虚拟析构函数，一切就绪。'
- en: Enforcement
  id: totrans-2397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Warn on any class that contains data members and also has an overridable (non-`final`)
    virtual function that wasn’t inherited from a base class.
  id: totrans-2398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对包含数据成员并且具有可覆盖（非 `final`）虚拟函数（该函数不是从基类继承的）的任何类发出警告。
- en: 'C.122: Use abstract classes as interfaces when complete separation of interface
    and implementation is needed'
  id: totrans-2399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.122：当需要完全分离接口和实现时，使用抽象类作为接口
- en: Reason
  id: totrans-2400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Such as on an ABI (link) boundary.
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 例如在 ABI（链接）边界上。
- en: Example
  id: totrans-2402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE282]'
  id: totrans-2403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: A user can now use `D1`s and `D2`s interchangeably through the interface provided
    by `Device`. Furthermore, we can update `D1` and `D2` in ways that are not binary
    compatible with older versions as long as all access goes through `Device`.
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以通过 `Device` 提供的接口相互使用 `D1` 和 `D2`。此外，只要所有访问都通过 `Device` 进行，我们就可以以与旧版本不兼容的方式更新
    `D1` 和 `D2`。
- en: Enforcement
  id: totrans-2405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: '[PRE283]'
  id: totrans-2406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'C.hierclass: Designing classes in a hierarchy:'
  id: totrans-2407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.hierclass：在层次结构中设计类：
- en: 'C.126: An abstract class typically doesn’t need a user-written constructor'
  id: totrans-2408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.126：一个抽象类通常不需要用户编写的构造函数
- en: Reason
  id: totrans-2409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An abstract class typically does not have any data for a constructor to initialize.
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 一个抽象类通常没有数据供构造函数初始化。
- en: Example
  id: totrans-2411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE284]'
  id: totrans-2412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Exception
  id: totrans-2413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: A base class constructor that does work, such as registering an object somewhere,
    might need a constructor.
  id: totrans-2414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类构造函数执行某些工作，例如在某处注册对象，可能需要一个构造函数。
- en: 'In extremely rare cases, you might find it reasonable for an abstract class
    to have a bit of data shared by all derived classes (e.g., use statistics data,
    debug information, etc.); such classes tend to have constructors. But be warned:
    Such classes also tend to be prone to requiring virtual inheritance.'
  id: totrans-2415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在极其罕见的情况下，您可能会发现抽象类拥有所有派生类共享的一点点数据是合理的（例如，使用统计数据、调试信息等）；这样的类往往有构造函数。但请注意：这样的类也往往容易需要虚拟继承。
- en: Enforcement
  id: totrans-2416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag abstract classes with constructors.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 标记具有构造函数的抽象类。
- en: 'C.127: A class with a virtual function should have a virtual or protected destructor'
  id: totrans-2418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.127：具有虚拟函数的类应该有一个虚拟或受保护的析构函数
- en: Reason
  id: totrans-2419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A class with a virtual function is usually (and in general) used via a pointer
    to base. Usually, the last user has to call delete on a pointer to base, often
    via a smart pointer to base, so the destructor should be public and virtual. Less
    commonly, if deletion through a pointer to base is not intended to be supported,
    the destructor should be protected and non-virtual; see [C.35](#rc-dtor-virtual).
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 具有虚函数的类通常（并且通常）通过基类的指针来使用。通常，最后一个用户必须调用基类指针的delete操作，通常是通过基类智能指针来完成的，因此析构函数应该是公共的和虚的。较少见的情况下，如果通过基类指针的删除不被支持，析构函数应该是受保护的和非虚的；参见[C.35](#rc-dtor-virtual)。
- en: Example, bad
  id: totrans-2421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE285]'
  id: totrans-2422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: Note
  id: totrans-2423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are people who don’t follow this rule because they plan to use a class
    only through a `shared_ptr`: `std::shared_ptr<B> p = std::make_shared<D>(args);`
    Here, the shared pointer will take care of deletion, so no leak will occur from
    an inappropriate `delete` of the base. People who do this consistently can get
    a false positive, but the rule is important – what if one was allocated using
    `make_unique`? It’s not safe unless the author of `B` ensures that it can never
    be misused, such as by making all constructors private and providing a factory
    function to enforce the allocation with `make_shared`.'
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: 有的人不遵循这条规则，因为他们计划只通过`shared_ptr`来使用一个类：`std::shared_ptr<B> p = std::make_shared<D>(args);`在这里，共享指针将负责删除，因此不会因为不适当的`delete`操作而导致泄漏。一贯这样做的人可能会得到一个假阳性，但规则很重要——如果使用`make_unique`分配怎么办？除非`B`的作者确保它永远不会被误用，例如通过将所有构造函数设为私有并提供一个工厂函数来强制使用`make_shared`进行分配，否则这是不安全的。
- en: Enforcement
  id: totrans-2425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: A class with any virtual functions should have a destructor that is either public
    and virtual or else protected and non-virtual.
  id: totrans-2426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有任何虚函数的类应该有一个公共和虚的或受保护和非虚的析构函数。
- en: Flag `delete` of a class with a virtual function but no virtual destructor.
  id: totrans-2427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记具有虚函数但没有虚析构函数的类的`delete`操作。
- en: 'C.128: Virtual functions should specify exactly one of `virtual`, `override`,
    or `final`'
  id: totrans-2428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.128：虚函数应明确指定`virtual`、`override`或`final`中的一个。
- en: Reason
  id: totrans-2429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Detection of mistakes. Writing explicit `virtual`, `override`,
    or `final` is self-documenting and enables the compiler to catch mismatch of types
    and/or names between base and derived classes. However, writing more than one
    of these three is both redundant and a potential source of errors.
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。错误检测。显式编写`virtual`、`override`或`final`是自文档化的，并使编译器能够捕获基类和派生类之间类型和/或名称的不匹配。然而，编写这三个中的任何一个都是多余的，并且可能是错误的一个潜在来源。
- en: 'It’s simple and clear:'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 简单明了：
- en: '`virtual` means exactly and only “this is a new virtual function.”'
  id: totrans-2432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual`意味着正好且仅是“这是一个新的虚函数”。'
- en: '`override` means exactly and only “this is a non-final overrider.”'
  id: totrans-2433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override`意味着正好且仅是“这是一个非最终覆盖者”。'
- en: '`final` means exactly and only “this is a final overrider.”'
  id: totrans-2434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`final`意味着正好且仅是“这是一个最终覆盖者”。'
- en: Example, bad
  id: totrans-2435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE286]'
  id: totrans-2436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Example, good
  id: totrans-2437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE287]'
  id: totrans-2438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Discussion
  id: totrans-2439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 讨论
- en: 'We want to eliminate two particular classes of errors:'
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望消除两种特定的错误类型：
- en: '**implicit virtual**: the programmer intended the function to be implicitly
    virtual and it is (but readers of the code can’t tell); or the programmer intended
    the function to be implicitly virtual but it isn’t (e.g., because of a subtle
    parameter list mismatch); or the programmer did not intend the function to be
    virtual but it is (because it happens to have the same signature as a virtual
    in the base class)'
  id: totrans-2441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式虚函数**：程序员意图函数隐式地是虚函数，并且它是（但代码的读者无法知道）；或者程序员意图函数隐式地是虚函数，但它不是（例如，由于参数列表的微妙不匹配）；或者程序员没有意图函数是虚函数，但它却是（因为它恰好与基类中的虚函数具有相同的签名）'
- en: '**implicit override**: the programmer intended the function to be implicitly
    an overrider and it is (but readers of the code can’t tell); or the programmer
    intended the function to be implicitly an overrider but it isn’t (e.g., because
    of a subtle parameter list mismatch); or the programmer did not intend the function
    to be an overrider but it is (because it happens to have the same signature as
    a virtual in the base class – note this problem arises whether or not the function
    is explicitly declared virtual, because the programmer might have intended to
    create either a new virtual function or a new non-virtual function)'
  id: totrans-2442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式覆盖**：程序员意图函数隐式地是一个覆盖者，并且它是（但代码的读者无法知道）；或者程序员意图函数隐式地是一个覆盖者，但它不是（例如，由于参数列表的微妙不匹配）；或者程序员没有意图函数是一个覆盖者，但它却是（因为它恰好与基类中的虚函数具有相同的签名——注意这个问题是否显式声明为虚函数都会出现，因为程序员可能意图创建一个新的虚函数或一个新的非虚函数）'
- en: 'Note: On a class defined as `final`, each individual virtual function should
    use either `override` or `final`; there is no semantic difference in this case.'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在定义为`final`的类中，每个单独的虚拟函数应使用`override`或`final`；在这种情况下没有语义上的区别。
- en: 'Note: Use `final` on functions sparingly. It does not necessarily lead to optimization,
    and it precludes further overriding.'
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：谨慎使用`final`。它不一定导致优化，并且它排除了进一步的覆盖。
- en: Enforcement
  id: totrans-2445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Compare virtual function names in base and derived classes and flag uses of
    the same name that do not override.
  id: totrans-2446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较基类和派生类中的虚拟函数名称，并标记出使用相同名称但没有重写的用法。
- en: Flag overrides with neither `override` nor `final`.
  id: totrans-2447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记既没有`override`也没有`final`的重写。
- en: Flag function declarations that use more than one of `virtual`, `override`,
    and `final`.
  id: totrans-2448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记使用一个以上的`virtual`、`override`和`final`的函数声明。
- en: 'C.129: When designing a class hierarchy, distinguish between implementation
    inheritance and interface inheritance'
  id: totrans-2449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.129：在设计类层次结构时，区分实现继承和接口继承
- en: Reason
  id: totrans-2450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Implementation details in an interface make the interface brittle; that is,
    make its users vulnerable to having to recompile after changes in the implementation.
    Data in a base class increases the complexity of implementing the base and can
    lead to replication of code.
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的实现细节会使接口变得脆弱；也就是说，使用者在实现更改后需要重新编译。
- en: Note
  id: totrans-2452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Definition:'
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：
- en: interface inheritance is the use of inheritance to separate users from implementations,
    in particular to allow derived classes to be added and changed without affecting
    the users of base classes.
  id: totrans-2454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口继承是使用继承来将用户与实现分离，特别是允许在不影响基类用户的情况下添加和更改派生类。
- en: implementation inheritance is the use of inheritance to simplify implementation
    of new facilities by making useful operations available for implementers of related
    new operations (sometimes called “programming by difference”).
  id: totrans-2455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现继承是使用继承来简化新设施的实施，通过为相关新操作的实施者提供有用的操作（有时称为“差异编程”）。
- en: A pure interface class is simply a set of pure virtual functions; see [I.25](#ri-abstract).
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 纯接口类只是一组纯虚拟函数；参见[I.25](#ri-abstract)。
- en: In early OOP (e.g., in the 1980s and 1990s), implementation inheritance and
    interface inheritance were often mixed and bad habits die hard. Even now, mixtures
    are not uncommon in old code bases and in old-style teaching material.
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的面向对象编程（例如，20世纪80年代和90年代），实现继承和接口继承经常混合，坏习惯很难改掉。即使现在，在旧代码库和旧式教学材料中，混合使用仍然很常见。
- en: The importance of keeping the two kinds of inheritance increases
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 保持两种继承方式的重要性增加
- en: with the size of a hierarchy (e.g., dozens of derived classes),
  id: totrans-2459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个层次的大小（例如，几十个派生类），
- en: with the length of time the hierarchy is used (e.g., decades), and
  id: totrans-2460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个层次被使用的时间长度（例如，几十年），并且
- en: with the number of distinct organizations in which a hierarchy is used (e.g.,
    it can be difficult to distribute an update to a base class)
  id: totrans-2461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个层次被使用的不同组织数量（例如，可能很难分发基类的更新）
- en: Example, bad
  id: totrans-2462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好
- en: '[PRE288]'
  id: totrans-2463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'Problems:'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：
- en: As the hierarchy grows and more data is added to `Shape`, the constructors get
    harder to write and maintain.
  id: totrans-2465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着层次的增长和更多数据添加到`Shape`中，构造函数的编写和维护变得更加困难。
- en: Why calculate the center for the `Triangle`? We might never use it.
  id: totrans-2466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么计算`Triangle`的中心？我们可能永远都不会用到它。
- en: Add a data member to `Shape` (e.g., drawing style or canvas) and all classes
    derived from `Shape` and all code using `Shape` will need to be reviewed, possibly
    changed, and probably recompiled.
  id: totrans-2467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`Shape`添加一个数据成员（例如，绘图样式或画布）并将所有从`Shape`派生的类以及所有使用`Shape`的代码都需要进行审查，可能需要更改，并且可能需要重新编译。
- en: 'The implementation of `Shape::move()` is an example of implementation inheritance:
    we have defined `move()` once and for all, for all derived classes. The more code
    there is in such base class member function implementations and the more data
    is shared by placing it in the base, the more benefits we gain - and the less
    stable the hierarchy is.'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape::move()`的实现是实现继承的一个例子：我们为所有派生类定义了`move()`，一次定义，永久使用。这样的基类成员函数实现中的代码越多，通过将其放在基类中共享的数据越多，我们获得的好处就越多——而层次结构就越不稳定。'
- en: Example
  id: totrans-2469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: 'This Shape hierarchy can be rewritten using interface inheritance:'
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 这个形状层次结构可以使用接口继承重写：
- en: '[PRE289]'
  id: totrans-2471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Note that a pure interface rarely has constructors: there is nothing to construct.'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一个纯接口很少具有构造函数：没有需要构造的内容。
- en: '[PRE290]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: The interface is now less brittle, but there is more work in implementing the
    member functions. For example, `center` has to be implemented by every class derived
    from `Shape`.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 接口现在不那么脆弱，但在实现成员函数方面需要更多的工作。例如，`center`必须由从`Shape`派生的每个类实现。
- en: Example, dual hierarchy
  id: totrans-2475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，双重层次结构
- en: How can we gain the benefit of stable hierarchies from interface hierarchies
    and the benefit of implementation reuse from implementation inheritance? One popular
    technique is dual hierarchies. There are many ways of implementing the idea of
    dual hierarchies; here, we use a multiple-inheritance variant.
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从接口层次结构中获得稳定层次结构的优势，并从实现继承中获得实现重用的优势？一种流行的技术是双重层次结构。实现双重层次结构的方法有很多；这里，我们使用多重继承变体。
- en: 'First we devise a hierarchy of interface classes:'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设计一个接口类层次结构：
- en: '[PRE291]'
  id: totrans-2478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'To make this interface useful, we must provide its implementation classes (here,
    named equivalently, but in the `Impl` namespace):'
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此接口有用，我们必须提供其实现类（在这里，名称相同，但在`Impl`命名空间中）：
- en: '[PRE292]'
  id: totrans-2480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Now `Shape` is a poor example of a class with an implementation, but bear with
    us because this is just a simple example of a technique aimed at more complex
    hierarchies.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Shape`是一个具有实现的类的不良示例，但请耐心，因为这只是一个针对更复杂层次结构的技术简单示例。
- en: '[PRE293]'
  id: totrans-2482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'And we could extend the hierarchies by adding a Smiley class (:-)):'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加笑脸类（:-)）来扩展层次结构。
- en: '[PRE294]'
  id: totrans-2484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'There are now two hierarchies:'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有两组层次结构：
- en: 'interface: Smiley -> Circle -> Shape'
  id: totrans-2486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口：笑脸 -> 圆形 -> 形状
- en: 'implementation: Impl::Smiley -> Impl::Circle -> Impl::Shape'
  id: totrans-2487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现：Impl::Smiley -> Impl::Circle -> Impl::Shape
- en: 'Since each implementation is derived from its interface as well as its implementation
    base class we get a lattice (DAG):'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个实现既派生自其接口，也派生自其实现基类，我们得到一个格（DAG）：
- en: '[PRE295]'
  id: totrans-2489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: As mentioned, this is just one way to construct a dual hierarchy.
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这只是构建双重层次结构的一种方法。
- en: The implementation hierarchy can be used directly, rather than through the abstract
    interface.
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: 实现层次结构可以直接使用，而不是通过抽象接口。
- en: '[PRE296]'
  id: totrans-2492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: This can be useful when the implementation class has members that are not offered
    in the abstract interface or if direct use of a member offers optimization opportunities
    (e.g., if an implementation member function is `final`).
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现类具有在抽象接口中未提供的成员或直接使用成员提供优化机会时（例如，如果实现成员函数是`final`），这可能很有用。
- en: Note
  id: totrans-2494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Another (related) technique for separating interface and implementation is [Pimpl](#ri-pimpl).
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种（相关）的分离接口和实现的技术是[Pimpl](#ri-pimpl)。
- en: Note
  id: totrans-2496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There is often a choice between offering common functionality as (implemented)
    base class functions and freestanding functions (in an implementation namespace).
    Base classes give a shorter notation and easier access to shared data (in the
    base) at the cost of the functionality being available only to users of the hierarchy.
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: 常常需要在提供（实现）基类函数和独立函数（在实现命名空间中）之间做出选择。基类提供了更短的表示和更易于访问共享数据（在基类中）的方法，但代价是功能仅对层次结构的用户可用。
- en: Enforcement
  id: totrans-2498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag a derived to base conversion to a base with both data and virtual functions
    (except for calls from a derived class member to a base class member)
  id: totrans-2499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记派生到具有数据和虚拟函数的基类的转换（除了从派生类成员到基类成员的调用）
- en: ???
  id: totrans-2500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'C.130: For making deep copies of polymorphic classes prefer a virtual `clone`
    function instead of public copy construction/assignment'
  id: totrans-2501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.130：对于多态类的深度复制，首选虚拟`clone`函数而不是公共复制构造函数/赋值操作
- en: Reason
  id: totrans-2502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Copying a polymorphic class is discouraged due to the slicing problem, see
    [C.67](#rc-copy-virtual). If you really need copy semantics, copy deeply: Provide
    a virtual `clone` function that will copy the actual most-derived type and return
    an owning pointer to the new object, and then in derived classes return the derived
    type (use a covariant return type).'
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片问题，不建议复制多态类，请参阅[C.67](#rc-copy-virtual)。如果您确实需要复制语义，请深度复制：提供一个虚拟的`clone`函数，该函数将复制实际的最派生类型，并返回指向新对象的拥有指针，然后在派生类中返回派生类型（使用协变返回类型）。
- en: Example
  id: totrans-2504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE297]'
  id: totrans-2505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'Generally, it is recommended to use smart pointers to represent ownership (see
    [R.20](#rr-owner)). However, because of language rules, the covariant return type
    cannot be a smart pointer: `D::clone` can’t return a `unique_ptr<D>` while `B::clone`
    returns `unique_ptr<B>`. Therefore, you either need to consistently return `unique_ptr<B>`
    in all overrides, or use `owner<>` utility from the [Guidelines Support Library](#ss-views).'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议使用智能指针来表示所有权（参见[R.20](#rr-owner)）。然而，由于语言规则，协变返回类型不能是智能指针：`D::clone`不能返回`unique_ptr<D>`，而`B::clone`返回`unique_ptr<B>`。因此，你需要在所有重写中一致地返回`unique_ptr<B>`，或者使用[指南支持库](#ss-views)中的`owner<>`实用工具。
- en: 'C.131: Avoid trivial getters and setters'
  id: totrans-2507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.131：避免平凡的获取器和设置器
- en: Reason
  id: totrans-2508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A trivial getter or setter adds no semantic value; the data item could just
    as well be `public`.
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: 一个平凡的获取器或设置器不增加语义价值；数据项也可以是`public`。
- en: Example
  id: totrans-2510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE298]'
  id: totrans-2511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Consider making such a class a `struct` – that is, a behaviorless bunch of variables,
    all public data and no member functions.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将此类改为`struct`——即一个无行为的变量集合，所有都是公共数据，没有成员函数。
- en: '[PRE299]'
  id: totrans-2513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'Note that we can put default initializers on data members: [C.49: Prefer initialization
    to assignment in constructors](#rc-initialize).'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们可以在数据成员上放置默认初始化器：[C.49：在构造函数中优先使用初始化而不是赋值](#rc-initialize)。
- en: Note
  id: totrans-2515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The key to this rule is whether the semantics of the getter/setter are trivial.
    While it is not a complete definition of “trivial”, consider whether there would
    be any difference beyond syntax if the getter/setter was a public data member
    instead. Examples of non-trivial semantics would be: maintaining a class invariant
    or converting between an internal type and an interface type.'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则的关键在于获取器/设置器的语义是否平凡。虽然这并不是“平凡”的完整定义，但考虑如果获取器/设置器是一个公共数据成员，语法之外是否会有任何区别。非平凡语义的例子包括：维护类的不变量或在内部类型和接口类型之间进行转换。
- en: Enforcement
  id: totrans-2517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag multiple `get` and `set` member functions that simply access a member without
    additional semantics.
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 标记多个仅访问成员而没有额外语义的`get`和`set`成员函数。
- en: 'C.132: Don’t make a function `virtual` without reason'
  id: totrans-2519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.132：不要无理由地将函数设为`virtual`
- en: Reason
  id: totrans-2520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Redundant `virtual` increases run-time and object-code size. A virtual function
    can be overridden and is thus open to mistakes in a derived class. A virtual function
    ensures code replication in a templated hierarchy.
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 无用的`virtual`增加了运行时和目标代码的大小。一个虚函数可以被重写，因此容易在派生类中出错。虚函数确保在模板层次结构中代码复制。
- en: Example, bad
  id: totrans-2522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE300]'
  id: totrans-2523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: This kind of “vector” isn’t meant to be used as a base class at all.
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“向量”根本不应该用作基类。
- en: Enforcement
  id: totrans-2525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag a class with virtual functions but no derived classes.
  id: totrans-2526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个具有虚函数但没有派生类的类。
- en: Flag a class where all member functions are virtual and have implementations.
  id: totrans-2527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个所有成员函数都是虚函数且有实现的类。
- en: 'C.133: Avoid `protected` data'
  id: totrans-2528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.133：避免使用`protected`数据
- en: '**Alternative formulation**: Make member data `public` or (preferably) `private`.'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：将成员数据设置为`public`或（更佳）`private`。'
- en: Reason
  id: totrans-2530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`protected` data is a source of complexity and errors. `protected` data complicates
    the statement of invariants. `protected` data inherently violates the guidance
    against putting data in base classes, which usually leads to having to deal with
    virtual inheritance as well.'
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`数据是复杂性和错误的一个来源。`protected`数据使得不变量的声明变得复杂。`protected`数据本质上违反了将数据放在基类中的指导原则，这通常会导致不得不处理虚继承。'
- en: Example, bad
  id: totrans-2532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE301]'
  id: totrans-2533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Now it is up to every derived `Shape` to manipulate the protected data correctly.
    This has been popular, but also a major source of maintenance problems. In a large
    class hierarchy, the consistent use of protected data is hard to maintain because
    there can be a lot of code, spread over a lot of classes. The set of classes that
    can touch that data is open: anyone can derive a new class and start manipulating
    the protected data. Often, it is not possible to examine the complete set of classes,
    so any change to the representation of the class becomes infeasible. There is
    no enforced invariant for the protected data; it is much like a set of global
    variables. The protected data has de facto become global to a large body of code.'
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由每个派生的`Shape`类来正确地操作受保护的数据。这很受欢迎，但也是维护问题的主要来源。在一个大的类层次结构中，一致地使用受保护数据很难维护，因为可能会有很多代码，分散在许多类中。可以接触那些数据的类集合是开放的：任何人都可以派生一个新的类并开始操作受保护的数据。通常，无法检查完整的类集合，因此任何对类表示的更改都变得不可行。没有强制的不变量来保护数据；它就像一组全局变量。实际上，受保护的数据已经变成了一大批代码的全局变量。
- en: Note
  id: totrans-2535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Protected data often looks tempting to enable arbitrary improvements through
    derivation. Often, what you get is unprincipled changes and errors. [Prefer `private`
    data](#rc-private) with a well-specified and enforced invariant. Alternatively,
    and often better, [keep data out of any class used as an interface](#rh-abstract).
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的数据往往很有吸引力，可以通过派生来实现任意改进。通常，你得到的是无原则的改变和错误。[优先使用`private`数据](#rc-private)，并具有良好定义和执行的不可变变量。或者，通常更好，[将数据排除在用作接口的任何类之外](#rh-abstract)。
- en: Note
  id: totrans-2537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Protected member function can be just fine.
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的成员函数可以非常好。
- en: Enforcement
  id: totrans-2539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag classes with `protected` data.
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 标记具有`protected`数据的类。
- en: 'C.134: Ensure all non-`const` data members have the same access level'
  id: totrans-2541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.134：确保所有非`const`数据成员具有相同的访问级别
- en: Reason
  id: totrans-2542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Prevention of logical confusion leading to errors. If the non-`const` data members
    don’t have the same access level, the type is confused about what it’s trying
    to do. Is it a type that maintains an invariant or simply a collection of values?
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
  zh: 防止逻辑混淆导致错误。如果非`const`数据成员不具有相同的访问级别，类型就会对其试图做什么感到困惑。这是一个维护不变量的类型，还是一个仅仅是一组值的集合？
- en: Discussion
  id: totrans-2544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The core question is: What code is responsible for maintaining a meaningful/correct
    value for that variable?'
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 核心问题是：哪段代码负责维护该变量的有意义/正确值？
- en: 'There are exactly two kinds of data members:'
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
  zh: 精确有两种数据成员：
- en: 'A: Ones that don’t participate in the object’s invariant. Any combination of
    values for these members is valid.'
  id: totrans-2547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A：那些不参与对象不变量的。这些成员的任何值组合都是有效的。
- en: 'B: Ones that do participate in the object’s invariant. Not every combination
    of values is meaningful (else there’d be no invariant). Therefore all code that
    has write access to these variables must know about the invariant, know the semantics,
    and know (and actively implement and enforce) the rules for keeping the values
    correct.'
  id: totrans-2548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B：那些参与对象不变量的。不是每个值的组合都是有意义的（否则就没有不变量）。因此，所有对这些变量具有写入访问权限的代码都必须了解不变量，了解语义，并了解（并积极实施和执行）保持值正确的规则。
- en: Data members in category A should just be `public` (or, more rarely, `protected`
    if you only want derived classes to see them). They don’t need encapsulation.
    All code in the system might as well see and manipulate them.
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 类别A中的数据成员应该是`public`的（或者，更少见的，如果是只想让派生类看到它们，则可以是`protected`）。它们不需要封装。系统中的所有代码都可以看到并操作它们。
- en: 'Data members in category B should be `private` or `const`. This is because
    encapsulation is important. To make them non-`private` and non-`const` would mean
    that the object can’t control its own state: An unbounded amount of code beyond
    the class would need to know about the invariant and participate in maintaining
    it accurately – if these data members were `public`, that would be all calling
    code that uses the object; if they were `protected`, it would be all the code
    in current and future derived classes. This leads to brittle and tightly coupled
    code that quickly becomes a nightmare to maintain. Any code that inadvertently
    sets the data members to an invalid or unexpected combination of values would
    corrupt the object and all subsequent uses of the object.'
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: B类中的数据成员应该是`private`或`const`。这是因为封装很重要。如果使它们非`private`和非`const`，则意味着对象无法控制自己的状态：超出类的未限定数量的代码需要了解不变性并参与其准确维护——如果这些数据成员是`public`的，那么将是所有使用该对象的所有调用代码；如果它们是`protected`的，那么将是当前和未来派生类中的所有代码。这会导致脆弱且紧密耦合的代码，很快就会变得难以维护。任何意外将数据成员设置为无效或意外组合值的代码都会破坏对象及其后续使用。
- en: 'Most classes are either all A or all B:'
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类要么全是A，要么全是B：
- en: '*All public*: If you’re writing an aggregate bundle-of-variables without an
    invariant across those variables, then all the variables should be `public`. [By
    convention, declare such classes `struct` rather than `class`](#rc-struct)'
  id: totrans-2552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*所有公共的*：如果你正在编写一个没有变量之间不变性的聚合变量包，那么所有变量都应该是`public`。 [按照惯例，声明这样的类为`struct`而不是`class`](#rc-struct)'
- en: '*All private*: If you’re writing a type that maintains an invariant, then all
    the non-`const` variables should be private – it should be encapsulated.'
  id: totrans-2553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*所有私有的*：如果你正在编写一个维护不变性的类型，那么所有非`const`变量都应该是私有的——它应该被封装。'
- en: Exception
  id: totrans-2554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Occasionally classes will mix A and B, usually for debug reasons. An encapsulated
    object might contain something like non-`const` debug instrumentation that isn’t
    part of the invariant and so falls into category A – it isn’t really part of the
    object’s value or meaningful observable state either. In that case, the A parts
    should be treated as A’s (made `public`, or in rarer cases `protected` if they
    should be visible only to derived classes) and the B parts should still be treated
    like B’s (`private` or `const`).
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: 有时类会混合A和B，通常是为了调试原因。一个封装的对象可能包含类似非`const`调试工具这样的东西，这不是不变性的一部分，因此属于A类——它也不是对象的真正价值或有意义的状态的一部分。在这种情况下，A部分应被视为A的（使其`public`，或在更罕见的情况下，如果它们应该仅对派生类可见，则使用`protected`），而B部分应继续像B一样处理（`private`或`const`）。
- en: Enforcement
  id: totrans-2556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag any class that has non-`const` data members with different access levels.
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 标记任何具有不同访问级别非`const`数据成员的类。
- en: 'C.135: Use multiple inheritance to represent multiple distinct interfaces'
  id: totrans-2558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.135: 使用多重继承来表示多个不同的接口'
- en: Reason
  id: totrans-2559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Not all classes will necessarily support all interfaces, and not all callers
    will necessarily want to deal with all operations. Especially to break apart monolithic
    interfaces into “aspects” of behavior supported by a given derived class.
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类都必然支持所有接口，也并非所有调用者都必然想要处理所有操作。特别是将单体接口分解为给定派生类支持的行为“方面”。
- en: Example
  id: totrans-2561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE302]'
  id: totrans-2562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '`istream` provides the interface to input operations; `ostream` provides the
    interface to output operations. `iostream` provides the union of the `istream`
    and `ostream` interfaces and the synchronization needed to allow both on a single
    stream.'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream`提供了输入操作的接口；`ostream`提供了输出操作的接口。`iostream`提供了`istream`和`ostream`接口的并集以及同步，以允许在单个流上同时使用这两个接口。'
- en: Note
  id: totrans-2564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is a very common use of inheritance because the need for multiple different
    interfaces to an implementation is common and such interfaces are often not easily
    or naturally organized into a single-rooted hierarchy.
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常常见的继承用法，因为对实现的不同接口的需求很常见，并且这些接口通常不容易或自然地组织成一个单根层次结构。
- en: Note
  id: totrans-2566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Such interfaces are typically abstract classes.
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的接口通常是抽象类。
- en: Enforcement
  id: totrans-2568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.136: Use multiple inheritance to represent the union of implementation attributes'
  id: totrans-2570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.136: 使用多重继承来表示实现属性的并集'
- en: Reason
  id: totrans-2571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Some forms of mixins have state and often operations on that state. If the operations
    are virtual the use of inheritance is necessary, if not using inheritance can
    avoid boilerplate and forwarding.
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 一些形式的混入有状态，并且通常对那个状态进行操作。如果操作是虚拟的，则使用继承是必要的，如果不使用继承可以避免样板和转发。
- en: Example
  id: totrans-2573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE303]'
  id: totrans-2574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '`istream` provides the interface to input operations (and some data); `ostream`
    provides the interface to output operations (and some data). `iostream` provides
    the union of the `istream` and `ostream` interfaces and the synchronization needed
    to allow both on a single stream.'
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: '`istream`提供了输入操作（以及一些数据）的接口；`ostream`提供了输出操作（以及一些数据）的接口。`iostream`提供了`istream`和`ostream`接口的联合以及同步，以允许在单个流上同时使用这两个接口。'
- en: Note
  id: totrans-2576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is a relatively rare use because implementation can often be organized
    into a single-rooted hierarchy.
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较少的使用，因为实现通常可以组织成一个单根层次结构。
- en: Example
  id: totrans-2578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Sometimes, an “implementation attribute” is more like a “mixin” that determines
    the behavior of an implementation and injects members to enable the implementation
    of the policies it requires. For example, see `std::enable_shared_from_this` or
    various bases from boost.intrusive (e.g. `list_base_hook` or `intrusive_ref_counter`).
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，“实现属性”更像是一个“混入”，它决定了实现的行为，并注入成员以实现它所要求的策略。例如，参见`std::enable_shared_from_this`或boost.intrusive的各种基类（例如`list_base_hook`或`intrusive_ref_counter`）。
- en: Enforcement
  id: totrans-2580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.137: Use `virtual` bases to avoid overly general base classes'
  id: totrans-2582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.137: 使用`virtual`基类来避免过于通用的基类'
- en: Reason
  id: totrans-2583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Allow separation of shared data and interface. To avoid all shared data to being
    put into an ultimate base class.
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: 允许分离共享数据和接口。为了避免所有共享数据都放入一个终极基类中。
- en: Example
  id: totrans-2585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE304]'
  id: totrans-2586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: Factoring out `Utility` makes sense if many derived classes share significant
    “implementation details.”
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果许多派生类共享重要的“实现细节”，则将`Utility`因子化是有意义的。
- en: Note
  id: totrans-2588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Obviously, the example is too “theoretical”, but it is hard to find a *small*
    realistic example. `Interface` is the root of an [interface hierarchy](#rh-abstract)
    and `Utility` is the root of an [implementation hierarchy](#rh-kind). Here is
    [a slightly more realistic example](https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck)
    with an explanation.
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，示例过于“理论化”，但很难找到一个*小*的现实示例。"Interface"是[接口层次结构](#rh-abstract)的根，"Utility"是[实现层次结构](#rh-kind)的根。这里有一个[稍微更现实的示例](https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck)及其解释。
- en: Note
  id: totrans-2590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Often, linearization of a hierarchy is a better solution.
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，层次结构的线性化是一个更好的解决方案。
- en: Enforcement
  id: totrans-2592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag mixed interface and implementation hierarchies.
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 标记混合接口和实现层次结构。
- en: 'C.138: Create an overload set for a derived class and its bases with `using`'
  id: totrans-2594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.138: 使用`using`为派生类及其基类创建一个重载集'
- en: Reason
  id: totrans-2595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Without a using declaration, member functions in the derived class hide the
    entire inherited overload sets.
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用声明的情况下，派生类中的成员函数会隐藏整个继承的重载集。
- en: Example, bad
  id: totrans-2597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE305]'
  id: totrans-2598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: Example, good
  id: totrans-2599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE306]'
  id: totrans-2600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Note
  id: totrans-2601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This issue affects both virtual and non-virtual member functions
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题影响虚拟和非虚拟成员函数
- en: For variadic bases, C++17 introduced a variadic form of the using-declaration,
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变长基类，C++17引入了使用声明的变长形式，
- en: '[PRE307]'
  id: totrans-2604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: Enforcement
  id: totrans-2605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Diagnose name hiding
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断名称隐藏
- en: 'C.139: Use `final` on classes sparingly'
  id: totrans-2607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.139: 在类上谨慎使用`final`'
- en: Reason
  id: totrans-2608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Capping a hierarchy with `final` classes is rarely needed for logical reasons
    and can be damaging to the extensibility of a hierarchy.
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑原因，很少需要使用`final`类来封顶一个层次结构，并且这可能会损害层次结构的可扩展性。
- en: Example, bad
  id: totrans-2610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE308]'
  id: totrans-2611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: Note
  id: totrans-2612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Not every class is meant to be a base class. Most standard-library classes are
    examples of that (e.g., `std::vector` and `std::string` are not designed to be
    derived from). This rule is about using `final` on classes with virtual functions
    meant to be interfaces for a class hierarchy.
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个类都旨在成为基类。大多数标准库类都是这样的例子（例如，`std::vector`和`std::string`不是设计为从其派生的）。本规则是关于在具有虚拟函数的类上使用`final`，这些虚拟函数旨在作为类层次结构的接口。
- en: Note
  id: totrans-2614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Claims of performance improvements from `final` should be substantiated. Too
    often, such claims are based on conjecture or experience with other languages.
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`final`的性能改进声明应该得到证实。过于频繁地，此类声明基于推测或对其他语言的体验。
- en: There are examples where `final` can be important for both logical and performance
    reasons. One example is a performance-critical AST hierarchy in a compiler or
    language analysis tool. New derived classes are not added every year and only
    by library implementers. However, misuses are (or at least have been) far more
    common.
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些例子中，`final`对于逻辑和性能原因都很重要。一个例子是编译器或语言分析工具中性能关键性的AST层次结构。每年都不会添加新的派生类，而且只有库实现者才会添加。然而，误用（或者至少曾经是）更为常见。
- en: Enforcement
  id: totrans-2617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag uses of `final` on classes.
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
  zh: 标记类上`final`的使用。
- en: 'C.140: Do not provide different default arguments for a virtual function and
    an overrider'
  id: totrans-2619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.140: 不要为虚拟函数和覆盖者提供不同的默认参数'
- en: Reason
  id: totrans-2620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'That can cause confusion: An overrider does not inherit default arguments.'
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致混淆：覆盖者不会继承默认参数。
- en: Example, bad
  id: totrans-2622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE309]'
  id: totrans-2623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Enforcement
  id: totrans-2624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag default arguments on virtual functions if they differ between base and
    derived declarations.
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果虚拟函数在基类和派生类声明中不同，则标记默认参数。
- en: 'C.hier-access: Accessing objects in a hierarchy'
  id: totrans-2626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'C.hier-access: 访问层次中的对象'
- en: 'C.145: Access polymorphic objects through pointers and references'
  id: totrans-2627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.145: 通过指针和引用访问多态对象'
- en: Reason
  id: totrans-2628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you have a class with a virtual function, you don’t (in general) know which
    class provided the function to be used.
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个具有虚拟函数的类，你通常不知道哪个类提供了要使用的函数。
- en: Example
  id: totrans-2630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE310]'
  id: totrans-2631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Both `d`s are sliced.
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `d` 都被切片了。
- en: Exception
  id: totrans-2633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: You can safely access a named polymorphic object in the scope of its definition,
    just don’t slice it.
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以安全地访问其定义作用域内的命名多态对象，只是不要切片它。
- en: '[PRE311]'
  id: totrans-2635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: See also
  id: totrans-2636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参见
- en: '[A polymorphic class should suppress copying](#rc-copy-virtual)'
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: '[多态类应该抑制复制](#rc-copy-virtual)'
- en: Enforcement
  id: totrans-2638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all slicing.
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有切片。
- en: 'C.146: Use `dynamic_cast` where class hierarchy navigation is unavoidable'
  id: totrans-2640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.146: 在类层次导航不可避免时使用 `dynamic_cast`'
- en: Reason
  id: totrans-2641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`dynamic_cast` is checked at run time.'
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic_cast` 在运行时进行检查。'
- en: Example
  id: totrans-2643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE312]'
  id: totrans-2644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'Use of the other casts can violate type safety and cause the program to access
    a variable that is actually of type `X` to be accessed as if it were of an unrelated
    type `Z`:'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他转换可能会违反类型安全，并导致程序以不相关类型 `Z` 的方式访问实际上为类型 `X` 的变量：
- en: '[PRE313]'
  id: totrans-2646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: Note
  id: totrans-2647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Like other casts, `dynamic_cast` is overused. [Prefer virtual functions to casting](#rh-use-virtual).
    Prefer [static polymorphism](#???) to hierarchy navigation where it is possible
    (no run-time resolution necessary) and reasonably convenient.
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他转换一样，`dynamic_cast` 被过度使用。[优先使用虚拟函数而不是转换](#rh-use-virtual)。如果可能，优先使用[静态多态](#???)而不是层次导航（不需要运行时解析且合理方便）。
- en: Note
  id: totrans-2649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some people use `dynamic_cast` where a `typeid` would have been more appropriate;
    `dynamic_cast` is a general “is kind of” operation for discovering the best interface
    to an object, whereas `typeid` is a “give me the exact type of this object” operation
    to discover the actual type of an object. The latter is an inherently simpler
    operation that ought to be faster. The latter (`typeid`) is easily hand-crafted
    if necessary (e.g., if working on a system where RTTI is – for some reason – prohibited),
    the former (`dynamic_cast`) is far harder to implement correctly in general.
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人使用 `dynamic_cast` 而不是更合适的 `typeid`；`dynamic_cast` 是一个通用的“是某种类型”操作，用于发现访问对象的最佳接口，而
    `typeid` 是一个“给出此对象的精确类型”操作，用于发现对象的实际类型。后者是一个本质上更简单的操作，应该更快。如果需要（例如，在某个系统中 RTTI
    被禁止），后者（`typeid`）可以很容易地手工制作，而前者（`dynamic_cast`）在一般情况下要难得多才能正确实现。
- en: 'Consider:'
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE314]'
  id: totrans-2652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: The result of `pb2->id() == "D"` is actually implementation defined. We added
    it to warn of the dangers of home-brew RTTI. This code might work as expected
    for years, just to fail on a new machine, new compiler, or a new linker that does
    not unify character literals.
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: '`pb2->id() == "D"` 的结果是实现定义的。我们添加它来警告自制的 RTTI 的危险。这段代码可能几年内都能按预期工作，但可能在新的机器、新的编译器或新的链接器上失败，这些链接器不统一字符字面量。'
- en: If you implement your own RTTI, be careful.
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现了自己的 RTTI，请小心。
- en: Exception
  id: totrans-2655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: If your implementation provided a really slow `dynamic_cast`, you might have
    to use a workaround. However, all workarounds that cannot be statically resolved
    involve explicit casting (typically `static_cast`) and are error-prone. You will
    basically be crafting your own special-purpose `dynamic_cast`. So, first make
    sure that your `dynamic_cast` really is as slow as you think it is (there are
    a fair number of unsupported rumors about) and that your use of `dynamic_cast`
    is really performance critical.
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的实现提供了一个非常慢的 `dynamic_cast`，你可能需要使用一个解决方案。然而，所有无法静态解决的解决方案都涉及显式转换（通常是 `static_cast`），并且容易出错。你基本上是在制作自己的专用
    `dynamic_cast`。所以，首先确保你的 `dynamic_cast` 真的像你想象的那样慢（有许多未经证实的谣言），并且你的 `dynamic_cast`
    使用确实是性能关键。
- en: We are of the opinion that current implementations of `dynamic_cast` are unnecessarily
    slow. For example, under suitable conditions, it is possible to perform a `dynamic_cast`
    in [fast constant time](https://www.stroustrup.com/fast_dynamic_casting.pdf).
    However, compatibility makes changes difficult even if all agree that an effort
    to optimize is worthwhile.
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为当前的`dynamic_cast`实现不必要地慢。例如，在合适条件下，可以以[快速常量时间](https://www.stroustrup.com/fast_dynamic_casting.pdf)执行`dynamic_cast`。然而，兼容性使得即使所有人都认为优化是值得的，改变也变得困难。
- en: In very rare cases, if you have measured that the `dynamic_cast` overhead is
    material, you have other means to statically guarantee that a downcast will succeed
    (e.g., you are using CRTP carefully), and there is no virtual inheritance involved,
    consider tactically resorting `static_cast` with a prominent comment and disclaimer
    summarizing this paragraph and that human attention is needed under maintenance
    because the type system can’t verify correctness. Even so, in our experience such
    “I know what I’m doing” situations are still a known bug source.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常罕见的情况下，如果你已经测量出`dynamic_cast`的开销是实质性的，你有其他方法来静态保证向下转换将成功（例如，你正在谨慎地使用CRTP），并且没有涉及虚拟继承，考虑策略性地回退到`static_cast`，并附上显眼的注释和免责声明总结本段，并指出在维护期间需要人工注意，因为类型系统无法验证正确性。即便如此，根据我们的经验，这种“我知道我在做什么”的情况仍然是已知的错误来源。
- en: Exception
  id: totrans-2659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'Consider:'
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE315]'
  id: totrans-2661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: Enforcement
  id: totrans-2662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all uses of `static_cast` for downcasts, including C-style casts that perform
    a `static_cast`.
  id: totrans-2663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有用于向下转换的`static_cast`的使用，包括执行`static_cast`的C样式转换。
- en: This rule is part of the [type-safety profile](#pro-type-downcast).
  id: totrans-2664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此规则是[类型安全配置文件](#pro-type-downcast)的一部分。
- en: 'C.147: Use `dynamic_cast` to a reference type when failure to find the required
    class is considered an error'
  id: totrans-2665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.147：当找不到所需类被视为错误时，使用`dynamic_cast`到引用类型
- en: Reason
  id: totrans-2666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Casting to a reference expresses that you intend to end up with a valid object,
    so the cast must succeed. `dynamic_cast` will then throw if it does not succeed.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型转换为引用表示你打算得到一个有效的对象，因此转换必须成功。如果`dynamic_cast`失败，它将抛出异常。
- en: Example
  id: totrans-2668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE316]'
  id: totrans-2669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Enforcement
  id: totrans-2670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.148: Use `dynamic_cast` to a pointer type when failure to find the required
    class is considered a valid alternative'
  id: totrans-2672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.148：当找不到所需类被视为有效替代方案时，使用`dynamic_cast`到指针类型
- en: Reason
  id: totrans-2673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The `dynamic_cast` conversion allows to test whether a pointer is pointing at
    a polymorphic object that has a given class in its hierarchy. Since failure to
    find the class merely returns a null value, it can be tested during run time.
    This allows writing code that can choose alternative paths depending on the results.
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic_cast`转换允许测试指针是否指向具有给定类层次结构的多态对象。由于找不到类的失败仅返回空值，它可以在运行时进行测试。这允许编写根据结果选择不同路径的代码。'
- en: Contrast with [C.147](#rh-ref-cast), where failure is an error, and should not
    be used for conditional execution.
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: 与[C.147](#rh-ref-cast)进行对比，其中失败被视为错误，不应用于条件执行。
- en: Example
  id: totrans-2676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: The example below describes the `add` function of a `Shape_owner` that takes
    ownership of constructed `Shape` objects. The objects are also sorted into views,
    according to their geometric attributes. In this example, `Shape` does not inherit
    from `Geometric_attributes`. Only its subclasses do.
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例描述了`Shape_owner`的`add`函数，该函数接收构造的`Shape`对象的所有权。这些对象也根据它们的几何属性排序到视图中。在这个例子中，`Shape`不继承自`Geometric_attributes`。只有它的子类才继承。
- en: '[PRE317]'
  id: totrans-2678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: Notes
  id: totrans-2679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: A failure to find the required class will cause `dynamic_cast` to return a null
    value, and de-referencing a null-valued pointer will lead to undefined behavior.
    Therefore the result of the `dynamic_cast` should always be treated as if it might
    contain a null value, and tested.
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 找不到所需类将导致`dynamic_cast`返回空值，解引用空值指针将导致未定义行为。因此，`dynamic_cast`的结果应始终被视为可能包含空值，并对其进行测试。
- en: Enforcement
  id: totrans-2681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Complex) Unless there is a null test on the result of a `dynamic_cast` of a
    pointer type, warn upon dereference of the pointer.
  id: totrans-2682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （复杂）除非对指针类型的`dynamic_cast`的结果进行空值测试，否则在解引用指针时发出警告。
- en: 'C.149: Use `unique_ptr` or `shared_ptr` to avoid forgetting to `delete` objects
    created using `new`'
  id: totrans-2683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.149：使用`unique_ptr`或`shared_ptr`来避免忘记删除使用`new`创建的对象
- en: Reason
  id: totrans-2684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoid resource leaks.
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
  zh: 避免资源泄露。
- en: Example
  id: totrans-2686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE318]'
  id: totrans-2687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: Enforcement
  id: totrans-2688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag initialization of a naked pointer with the result of a `new`
  id: totrans-2689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记裸指针的初始化为`new`的结果
- en: Flag `delete` of local variable
  id: totrans-2690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记局部变量的`delete`
- en: 'C.150: Use `make_unique()` to construct objects owned by `unique_ptr`s'
  id: totrans-2691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.150: 使用 `make_unique()` 构造 `unique_ptr` 拥有的对象'
- en: See [R.23](#rr-make_unique)
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [R.23](#rr-make_unique)
- en: 'C.151: Use `make_shared()` to construct objects owned by `shared_ptr`s'
  id: totrans-2693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.151: 使用 `make_shared()` 构造 `shared_ptr` 拥有的对象'
- en: See [R.22](#rr-make_shared)
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [R.22](#rr-make_shared)
- en: 'C.152: Never assign a pointer to an array of derived class objects to a pointer
    to its base'
  id: totrans-2695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.152: 永远不要将派生类对象的数组指针赋值给基类指针'
- en: Reason
  id: totrans-2696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Subscripting the resulting base pointer will lead to invalid object access and
    probably to memory corruption.
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 对结果基类指针进行下标访问将导致无效的对象访问，并可能导致内存损坏。
- en: Example
  id: totrans-2698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE319]'
  id: totrans-2699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: Enforcement
  id: totrans-2700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag all combinations of array decay and base to derived conversions.
  id: totrans-2701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有数组降级和基类到派生类转换的组合。
- en: Pass an array as a `span` rather than as a pointer, and don’t let the array
    name suffer a derived-to-base conversion before getting into the `span`
  id: totrans-2702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组作为 `span` 而不是指针传递，并且不要让数组名称在进入 `span` 之前经历从派生类到基类的转换
- en: 'C.153: Prefer virtual function to casting'
  id: totrans-2703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.153: 优先使用虚函数而不是类型转换'
- en: Reason
  id: totrans-2704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A virtual function call is safe, whereas casting is error-prone. A virtual function
    call reaches the most derived function, whereas a cast might reach an intermediate
    class and therefore give a wrong result (especially as a hierarchy is modified
    during maintenance).
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数调用是安全的，而类型转换则容易出错。虚函数调用会到达最派生的函数，而类型转换可能到达中间类，因此可能给出错误的结果（特别是在维护期间修改了层次结构时）。
- en: Example
  id: totrans-2706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE320]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: Enforcement
  id: totrans-2708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: See [C.146](#rh-dynamic_cast) and ???
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [C.146](#rh-dynamic_cast) 和 ???
- en: 'C.over: Overloading and overloaded operators'
  id: totrans-2710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'C.over: 重载和重载运算符'
- en: You can overload ordinary functions, function templates, and operators. You
    cannot overload function objects.
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重载普通函数、函数模板和运算符。你不能重载函数对象。
- en: 'Overload rule summary:'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: 重载规则总结：
- en: '[C.160: Define operators primarily to mimic conventional usage](#ro-conventional)'
  id: totrans-2713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.160: 主要定义运算符以模仿传统用法](#ro-conventional)'
- en: '[C.161: Use non-member functions for symmetric operators](#ro-symmetric)'
  id: totrans-2714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.161: 使用非成员函数实现对称运算符](#ro-symmetric)'
- en: '[C.162: Overload operations that are roughly equivalent](#ro-equivalent)'
  id: totrans-2715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.162: 重载大致等价的操作](#ro-equivalent)'
- en: '[C.163: Overload only for operations that are roughly equivalent](#ro-equivalent-2)'
  id: totrans-2716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.163: 仅重载大致等价的操作](#ro-equivalent-2)'
- en: '[C.164: Avoid implicit conversion operators](#ro-conversion)'
  id: totrans-2717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.164: 避免隐式转换运算符](#ro-conversion)'
- en: '[C.165: Use `using` for customization points](#ro-custom)'
  id: totrans-2718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.165: 使用 `using` 关键字进行定制点](#ro-custom)'
- en: '[C.166: Overload unary `&` only as part of a system of smart pointers and references](#ro-address-of)'
  id: totrans-2719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.166: 仅作为智能指针和引用系统的一部分重载一元 `&` 运算符](#ro-address-of)'
- en: '[C.167: Use an operator for an operation with its conventional meaning](#ro-overload)'
  id: totrans-2720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.167: 使用运算符实现具有传统意义的操作](#ro-overload)'
- en: '[C.168: Define overloaded operators in the namespace of their operands](#ro-namespace)'
  id: totrans-2721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.168: 在操作数的命名空间中定义重载运算符](#ro-namespace)'
- en: '[C.170: If you feel like overloading a lambda, use a generic lambda](#ro-lambda)'
  id: totrans-2722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.170: 如果你想重载lambda表达式，请使用泛型lambda](#ro-lambda)'
- en: 'C.160: Define operators primarily to mimic conventional usage'
  id: totrans-2723
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.160: 主要定义运算符以模仿传统用法'
- en: Reason
  id: totrans-2724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Minimize surprises.
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化意外。
- en: Example
  id: totrans-2726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE321]'
  id: totrans-2727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'Here, the conventional semantics is maintained: [Copies compare equal](#ss-copy).'
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，传统的语义得到了保持：[副本比较相等](#ss-copy)。
- en: Example, bad
  id: totrans-2729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE322]'
  id: totrans-2730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Note
  id: totrans-2731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Non-member operators should be either friends or defined in [the same namespace
    as their operands](#ro-namespace). [Binary operators should treat their operands
    equivalently](#ro-symmetric).
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: 非成员运算符应该是友元或者定义在与它们的操作数相同的命名空间中[在操作数相同的命名空间中定义](#ro-namespace)。[二元运算符应该等价地对待它们的操作数](#ro-symmetric)。
- en: Enforcement
  id: totrans-2733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Possibly impossible.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不可能。
- en: 'C.161: Use non-member functions for symmetric operators'
  id: totrans-2735
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.161: 使用非成员函数实现对称运算符'
- en: Reason
  id: totrans-2736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you use member functions, you need two. Unless you use a non-member function
    for (say) `==`, `a == b` and `b == a` will be subtly different.
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用成员函数，你需要两个。除非你为（例如）`==` 使用非成员函数，否则 `a == b` 和 `b == a` 将会有细微的差别。
- en: Example
  id: totrans-2738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE323]'
  id: totrans-2739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: Enforcement
  id: totrans-2740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag member operator functions.
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: 标记成员运算符函数。
- en: 'C.162: Overload operations that are roughly equivalent'
  id: totrans-2742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.162: 重载大致等价的操作'
- en: Reason
  id: totrans-2743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Having different names for logically equivalent operations on different argument
    types is confusing, leads to encoding type information in function names, and
    inhibits generic programming.
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同参数类型上逻辑上等价的操作使用不同的名称会令人困惑，会导致在函数名称中编码类型信息，并阻碍泛型编程。
- en: Example
  id: totrans-2745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE324]'
  id: totrans-2747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'These three functions all print their arguments (appropriately). Conversely:'
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数都适当地打印它们的参数。相反：
- en: '[PRE325]'
  id: totrans-2749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: These three functions all print their arguments (appropriately). Adding to the
    name just introduced verbosity and inhibits generic code.
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数都适当地打印它们的参数。在名称中添加内容增加了冗余，并阻碍了泛型代码。
- en: Enforcement
  id: totrans-2751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.163: Overload only for operations that are roughly equivalent'
  id: totrans-2753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.163: 仅对大致等效的操作进行重载'
- en: Reason
  id: totrans-2754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Having the same name for logically different functions is confusing and leads
    to errors when using generic programming.
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逻辑上不同的函数使用相同的名称会令人困惑，并导致在泛型编程中使用时出错。
- en: Example
  id: totrans-2756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE326]'
  id: totrans-2758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'The two operations are fundamentally different (and unrelated) so it is good
    that their names differ. Conversely:'
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作在本质上不同（且无关），因此它们的名称不同是好事。相反：
- en: '[PRE327]'
  id: totrans-2760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: The two operations are still fundamentally different (and unrelated) but the
    names have been reduced to their (common) minimum, opening opportunities for confusion.
    Fortunately, the type system will catch many such mistakes.
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作在本质上仍然不同（且无关），但名称已被缩减到它们的（共同）最小值，这为混淆打开了机会。幸运的是，类型系统将捕获许多此类错误。
- en: Note
  id: totrans-2762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Be particularly careful about common and popular names, such as `open`, `move`,
    `+`, and `==`.
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意常见和流行的名称，例如 `open`、`move`、`+` 和 `==`。
- en: Enforcement
  id: totrans-2764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.164: Avoid implicit conversion operators'
  id: totrans-2766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.164: 避免隐式转换运算符'
- en: Reason
  id: totrans-2767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Implicit conversions can be essential (e.g., `double` to `int`) but often cause
    surprises (e.g., `String` to C-style string).
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换可能是必要的（例如，`double` 到 `int`），但通常会导致意外（例如，`String` 到 C 风格字符串）。
- en: Note
  id: totrans-2769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Prefer explicitly named conversions until a serious need is demonstrated. By
    “serious need” we mean a reason that is fundamental in the application domain
    (such as an integer to complex number conversion) and frequently needed. Do not
    introduce implicit conversions (through conversion operators or non-`explicit`
    constructors) just to gain a minor convenience.
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: 在证明有严重需求之前，优先使用显式命名的转换。通过“严重需求”我们指的是在应用领域中基本的原因（例如，整数到复数的转换）并且经常需要。不要仅仅为了获得微小的便利而引入隐式转换（通过转换运算符或非
    `explicit` 构造函数）。
- en: Example
  id: totrans-2771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE328]'
  id: totrans-2772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: The surprising and potentially damaging implicit conversion can occur in arbitrarily
    hard-to spot contexts, e.g.,
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到且可能有害的隐式转换可能在难以察觉的任意环境中发生，例如，
- en: '[PRE329]'
  id: totrans-2774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: The string returned by `ff()` is destroyed before the returned pointer into
    it can be used.
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: '`ff()` 返回的字符串在返回到其中的指针可以使用之前就被销毁了。'
- en: Enforcement
  id: totrans-2776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all non-explicit conversion operators.
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有非显式转换运算符。
- en: 'C.165: Use `using` for customization points'
  id: totrans-2778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.165: 使用 `using` 进行定制'
- en: Reason
  id: totrans-2779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To find function objects and functions defined in a separate namespace to “customize”
    a common function.
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到定义在单独命名空间中的函数对象和函数，以“定制”通用函数。
- en: Example
  id: totrans-2781
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Consider `swap`. It is a general (standard-library) function with a definition
    that will work for just about any type. However, it is desirable to define specific
    `swap()`s for specific types. For example, the general `swap()` will copy the
    elements of two `vector`s being swapped, whereas a good specific implementation
    will not copy elements at all.
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `swap`。它是一个通用（标准库）函数，其定义适用于几乎所有类型。然而，为特定类型定义特定的 `swap()` 是所希望的。例如，通用 `swap()`
    将复制正在交换的两个 `vector` 的元素，而一个好的特定实现则根本不会复制元素。
- en: '[PRE330]'
  id: totrans-2783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'The `std::swap()` in `f1()` does exactly what we asked it to do: it calls the
    `swap()` in namespace `std`. Unfortunately, that’s probably not what we wanted.
    How do we get `N::X` considered?'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1()` 中的 `std::swap()` 正好做了我们要求它做的事情：它调用了命名空间 `std` 中的 `swap()`。不幸的是，这可能不是我们想要的。我们如何使
    `N::X` 被考虑？'
- en: '[PRE331]'
  id: totrans-2785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'But that might not be what we wanted for generic code. There, we typically
    want the specific function if it exists and the general function if not. This
    is done by including the general function in the lookup for the function:'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: 但这可能不是我们为泛型代码所期望的。在那里，我们通常希望如果存在特定函数，则使用该特定函数；如果不存在，则使用通用函数。这是通过在函数查找中包含通用函数来实现的：
- en: '[PRE332]'
  id: totrans-2787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: Enforcement
  id: totrans-2788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Unlikely, except for known customization points, such as `swap`. The problem
    is that the unqualified and qualified lookups both have uses.
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已知的定制点，如 `swap`，否则不太可能。问题是未指定和指定查找都有用途。
- en: 'C.166: Overload unary `&` only as part of a system of smart pointers and references'
  id: totrans-2790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.166: 仅在智能指针和引用系统中将一元 `&` 赋予重载'
- en: Reason
  id: totrans-2791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The `&` operator is fundamental in C++. Many parts of the C++ semantics assume
    its default meaning.
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`&` 运算符是基本的。C++ 语义的许多部分都假设了它的默认意义。
- en: Example
  id: totrans-2793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE333]'
  id: totrans-2794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: Note
  id: totrans-2795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you “mess with” operator `&` be sure that its definition has matching meanings
    for `->`, `[]`, `*`, and `.` on the result type. Note that operator `.` currently
    cannot be overloaded so a perfect system is impossible. We hope to remedy that:
    [Operator Dot (R2)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf).
    Note that `std::addressof()` always yields a built-in pointer.'
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您“玩弄”运算符 `&`，请确保其定义在结果类型上的 `->`、`[]`、`*` 和 `.` 上具有匹配的含义。请注意，运算符 `.` 当前不能重载，因此完美的系统是不可能的。我们希望解决这个问题：[运算符点
    (R2)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf)。请注意，`std::addressof()`
    总是返回一个内置指针。
- en: Enforcement
  id: totrans-2797
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Tricky. Warn if `&` is user-defined without also defining `->` for the result
    type.
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂。如果用户定义了 `&` 但没有同时定义结果类型的 `->`，则发出警告。
- en: 'C.167: Use an operator for an operation with its conventional meaning'
  id: totrans-2799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.167: 使用具有传统意义的运算符'
- en: Reason
  id: totrans-2800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Convention. Reusability. Support for generic code
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。约定。可重用性。对泛型代码的支持
- en: Example
  id: totrans-2802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE334]'
  id: totrans-2803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'By itself, `cout_my_class` would be OK, but it is not usable/composable with
    code that relies on the `<<` convention for output:'
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来说，`cout_my_class` 可能是好的，但它不能与依赖于 `<<` 输出约定的代码一起使用/组合：
- en: '[PRE335]'
  id: totrans-2805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: Note
  id: totrans-2806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are strong and vigorous conventions for the meaning of most operators,
    such as
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符的含义有强烈和明确的约定，例如
- en: comparisons (`==`, `!=`, `<`, `<=`, `>`, `>=`, and `<=>`),
  id: totrans-2808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符（`==`、`!=`、`<`、`<=`、`>`、`>=` 和 `<=>`）
- en: arithmetic operations (`+`, `-`, `*`, `/`, and `%`)
  id: totrans-2809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算（`+`、`-`、`*`、`/` 和 `%`）
- en: access operations (`.`, `->`, unary `*`, and `[]`)
  id: totrans-2810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问操作（`.`、`->`、一元 `*` 和 `[]`）
- en: assignment (`=`)
  id: totrans-2811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值（`=`）
- en: Don’t define those unconventionally and don’t invent your own names for them.
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
  zh: 不要定义那些非传统的，也不要为它们发明自己的名称。
- en: Enforcement
  id: totrans-2813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Tricky. Requires semantic insight.
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂。需要语义洞察。
- en: 'C.168: Define overloaded operators in the namespace of their operands'
  id: totrans-2815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.168: 在操作数的命名空间中定义重载运算符'
- en: Reason
  id: totrans-2816
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Ability for find operators using ADL. Avoiding inconsistent definition
    in different namespaces
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。使用 ADL 查找运算符的能力。避免在不同命名空间中定义不一致
- en: Example
  id: totrans-2818
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE336]'
  id: totrans-2819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: Example
  id: totrans-2820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE337]'
  id: totrans-2821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: Example, bad
  id: totrans-2822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE338]'
  id: totrans-2823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Here, the meaning of `!s` differs in `N` and `M`. This can be most confusing.
    Remove the definition of `namespace M` and the confusion is replaced by an opportunity
    to make the mistake.
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`!s` 在 `N` 和 `M` 中的含义不同。这可能会非常令人困惑。删除 `namespace M` 的定义，困惑就会变成一个犯错误的机会。
- en: Note
  id: totrans-2825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If a binary operator is defined for two types that are defined in different
    namespaces, you cannot follow this rule. For example:'
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为定义在不同命名空间中的两个类型定义了二元运算符，则不能遵循此规则。例如：
- en: '[PRE339]'
  id: totrans-2827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: This might be something best avoided.
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最好避免的事情。
- en: See also
  id: totrans-2829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参见
- en: This is a special case of the rule that [helper functions should be defined
    in the same namespace as their class](#rc-helper).
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: 这是规则的特殊情况，即 [辅助函数应与其类在同一个命名空间中定义](#rc-helper)。
- en: Enforcement
  id: totrans-2831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag operator definitions that are not in the namespace of their operands
  id: totrans-2832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记不在操作数命名空间中的运算符定义
- en: 'C.170: If you feel like overloading a lambda, use a generic lambda'
  id: totrans-2833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.170: 如果您想重载 lambda，请使用泛型 lambda'
- en: Reason
  id: totrans-2834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: You cannot overload by defining two different lambdas with the same name.
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能通过定义两个具有相同名称的不同 lambda 来重载。
- en: Example
  id: totrans-2836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE340]'
  id: totrans-2837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: Enforcement
  id: totrans-2838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: The compiler catches the attempt to overload a lambda.
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会捕获尝试重载 lambda 的尝试。
- en: 'C.union: Unions'
  id: totrans-2840
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'C.union: 联合'
- en: A `union` is a `struct` where all members start at the same address so that
    it can hold only one member at a time. A `union` does not keep track of which
    member is stored so the programmer has to get it right; this is inherently error-prone,
    but there are ways to compensate.
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: '`union` 是一个 `struct`，其中所有成员都从同一地址开始，因此一次只能保存一个成员。`union` 不跟踪存储的是哪个成员，因此程序员必须正确获取它；这固有的容易出错，但有一些补偿方法。'
- en: A type that is a `union` plus an indicator of which member is currently held
    is called a *tagged union*, a *discriminated union*, or a *variant*.
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 一种既是 `union` 又有当前持有成员指示器的类型称为 *标记联合*、*区分联合* 或 *变体*。
- en: 'Union rule summary:'
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 联合规则摘要：
- en: '[C.180: Use `union`s to save Memory](#ru-union)'
  id: totrans-2844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.180: 使用 `union` 来节省内存](#ru-union)'
- en: '[C.181: Avoid “naked” `union`s](#ru-naked)'
  id: totrans-2845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.181: 避免使用“裸”`union`](#ru-naked)'
- en: '[C.182: Use anonymous `union`s to implement tagged unions](#ru-anonymous)'
  id: totrans-2846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.182: 使用匿名 `union` 来实现标记联合](#ru-anonymous)'
- en: '[C.183: Don’t use a `union` for type punning](#ru-pun)'
  id: totrans-2847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C.183: 不要使用 `union` 进行类型欺骗](#ru-pun)'
- en: ???
  id: totrans-2848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'C.180: Use `union`s to save memory'
  id: totrans-2849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.180: 使用 `union` 来节省内存'
- en: Reason
  id: totrans-2850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A `union` allows a single piece of memory to be used for different types of
    objects at different times. Consequently, it can be used to save memory when we
    have several objects that are never used at the same time.
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
  zh: '`union`允许在特定时间使用同一块内存来存储不同类型的对象。因此，当有多个对象永远不会同时使用时，可以使用它来节省内存。'
- en: Example
  id: totrans-2852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE341]'
  id: totrans-2853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'But heed the warning: [Avoid “naked” `union`s](#ru-naked)'
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意警告：[避免“裸”`union`](#ru-naked)
- en: Example
  id: totrans-2855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE342]'
  id: totrans-2856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: Enforcement
  id: totrans-2857
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.181: Avoid “naked” `union`s'
  id: totrans-2859
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.181：避免“裸”`union`
- en: Reason
  id: totrans-2860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A *naked union* is a union without an associated indicator which member (if
    any) it holds, so that the programmer has to keep track. Naked unions are a source
    of type errors.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*naked union*是一个没有关联指示器的联合，它持有（如果有的话）哪个成员，因此程序员必须跟踪。裸联合是类型错误的来源。
- en: Example, bad
  id: totrans-2862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE343]'
  id: totrans-2863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'So far, so good, but we can easily misuse the `union`:'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但我们很容易误用`union`：
- en: '[PRE344]'
  id: totrans-2865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: Note that the type error happened without any explicit cast. When we tested
    that program the last value printed was `1683627180` which is the integer value
    for the bit pattern for `987.654`. What we have here is an “invisible” type error
    that happens to give a result that could easily look innocent.
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型错误在没有任何显式转换的情况下发生。当我们测试该程序时，最后打印的值是`1683627180`，这是`987.654`的位模式的整数值。我们这里有一个“不可见”的类型错误，它恰好给出了一个可能看起来无辜的结果。
- en: 'And, talking about “invisible”, this code produced no output:'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于“不可见”，这段代码没有产生输出：
- en: '[PRE345]'
  id: totrans-2868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Alternative
  id: totrans-2869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Wrap a `union` in a class together with a type field.
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: 将`union`与类型字段一起包装在类中。
- en: 'The C++17 `variant` type (found in `<variant>`) does that for you:'
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: C++17的`variant`类型（在`<variant>`中找到）为你做了这件事：
- en: '[PRE346]'
  id: totrans-2872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: Enforcement
  id: totrans-2873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.182: Use anonymous `union`s to implement tagged unions'
  id: totrans-2875
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.182：使用匿名`union`实现标签联合
- en: Reason
  id: totrans-2876
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A well-designed tagged union is type safe. An *anonymous* union simplifies the
    definition of a class with a (tag, union) pair.
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的标签联合是类型安全的。一个*匿名*联合简化了具有（标签，联合）对的类的定义。
- en: Example
  id: totrans-2878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: This example is mostly borrowed from TC++PL4, pp. 216–218. You can look there
    for an explanation.
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子主要借鉴自TC++PL4，第216-218页。你可以在那里找到解释。
- en: The code is somewhat elaborate. Handling a type with user-defined assignment
    and destructor is tricky. Saving programmers from having to write such code is
    one reason for including `variant` in the standard.
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有些复杂。处理具有用户定义赋值运算符和析构函数的类型是棘手的。避免程序员编写此类代码是包括`variant`在标准中的一个原因。
- en: '[PRE347]'
  id: totrans-2881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: Enforcement
  id: totrans-2882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C.183: Don’t use a `union` for type punning'
  id: totrans-2884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.183：不要使用`union`进行类型戏法
- en: Reason
  id: totrans-2885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is undefined behavior to read a `union` member with a different type from
    the one with which it was written. Such punning is invisible, or at least harder
    to spot than using a named cast. Type punning using a `union` is a source of errors.
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与写入时不同类型的类型读取`union`成员是未定义的行为。这种戏法是不可见的，或者至少比使用命名转换更难发现。使用`union`进行类型戏法是错误的来源。
- en: Example, bad
  id: totrans-2887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE348]'
  id: totrans-2888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: The idea of `Pun` is to be able to look at the character representation of an
    `int`.
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pun`的想法是能够查看`int`的字符表示。'
- en: '[PRE349]'
  id: totrans-2890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'If you wanted to see the bytes of an `int`, use a (named) cast:'
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看`int`的字节，请使用一个（命名的）转换：
- en: '[PRE350]'
  id: totrans-2892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: Accessing the result of a `reinterpret_cast` from the object’s declared type
    to `char*`, `unsigned char*`, or `std::byte*` is defined behavior. (Using `reinterpret_cast`
    is discouraged, but at least we can see that something tricky is going on.)
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象的声明类型到`char*`、`unsigned char*`或`std::byte*`的`reinterpret_cast`结果是定义良好的行为。（使用`reinterpret_cast`是不被鼓励的，但至少我们可以看到有些棘手的事情正在发生。）
- en: Note
  id: totrans-2894
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, `union`s are commonly used for type punning. We don’t consider
    “sometimes, it works as expected” a conclusive argument.
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`union`通常用于类型戏法。我们不认为“有时它按预期工作”是一个决定性的论据。
- en: Modern C++ introduced `std::byte` (C++17) and `std::bit_cast` (C++20) to facilitate
    operations on raw object representations. Use `reinterpret_cast` along with `std::byte`
    instead of `unsigned char` or `char` for these operations.
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++引入了`std::byte`（C++17）和`std::bit_cast`（C++20）以简化对原始对象表示的操作。在这些操作中使用`reinterpret_cast`和`std::byte`代替`unsigned
    char`或`char`。
- en: Enforcement
  id: totrans-2897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Enum: Enumerations'
  id: totrans-2899
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举：枚举
- en: Enumerations are used to define sets of integer values and for defining types
    for such sets of values. There are two kinds of enumerations, “plain” `enum`s
    and `class enum`s.
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举用于定义整数值集合以及为这些值集合定义类型。有两种枚举类型，“普通”`enum`和`class enum`。
- en: 'Enumeration rule summary:'
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举规则摘要：
- en: '[Enum.1: Prefer enumerations over macros](#renum-macro)'
  id: totrans-2902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.1：优先使用枚举而不是宏](#renum-macro)'
- en: '[Enum.2: Use enumerations to represent sets of related named constants](#renum-set)'
  id: totrans-2903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.2：使用枚举表示相关命名字符常量的集合](#renum-set)'
- en: '[Enum.3: Prefer `enum class`es over “plain” `enum`s](#renum-class)'
  id: totrans-2904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.3：优先使用`enum class`而不是“普通”的`enum`](#renum-class)'
- en: '[Enum.4: Define operations on enumerations for safe and simple use](#renum-oper)'
  id: totrans-2905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.4：为枚举定义操作以实现安全和简单使用](#renum-oper)'
- en: '[Enum.5: Don’t use `ALL_CAPS` for enumerators](#renum-caps)'
  id: totrans-2906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.5：不要使用`ALL_CAPS`作为枚举值](#renum-caps)'
- en: '[Enum.6: Avoid unnamed enumerations](#renum-unnamed)'
  id: totrans-2907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.6：避免未命名的枚举](#renum-unnamed)'
- en: '[Enum.7: Specify the underlying type of an enumeration only when necessary](#renum-underlying)'
  id: totrans-2908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.7：仅在必要时指定枚举的基础类型](#renum-underlying)'
- en: '[Enum.8: Specify enumerator values only when necessary](#renum-value)'
  id: totrans-2909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[枚举.8：仅在必要时指定枚举值](#renum-value)'
- en: 'Enum.1: Prefer enumerations over macros'
  id: totrans-2910
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举.1：优先使用枚举而不是宏
- en: Reason
  id: totrans-2911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Macros do not obey scope and type rules. Also, macro names are removed during
    preprocessing and so usually don’t appear in tools like debuggers.
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: 宏不遵守作用域和类型规则。此外，宏名称在预处理期间被删除，因此通常不会出现在调试器等工具中。
- en: Example
  id: totrans-2913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'First some bad old code:'
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一些旧的糟糕代码：
- en: '[PRE351]'
  id: totrans-2915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'Instead use an `enum`:'
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
  zh: 而是使用`enum`：
- en: '[PRE352]'
  id: totrans-2917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: We used an `enum class` to avoid name clashes.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`enum class`来避免名称冲突。
- en: Note
  id: totrans-2919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Also consider `constexpr` and `const inline` variables.
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: 还应考虑`constexpr`和`const inline`变量。
- en: Enforcement
  id: totrans-2921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag macros that define integer values. Use `enum` or `const inline` or another
    non-macro alternative instead.
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 标记定义整数值的宏。使用`enum`或`const inline`或其他非宏替代方案。
- en: 'Enum.2: Use enumerations to represent sets of related named constants'
  id: totrans-2923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举.2：使用枚举表示相关命名字符常量的集合
- en: Reason
  id: totrans-2924
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An enumeration shows the enumerators to be related and can be a named type.
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举显示了枚举值之间的关系，并且可以是一个命名类型。
- en: Example
  id: totrans-2926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE353]'
  id: totrans-2927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: Note
  id: totrans-2928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Switching on an enumeration is common and the compiler can warn against unusual
    patterns of case labels. For example:'
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举上使用`switch`是常见的，编译器可以警告不寻常的`case`标签模式。例如：
- en: '[PRE354]'
  id: totrans-2930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: Such off-by-one `switch`-statements are often the results of an added enumerator
    and insufficient testing.
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 这种偏移量`switch`语句通常是添加枚举值和测试不足的结果。
- en: Enforcement
  id: totrans-2932
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag `switch`-statements where the `case`s cover most but not all enumerators
    of an enumeration.
  id: totrans-2933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`switch`语句，其中`case`涵盖了枚举类型的大多数枚举值，但不是全部。
- en: Flag `switch`-statements where the `case`s cover a few enumerators of an enumeration,
    but there is no `default`.
  id: totrans-2934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`switch`语句，其中`case`涵盖了枚举类型的一些枚举值，但没有`default`。
- en: 'Enum.3: Prefer class enums over “plain” enums'
  id: totrans-2935
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举.3：优先使用类枚举而不是“普通”枚举
- en: Reason
  id: totrans-2936
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'To minimize surprises: traditional enums convert to int too readily.'
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化意外：传统的枚举类型太容易转换为整型。
- en: Example
  id: totrans-2938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE355]'
  id: totrans-2939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'Instead use an `enum class`:'
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: 而是使用`enum class`：
- en: '[PRE356]'
  id: totrans-2941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: Enforcement
  id: totrans-2942
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: (Simple) Warn on any non-class `enum` definition.
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）对任何非类`enum`定义发出警告。
- en: 'Enum.4: Define operations on enumerations for safe and simple use'
  id: totrans-2944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举.4：为枚举定义操作以实现安全和简单使用
- en: Reason
  id: totrans-2945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Convenience of use and avoidance of errors.
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方便和避免错误。
- en: Example
  id: totrans-2947
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE357]'
  id: totrans-2948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: The use of a `static_cast` is not pretty, but
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static_cast`并不美观，但
- en: '[PRE358]'
  id: totrans-2950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: is an infinite recursion, and writing it without a cast, using a `switch` on
    all cases is long-winded.
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 是无限递归，如果不进行类型转换，使用所有情况的`switch`将变得冗长。
- en: Enforcement
  id: totrans-2952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag repeated expressions cast back into an enumeration.
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 标记重复表达式转换回枚举。
- en: 'Enum.5: Don’t use `ALL_CAPS` for enumerators'
  id: totrans-2954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举.5：不要使用`ALL_CAPS`作为枚举值
- en: Reason
  id: totrans-2955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoid clashes with macros.
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: 避免与宏冲突。
- en: Example, bad
  id: totrans-2957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE359]'
  id: totrans-2958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: Enforcement
  id: totrans-2959
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag ALL_CAPS enumerators.
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 标记`ALL_CAPS`枚举值。
- en: 'Enum.6: Avoid unnamed enumerations'
  id: totrans-2961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举.6：避免未命名的枚举
- en: Reason
  id: totrans-2962
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you can’t name an enumeration, the values are not related
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法命名枚举，则值之间没有关联
- en: Example, bad
  id: totrans-2964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE360]'
  id: totrans-2965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: Such code is not uncommon in code written before there were convenient alternative
    ways of specifying integer constants.
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码在编写之前没有方便的指定整型常量的替代方法时并不少见。
- en: Alternative
  id: totrans-2967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'Use `constexpr` values instead. For example:'
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`constexpr`值代替。例如：
- en: '[PRE361]'
  id: totrans-2969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: Enforcement
  id: totrans-2970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag unnamed enumerations.
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: 标记未命名的枚举。
- en: 'Enum.7: Specify the underlying type of an enumeration only when necessary'
  id: totrans-2972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举.7：仅在必要时指定枚举的基础类型
- en: Reason
  id: totrans-2973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The default is the easiest to read and write. `int` is the default integer type.
    `int` is compatible with C `enum`s.
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是最容易阅读和编写的。`int`是默认的整型。`int`与C语言的`enum`兼容。
- en: Example
  id: totrans-2975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE362]'
  id: totrans-2976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: Note
  id: totrans-2977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Specifying the underlying type is necessary to forward-declare an enum or enum
    class:'
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
  zh: 指定基础类型是枚举或枚举类前向声明的必要条件：
- en: '[PRE363]'
  id: totrans-2979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'or to ensure that values of that type have a specified bit-precision:'
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
  zh: 或者为了确保该类型的值具有指定的位精度：
- en: '[PRE364]'
  id: totrans-2981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: Enforcement
  id: totrans-2982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ????
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: ????
- en: 'Enum.8: Specify enumerator values only when necessary'
  id: totrans-2984
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '枚举.8: 仅在必要时指定枚举值'
- en: Reason
  id: totrans-2985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s the simplest. It avoids duplicate enumerator values. The default gives
    a consecutive set of values that is good for `switch`-statement implementations.
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的。它避免了重复的枚举值。默认情况下，它给出一个连续的值集，这对于 `switch` 语句的实现是有益的。
- en: Example
  id: totrans-2987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE365]'
  id: totrans-2988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: Specifying values is necessary to match conventional values (e.g., `Month`)
    and where consecutive values are undesirable (e.g., to get separate bits as in
    `Base_flag`).
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
  zh: 指定值是必要的，以匹配传统值（例如，`Month`）以及连续值不理想的情况（例如，在 `Base_flag` 中获取单独的位）。
- en: Enforcement
  id: totrans-2990
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag duplicate enumerator values
  id: totrans-2991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记重复枚举值
- en: Flag explicitly specified all-consecutive enumerator values
  id: totrans-2992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记显式指定的所有连续枚举值
- en: 'R: Resource management'
  id: totrans-2993
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'R: 资源管理'
- en: This section contains rules related to resources. A resource is anything that
    must be acquired and (explicitly or implicitly) released, such as memory, file
    handles, sockets, and locks. The reason it must be released is typically that
    it can be in short supply, so even delayed release might do harm. The fundamental
    aim is to ensure that we don’t leak any resources and that we don’t hold a resource
    longer than we need to. An entity that is responsible for releasing a resource
    is called an owner.
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含与资源相关的规则。资源是指任何必须获取和（显式或隐式）释放的东西，例如内存、文件句柄、套接字和锁。必须释放的原因通常是它们可能短缺，因此即使是延迟释放也可能造成损害。基本目标是确保我们不泄漏任何资源，并且我们不会长时间持有不需要的资源。负责释放资源的实体称为所有者。
- en: 'There are a few cases where leaks can be acceptable or even optimal: If you
    are writing a program that simply produces an output based on an input and the
    amount of memory needed is proportional to the size of the input, the optimal
    strategy (for performance and ease of programming) is sometimes simply never to
    delete anything. If you have enough memory to handle your largest input, leak
    away, but be sure to give a good error message if you are wrong. Here, we ignore
    such cases.'
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况下泄漏可能是可接受的，甚至是最优的：如果你正在编写一个程序，该程序仅基于输入产生输出，并且所需的内存量与输入的大小成比例，那么（对于性能和编程的简便性）有时简单地永不删除任何东西的策略可能是最优的。如果你有足够的内存来处理最大的输入，那么可以泄漏，但如果你错了，一定要给出一个好的错误信息。在这里，我们忽略这样的情况。
- en: 'Resource management rule summary:'
  id: totrans-2996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理规则摘要：
- en: '[R.1: Manage resources automatically using resource handles and RAII (Resource
    Acquisition Is Initialization)](#rr-raii)'
  id: totrans-2997
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.1: 使用资源句柄和 RAII（资源获取即初始化）自动管理资源](#rr-raii)'
- en: '[R.2: In interfaces, use raw pointers to denote individual objects (only)](#rr-use-ptr)'
  id: totrans-2998
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.2: 在接口中，使用原始指针来表示单个对象（仅限）](#rr-use-ptr)'
- en: '[R.3: A raw pointer (a `T*`) is non-owning](#rr-ptr)'
  id: totrans-2999
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.3: 原始指针（`T*`）是非所有权的](#rr-ptr)'
- en: '[R.4: A raw reference (a `T&`) is non-owning](#rr-ref)'
  id: totrans-3000
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.4: 原始引用（`T&`）是非所有权的](#rr-ref)'
- en: '[R.5: Prefer scoped objects, don’t heap-allocate unnecessarily](#rr-scoped)'
  id: totrans-3001
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.5: 优先使用作用域对象，不要不必要地堆分配](#rr-scoped)'
- en: '[R.6: Avoid non-`const` global variables](#rr-global)'
  id: totrans-3002
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.6: 避免使用非 `const` 全局变量](#rr-global)'
- en: 'Allocation and deallocation rule summary:'
  id: totrans-3003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配和释放规则摘要：
- en: '[R.10: Avoid `malloc()` and `free()`](#rr-mallocfree)'
  id: totrans-3004
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.10: 避免使用 `malloc()` 和 `free()`](#rr-mallocfree)'
- en: '[R.11: Avoid calling `new` and `delete` explicitly](#rr-newdelete)'
  id: totrans-3005
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.11: 避免显式调用 `new` 和 `delete`](#rr-newdelete)'
- en: '[R.12: Immediately give the result of an explicit resource allocation to a
    manager object](#rr-immediate-alloc)'
  id: totrans-3006
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.12: 立即将显式资源分配的结果传递给管理对象](#rr-immediate-alloc)'
- en: '[R.13: Perform at most one explicit resource allocation in a single expression
    statement](#rr-single-alloc)'
  id: totrans-3007
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.13: 在单个表达式语句中最多执行一次显式资源分配](#rr-single-alloc)'
- en: '[R.14: Avoid `[]` parameters, prefer `span`](#rr-ap)'
  id: totrans-3008
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.14: 避免使用 `[]` 参数，优先使用 `span`](#rr-ap)'
- en: '[R.15: Always overload matched allocation/deallocation pairs](#rr-pair)'
  id: totrans-3009
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.15: 总是重载匹配的分配/释放对](#rr-pair)'
- en: 'Smart pointer rule summary:'
  id: totrans-3010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能指针规则摘要：
- en: '[R.20: Use `unique_ptr` or `shared_ptr` to represent ownership](#rr-owner)'
  id: totrans-3011
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.20: 使用 `unique_ptr` 或 `shared_ptr` 来表示所有权](#rr-owner)'
- en: '[R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership](#rr-unique)'
  id: totrans-3012
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.21: 除非需要共享所有权，否则优先使用 `unique_ptr`](#rr-unique)'
- en: '[R.22: Use `make_shared()` to make `shared_ptr`s](#rr-make_shared)'
  id: totrans-3013
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.22: 使用 `make_shared()` 来创建 `shared_ptr`](#rr-make_shared)'
- en: '[R.23: Use `make_unique()` to make `unique_ptr`s](#rr-make_unique)'
  id: totrans-3014
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.23: 使用 `make_unique()` 来创建 `unique_ptr`](#rr-make_unique)'
- en: '[R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s](#rr-weak_ptr)'
  id: totrans-3015
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.24: 使用 `std::weak_ptr` 来打破 `shared_ptr` 的循环](#rr-weak_ptr)'
- en: '[R.30: Take smart pointers as parameters only to explicitly express lifetime
    semantics](#rr-smartptrparam)'
  id: totrans-3016
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.30: 仅为了显式表达生命周期语义，将智能指针作为参数传递](#rr-smartptrparam)'
- en: '[R.31: If you have non-`std` smart pointers, follow the basic pattern from
    `std`](#rr-smart)'
  id: totrans-3017
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.31: 如果你有非 `std` 智能指针，遵循 `std` 中的基本模式](#rr-smart)'
- en: '[R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes
    ownership of a `widget`](#rr-uniqueptrparam)'
  id: totrans-3018
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.32: 使用 `unique_ptr<widget>` 参数来表示函数假定拥有 `widget` 的所有权](#rr-uniqueptrparam)'
- en: '[R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats
    the `widget`](#rr-reseat)'
  id: totrans-3019
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.33: 使用 `unique_ptr<widget>&` 参数来表示函数重新设置 `widget` 的位置](#rr-reseat)'
- en: '[R.34: Take a `shared_ptr<widget>` parameter to express shared ownership](#rr-sharedptrparam-owner)'
  id: totrans-3020
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.34: 使用 `shared_ptr<widget>` 参数来表示共享所有权](#rr-sharedptrparam-owner)'
- en: '[R.35: Take a `shared_ptr<widget>&` parameter to express that a function might
    reseat the shared pointer](#rr-sharedptrparam)'
  id: totrans-3021
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.35: 使用 `shared_ptr<widget>&` 参数来表示函数可能重新设置共享指针](#rr-sharedptrparam)'
- en: '[R.36: Take a `const shared_ptr<widget>&` parameter to express that it might
    retain a reference count to the object ???](#rr-sharedptrparam-const)'
  id: totrans-3022
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.36: 使用 `const shared_ptr<widget>&` 参数来表示它可能保留对象的引用计数 ???](#rr-sharedptrparam-const)'
- en: '[R.37: Do not pass a pointer or reference obtained from an aliased smart pointer](#rr-smartptrget)'
  id: totrans-3023
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[R.37: 不要传递从别名智能指针获得的指针或引用](#rr-smartptrget)'
- en: 'R.1: Manage resources automatically using resource handles and RAII (Resource
    Acquisition Is Initialization)'
  id: totrans-3024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.1: 使用资源句柄和 RAII（资源获取即初始化）自动管理资源'
- en: Reason
  id: totrans-3025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid leaks and the complexity of manual resource management. C++’s language-enforced
    constructor/destructor symmetry mirrors the symmetry inherent in resource acquire/release
    function pairs such as `fopen`/`fclose`, `lock`/`unlock`, and `new`/`delete`.
    Whenever you deal with a resource that needs paired acquire/release function calls,
    encapsulate that resource in an object that enforces pairing for you – acquire
    the resource in its constructor, and release it in its destructor.
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免泄漏和手动资源管理的复杂性。C++ 的语言强制构造函数/析构函数对称性反映了 `fopen`/`fclose`、`lock`/`unlock`
    和 `new`/`delete` 等资源获取/释放函数对固有的对称性。每当您处理需要成对获取/释放函数调用的资源时，请将资源封装在强制成对的对象中——在构造函数中获取资源，并在析构函数中释放它。
- en: Example, bad
  id: totrans-3027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: 'Consider:'
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE366]'
  id: totrans-3029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: In this code, you have to remember to `unlock`, `close_port`, and `delete` on
    all paths, and do each exactly once. Further, if any of the code marked `...`
    throws an exception, then `x` is leaked and `my_mutex` remains locked.
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您必须记住在所有路径上执行 `unlock`、`close_port` 和 `delete`，并且每个操作都恰好执行一次。此外，如果标记为
    `...` 的任何代码抛出异常，则 `x` 将泄漏，并且 `my_mutex` 保持锁定状态。
- en: Example
  id: totrans-3031
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE367]'
  id: totrans-3033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: Now all resource cleanup is automatic, performed once on all paths whether or
    not there is an exception. As a bonus, the function now advertises that it takes
    over ownership of the pointer.
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有资源清理都是自动的，无论是否有异常，都会在所有路径上执行一次。作为额外的好处，函数现在声明它接管了指针的所有权。
- en: 'What is `Port`? A handy wrapper that encapsulates the resource:'
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 `Port`？一个方便的包装器，它封装了资源：
- en: '[PRE368]'
  id: totrans-3036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: Note
  id: totrans-3037
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Where a resource is “ill-behaved” in that it isn’t represented as a class with
    a destructor, wrap it in a class or use [`finally`](#re-finally)
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源“行为不良”，即不以具有析构函数的类的形式表示，请将其包装在类中或使用 `finally`（#re-finally）。
- en: '**See also**: [RAII](#re-raii)'
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [RAII](#re-raii)'
- en: 'R.2: In interfaces, use raw pointers to denote individual objects (only)'
  id: totrans-3040
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.2: 在接口中，使用原始指针表示单个对象（仅限）'
- en: Reason
  id: totrans-3041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Arrays are best represented by a container type (e.g., `vector` (owning)) or
    a `span` (non-owning). Such containers and views hold sufficient information to
    do range checking.
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
  zh: 数组最好用容器类型（例如，`vector`（拥有））或 `span`（非拥有）表示。这样的容器和视图包含足够的信息来进行范围检查。
- en: Example, bad
  id: totrans-3043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE369]'
  id: totrans-3044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: The compiler does not read comments, and without reading other code you do not
    know whether `p` really points to `n` elements. Use a `span` instead.
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不读取注释，如果不阅读其他代码，您不知道 `p` 是否真的指向 `n` 个元素。请使用 `span` 代替。
- en: Example
  id: totrans-3046
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE370]'
  id: totrans-3047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: Exception
  id: totrans-3048
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: C-style strings are passed as single pointers to a zero-terminated sequence
    of characters. Use `zstring` rather than `char*` to indicate that you rely on
    that convention.
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
  zh: C 风格的字符串作为指向零终止字符序列的单个指针传递。使用 `zstring` 而不是 `char*` 来表示您依赖于该约定。
- en: Note
  id: totrans-3050
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Many current uses of pointers to a single element could be references. However,
    where `nullptr` is a possible value, a reference might not be a reasonable alternative.
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
  zh: 许多当前对单个元素指针的使用可以是引用。然而，当 `nullptr` 是可能值时，引用可能不是合理的替代方案。
- en: Enforcement
  id: totrans-3052
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag pointer arithmetic (including `++`) on a pointer that is not part of a
    container, view, or iterator. This rule would generate a huge number of false
    positives if applied to an older code base.
  id: totrans-3053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记非容器、视图或迭代器部分的指针上的指针算术（包括`++`）。如果将此规则应用于较旧的代码库，它将产生大量的误报。
- en: Flag array names passed as simple pointers
  id: totrans-3054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记作为简单指针传递的数组名称
- en: 'R.3: A raw pointer (a `T*`) is non-owning'
  id: totrans-3055
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.3：原始指针（`T*`）是非拥有的
- en: Reason
  id: totrans-3056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: There is nothing (in the C++ standard or in most code) to say otherwise and
    most raw pointers are non-owning. We want owning pointers identified so that we
    can reliably and efficiently delete the objects pointed to by owning pointers.
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++标准或大多数代码中都没有其他说法，并且大多数原始指针都是非拥有的。我们希望识别拥有指针，以便我们可以可靠且高效地删除由拥有指针指向的对象。
- en: Example
  id: totrans-3058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE371]'
  id: totrans-3059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: The `unique_ptr` protects against leaks by guaranteeing the deletion of its
    object (even in the presence of exceptions). The `T*` does not.
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`通过保证其对象的删除来防止泄漏（即使在异常的情况下）。`T*`不这样做。'
- en: Example
  id: totrans-3061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE372]'
  id: totrans-3062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'We can fix that problem by making ownership explicit:'
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使所有权明确来修复该问题：
- en: '[PRE373]'
  id: totrans-3064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: Exception
  id: totrans-3065
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'A major class of exception is legacy code, especially code that must remain
    compilable as C or interface with C and C-style C++ through ABIs. The fact that
    there are billions of lines of code that violate this rule against owning `T*`s
    cannot be ignored. We’d love to see program transformation tools turning 20-year-old
    “legacy” code into shiny modern code, we encourage the development, deployment
    and use of such tools, we hope the guidelines will help the development of such
    tools, and we even contributed (and contribute) to the research and development
    in this area. However, it will take time: “legacy code” is generated faster than
    we can renovate old code, and so it will be for a few years.'
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要的异常类别是遗留代码，特别是必须作为C编译或通过ABIs与C和C风格C++接口的代码。有数十亿行代码违反了关于拥有`T*`的规则这一事实不能被忽视。我们很乐意看到程序转换工具将20年前的“遗留”代码转换为闪亮的现代代码，我们鼓励开发、部署和使用此类工具，我们希望这些指南将有助于此类工具的开发，我们甚至为此领域的研究和开发做出了（并继续做出）贡献。然而，这需要时间：“遗留代码”的产生速度比我们修复旧代码的速度快，所以接下来几年将会是这样。
- en: This code cannot all be rewritten (even assuming good code transformation software),
    especially not soon. This problem cannot be solved (at scale) by transforming
    all owning pointers to `unique_ptr`s and `shared_ptr`s, partly because we need/use
    owning “raw pointers” as well as simple pointers in the implementation of our
    fundamental resource handles. For example, common `vector` implementations have
    one owning pointer and two non-owning pointers. Many ABIs (and essentially all
    interfaces to C code) use `T*`s, some of them owning. Some interfaces cannot be
    simply annotated with `owner` because they need to remain compilable as C (although
    this would be a rare good use for a macro, that expands to `owner` in C++ mode
    only).
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不能全部重写（即使假设有良好的代码转换软件），尤其是不能很快地重写。这个问题不能通过将所有拥有指针转换为`unique_ptr`和`shared_ptr`来解决（在规模上），部分原因是我们需要/使用拥有“原始指针”以及在我们的基本资源处理实现中的简单指针。例如，常见的`vector`实现有一个拥有指针和两个非拥有指针。许多ABIs（以及本质上所有C代码的接口）使用`T*`，其中一些是拥有的。一些接口不能简单地用`owner`标注，因为它们需要保持C的可编译性（尽管这将是仅在C++模式下展开为`owner`的宏的罕见良好用途）。
- en: Note
  id: totrans-3068
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`owner<T*>` has no default semantics beyond `T*`. It can be used without changing
    any code using it and without affecting ABIs. It is simply an indicator to programmers
    and analysis tools. For example, if an `owner<T*>` is a member of a class, that
    class better have a destructor that `delete`s it.'
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner<T*>`在`T*`之外没有默认语义。它可以不改变使用它的任何代码，也不影响ABIs。它只是对程序员和分析工具的指示。例如，如果`owner<T*>`是一个类的成员，那么该类最好有一个析构函数来删除它。'
- en: Example, bad
  id: totrans-3070
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: Returning a (raw) pointer imposes a lifetime management uncertainty on the caller;
    that is, who deletes the pointed-to object?
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（原始）指针给调用者施加了生命周期管理的不确定性；也就是说，谁删除指向的对象？
- en: '[PRE374]'
  id: totrans-3072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: 'In addition to suffering from the problem of [leak](#rp-leak), this adds a
    spurious allocation and deallocation operation, and is needlessly verbose. If
    Gadget is cheap to move out of a function (i.e., is small or has an efficient
    move operation), just return it “by value” (see [“out” return values](#rf-out)):'
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遭受[泄漏](#rp-leak)问题之外，这还增加了一个虚假的分配和释放操作，并且是多余的冗长。如果Gadget从函数中移出成本低（即，它很小或者有高效的移动操作），只需通过“值”返回它（参见[“输出”返回值](#rf-out)）：
- en: '[PRE375]'
  id: totrans-3074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: Note
  id: totrans-3075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This rule applies to factory functions.
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则适用于工厂函数。
- en: Note
  id: totrans-3077
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If pointer semantics are required (e.g., because the return type needs to refer
    to a base class of a class hierarchy (an interface)), return a “smart pointer.”
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要指针语义（例如，因为返回类型需要引用类层次结构（接口）的基类），则返回一个“智能指针”。
- en: Enforcement
  id: totrans-3079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn on `delete` of a raw pointer that is not an `owner<T>`.
  id: totrans-3080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果删除了一个不是 `owner<T>` 的原始指针，则发出警告。
- en: (Moderate) Warn on failure to either `reset` or explicitly `delete` an `owner<T>`
    pointer on every code path.
  id: totrans-3081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （中等）在每个代码路径上如果没有重置或显式删除 `owner<T>` 指针，则发出警告。
- en: (Simple) Warn if the return value of `new` is assigned to a raw pointer.
  id: totrans-3082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果 `new` 的返回值被分配给一个原始指针，则发出警告。
- en: (Simple) Warn if a function returns an object that was allocated within the
    function but has a move constructor. Suggest considering returning it by value
    instead.
  id: totrans-3083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果函数返回的对象在函数内分配并且具有移动构造函数，则发出警告。建议考虑通过值返回它。
- en: 'R.4: A raw reference (a `T&`) is non-owning'
  id: totrans-3084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.4: 原始引用（一个 `T&`）是非所有者'
- en: Reason
  id: totrans-3085
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: There is nothing (in the C++ standard or in most code) to say otherwise and
    most raw references are non-owning. We want owners identified so that we can reliably
    and efficiently delete the objects pointed to by owning pointers.
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 标准或大多数代码中，没有其他说法，大多数原始引用都是非所有者。我们希望识别所有者，以便我们可以可靠且高效地删除所有者指针指向的对象。
- en: Example
  id: totrans-3087
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE376]'
  id: totrans-3088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '**See also**: [The raw pointer rule](#rr-ptr)'
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
  zh: '**另见**: [原始指针规则](#rr-ptr)'
- en: Enforcement
  id: totrans-3090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: See [the raw pointer rule](#rr-ptr)
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [原始指针规则](#rr-ptr)
- en: 'R.5: Prefer scoped objects, don’t heap-allocate unnecessarily'
  id: totrans-3092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.5: 优先使用作用域对象，不要不必要地堆分配'
- en: Reason
  id: totrans-3093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A scoped object is a local object, a global object, or a member. This implies
    that there is no separate allocation and deallocation cost in excess of that already
    used for the containing scope or object. The members of a scoped object are themselves
    scoped and the scoped object’s constructor and destructor manage the members’
    lifetimes.
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域对象是一个局部对象、全局对象或成员。这意味着没有超过包含作用域或对象已使用的分配和释放成本的额外成本。作用域对象的成员本身也是作用域的，作用域对象的构造函数和析构函数管理成员的生命周期。
- en: Example
  id: totrans-3095
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'The following example is inefficient (because it has unnecessary allocation
    and deallocation), vulnerable to exception throws and returns in the `...` part
    (leading to leaks), and verbose:'
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例效率低下（因为它有必要的分配和释放），容易受到 `...` 部分的异常抛出和返回的影响（导致泄漏），并且冗长：
- en: '[PRE377]'
  id: totrans-3097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'Instead, use a local variable:'
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用局部变量：
- en: '[PRE378]'
  id: totrans-3099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: Enforcement
  id: totrans-3100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Moderate) Warn if an object is allocated and then deallocated on all paths
    within a function. Suggest it should be a local stack object instead.
  id: totrans-3101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （中等）如果在函数内的所有路径上对一个对象进行了分配然后释放，则发出警告。建议它应该是一个局部栈对象。
- en: '(Simple) Warn if a local `Unique_pointer` or `Shared_pointer` that is not moved,
    copied, reassigned or `reset` before its lifetime ends is not declared `const`.
    Exception: Do not produce such a warning on a local `Unique_pointer` to an unbounded
    array. (See below.)'
  id: totrans-3102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果局部 `Unique_pointer` 或 `Shared_pointer` 在其生命周期结束之前没有被移动、复制、重新分配或 `reset`，则发出警告。例外：不要在指向无界数组的局部
    `Unique_pointer` 上产生此类警告。（见下文。）
- en: Exception
  id: totrans-3103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: If your stack space is limited, it is OK to create a local `const unique_ptr<BigObject>`
    to store the object on the heap instead of the stack.
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的栈空间有限，创建一个局部的 `const unique_ptr<BigObject>` 来在堆上存储对象而不是在栈上是可以的。
- en: 'R.6: Avoid non-`const` global variables'
  id: totrans-3105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.6: 避免非 `const` 全局变量'
- en: See [I.2](#ri-global)
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [I.2](#ri-global)
- en: 'R.alloc: Allocation and deallocation'
  id: totrans-3107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'R.alloc: 分配和释放'
- en: 'R.10: Avoid `malloc()` and `free()`'
  id: totrans-3108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.10: 避免使用 `malloc()` 和 `free()`'
- en: Reason
  id: totrans-3109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`malloc()` and `free()` do not support construction and destruction, and do
    not mix well with `new` and `delete`.'
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc()` 和 `free()` 不支持构造和析构，并且与 `new` 和 `delete` 不兼容。'
- en: Example
  id: totrans-3111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE379]'
  id: totrans-3112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: In some implementations that `delete` and that `free()` might work, or maybe
    they will cause run-time errors.
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些实现中，`delete` 和 `free()` 可能会工作，或者可能引起运行时错误。
- en: Exception
  id: totrans-3114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: There are applications and sections of code where exceptions are not acceptable.
    Some of the best such examples are in life-critical hard-real-time code. Beware
    that many bans on exception use are based on superstition (bad) or by concerns
    for older code bases with unsystematic resource management (unfortunately, but
    sometimes necessary). In such cases, consider the `nothrow` versions of `new`.
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用和代码段中，异常是不被接受的。其中一些最好的例子是生命攸关的硬实时代码。请注意，许多对异常使用的禁令是基于迷信（不好的）或对具有非系统资源管理的旧代码库的关注（不幸但有时是必要的）。在这种情况下，考虑
    `nothrow` 版本的 `new`。
- en: Enforcement
  id: totrans-3116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag explicit use of `malloc` and `free`.
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
  zh: 标记显式使用`malloc`和`free`。
- en: 'R.11: Avoid calling `new` and `delete` explicitly'
  id: totrans-3118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.11：避免显式调用`new`和`delete`
- en: Reason
  id: totrans-3119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The pointer returned by `new` should belong to a resource handle (that can call
    `delete`). If the pointer returned by `new` is assigned to a plain/naked pointer,
    the object can be leaked.
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`返回的指针应该属于资源句柄（可以调用`delete`）。如果`new`返回的指针被赋给一个普通/裸露的指针，对象可能会泄漏。'
- en: Note
  id: totrans-3121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In a large program, a naked `delete` (that is a `delete` in application code,
    rather than part of code devoted to resource management) is a likely bug: if you
    have N `delete`s, how can you be certain that you don’t need N+1 or N-1? The bug
    might be latent: it might emerge only during maintenance. If you have a naked
    `new`, you probably need a naked `delete` somewhere, so you probably have a bug.'
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型程序中，裸露的`delete`（即在应用代码中的`delete`，而不是资源管理代码的一部分）很可能是一个错误：如果你有N个`delete`，你怎么能确定你不需要N+1或N-1个？这个错误可能是隐性的：它可能只在维护期间出现。如果你有一个裸露的`new`，你可能在某个地方需要一个裸露的`delete`，所以你可能有一个错误。
- en: Enforcement
  id: totrans-3123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn on any explicit use of `new` and `delete`. Suggest using `make_unique`
    instead.
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）对任何显式使用`new`和`delete`发出警告。建议使用`make_unique`代替。
- en: 'R.12: Immediately give the result of an explicit resource allocation to a manager
    object'
  id: totrans-3125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.12：立即将显式资源分配的结果赋给管理对象
- en: Reason
  id: totrans-3126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you don’t, an exception or a return might lead to a leak.
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，异常或返回可能会引起泄漏。
- en: Example, bad
  id: totrans-3128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE380]'
  id: totrans-3129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: The allocation of `buf` might fail and leak the file handle.
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf`的分配可能会失败并泄漏文件句柄。'
- en: Example
  id: totrans-3131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE381]'
  id: totrans-3132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: The use of the file handle (in `ifstream`) is simple, efficient, and safe.
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: 文件句柄（在`ifstream`中）的使用简单、高效且安全。
- en: Enforcement
  id: totrans-3134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag explicit allocations used to initialize pointers (problem: how many direct
    resource allocations can we recognize?)'
  id: totrans-3135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记用于初始化指针的显式分配（问题：我们能够识别多少个直接资源分配？）
- en: 'R.13: Perform at most one explicit resource allocation in a single expression
    statement'
  id: totrans-3136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.13：在一个表达式语句中最多执行一个显式资源分配
- en: Reason
  id: totrans-3137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you perform two explicit resource allocations in one statement, you could
    leak resources because the order of evaluation of many subexpressions, including
    function arguments, is unspecified.
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个语句中执行两个显式资源分配，你可能会因为许多子表达式（包括函数参数）的评估顺序未指定而导致资源泄漏。
- en: Example
  id: totrans-3139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE382]'
  id: totrans-3140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'This `fun` can be called like this:'
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`fun`可以这样调用：
- en: '[PRE383]'
  id: totrans-3142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: 'This is exception-unsafe because the compiler might reorder the two expressions
    building the function’s two arguments. In particular, the compiler can interleave
    execution of the two expressions: Memory allocation (by calling `operator new`)
    could be done first for both objects, followed by attempts to call the two `Widget`
    constructors. If one of the constructor calls throws an exception, then the other
    object’s memory will never be released!'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不异常安全的，因为编译器可能会重新排序构建函数两个参数的两个表达式。特别是，编译器可以交错执行这两个表达式：两个对象的内存分配（通过调用`operator
    new`）可能首先完成，然后尝试调用两个`Widget`构造函数。如果其中一个构造函数调用抛出异常，那么另一个对象的内存将永远不会释放！
- en: 'This subtle problem has a simple solution: Never perform more than one explicit
    resource allocation in a single expression statement. For example:'
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微妙的问题有一个简单的解决方案：永远不要在单个表达式语句中执行超过一个显式资源分配。例如：
- en: '[PRE384]'
  id: totrans-3145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'The best solution is to avoid explicit allocation entirely, use factory functions
    that return owning objects:'
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是完全避免显式分配，使用返回拥有对象的工厂函数：
- en: '[PRE385]'
  id: totrans-3147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: Write your own factory wrapper if there is not one already.
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还没有，请编写自己的工厂包装器。
- en: Enforcement
  id: totrans-3149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag expressions with multiple explicit resource allocations (problem: how
    many direct resource allocations can we recognize?)'
  id: totrans-3150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记具有多个显式资源分配的标志表达式（问题：我们能够识别多少个直接资源分配？）
- en: 'R.14: Avoid `[]` parameters, prefer `span`'
  id: totrans-3151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.14：避免使用`[]`参数，首选`span`
- en: Reason
  id: totrans-3152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An array decays to a pointer, thereby losing its size, opening the opportunity
    for range errors. Use `span` to preserve size information.
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: 数组会退化成指针，从而丢失其大小，这为范围错误提供了机会。使用`span`来保留大小信息。
- en: Example
  id: totrans-3154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE386]'
  id: totrans-3155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: Enforcement
  id: totrans-3156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `[]` parameters. Use `span` instead.
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 标记`[]`参数。使用`span`代替。
- en: 'R.15: Always overload matched allocation/deallocation pairs'
  id: totrans-3158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.15：始终重载匹配的分配/释放对
- en: Reason
  id: totrans-3159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Otherwise you get mismatched operations and chaos.
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
  zh: 否则你会得到不匹配的操作和混乱。
- en: Example
  id: totrans-3161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE387]'
  id: totrans-3162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: Note
  id: totrans-3163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you want memory that cannot be deallocated, `=delete` the deallocation operation.
    Don’t leave it undeclared.
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要无法释放的内存，`=delete`释放操作。不要让它未声明。
- en: Enforcement
  id: totrans-3165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag incomplete pairs.
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: 标记不完整的对。
- en: 'R.smart: Smart pointers'
  id: totrans-3167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'R.smart: 智能指针'
- en: 'R.20: Use `unique_ptr` or `shared_ptr` to represent ownership'
  id: totrans-3168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.20: 使用 `unique_ptr` 或 `shared_ptr` 来表示所有权'
- en: Reason
  id: totrans-3169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: They can prevent resource leaks.
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以防止资源泄漏。
- en: Example
  id: totrans-3171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE388]'
  id: totrans-3173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: This will leak the object used to initialize `p1` (only).
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致用于初始化 `p1` 的对象泄漏（仅限）。
- en: Enforcement
  id: totrans-3175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if the return value of `new` is assigned to a raw pointer.
  id: totrans-3176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果 `new` 的返回值被分配给一个原始指针，则发出警告。
- en: (Simple) Warn if the result of a function returning a raw owning pointer is
    assigned to a raw pointer.
  id: totrans-3177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果函数返回的原始拥有指针的结果被分配给一个原始指针，则发出警告。
- en: 'R.21: Prefer `unique_ptr` over `shared_ptr` unless you need to share ownership'
  id: totrans-3178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.21: 除非你需要共享所有权，否则优先使用 `unique_ptr`'
- en: Reason
  id: totrans-3179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A `unique_ptr` is conceptually simpler and more predictable (you know when destruction
    happens) and faster (you don’t implicitly maintain a use count).
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr` 概念上更简单、更可预测（你知道何时发生销毁）并且更快（你不需要隐式维护使用计数）。'
- en: Example, bad
  id: totrans-3181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: This needlessly adds and maintains a reference count.
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
  zh: 这无谓地增加了并维护了引用计数。
- en: '[PRE389]'
  id: totrans-3183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: Example
  id: totrans-3184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'This is more efficient:'
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
  zh: 这更有效率：
- en: '[PRE390]'
  id: totrans-3186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: Enforcement
  id: totrans-3187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a function uses a `Shared_pointer` with an object allocated
    within the function, but never returns the `Shared_pointer` or passes it to a
    function requiring a `Shared_pointer`. Suggest using `unique_ptr` instead.
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）如果函数使用一个在函数内部分配对象的 `Shared_pointer`，但从未返回该 `Shared_pointer` 或将其传递给需要 `Shared_pointer`
    的函数，则发出警告。建议使用 `unique_ptr`。
- en: 'R.22: Use `make_shared()` to make `shared_ptr`s'
  id: totrans-3189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.22: 使用 `make_shared()` 来创建 `shared_ptr`'
- en: Reason
  id: totrans-3190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`make_shared` gives a more concise statement of the construction. It also gives
    an opportunity to eliminate a separate allocation for the reference counts, by
    placing the `shared_ptr`’s use counts next to its object. It also ensures exception
    safety in complex expressions (in pre-C++17 code).'
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_shared` 提供了更简洁的构造语句。它还提供了消除单独分配引用计数的可能性，通过将 `shared_ptr` 的使用计数放置在其对象旁边。它还确保了复杂表达式中的异常安全性（在
    C++17 之前的代码中）。'
- en: Example
  id: totrans-3192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-3193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE391]'
  id: totrans-3194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: The `make_shared()` version mentions `X` only once, so it is usually shorter
    (as well as faster) than the version with the explicit `new`.
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_shared()` 版本只提及 `X` 一次，因此通常比显式 `new` 版本更短（以及更快）。'
- en: Enforcement
  id: totrans-3196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a `shared_ptr` is constructed from the result of `new` rather
    than `make_shared`.
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）如果 `shared_ptr` 是从 `new` 的结果而不是 `make_shared` 构造的，则发出警告。
- en: 'R.23: Use `make_unique()` to make `unique_ptr`s'
  id: totrans-3198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.23: 使用 `make_unique()` 来创建 `unique_ptr`'
- en: Reason
  id: totrans-3199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`make_unique` gives a more concise statement of the construction. It also ensures
    exception safety in complex expressions (in pre-C++17 code).'
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_unique` 提供了更简洁的构造语句。它还确保了复杂表达式中的异常安全性（在 C++17 之前的代码中）。'
- en: Example
  id: totrans-3201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE392]'
  id: totrans-3202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: Enforcement
  id: totrans-3203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a `unique_ptr` is constructed from the result of `new` rather
    than `make_unique`.
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
  zh: （简单）如果 `unique_ptr` 是从 `new` 的结果而不是 `make_unique` 构造的，则发出警告。
- en: 'R.24: Use `std::weak_ptr` to break cycles of `shared_ptr`s'
  id: totrans-3205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.24: 使用 `std::weak_ptr` 来打破 `shared_ptr` 的循环'
- en: Reason
  id: totrans-3206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`shared_ptr`s rely on use counting and the use count for a cyclic structure
    never goes to zero, so we need a mechanism to be able to destroy a cyclic structure.'
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`s 依赖于使用计数，并且循环结构的使用计数永远不会降到零，因此我们需要一种机制来能够销毁循环结构。'
- en: Example
  id: totrans-3208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE393]'
  id: totrans-3209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: Note
  id: totrans-3210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: '??? (HS: A lot of people say “to break cycles”, while I think “temporary shared
    ownership” is more to the point.) ???(BS: breaking cycles is what you must do;
    temporarily sharing ownership is how you do it. You could “temporarily share ownership”
    simply by using another `shared_ptr`.)'
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
  zh: '??? (HS: 许多人说“打破循环”，而我认为“临时共享所有权”更准确。) ???(BS: 打破循环是你必须做的；临时共享所有权是你如何做的。你可以简单地通过使用另一个
    `shared_ptr` 来“临时共享所有权”。)'
- en: Enforcement
  id: totrans-3212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ??? probably impossible. If we could statically detect cycles, we wouldn’t need
    `weak_ptr`
  id: totrans-3213
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 可能不可能。如果我们能够静态检测循环，我们就不需要 `weak_ptr`
- en: 'R.30: Take smart pointers as parameters only to explicitly express lifetime
    semantics'
  id: totrans-3214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.30: 仅为了显式表达生命周期语义，将智能指针作为参数'
- en: See [F.7](#rf-smart).
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [F.7](#rf-smart)。
- en: 'R.31: If you have non-`std` smart pointers, follow the basic pattern from `std`'
  id: totrans-3216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.31: 如果你有非 `std` 智能指针，遵循 `std` 的基本模式'
- en: Reason
  id: totrans-3217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The rules in the following section also work for other kinds of third-party
    and custom smart pointers and are very useful for diagnosing common smart pointer
    errors that cause performance and correctness problems. You want the rules to
    work on all the smart pointers you use.
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分中的规则也适用于其他类型的第三方和自定义智能指针，并且对于诊断导致性能和正确性问题的一般智能指针错误非常有用。您希望这些规则适用于您使用的所有智能指针。
- en: 'Any type (including primary template or specialization) that overloads unary
    `*` and `->` is considered a smart pointer:'
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
  zh: 任何重载一元 `*` 和 `->` 的类型（包括主模板或特化）都被视为智能指针：
- en: If it is copyable, it is recognized as a reference-counted `shared_ptr`.
  id: totrans-3220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是可复制的，则被视为引用计数的 `shared_ptr`。
- en: If it is not copyable, it is recognized as a unique `unique_ptr`.
  id: totrans-3221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它不可复制，则被视为唯一的 `unique_ptr`。
- en: Example, bad
  id: totrans-3222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE394]'
  id: totrans-3223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: 'Both cases are an error under the [`sharedptrparam` guideline](#rr-smartptrparam):
    `p` is a `Shared_pointer`, but nothing about its sharedness is used here and passing
    it by value is a silent pessimization; these functions should accept a smart pointer
    only if they need to participate in the widget’s lifetime management. Otherwise
    they should accept a `widget*`, if it can be `nullptr`. Otherwise, and ideally,
    the function should accept a `widget&`. These smart pointers match the `Shared_pointer`
    concept, so these guideline enforcement rules work on them out of the box and
    expose this common pessimization.'
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都违反了 `sharedptrparam` 指南（#rr-smartptrparam）：`p` 是 `Shared_pointer`，但在这里没有使用其共享性，按值传递是一个无声的优化；这些函数应该只接受智能指针，如果它们需要参与
    `widget` 的生命周期管理。否则，如果它可以 `nullptr`，则应接受 `widget*`。否则，理想情况下，函数应接受 `widget&`。这些智能指针与
    `Shared_pointer` 概念相匹配，因此这些指南执行规则在它们上自动生效并暴露了这种常见的优化。
- en: 'R.32: Take a `unique_ptr<widget>` parameter to express that a function assumes
    ownership of a `widget`'
  id: totrans-3225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.32: 使用 `unique_ptr<widget>` 参数来表示函数假定对 `widget` 拥有所有权'
- en: Reason
  id: totrans-3226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using `unique_ptr` in this way both documents and enforces the function call’s
    ownership transfer.
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 `unique_ptr` 既可以记录也可以强制函数调用的所有权转移。
- en: Example
  id: totrans-3228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE395]'
  id: totrans-3229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: Enforcement
  id: totrans-3230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a function takes a `Unique_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 如果函数通过左值引用接受 `Unique_pointer<T>` 参数并在至少一个代码路径上既没有对其赋值也没有调用 `reset()`，则发出警告。建议改为接受
    `T*` 或 `T&`。
- en: 'R.33: Take a `unique_ptr<widget>&` parameter to express that a function reseats
    the `widget`'
  id: totrans-3232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.33: 使用 `unique_ptr<widget>&` 参数来表示函数重新设置了 `widget`'
- en: Reason
  id: totrans-3233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using `unique_ptr` in this way both documents and enforces the function call’s
    reseating semantics.
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 `unique_ptr` 既可以记录也可以强制函数调用的重新设置语义。
- en: Note
  id: totrans-3235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: “reseat” means “making a pointer or a smart pointer refer to a different object.”
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
  zh: “重新设置”意味着“使指针或智能指针指向不同的对象。”
- en: Example
  id: totrans-3237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE396]'
  id: totrans-3238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: Enforcement
  id: totrans-3239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a function takes a `Unique_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 如果函数通过左值引用接受 `Unique_pointer<T>` 参数并在至少一个代码路径上既没有对其赋值也没有调用 `reset()`，则发出警告。建议改为接受
    `T*` 或 `T&`。
- en: 'R.34: Take a `shared_ptr<widget>` parameter to express shared ownership'
  id: totrans-3241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.34: 使用 `shared_ptr<widget>` 参数来表示共享所有权'
- en: Reason
  id: totrans-3242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This makes the function’s ownership sharing explicit.
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得函数的所有权共享是明确的。
- en: Example, good
  id: totrans-3244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE397]'
  id: totrans-3245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: Enforcement
  id: totrans-3246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) 如果函数通过左值引用接受 `Shared_pointer<T>` 参数并在至少一个代码路径上既没有对其赋值也没有调用 `reset()`，则发出警告。建议改为接受
    `T*` 或 `T&`。
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value
    or by reference to `const` and does not copy or move it to another `Shared_pointer`
    on at least one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) ((基础)) 如果函数通过值或 `const` 引用接受 `Shared_pointer<T>` 并在至少一个代码路径上没有将其复制或移动到另一个
    `Shared_pointer`，则发出警告。建议改为接受 `T*` 或 `T&`。
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue
    reference. Suggesting taking it by value instead.
  id: totrans-3249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (简单) ((基础)) 如果函数通过右值引用接受 `Shared_pointer<T>`，则发出警告。建议改为按值接受。
- en: 'R.35: Take a `shared_ptr<widget>&` parameter to express that a function might
    reseat the shared pointer'
  id: totrans-3250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'R.35: 使用 `shared_ptr<widget>&` 参数来表示函数可能重新设置了共享指针'
- en: Reason
  id: totrans-3251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This makes the function’s reseating explicit.
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得函数的重新设置是明确的。
- en: Note
  id: totrans-3253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: “reseat” means “making a reference or a smart pointer refer to a different object.”
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
  zh: “reseat”意味着“使引用或智能指针指向不同的对象。”
- en: Example, good
  id: totrans-3255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE398]'
  id: totrans-3256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: Enforcement
  id: totrans-3257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果函数通过左值引用接受一个 `Shared_pointer<T>` 参数，但在至少一个代码路径上既没有对其赋值也没有调用 `reset()`，则发出警告。建议使用
    `T*` 或 `T&`。
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value
    or by reference to `const` and does not copy or move it to another `Shared_pointer`
    on at least one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 如果函数通过值或 `const` 引用接受 `Shared_pointer<T>`，但在至少一个代码路径上既没有复制也没有移动它到另一个
    `Shared_pointer`，则发出警告。建议使用 `T*` 或 `T&`。
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue
    reference. Suggesting taking it by value instead.
  id: totrans-3260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 如果函数通过右值引用接受一个 `Shared_pointer<T>`，则发出警告。建议使用值引用。
- en: 'R.36: Take a `const shared_ptr<widget>&` parameter to express that it might
    retain a reference count to the object ???'
  id: totrans-3261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.36：使用 `const shared_ptr<widget>&` 参数来表示它可能保留对对象的引用计数 ???
- en: Reason
  id: totrans-3262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This makes the function’s ??? explicit.
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得函数的 ??? 明确。
- en: Example, good
  id: totrans-3264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE399]'
  id: totrans-3265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Enforcement
  id: totrans-3266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a function takes a `Shared_pointer<T>` parameter by lvalue
    reference and does not either assign to it or call `reset()` on it on at least
    one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果函数通过左值引用接受一个 `Shared_pointer<T>` 参数，但在至少一个代码路径上既没有对其赋值也没有调用 `reset()`，则发出警告。建议使用
    `T*` 或 `T&`。
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by value
    or by reference to `const` and does not copy or move it to another `Shared_pointer`
    on at least one code path. Suggest taking a `T*` or `T&` instead.
  id: totrans-3268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 如果函数通过值或 `const` 引用接受一个 `Shared_pointer<T>`，但在至少一个代码路径上既没有复制也没有移动它到另一个
    `Shared_pointer`，则发出警告。建议使用 `T*` 或 `T&`。
- en: (Simple) ((Foundation)) Warn if a function takes a `Shared_pointer<T>` by rvalue
    reference. Suggesting taking it by value instead.
  id: totrans-3269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）((基础)) 如果函数通过右值引用接受一个 `Shared_pointer<T>`，则发出警告。建议使用值引用。
- en: 'R.37: Do not pass a pointer or reference obtained from an aliased smart pointer'
  id: totrans-3270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R.37：不要传递从别名智能指针获得的指针或引用
- en: Reason
  id: totrans-3271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Violating this rule is the number one cause of losing reference counts and finding
    yourself with a dangling pointer. Functions should prefer to pass raw pointers
    and references down call chains. At the top of the call tree where you obtain
    the raw pointer or reference from a smart pointer that keeps the object alive.
    You need to be sure that the smart pointer cannot inadvertently be reset or reassigned
    from within the call tree below.
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 违反此规则是丢失引用计数和发现自己有一个悬垂指针的主要原因。函数应优先将原始指针和引用传递到调用链中。在调用树的顶部，你从保持对象存活的智能指针中获取原始指针或引用。你需要确保智能指针不会在调用树下方意外地被重置或重新分配。
- en: Note
  id: totrans-3273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To do this, sometimes you need to take a local copy of a smart pointer, which
    firmly keeps the object alive for the duration of the function and the call tree.
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，有时你需要获取智能指针的局部副本，这样就可以在函数和调用树持续的时间内确保对象存活。
- en: Example
  id: totrans-3275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider this code:'
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE400]'
  id: totrans-3277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: 'The following should not pass code review:'
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码不应通过代码审查：
- en: '[PRE401]'
  id: totrans-3279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: 'The fix is simple – take a local copy of the pointer to “keep a ref count”
    for your call tree:'
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是简单的——获取指针的局部副本以“保持引用计数”：
- en: '[PRE402]'
  id: totrans-3281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: Enforcement
  id: totrans-3282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: (Simple) Warn if a pointer or reference obtained from a smart pointer variable
    (`Unique_pointer` or `Shared_pointer`) that is non-local, or that is local but
    potentially aliased, is used in a function call. If the smart pointer is a `Shared_pointer`
    then suggest taking a local copy of the smart pointer and obtain a pointer or
    reference from that instead.
  id: totrans-3283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （简单）如果从非局部智能指针变量（`Unique_pointer` 或 `Shared_pointer`）或潜在别名的局部智能指针变量中获得的指针或引用在函数调用中使用，则发出警告。如果智能指针是
    `Shared_pointer`，则建议获取智能指针的局部副本，并从该副本中获取指针或引用。
- en: 'ES: Expressions and statements'
  id: totrans-3284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'ES: 表达式和语句'
- en: Expressions and statements are the lowest and most direct way of expressing
    actions and computation. Declarations in local scopes are statements.
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式和语句是表达动作和计算最低级和最直接的方式。局部作用域中的声明是语句。
- en: 'For naming, commenting, and indentation rules, see [NL: Naming and layout](#s-naming).'
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
  zh: '关于命名、注释和缩进规则，请参阅 [NL: 命名和布局](#s-naming)。'
- en: 'General rules:'
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则：
- en: '[ES.1: Prefer the standard library to other libraries and to “handcrafted code”](#res-lib)'
  id: totrans-3288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.1: 优先使用标准库而不是其他库和“手工代码”](#res-lib)'
- en: '[ES.2: Prefer suitable abstractions to direct use of language features](#res-abstr)'
  id: totrans-3289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.2: 优先使用合适的抽象而不是直接使用语言特性](#res-abstr)'
- en: '[ES.3: Don’t repeat yourself, avoid redundant code](#res-dry)'
  id: totrans-3290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.3: 不要重复自己，避免冗余代码](#res-dry)'
- en: 'Declaration rules:'
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
  zh: 声明规则：
- en: '[ES.5: Keep scopes small](#res-scope)'
  id: totrans-3292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.5: 保持作用域小](#res-scope)'
- en: '[ES.6: Declare names in for-statement initializers and conditions to limit
    scope](#res-cond)'
  id: totrans-3293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.6: 在 for 语句的初始化器和条件中声明名称以限制作用域](#res-cond)'
- en: '[ES.7: Keep common and local names short, and keep uncommon and non-local names
    longer](#res-name-length)'
  id: totrans-3294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.7: 保持常见和局部名称短，不常见和非局部名称长](#res-name-length)'
- en: '[ES.8: Avoid similar-looking names](#res-name-similar)'
  id: totrans-3295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.8: 避免类似外观的名称](#res-name-similar)'
- en: '[ES.9: Avoid `ALL_CAPS` names](#res-not-caps)'
  id: totrans-3296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.9: 避免使用 `ALL_CAPS` 名称](#res-not-caps)'
- en: '[ES.10: Declare one name (only) per declaration](#res-name-one)'
  id: totrans-3297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.10: 每个声明只声明一个名称](#res-name-one)'
- en: '[ES.11: Use `auto` to avoid redundant repetition of type names](#res-auto)'
  id: totrans-3298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.11: 使用 `auto` 避免重复类型名称](#res-auto)'
- en: '[ES.12: Do not reuse names in nested scopes](#res-reuse)'
  id: totrans-3299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.12: 不要在嵌套作用域中重用名称](#res-reuse)'
- en: '[ES.20: Always initialize an object](#res-always)'
  id: totrans-3300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.20: 总是初始化对象](#res-always)'
- en: '[ES.21: Don’t introduce a variable (or constant) before you need to use it](#res-introduce)'
  id: totrans-3301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.21: 在需要使用它之前不要引入变量（或常量）](#res-introduce)'
- en: '[ES.22: Don’t declare a variable until you have a value to initialize it with](#res-init)'
  id: totrans-3302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.22: 在没有初始化值之前不要声明变量](#res-init)'
- en: '[ES.23: Prefer the `{}`-initializer syntax](#res-list)'
  id: totrans-3303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.23: 优先使用 `{}` 初始化器语法](#res-list)'
- en: '[ES.24: Use a `unique_ptr<T>` to hold pointers](#res-unique)'
  id: totrans-3304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.24: 使用 `unique_ptr<T>` 来持有指针](#res-unique)'
- en: '[ES.25: Declare an object `const` or `constexpr` unless you want to modify
    its value later on](#res-const)'
  id: totrans-3305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.25: 除非以后想修改其值，否则声明对象为 `const` 或 `constexpr`](#res-const)'
- en: '[ES.26: Don’t use a variable for two unrelated purposes](#res-recycle)'
  id: totrans-3306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.26: 不要将变量用于两个不相关的目的](#res-recycle)'
- en: '[ES.27: Use `std::array` or `stack_array` for arrays on the stack](#res-stack)'
  id: totrans-3307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.27: 使用 `std::array` 或 `stack_array` 在栈上创建数组](#res-stack)'
- en: '[ES.28: Use lambdas for complex initialization, especially of `const` variables](#res-lambda-init)'
  id: totrans-3308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.28: 使用 lambda 表达式进行复杂的初始化，特别是 `const` 变量的初始化](#res-lambda-init)'
- en: '[ES.30: Don’t use macros for program text manipulation](#res-macros)'
  id: totrans-3309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.30: 不要使用宏进行程序文本操作](#res-macros)'
- en: '[ES.31: Don’t use macros for constants or “functions”](#res-macros2)'
  id: totrans-3310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.31: 不要将宏用于常量或“函数”](#res-macros2)'
- en: '[ES.32: Use `ALL_CAPS` for all macro names](#res-all_caps)'
  id: totrans-3311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.32: 使用 `ALL_CAPS` 为所有宏命名](#res-all_caps)'
- en: '[ES.33: If you must use macros, give them unique names](#res-macros3)'
  id: totrans-3312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.33: 如果必须使用宏，请给它们唯一的名称](#res-macros3)'
- en: '[ES.34: Don’t define a (C-style) variadic function](#res-ellipses)'
  id: totrans-3313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.34: 不要定义（C样式的）可变参数函数](#res-ellipses)'
- en: 'Expression rules:'
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式规则：
- en: '[ES.40: Avoid complicated expressions](#res-complicated)'
  id: totrans-3315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.40: 避免复杂的表达式](#res-complicated)'
- en: '[ES.41: If in doubt about operator precedence, parenthesize](#res-parens)'
  id: totrans-3316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.41: 如果对运算符优先级有疑问，请使用括号](#res-parens)'
- en: '[ES.42: Keep use of pointers simple and straightforward](#res-ptr)'
  id: totrans-3317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.42: 保持指针使用简单直接](#res-ptr)'
- en: '[ES.43: Avoid expressions with undefined order of evaluation](#res-order)'
  id: totrans-3318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.43: 避免具有未定义评估顺序的表达式](#res-order)'
- en: '[ES.44: Don’t depend on order of evaluation of function arguments](#res-order-fct)'
  id: totrans-3319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.44: 不要依赖于函数参数的评估顺序](#res-order-fct)'
- en: '[ES.45: Avoid “magic constants”; use symbolic constants](#res-magic)'
  id: totrans-3320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.45: 避免使用“魔法常量”；使用符号常量](#res-magic)'
- en: '[ES.46: Avoid narrowing conversions](#res-narrowing)'
  id: totrans-3321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.46: 避免窄化转换](#res-narrowing)'
- en: '[ES.47: Use `nullptr` rather than `0` or `NULL`](#res-nullptr)'
  id: totrans-3322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.47: 使用 `nullptr` 而不是 `0` 或 `NULL`](#res-nullptr)'
- en: '[ES.48: Avoid casts](#res-casts)'
  id: totrans-3323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.48: 避免类型转换](#res-casts)'
- en: '[ES.49: If you must use a cast, use a named cast](#res-casts-named)'
  id: totrans-3324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.49: 如果必须使用类型转换，请使用命名类型转换](#res-casts-named)'
- en: '[ES.50: Don’t cast away `const`](#res-casts-const)'
  id: totrans-3325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.50: 不要取消 `const`](#res-casts-const)'
- en: '[ES.55: Avoid the need for range checking](#res-range-checking)'
  id: totrans-3326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.55: 避免需要范围检查](#res-range-checking)'
- en: '[ES.56: Write `std::move()` only when you need to explicitly move an object
    to another scope](#res-move)'
  id: totrans-3327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.56: 只有在需要显式将对象移动到另一个作用域时才使用 `std::move()`](#res-move)'
- en: '[ES.60: Avoid `new` and `delete` outside resource management functions](#res-new)'
  id: totrans-3328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.60: 避免在资源管理函数外部使用 `new` 和 `delete`](#res-new)'
- en: '[ES.61: Delete arrays using `delete[]` and non-arrays using `delete`](#res-del)'
  id: totrans-3329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.61: 使用 `delete[]` 删除数组，使用 `delete` 删除非数组](#res-del)'
- en: '[ES.62: Don’t compare pointers into different arrays](#res-arr2)'
  id: totrans-3330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.62: 不要比较来自不同数组的指针](#res-arr2)'
- en: '[ES.63: Don’t slice](#res-slice)'
  id: totrans-3331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.63: 不要切片](#res-slice)'
- en: '[ES.64: Use the `T{e}`notation for construction](#res-construct)'
  id: totrans-3332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.64: 使用 `T{e}` 符号进行构造](#res-construct)'
- en: '[ES.65: Don’t dereference an invalid pointer](#res-deref)'
  id: totrans-3333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.65: 不要解引用无效指针](#res-deref)'
- en: 'Statement rules:'
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
  zh: 语句规则：
- en: '[ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice](#res-switch-if)'
  id: totrans-3335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.70: 当有选择时，优先使用 `switch` 语句而不是 `if` 语句](#res-switch-if)'
- en: '[ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a
    choice](#res-for-range)'
  id: totrans-3336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.71: 当有选择时，优先使用范围 `for` 语句而不是 `for` 语句](#res-for-range)'
- en: '[ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious
    loop variable](#res-for-while)'
  id: totrans-3337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.72: 当有明显的循环变量时，优先使用 `for` 语句而不是 `while` 语句](#res-for-while)'
- en: '[ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious
    loop variable](#res-while-for)'
  id: totrans-3338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.73: 当没有明显的循环变量时，优先使用 `while` 语句而不是 `for` 语句](#res-while-for)'
- en: '[ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement](#res-for-init)'
  id: totrans-3339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.74: 优先在 `for` 语句的初始化部分声明循环变量](#res-for-init)'
- en: '[ES.75: Avoid `do`-statements](#res-do)'
  id: totrans-3340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.75: 避免使用 `do` 语句](#res-do)'
- en: '[ES.76: Avoid `goto`](#res-goto)'
  id: totrans-3341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.76: 避免使用 `goto`](#res-goto)'
- en: '[ES.77: Minimize the use of `break` and `continue` in loops](#res-continue)'
  id: totrans-3342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.77: 最小化循环中 `break` 和 `continue` 的使用](#res-continue)'
- en: '[ES.78: Don’t rely on implicit fallthrough in `switch` statements](#res-break)'
  id: totrans-3343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.78: 不要在 `switch` 语句中依赖隐式穿透](#res-break)'
- en: '[ES.79: Use `default` to handle common cases (only)](#res-default)'
  id: totrans-3344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.79: 使用 `default` 处理常见情况（仅限）](#res-default)'
- en: '[ES.84: Don’t try to declare a local variable with no name](#res-noname)'
  id: totrans-3345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.84: 不要尝试声明一个没有名称的局部变量](#res-noname)'
- en: '[ES.85: Make empty statements visible](#res-empty)'
  id: totrans-3346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.85: 使空语句可见](#res-empty)'
- en: '[ES.86: Avoid modifying loop control variables inside the body of raw for-loops](#res-loop-counter)'
  id: totrans-3347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.86: 避免在原始 `for` 循环体中修改循环控制变量](#res-loop-counter)'
- en: '[ES.87: Don’t add redundant `==` or `!=` to conditions](#res-if)'
  id: totrans-3348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.87: 不要在条件中添加多余的 `==` 或 `!=`](#res-if)'
- en: 'Arithmetic rules:'
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
  zh: 算术规则：
- en: '[ES.100: Don’t mix signed and unsigned arithmetic](#res-mix)'
  id: totrans-3350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.100: 不要混合有符号和无符号算术](#res-mix)'
- en: '[ES.101: Use unsigned types for bit manipulation](#res-unsigned)'
  id: totrans-3351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.101: 使用无符号类型进行位操作](#res-unsigned)'
- en: '[ES.102: Use signed types for arithmetic](#res-signed)'
  id: totrans-3352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.102: 使用有符号类型进行算术](#res-signed)'
- en: '[ES.103: Don’t overflow](#res-overflow)'
  id: totrans-3353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.103: 不要溢出](#res-overflow)'
- en: '[ES.104: Don’t underflow](#res-underflow)'
  id: totrans-3354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.104: 不要下溢](#res-underflow)'
- en: '[ES.105: Don’t divide by integer zero](#res-zero)'
  id: totrans-3355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.105: 不要除以整数零](#res-zero)'
- en: '[ES.106: Don’t try to avoid negative values by using `unsigned`](#res-nonnegative)'
  id: totrans-3356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.106: 不要通过使用 `unsigned` 来尝试避免负值](#res-nonnegative)'
- en: '[ES.107: Don’t use `unsigned` for subscripts, prefer `gsl::index`](#res-subscripts)'
  id: totrans-3357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.107: 不要使用 `unsigned` 作为下标，优先使用 `gsl::index`](#res-subscripts)'
- en: 'ES.1: Prefer the standard library to other libraries and to “handcrafted code”'
  id: totrans-3358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.1: 优先使用标准库而不是其他库和“手工编写”的代码'
- en: Reason
  id: totrans-3359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Code using a library can be much easier to write than code working directly
    with language features, much shorter, tend to be of a higher level of abstraction,
    and the library code is presumably already tested. The ISO C++ Standard Library
    is among the most widely known and best tested libraries. It is available as part
    of all C++ implementations.
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库编写的代码可能比直接使用语言特性的代码更容易编写，更短，往往具有更高的抽象级别，并且库代码可能已经过测试。ISO C++ 标准库是最广为人知且测试最好的库之一。它作为所有
    C++ 实现的一部分提供。
- en: Example
  id: totrans-3361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE403]'
  id: totrans-3362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'a range version of `accumulate` would be even better:'
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `accumulate` 的范围版本会更好：
- en: '[PRE404]'
  id: totrans-3364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: 'but don’t hand-code a well-known algorithm:'
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要手动编写一个众所周知的算法：
- en: '[PRE405]'
  id: totrans-3366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: Exception
  id: totrans-3367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Large parts of the standard library rely on dynamic allocation (free store).
    These parts, notably the containers but not the algorithms, are unsuitable for
    some hard-real-time and embedded applications. In such cases, consider providing/using
    similar facilities, e.g., a standard-library-style container implemented using
    a pool allocator.
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的大部分部分依赖于动态分配（自由存储）。这些部分，特别是容器，但不包括算法，对于某些硬实时和嵌入式应用来说是不合适的。在这种情况下，考虑提供/使用类似的设施，例如，使用池分配器实现的具有标准库风格的容器。
- en: Enforcement
  id: totrans-3369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Not easy. ??? Look for messy loops, nested loops, long functions, absence of
    function calls, lack of use of built-in types. Cyclomatic complexity?
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
  zh: 不容易。??? 寻找混乱的循环、嵌套循环、长函数、缺少函数调用、缺少内置类型的使用。循环复杂度？
- en: 'ES.2: Prefer suitable abstractions to direct use of language features'
  id: totrans-3371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.2: 优先使用合适的抽象而不是直接使用语言特性'
- en: Reason
  id: totrans-3372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A “suitable abstraction” (e.g., library or class) is closer to the application
    concepts than the bare language, leads to shorter and clearer code, and is likely
    to be better tested.
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
  zh: “合适的抽象”（例如，库或类）比裸语言更接近应用程序概念，导致代码更短、更清晰，并且可能更容易测试。
- en: Example
  id: totrans-3374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE406]'
  id: totrans-3375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: 'The more traditional and lower-level near-equivalent is longer, messier, harder
    to get right, and most likely slower:'
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: 更传统和更低级的近等价物更长、更混乱、更难正确实现，并且可能更慢：
- en: '[PRE407]'
  id: totrans-3377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: Once the checking for overflow and error handling has been added that code gets
    quite messy, and there is the problem remembering to `delete` the returned pointer
    and the C-style strings that array contains.
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了溢出检查和错误处理，代码就会变得相当混乱，并且存在忘记删除返回指针和数组中包含的C风格字符串的问题。
- en: Enforcement
  id: totrans-3379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Not easy. ??? Look for messy loops, nested loops, long functions, absence of
    function calls, lack of use of built-in types. Cyclomatic complexity?
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
  zh: 不容易。??? 寻找混乱的循环、嵌套循环、长函数、缺少函数调用、缺少内置类型的使用。循环复杂度？
- en: 'ES.3: Don’t repeat yourself, avoid redundant code'
  id: totrans-3381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.3: 不要重复自己，避免冗余代码'
- en: Duplicated or otherwise redundant code obscures intent, makes it harder to understand
    the logic, and makes maintenance harder, among other problems. It often arises
    from cut-and-paste programming.
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
  zh: 复制或冗余代码会模糊意图，使逻辑更难理解，并使维护更困难，以及其他问题。它通常源于剪切和粘贴编程。
- en: Use standard algorithms where appropriate, instead of writing some own implementation.
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的地方使用标准算法，而不是编写自己的实现。
- en: '**See also**: [SL.1](#rsl-lib), [ES.11](#res-auto)'
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[SL.1](#rsl-lib)，[ES.11](#res-auto)'
- en: Example
  id: totrans-3385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE408]'
  id: totrans-3386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: Enforcement
  id: totrans-3387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Use a static analyzer. It will catch at least some redundant constructs.
  id: totrans-3388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态分析器。它至少会捕获一些冗余结构。
- en: Code review
  id: totrans-3389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: 'ES.dcl: Declarations'
  id: totrans-3390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'ES.dcl: 声明'
- en: A declaration is a statement. A declaration introduces a name into a scope and
    might cause the construction of a named object.
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
  zh: 声明是一个语句。声明将名称引入作用域，并可能导致命名对象的构造。
- en: 'ES.5: Keep scopes small'
  id: totrans-3392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.5: 保持作用域小'
- en: Reason
  id: totrans-3393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Minimize resource retention. Avoid accidental misuse of value.
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。最小化资源保留。避免意外误用值。
- en: '**Alternative formulation**: Don’t declare a name in an unnecessarily large
    scope.'
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种表述**：不要在不需要的宽泛作用域中声明名称。'
- en: Example
  id: totrans-3396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE409]'
  id: totrans-3397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: Example, bad
  id: totrans-3398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE410]'
  id: totrans-3399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'This function is by most measures too long anyway, but the point is that the
    resources used by `fn` and the file handle held by `is` are retained for much
    longer than needed and that unanticipated use of `is` and `fn` could happen later
    in the function. In this case, it might be a good idea to factor out the read:'
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数无论如何都太长了，但关键是`fn`使用的资源以及`is`持有的文件句柄保留的时间比所需的要长得多，并且`is`和`fn`的未预期使用可能在函数的后面发生。在这种情况下，提取读取可能是个好主意：
- en: '[PRE411]'
  id: totrans-3401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: Enforcement
  id: totrans-3402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag loop variable declared outside a loop and not used after the loop
  id: totrans-3403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记在循环外部声明且在循环之后未使用的循环变量
- en: Flag when expensive resources, such as file handles and locks are not used for
    N-lines (for some suitable N)
  id: totrans-3404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当昂贵资源（如文件句柄和锁）未用于N行（对于某些合适的N）时标记。
- en: 'ES.6: Declare names in for-statement initializers and conditions to limit scope'
  id: totrans-3405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.6: 在for语句的初始化器和条件中声明名称以限制作用域'
- en: Reason
  id: totrans-3406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Limit the loop variable visibility to the scope of the loop. Avoid
    using the loop variable for other purposes after the loop. Minimize resource retention.
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。限制循环变量的可见性到循环的作用域。避免在循环之后将循环变量用于其他目的。最小化资源保留。
- en: Example
  id: totrans-3408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE412]'
  id: totrans-3409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: Example, don’t
  id: totrans-3410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不要
- en: '[PRE413]'
  id: totrans-3411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '**See also**: [Don’t use a variable for two unrelated purposes](#res-recycle)'
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[不要将变量用于两个无关的目的](#res-recycle)'
- en: Enforcement
  id: totrans-3413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Warn when a variable modified inside the `for`-statement is declared outside
    the loop and not being used outside the loop.
  id: totrans-3414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`for`语句内部修改的变量在循环外部声明且不在循环外部使用时警告。
- en: (hard) Flag loop variables declared before the loop and used after the loop
    for an unrelated purpose.
  id: totrans-3415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （困难）标记在循环之前声明并在循环之后用于无关目的的循环变量。
- en: '**Discussion**: Scoping the loop variable to the loop body also helps code
    optimizers greatly. Recognizing that the induction variable is only accessible
    in the loop body unblocks optimizations such as hoisting, strength reduction,
    loop-invariant code motion, etc.'
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**：将循环变量作用域限制在循环体中也有助于代码优化器。认识到归纳变量仅在循环体中可访问，可以解除诸如提升、强度降低、循环不变式代码移动等优化。'
- en: C++17 and C++20 example
  id: totrans-3417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: C++17和C++20示例
- en: 'Note: C++17 and C++20 also add `if`, `switch`, and range-`for` initializer
    statements. These require C++17 and C++20 support.'
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：C++17 和 C++20 还添加了 `if`、`switch` 和范围-`for` 初始化语句。这些需要 C++17 和 C++20 支持。
- en: '[PRE414]'
  id: totrans-3419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: C++17 and C++20 enforcement (if using a C++17 or C++20 compiler)
  id: totrans-3420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: C++17 和 C++20 强制执行（如果使用 C++17 或 C++20 编译器）
- en: Flag selection/loop variables declared before the body and not used after the
    body
  id: totrans-3421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主体之前声明并在主体之后未使用的标志选择/循环变量
- en: (hard) Flag selection/loop variables declared before the body and used after
    the body for an unrelated purpose.
  id: totrans-3422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （困难）在主体之前声明并在主体之后用于无关目的的标志选择/循环变量。
- en: 'ES.7: Keep common and local names short, and keep uncommon and non-local names
    longer'
  id: totrans-3423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.7：保持常见和局部名称短，保持不常见和非局部名称长
- en: Reason
  id: totrans-3424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Lowering the chance of clashes between unrelated non-local names.
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。降低无关非局部名称之间的冲突机会。
- en: Example
  id: totrans-3426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Conventional short, local names increase readability:'
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的简短、局部名称可以提高可读性：
- en: '[PRE415]'
  id: totrans-3428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: An index is conventionally called `i` and there is no hint about the meaning
    of the vector in this generic function, so `v` is as good a name as any. Compare
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: 索引通常称为 `i`，在这个通用函数中没有任何关于向量的含义的提示，因此 `v` 是一个很好的名称。比较
- en: '[PRE416]'
  id: totrans-3430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: Yes, it is a caricature, but we have seen worse.
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个夸张，但我们见过更糟糕的。
- en: Example
  id: totrans-3432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Unconventional and short non-local names obscure code:'
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 不寻常且简短的非局部名称会模糊代码：
- en: '[PRE417]'
  id: totrans-3434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'Better, give non-local entities readable names:'
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: 更好，给非局部实体赋予可读的名称：
- en: '[PRE418]'
  id: totrans-3436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: Here, there is a chance that the reader knows what `trim_tail` means and that
    the reader can remember it after looking it up.
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，读者可能知道 `trim_tail` 的含义，并且读者在查找后可以记住它。
- en: Example, bad
  id: totrans-3438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Argument names of large functions are de facto non-local and should be meaningful:'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: 大函数的参数名称实际上是局部的，并且应该是有意义的：
- en: '[PRE419]'
  id: totrans-3440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: We recommend keeping functions short, but that rule isn’t universally adhered
    to and naming should reflect that.
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议保持函数简短，但这条规则并不普遍遵守，命名应该反映这一点。
- en: Enforcement
  id: totrans-3442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Check length of local and non-local names. Also take function length into account.
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
  zh: 检查局部和非局部名称的长度。还要考虑函数长度。
- en: 'ES.8: Avoid similar-looking names'
  id: totrans-3444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.8：避免类似名称
- en: Reason
  id: totrans-3445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Code clarity and readability. Too-similar names slow down comprehension and
    increase the likelihood of error.
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清晰度和可读性。过于相似的名字会减慢理解速度并增加出错的可能性。
- en: Example, bad
  id: totrans-3447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE420]'
  id: totrans-3448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: Example, bad
  id: totrans-3449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: Do not declare a non-type with the same name as a type in the same scope. This
    removes the need to disambiguate with a keyword such as `struct` or `enum`. It
    also removes a source of errors, as `struct X` can implicitly declare `X` if lookup
    fails.
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在同一作用域中声明与类型具有相同名称的非类型。这消除了使用关键字如 `struct` 或 `enum` 来消除歧义的需求。这也消除了错误来源，因为如果查找失败，`struct
    X` 可以隐式声明 `X`。
- en: '[PRE421]'
  id: totrans-3451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: Exception
  id: totrans-3452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Antique header files might declare non-types and types with the same name in
    the same scope.
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: 古老的头文件可能声明了在同一作用域中具有相同名称的非类型和类型。
- en: Enforcement
  id: totrans-3454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Check names against a list of known confusing letter and digit combinations.
  id: totrans-3455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将名称与已知易混淆的字母和数字组合列表进行核对。
- en: Flag a declaration of a variable, function, or enumerator that hides a class
    or enumeration declared in the same scope.
  id: totrans-3456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个变量、函数或枚举器的声明，该声明隐藏了在同一作用域中声明的类或枚举。
- en: 'ES.9: Avoid `ALL_CAPS` names'
  id: totrans-3457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.9：避免 `ALL_CAPS` 名称
- en: Reason
  id: totrans-3458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Such names are commonly used for macros. Thus, `ALL_CAPS` name are vulnerable
    to unintended macro substitution.
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称通常用于宏。因此，`ALL CAPS` 名称容易受到意外宏替换的影响。
- en: Example
  id: totrans-3460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE422]'
  id: totrans-3461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: Note
  id: totrans-3462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use `ALL_CAPS` for constants just because constants used to be macros.
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为常量曾经是宏就使用 `ALL_CAPS`。
- en: Enforcement
  id: totrans-3464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag all uses of ALL CAPS. For older code, accept ALL CAPS for macro names and
    flag all non-all-CAPS macro names.
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有 `ALL CAPS` 的使用。对于旧代码，接受宏名称为 `ALL CAPS` 并标记所有非全大写的宏名称。
- en: 'ES.10: Declare one name (only) per declaration'
  id: totrans-3466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.10：每个声明只声明一个名称（仅此）
- en: Reason
  id: totrans-3467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: One declaration per line increases readability and avoids mistakes related to
    the C/C++ grammar. It also leaves room for a more descriptive end-of-line comment.
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
  zh: 每行一个声明可以提高可读性并避免与 C/C++ 语法相关的错误。它还留出了更多描述性行尾注释的空间。
- en: Example, bad
  id: totrans-3469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE423]'
  id: totrans-3470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: Exception
  id: totrans-3471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: A function declaration can contain several function argument declarations.
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明可以包含多个函数参数声明。
- en: Exception
  id: totrans-3473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'A structured binding (C++17) is specifically designed to introduce several
    variables:'
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定（C++17）专门设计用于引入多个变量：
- en: '[PRE424]'
  id: totrans-3475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: Example
  id: totrans-3476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE425]'
  id: totrans-3477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'or better using concepts:'
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的是使用概念：
- en: '[PRE426]'
  id: totrans-3479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: Example
  id: totrans-3480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE427]'
  id: totrans-3481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'or:'
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE428]'
  id: totrans-3483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'or:'
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE429]'
  id: totrans-3485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: Example
  id: totrans-3486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE430]'
  id: totrans-3487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: In a long list of declarators it is easy to overlook an uninitialized variable.
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
  zh: 在长列表的声明中，很容易忽略未初始化的变量。
- en: Enforcement
  id: totrans-3489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag variable and constant declarations with multiple declarators (e.g., `int*
    p, q;`)
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有多个声明符的变量和常量声明标记为（例如，`int* p, q;`）
- en: 'ES.11: Use `auto` to avoid redundant repetition of type names'
  id: totrans-3491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.11：使用 `auto` 避免类型名的冗余重复
- en: Reason
  id: totrans-3492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Simple repetition is tedious and error-prone.
  id: totrans-3493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单重复既乏味又容易出错。
- en: When you use `auto`, the name of the declared entity is in a fixed position
    in the declaration, increasing readability.
  id: totrans-3494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用 `auto` 时，声明的实体名称在声明中处于固定位置，增加了可读性。
- en: In a function template declaration the return type can be a member type.
  id: totrans-3495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数模板声明中，返回类型可以是成员类型。
- en: Example
  id: totrans-3496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE431]'
  id: totrans-3498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: In each case, we save writing a longish, hard-to-remember type that the compiler
    already knows but a programmer could get wrong.
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们节省了编写一个长而难以记住的类型，编译器已经知道，但程序员可能会出错。
- en: Example
  id: totrans-3500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE432]'
  id: totrans-3501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: Exception
  id: totrans-3502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Avoid `auto` for initializer lists and in cases where you know exactly which
    type you want and where an initializer might require conversion.
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在初始化列表和已知确切类型且可能需要转换的地方使用 `auto`。
- en: Example
  id: totrans-3504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE433]'
  id: totrans-3505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: Note
  id: totrans-3506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'As of C++20, we can (and should) use concepts to be more specific about the
    type we are deducing:'
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 C++20，我们可以（并且应该）使用概念来更具体地说明我们正在推导的类型：
- en: '[PRE434]'
  id: totrans-3508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: Example (C++17)
  id: totrans-3509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例（C++17）
- en: '[PRE435]'
  id: totrans-3510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: Enforcement
  id: totrans-3511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag redundant repetition of type names in a declaration.
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
  zh: 将声明中类型名的冗余重复标记为
- en: 'ES.12: Do not reuse names in nested scopes'
  id: totrans-3513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.12：不要在嵌套作用域中重用名称
- en: Reason
  id: totrans-3514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is easy to get confused about which variable is used. Can cause maintenance
    problems.
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
  zh: 容易混淆使用哪个变量。可能导致维护问题。
- en: Example, bad
  id: totrans-3516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE436]'
  id: totrans-3517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: If this is a large `if`-statement, it is easy to overlook that a new `d` has
    been introduced in the inner scope. This is a known source of bugs. Sometimes
    such reuse of a name in an inner scope is called “shadowing”.
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个大的 `if`-语句，很容易忽略在内部作用域中引入了新的 `d`。这是已知的错误来源。有时在内部作用域中这种名称的重用被称为“遮蔽”。
- en: Note
  id: totrans-3519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Shadowing is primarily a problem when functions are too large and too complex.
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数太大、太复杂时，遮蔽主要是一个问题。
- en: Example
  id: totrans-3521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Shadowing of function arguments in the outermost block is disallowed by the
    language:'
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
  zh: 外部块中函数参数的遮蔽在语言中是不允许的：
- en: '[PRE437]'
  id: totrans-3523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: Example, bad
  id: totrans-3524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'Reuse of a member name as a local variable can also be a problem:'
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
  zh: 将成员名作为局部变量重用也可能是一个问题：
- en: '[PRE438]'
  id: totrans-3526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: Exception
  id: totrans-3527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'We often reuse function names from a base class in a derived class:'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在派生类中重用基类中的函数名：
- en: '[PRE439]'
  id: totrans-3529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: This is error-prone. For example, had we forgotten the using declaration, a
    call `d.f(1)` would not have found the `int` version of `f`.
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有风险的。例如，如果我们忘记了使用声明，调用 `d.f(1)` 就不会找到 `int` 版本的 `f`。
- en: ??? Do we need a specific rule about shadowing/hiding in class hierarchies?
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 我们需要关于遮蔽/隐藏在类层次结构中的特定规则吗？
- en: Enforcement
  id: totrans-3532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag reuse of a name in nested local scopes
  id: totrans-3533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在嵌套局部作用域中重用的名称标记为
- en: Flag reuse of a member name as a local variable in a member function
  id: totrans-3534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将成员函数中的成员名重用作为局部变量标记为
- en: Flag reuse of a global name as a local variable or a member name
  id: totrans-3535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将全局名称的重用作为局部变量或成员名称标记为
- en: Flag reuse of a base class member name in a derived class (except for function
    names)
  id: totrans-3536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基类成员名称在派生类中重用（除了函数名）
- en: 'ES.20: Always initialize an object'
  id: totrans-3537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.20：始终初始化对象
- en: Reason
  id: totrans-3538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoid used-before-set errors and their associated undefined behavior. Avoid
    problems with comprehension of complex initialization. Simplify refactoring.
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用前未设置的错误及其相关的未定义行为。避免与复杂初始化相关的理解问题。简化重构。
- en: Example
  id: totrans-3540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE440]'
  id: totrans-3541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'No, `i = 7` does not initialize `i`; it assigns to it. Also, `i` can be read
    in the `...` part. Better:'
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
  zh: 不，`i = 7` 并不是初始化 `i`，而是将其赋值。此外，`i` 可以在 `...` 部分被读取。更好的做法是：
- en: '[PRE441]'
  id: totrans-3543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: Note
  id: totrans-3544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The *always initialize* rule is deliberately stronger than the *an object must
    be set before used* language rule. The latter, more relaxed rule, catches the
    technical bugs, but:'
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
  zh: “始终初始化”规则故意比“对象在使用前必须设置”的语言规则更强。后者更为宽松的规则可以捕获技术错误，但：
- en: It leads to less readable code
  id: totrans-3546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会导致代码可读性降低
- en: It encourages people to declare names in greater than necessary scopes
  id: totrans-3547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它鼓励人们在比必要的范围内声明名称
- en: It leads to harder to read code
  id: totrans-3548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会导致代码难以阅读
- en: It leads to logic bugs by encouraging complex code
  id: totrans-3549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这通过鼓励复杂代码导致逻辑错误
- en: It hampers refactoring
  id: totrans-3550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这阻碍了重构
- en: The *always initialize* rule is a style rule aimed to improve maintainability
    as well as a rule protecting against used-before-set errors.
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: “始终初始化”规则是一种旨在提高可维护性的风格规则，也是一项旨在防止使用前未设置错误的规则。
- en: Example
  id: totrans-3552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Here is an example that is often considered to demonstrate the need for a more
    relaxed rule for initialization
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个经常被认为需要更宽松初始化规则的例子
- en: '[PRE442]'
  id: totrans-3554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: This cannot trivially be rewritten to initialize `i` and `j` with initializers.
    Note that for types with a default constructor, attempting to postpone initialization
    simply leads to a default initialization followed by an assignment. A popular
    reason for such examples is “efficiency”, but a compiler that can detect whether
    we made a used-before-set error can also eliminate any redundant double initialization.
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 这不能简单地重写为使用初始化器初始化 `i` 和 `j`。注意，对于具有默认构造函数的类型，尝试推迟初始化只会导致默认初始化后跟赋值。这种例子流行的原因之一是“效率”，但可以检测我们是否犯了使用前未设置错误的编译器也可以消除任何冗余的双重初始化。
- en: 'Assuming that there is a logical connection between `i` and `j`, that connection
    should probably be expressed in code:'
  id: totrans-3556
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `i` 和 `j` 之间存在逻辑联系，那么这种联系可能应该在代码中表达出来：
- en: '[PRE443]'
  id: totrans-3557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'If the `make_related_widgets` function is otherwise redundant, we can eliminate
    it by using a lambda [ES.28](#res-lambda-init):'
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `make_related_widgets` 函数在其他方面是冗余的，我们可以通过使用 lambda [ES.28](#res-lambda-init)
    来消除它：
- en: '[PRE444]'
  id: totrans-3559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'Using a value representing “uninitialized” is a symptom of a problem and not
    a solution:'
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表示“未初始化”的值是问题的症状，而不是解决方案：
- en: '[PRE445]'
  id: totrans-3561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'Now the compiler cannot even simply detect a used-before-set. Further, we’ve
    introduced complexity in the state space for widget: which operations are valid
    on an `uninit` widget and which are not?'
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器甚至无法简单地检测到使用前未设置的情况。此外，我们在小部件的状态空间中引入了复杂性：哪些操作在未初始化的小部件上是有效的，哪些不是？
- en: Note
  id: totrans-3563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Complex initialization has been popular with clever programmers for decades.
    It has also been a major source of errors and complexity. Many such errors are
    introduced during maintenance years after the initial implementation.
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂初始化几十年来一直是聪明程序员的流行做法。它也是错误和复杂性的主要来源。许多这样的错误是在初始实现后的维护年份中引入的。
- en: Example
  id: totrans-3565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: This rule covers data members.
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则涵盖数据成员。
- en: '[PRE446]'
  id: totrans-3567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: The compiler will flag the uninitialized `cm3` because it is a `const`, but
    it will not catch the lack of initialization of `m3`. Usually, a rare spurious
    member initialization is worth the absence of errors from lack of initialization
    and often an optimizer can eliminate a redundant initialization (e.g., an initialization
    that occurs immediately before an assignment).
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会标记未初始化的 `cm3`，因为它是一个 `const`，但它不会捕捉到 `m3` 初始化不足的问题。通常，一个罕见的虚假成员初始化可以弥补初始化不足的错误，并且优化器通常可以消除冗余初始化（例如，在赋值之前立即发生的初始化）。
- en: Exception
  id: totrans-3569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'If you are declaring an object that is just about to be initialized from input,
    initializing it would cause a double initialization. However, beware that this
    might leave uninitialized data beyond the input – and that has been a fertile
    source of errors and security breaches:'
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在声明一个即将从输入初始化的对象，初始化它会导致双重初始化。然而，请注意，这可能会留下未初始化的数据——这已经成为错误和安全漏洞的温床：
- en: '[PRE447]'
  id: totrans-3571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: The cost of initializing that array could be significant in some situations.
    However, such examples do tend to leave uninitialized variables accessible, so
    they should be treated with suspicion.
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，初始化该数组可能代价高昂。然而，这样的例子往往会使未初始化的变量可访问，因此应该对此表示怀疑。
- en: '[PRE448]'
  id: totrans-3573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: Because of the restrictive initialization rules for arrays and `std::array`,
    they offer the most compelling examples of the need for this exception.
  id: totrans-3574
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组和 `std::array` 的限制性初始化规则，它们提供了需要这种异常的最有说服力的例子。
- en: 'When feasible use a library function that is known not to overflow. For example:'
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 当可行时，使用已知不会溢出的库函数。例如：
- en: '[PRE449]'
  id: totrans-3576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'Don’t consider simple variables that are targets for input operations exceptions
    to this rule:'
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将简单变量视为输入操作的异常情况：
- en: '[PRE450]'
  id: totrans-3578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: In the not uncommon case where the input target and the input operation get
    separated (as they should not) the possibility of used-before-set opens up.
  id: totrans-3579
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入目标和输入操作分离（如不应发生的那样）的不太常见的情况下，使用前未设置的可能性就出现了。
- en: '[PRE451]'
  id: totrans-3580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: A good optimizer should know about input operations and eliminate the redundant
    operation.
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的优化器应该了解输入操作并消除冗余操作。
- en: Note
  id: totrans-3582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sometimes, a lambda can be used as an initializer to avoid an uninitialized
    variable:'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可以使用 lambda 作为初始化器来避免未初始化的变量：
- en: '[PRE452]'
  id: totrans-3584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'or maybe:'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: 或者也许：
- en: '[PRE453]'
  id: totrans-3586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '**See also**: [ES.28](#res-lambda-init)'
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [ES.28](#res-lambda-init)'
- en: Enforcement
  id: totrans-3588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag every uninitialized variable. Don’t flag variables of user-defined types
    with default constructors.
  id: totrans-3589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有未初始化的变量。不要标记具有默认构造函数的用户定义类型的变量。
- en: Check that an uninitialized buffer is written into *immediately* after declaration.
    Passing an uninitialized variable as a reference to non-`const` argument can be
    assumed to be a write into the variable.
  id: totrans-3590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查在声明后立即写入未初始化的缓冲区。将未初始化的变量作为非`const`参数的引用传递可以假设为对变量的写入。
- en: 'ES.21: Don’t introduce a variable (or constant) before you need to use it'
  id: totrans-3591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.21: 在需要使用它之前不要引入变量（或常量）'
- en: Reason
  id: totrans-3592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. To limit the scope in which the variable can be used.
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。为了限制变量可以使用的范围。
- en: Example
  id: totrans-3594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE454]'
  id: totrans-3595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: Enforcement
  id: totrans-3596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag declarations that are distant from their first use.
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: 标记远离其首次使用的声明。
- en: 'ES.22: Don’t declare a variable until you have a value to initialize it with'
  id: totrans-3598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.22: 在你有值可以初始化它之前不要声明变量'
- en: Reason
  id: totrans-3599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Limit the scope in which a variable can be used. Don’t risk used-before-set.
    Initialization is often more efficient than assignment.
  id: totrans-3600
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。限制变量可以使用的范围。不要冒险使用未设置的变量。初始化通常比赋值更有效。
- en: Example, bad
  id: totrans-3601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE455]'
  id: totrans-3602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: Example, bad
  id: totrans-3603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE456]'
  id: totrans-3604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: This would be fine if there was a default initialization for `SomeLargeType`
    that wasn’t too expensive. Otherwise, a programmer might very well wonder if every
    possible path through the maze of conditions has been covered. If not, we have
    a “use before set” bug. This is a maintenance trap.
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`SomeLargeType`有一个不太昂贵的默认初始化，这将是可行的。否则，程序员可能会非常想知道是否已经覆盖了迷宫中所有可能的条件路径。如果没有，我们就有了一个“使用前设置”的bug。这是一个维护陷阱。
- en: For initializers of moderate complexity, including for `const` variables, consider
    using a lambda to express the initializer; see [ES.28](#res-lambda-init).
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中等复杂性的初始化器，包括`const`变量，考虑使用lambda表达式来表示初始化器；参见[ES.28](#res-lambda-init)。
- en: Enforcement
  id: totrans-3607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag declarations with default initialization that are assigned to before they
    are first read.
  id: totrans-3608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记在首次读取之前就分配了默认初始化的声明。
- en: Flag any complicated computation after an uninitialized variable and before
    its use.
  id: totrans-3609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记在未初始化变量之后和使用之前的任何复杂计算。
- en: 'ES.23: Prefer the `{}`-initializer syntax'
  id: totrans-3610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.23: 优先使用`{}`初始化器语法'
- en: Reason
  id: totrans-3611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Prefer `{}`. The rules for `{}` initialization are simpler, more general, less
    ambiguous, and safer than for other forms of initialization.
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
  zh: 优先使用`{}`。`{}`初始化的规则更简单、更通用、更不模糊且更安全，比其他形式的初始化。
- en: Use `=` only when you are sure that there can be no narrowing conversions. For
    built-in arithmetic types, use `=` only with `auto`.
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你确定没有窄化转换时才使用`=`。对于内置算术类型，仅与`auto`一起使用`=`。
- en: Avoid `()` initialization, which allows parsing ambiguities.
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`()`初始化，这允许解析歧义。
- en: Example
  id: totrans-3615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE457]'
  id: totrans-3616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: Exception
  id: totrans-3617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例外
- en: 'For containers, there is a tradition for using `{...}` for a list of elements
    and `(...)` for sizes:'
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
  zh: 对于容器，有一个使用`{...}`表示元素列表和`(...)`表示大小的传统：
- en: '[PRE458]'
  id: totrans-3619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: Note
  id: totrans-3620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`{}`-initializers do not allow narrowing conversions (and that is usually a
    good thing) and allow explicit constructors (which is fine, we’re intentionally
    initializing a new variable).'
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}`初始化器不允许窄化转换（这通常是好事）并允许显式构造函数（这很好，我们有意初始化一个新变量）。'
- en: Example
  id: totrans-3622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE459]'
  id: totrans-3623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: Note
  id: totrans-3624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`{}` initialization can be used for nearly all initialization; other forms
    of initialization can’t:'
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}`初始化可以用于几乎所有初始化；其他形式的初始化则不行：'
- en: '[PRE460]'
  id: totrans-3626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: For that reason, `{}`-initialization is often called “uniform initialization”
    (though there unfortunately are a few irregularities left).
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`{}`初始化通常被称为“统一初始化”（尽管不幸的是还有一些不规则之处）。
- en: Note
  id: totrans-3628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Initialization of a variable declared using `auto` with a single value, e.g.,
    `{v}`, had surprising results until C++17. The C++17 rules are somewhat less surprising:'
  id: totrans-3629
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个值（例如，`{v}`）初始化使用`auto`声明的变量的初始化，在C++17之前有令人惊讶的结果。C++17的规则相对不那么令人惊讶：
- en: '[PRE461]'
  id: totrans-3630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: Use `={...}` if you really want an `initializer_list<T>`
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想使用`initializer_list<T>`，请使用`={...}`
- en: '[PRE462]'
  id: totrans-3632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: Note
  id: totrans-3633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`={}` gives copy initialization whereas `{}` gives direct initialization. Like
    the distinction between copy-initialization and direct-initialization itself,
    this can lead to surprises. `{}` accepts `explicit` constructors; `={}` does not.
    For example:'
  id: totrans-3634
  prefs: []
  type: TYPE_NORMAL
  zh: '`={}`提供复制初始化，而`{}`提供直接初始化。就像复制初始化和直接初始化之间的区别本身可能导致惊讶一样，这可能会导致意外。`{}`接受`explicit`构造函数；`={}`则不接受。例如：'
- en: '[PRE463]'
  id: totrans-3635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: Use plain `{}`-initialization unless you specifically want to disable explicit
    constructors.
  id: totrans-3636
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你明确想要禁用显式构造函数，否则请使用普通的 `{}`-初始化。
- en: Example
  id: totrans-3637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE464]'
  id: totrans-3638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '**See also**: [Discussion](#???)'
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[讨论](#???)'
- en: Enforcement
  id: totrans-3640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag uses of `=` to initialize arithmetic types where narrowing occurs.
  id: totrans-3641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记使用 `=` 初始化发生缩窄的算术类型的用法。
- en: Flag uses of `()` initialization syntax that are actually declarations. (Many
    compilers should warn on this already.)
  id: totrans-3642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记使用 `()` 初始化语法实际上是声明的用法。（许多编译器应该已经对此发出警告。）
- en: 'ES.24: Use a `unique_ptr<T>` to hold pointers'
  id: totrans-3643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.24：使用 `unique_ptr<T>` 来持有指针
- en: Reason
  id: totrans-3644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Using `std::unique_ptr` is the simplest way to avoid leaks. It is reliable,
    it makes the type system do much of the work to validate ownership safety, it
    increases readability, and it has zero or near zero run-time cost.
  id: totrans-3645
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::unique_ptr` 是避免泄漏的最简单方法。它是可靠的，它使类型系统做很多工作以验证所有权安全性，它提高了可读性，并且具有零或接近零的运行时成本。
- en: Example
  id: totrans-3646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE465]'
  id: totrans-3647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: If `leak == true` the object pointed to by `p2` is leaked and the object pointed
    to by `p1` is not. The same is the case when `at()` throws. In both cases, the
    `delete p2` statement is not reached.
  id: totrans-3648
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `leak == true`，则 `p2` 指向的对象会泄漏，而 `p1` 指向的对象不会。当 `at()` 抛出异常时，情况也是如此。在这两种情况下，都不会执行
    `delete p2` 语句。
- en: Enforcement
  id: totrans-3649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Look for raw pointers that are targets of `new`, `malloc()`, or functions that
    might return such pointers.
  id: totrans-3650
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 `new`、`malloc()` 或可能返回此类指针的函数的目标原始指针。
- en: 'ES.25: Declare an object `const` or `constexpr` unless you want to modify its
    value later on'
  id: totrans-3651
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.25：除非你以后想修改其值，否则请声明对象为 `const` 或 `constexpr`
- en: Reason
  id: totrans-3652
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That way you can’t change the value by mistake. That way might offer the compiler
    optimization opportunities.
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做你就不小心改变值了。这样做可能会为编译器提供优化机会。
- en: Example
  id: totrans-3654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE466]'
  id: totrans-3655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: Enforcement
  id: totrans-3656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Look to see if a variable is actually mutated, and flag it if not. Unfortunately,
    it might be impossible to detect when a non-`const` was not *intended* to vary
    (vs when it merely did not vary).
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
  zh: 查看变量是否实际上被修改，如果没有，则标记它。不幸的是，可能无法检测到非 `const` 不是 *有意* 变化（与它仅仅没有变化的情况相比）。
- en: 'ES.26: Don’t use a variable for two unrelated purposes'
  id: totrans-3658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.26：不要将变量用于两个不相关的目的
- en: Reason
  id: totrans-3659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability and safety.
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性和安全性。
- en: Example, bad
  id: totrans-3661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE467]'
  id: totrans-3662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: Note
  id: totrans-3663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As an optimization, you might want to reuse a buffer as a scratch pad, but even
    then prefer to limit the variable’s scope as much as possible and be careful not
    to cause bugs from data left in a recycled buffer as this is a common source of
    security bugs.
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
  zh: 作为优化，你可能想要将缓冲区作为临时垫板重用，但即使在这种情况下，也尽可能限制变量的作用域，并小心不要因为回收的缓冲区中遗留的数据而引起错误，因为这通常是安全漏洞的常见来源。
- en: '[PRE468]'
  id: totrans-3665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: Enforcement
  id: totrans-3666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag recycled variables.
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: 标记回收变量。
- en: 'ES.27: Use `std::array` or `stack_array` for arrays on the stack'
  id: totrans-3668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.27：使用 `std::array` 或 `stack_array` 为栈上的数组
- en: Reason
  id: totrans-3669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: They are readable and don’t implicitly convert to pointers. They are not confused
    with non-standard extensions of built-in arrays.
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
  zh: 它们易于阅读，并且不会隐式转换为指针。它们与非标准扩展的内置数组不会混淆。
- en: Example, bad
  id: totrans-3671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE469]'
  id: totrans-3672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: Note
  id: totrans-3673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The definition of `a1` is legal C++ and has always been. There is a lot of such
    code. It is error-prone, though, especially when the bound is non-local. Also,
    it is a “popular” source of errors (buffer overflow, pointers from array decay,
    etc.). The definition of `a2` is C but not C++ and is considered a security risk.
  id: totrans-3674
  prefs: []
  type: TYPE_NORMAL
  zh: '`a1` 的定义是合法的 C++，并且始终如此。有很多这样的代码。尽管如此，它容易出错，尤其是当界限是非局部的时候。它也是一个“流行”的错误来源（缓冲区溢出、从数组衰减的指针等）。`a2`
    的定义是 C 但不是 C++，被认为是一个安全风险。'
- en: Example
  id: totrans-3675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE470]'
  id: totrans-3676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: Enforcement
  id: totrans-3677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag arrays with non-constant bounds (C-style VLAs)
  id: totrans-3678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非常量界限标记数组（C样式的 VLAs）
- en: Flag arrays with non-local constant bounds
  id: totrans-3679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非局部常量界限标记标志数组
- en: 'ES.28: Use lambdas for complex initialization, especially of `const` variables'
  id: totrans-3680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.28：使用 lambda 表达式进行复杂初始化，特别是 `const` 变量
- en: Reason
  id: totrans-3681
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It nicely encapsulates local initialization, including cleaning up scratch variables
    needed only for the initialization, without needing to create a needless non-local
    yet non-reusable function. It also works for variables that should be `const`
    but only after some initialization work.
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
  zh: 它很好地封装了局部初始化，包括清理仅用于初始化的临时变量，而无需创建不必要的非局部且不可重用的函数。它也适用于应该为 `const` 但仅在初始化工作之后才为
    `const` 的变量。
- en: Example, bad
  id: totrans-3683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE471]'
  id: totrans-3684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: Example, good
  id: totrans-3685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE472]'
  id: totrans-3686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: If at all possible, reduce the conditions to a simple set of alternatives (e.g.,
    an `enum`) and don’t mix up selection and initialization.
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，将条件简化为简单的一组替代方案（例如，一个 `enum`），并且不要混淆选择和初始化。
- en: Enforcement
  id: totrans-3688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Hard. At best a heuristic. Look for an uninitialized variable followed by a
    loop assigning to it.
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
  zh: 困难。至多是一个启发式方法。寻找一个未初始化的变量后面跟着一个将其赋值的循环。
- en: 'ES.30: Don’t use macros for program text manipulation'
  id: totrans-3690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.30: 不要使用宏进行程序文本操作'
- en: Reason
  id: totrans-3691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Macros are a major source of bugs. Macros don’t obey the usual scope and type
    rules. Macros ensure that the human reader sees something different from what
    the compiler sees. Macros complicate tool building.
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是错误的主要来源。宏不遵循通常的作用域和类型规则。宏确保人类读者看到的内容与编译器看到的内容不同。宏使工具构建复杂化。
- en: Example, bad
  id: totrans-3693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE473]'
  id: totrans-3694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: This innocuous-looking macro makes a single lower case `c` instead of a `C`
    into a bad flow-control bug.
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似无害的宏将单个小写`c`而不是`C`变成了一个糟糕的流程控制错误。
- en: Note
  id: totrans-3696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: This rule does not ban the use of macros for “configuration control” use in
    `#ifdef`s, etc.
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则并不禁止在`#ifdef`等“配置控制”中使用宏。
- en: In the future, modules are likely to eliminate the need for macros in configuration
    control.
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，模块可能会消除配置控制中宏的需求。
- en: Note
  id: totrans-3699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'This rule is meant to also discourage use of `#` for stringification and `##`
    for concatenation. As usual for macros, there are uses that are “mostly harmless”,
    but even these can create problems for tools, such as auto completers, static
    analyzers, and debuggers. Often the desire to use fancy macros is a sign of an
    overly complex design. Also, `#` and `##` encourages the definition and use of
    macros:'
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则旨在也劝阻使用`#`进行字符串化以及`##`进行连接。对于宏来说，通常有一些“基本上无害”的使用，但这些也可能为工具（如自动完成器、静态分析器和调试器）带来问题。通常，使用花哨宏的愿望是设计过于复杂的标志。此外，`#`和`##`鼓励定义和使用宏：
- en: '[PRE474]'
  id: totrans-3701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: 'There are workarounds for low-level string manipulation using macros. For example:'
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏进行低级字符串操作有解决方案。例如：
- en: '[PRE475]'
  id: totrans-3703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: This is not as convenient as a macro to define, but as easy to use, has zero
    overhead, and is typed and scoped.
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
  zh: 这不如宏定义方便，但使用起来方便，没有开销，并且是类型化和作用域化的。
- en: In the future, static reflection is likely to eliminate the last needs for the
    preprocessor for program text manipulation.
  id: totrans-3705
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，静态反射可能会消除程序文本操作中预处理器最后的需要。
- en: Enforcement
  id: totrans-3706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Scream when you see a macro that isn’t just used for source control (e.g., `#ifdef`)
  id: totrans-3707
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到不是仅用于源控制（例如，`#ifdef`）的宏时，要大声疾呼。
- en: 'ES.31: Don’t use macros for constants or “functions”'
  id: totrans-3708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.31: 不要使用宏定义常量或“函数”'
- en: Reason
  id: totrans-3709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Macros are a major source of bugs. Macros don’t obey the usual scope and type
    rules. Macros don’t obey the usual rules for argument passing. Macros ensure that
    the human reader sees something different from what the compiler sees. Macros
    complicate tool building.
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是错误的主要来源。宏不遵循通常的作用域和类型规则。宏不遵循通常的参数传递规则。宏确保人类读者看到的内容与编译器看到的内容不同。宏使工具构建复杂化。
- en: Example, bad
  id: totrans-3711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE476]'
  id: totrans-3712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: 'Even if we hadn’t left a well-known bug in `SQUARE` there are much better behaved
    alternatives; for example:'
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在`SQUARE`中留下了一个众所周知的错误，也有许多表现更好的替代方案；例如：
- en: '[PRE477]'
  id: totrans-3714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: Enforcement
  id: totrans-3715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Scream when you see a macro that isn’t just used for source control (e.g., `#ifdef`)
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到不是仅用于源控制（例如，`#ifdef`）的宏时，要大声疾呼。
- en: 'ES.32: Use `ALL_CAPS` for all macro names'
  id: totrans-3717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.32: 使用`ALL_CAPS`为所有宏命名'
- en: Reason
  id: totrans-3718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Convention. Readability. Distinguishing macros.
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯。可读性。区分宏。
- en: Example
  id: totrans-3720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE478]'
  id: totrans-3721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: Enforcement
  id: totrans-3722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Scream when you see a lower case macro.
  id: totrans-3723
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到小写宏时，要大声疾呼。
- en: 'ES.33: If you must use macros, give them unique names'
  id: totrans-3724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.33: 如果必须使用宏，请给它们起独特的名字'
- en: Reason
  id: totrans-3725
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Macros do not obey scope rules.
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
  zh: 宏不遵循作用域规则。
- en: Example
  id: totrans-3727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE479]'
  id: totrans-3728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: Note
  id: totrans-3729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'Avoid macros if you can: [ES.30](#res-macros), [ES.31](#res-macros2), and [ES.32](#res-all_caps).
    However, there are billions of lines of code littered with macros and a long tradition
    for using and overusing macros. If you are forced to use macros, use long names
    and supposedly unique prefixes (e.g., your organization’s name) to lower the likelihood
    of a clash.'
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，避免使用宏：[ES.30](#res-macros)，[ES.31](#res-macros2)，和[ES.32](#res-all_caps)。然而，有成千上万行代码中充满了宏，并且有使用和过度使用宏的悠久传统。如果你被迫使用宏，请使用长名称和假设的独特前缀（例如，你所在组织的名称）以降低冲突的可能性。
- en: Enforcement
  id: totrans-3731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Warn against short macro names.
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
  zh: 警告使用简短的宏名。
- en: 'ES.34: Don’t define a (C-style) variadic function'
  id: totrans-3733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.34: 不要定义（C风格）变长函数'
- en: Reason
  id: totrans-3734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Not type safe. Requires messy cast-and-macro-laden code to get working right.
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全类型。需要混乱的强制转换和宏代码才能正确工作。
- en: Example
  id: totrans-3736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE480]'
  id: totrans-3737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '**Alternative**: Overloading. Templates. Variadic templates.'
  id: totrans-3738
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：重载。模板。变长模板。'
- en: '[PRE481]'
  id: totrans-3739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: Note
  id: totrans-3740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: This is basically the way `printf` is implemented.
  id: totrans-3741
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是`printf`的实现方式。
- en: Enforcement
  id: totrans-3742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag definitions of C-style variadic functions.
  id: totrans-3743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 C 风格的变长函数的定义。
- en: Flag `#include <cstdarg>` and `#include <stdarg.h>`
  id: totrans-3744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 `#include <cstdarg>` 和 `#include <stdarg.h>`
- en: 'ES.expr: Expressions'
  id: totrans-3745
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES.expr：表达式
- en: Expressions manipulate values.
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式操作值。
- en: 'ES.40: Avoid complicated expressions'
  id: totrans-3747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.40：避免复杂表达式
- en: Reason
  id: totrans-3748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Complicated expressions are error-prone.
  id: totrans-3749
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的表达式容易出错。
- en: Example
  id: totrans-3750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE482]'
  id: totrans-3751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: Some of these expressions are unconditionally bad (e.g., they rely on undefined
    behavior). Others are simply so complicated and/or unusual that even good programmers
    could misunderstand them or overlook a problem when in a hurry.
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这样的表达式无条件地是错误的（例如，它们依赖于未定义的行为）。其他表达式则非常复杂和/或异常，即使是优秀的程序员在匆忙中也可能误解它们或忽略问题。
- en: Note
  id: totrans-3753
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: C++17 tightens up the rules for the order of evaluation (left-to-right except
    right-to-left in assignments, and the order of evaluation of function arguments
    is unspecified; [see ES.43](#res-order)), but that doesn’t change the fact that
    complicated expressions are potentially confusing.
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 紧缩了评估顺序的规则（除了赋值时从右到左，函数参数的评估顺序是不确定的；[见 ES.43](#res-order))，但这并不改变复杂表达式可能令人困惑的事实。
- en: Note
  id: totrans-3755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A programmer should know and use the basic rules for expressions.
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该了解并使用表达式的基本规则。
- en: Example
  id: totrans-3757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE483]'
  id: totrans-3758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: Enforcement
  id: totrans-3759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Tricky. How complicated must an expression be to be considered complicated?
    Writing computations as statements with one operation each is also confusing.
    Things to consider:'
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂。一个表达式必须多么复杂才能被认为是复杂的？将计算写成每个语句只有一个操作也是令人困惑的。需要考虑的事项：
- en: 'side effects: side effects on multiple non-local variables (for some definition
    of non-local) can be suspect, especially if the side effects are in separate subexpressions'
  id: totrans-3761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用：对多个非局部变量（根据某些定义的非局部）的副作用可能是可疑的，特别是如果副作用在单独的子表达式中
- en: writes to aliased variables
  id: totrans-3762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入别名变量
- en: more than N operators (and what should N be?)
  id: totrans-3763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过 N 个运算符（N 应该是多少？）
- en: reliance of subtle precedence rules
  id: totrans-3764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精微的优先级规则依赖
- en: uses undefined behavior (can we catch all undefined behavior?)
  id: totrans-3765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未定义的行为（我们能捕捉到所有未定义的行为吗？）
- en: implementation defined behavior?
  id: totrans-3766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现定义的行为？
- en: ???
  id: totrans-3767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.41: If in doubt about operator precedence, parenthesize'
  id: totrans-3768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.41：如果对运算符优先级有疑问，请使用括号
- en: Reason
  id: totrans-3769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoid errors. Readability. Not everyone has the operator table memorized.
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
  zh: 避免错误。可读性。并非每个人都记住了运算符表。
- en: Example
  id: totrans-3771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE484]'
  id: totrans-3772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'Note: We recommend that programmers know their precedence table for the arithmetic
    operations, the logical operations, but consider mixing bitwise logical operations
    with other operators in need of parentheses.'
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们建议程序员了解算术运算、逻辑运算的优先级表，但考虑将位运算符与其他需要括号的运算符混合使用。
- en: '[PRE485]'
  id: totrans-3774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: Note
  id: totrans-3775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You should know enough not to need parentheses for:'
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道足够的信息，不需要括号：
- en: '[PRE486]'
  id: totrans-3777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: Enforcement
  id: totrans-3778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag combinations of bitwise-logical operators and other operators.
  id: totrans-3779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记位运算符组合和其他运算符的组合。
- en: Flag assignment operators not as the leftmost operator.
  id: totrans-3780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记赋值运算符不是最左边的运算符。
- en: ???
  id: totrans-3781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.42: Keep use of pointers simple and straightforward'
  id: totrans-3782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.42：保持指针使用简单直接
- en: Reason
  id: totrans-3783
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Complicated pointer manipulation is a major source of errors.
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的指针操作是错误的主要来源。
- en: Note
  id: totrans-3785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Use `gsl::span` instead. Pointers should [only refer to single objects](#ri-array).
    Pointer arithmetic is fragile and easy to get wrong, the source of many, many
    bad bugs and security violations. `span` is a bounds-checked, safe type for accessing
    arrays of data. Access into an array with known bounds using a constant as a subscript
    can be validated by the compiler.
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gsl::span` 代替。指针应[仅引用单个对象](#ri-array)。指针算术是脆弱的，容易出错，是许多许多糟糕的漏洞和安全违规的来源。`span`
    是一个边界检查的、安全的类型，用于访问数据数组。使用常数作为下标访问已知边界的数组可以通过编译器进行验证。
- en: Example, bad
  id: totrans-3787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE487]'
  id: totrans-3788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: Example, good
  id: totrans-3789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE488]'
  id: totrans-3790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: Note
  id: totrans-3791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Subscripting with a variable is difficult for both tools and humans to validate
    as safe. `span` is a run-time bounds-checked, safe type for accessing arrays of
    data. `at()` is another alternative that ensures single accesses are bounds-checked.
    If iterators are needed to access an array, use the iterators from a `span` constructed
    over the array.
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量进行下标操作对工具和人类来说都很难验证其安全性。`span` 是一个运行时边界检查的、安全的类型，用于访问数据数组。`at()` 是另一个确保单次访问边界检查的替代方案。如果需要迭代器来访问数组，请使用在数组上构建的
    `span` 中的迭代器。
- en: Example, bad
  id: totrans-3793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE489]'
  id: totrans-3794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: Example, good
  id: totrans-3795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: 'Use a `span`:'
  id: totrans-3796
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个`span`：
- en: '[PRE490]'
  id: totrans-3797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: 'Use `at()`:'
  id: totrans-3798
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `at()`：
- en: '[PRE491]'
  id: totrans-3799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: Example, bad
  id: totrans-3800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE492]'
  id: totrans-3801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: Example, good
  id: totrans-3802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: 'Use a `span`:'
  id: totrans-3803
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `span`：
- en: '[PRE493]'
  id: totrans-3804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: 'Use a `span` and range-`for`:'
  id: totrans-3805
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `span` 和范围-`for`：
- en: '[PRE494]'
  id: totrans-3806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: 'Use `at()` for access:'
  id: totrans-3807
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `at()` 进行访问：
- en: '[PRE495]'
  id: totrans-3808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'Use a range-`for`:'
  id: totrans-3809
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围-`for`：
- en: '[PRE496]'
  id: totrans-3810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: Note
  id: totrans-3811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Tooling can offer rewrites of array accesses that involve dynamic index expressions
    to use `at()` instead:'
  id: totrans-3812
  prefs: []
  type: TYPE_NORMAL
  zh: 工具可以提供重写涉及动态索引表达式的数组访问，以使用`at()`代替：
- en: '[PRE497]'
  id: totrans-3813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: Example
  id: totrans-3814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Turning an array into a pointer (as the language does essentially always) removes
    opportunities for checking, so avoid it
  id: totrans-3815
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组转换为指针（语言基本上总是这样做）消除了检查的机会，因此避免这样做
- en: '[PRE498]'
  id: totrans-3816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: 'If you want to pass an array, say so:'
  id: totrans-3817
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要传递一个数组，请明确指出：
- en: '[PRE499]'
  id: totrans-3818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: Enforcement
  id: totrans-3819
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag any arithmetic operation on an expression of pointer type that results
    in a value of pointer type.
  id: totrans-3820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记任何在指针类型表达式上进行的算术操作，其结果为指针类型值。
- en: Flag any indexing expression on an expression or variable of array type (either
    static array or `std::array`) where the indexer is not a compile-time constant
    expression with a value between `0` and the upper bound of the array.
  id: totrans-3821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记任何在数组类型（静态数组或`std::array`）表达式或变量上的索引表达式，其中索引器不是编译时具有值在`0`和数组上界之间的常量表达式。
- en: Flag any expression that would rely on implicit conversion of an array type
    to a pointer type.
  id: totrans-3822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记任何可能依赖于数组类型到指针类型隐式转换的表达式。
- en: This rule is part of the [bounds-safety profile](#ss-bounds).
  id: totrans-3823
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则是[边界安全配置文件](#ss-bounds)的一部分。
- en: 'ES.43: Avoid expressions with undefined order of evaluation'
  id: totrans-3824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.43：避免具有未定义求值顺序的表达式
- en: Reason
  id: totrans-3825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: You have no idea what such code does. Portability. Even if it does something
    sensible for you, it might do something different on another compiler (e.g., the
    next release of your compiler) or with a different optimizer setting.
  id: totrans-3826
  prefs: []
  type: TYPE_NORMAL
  zh: 你根本不知道这样的代码会做什么。可移植性。即使它对你来说做了一些合理的事情，它可能在另一个编译器（例如，你编译器的下一个版本）或不同的优化器设置下做不同的事情。
- en: Note
  id: totrans-3827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'C++17 tightens up the rules for the order of evaluation: left-to-right except
    right-to-left in assignments, and the order of evaluation of function arguments
    is unspecified.'
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
  zh: C++17加强了求值顺序的规则：左到右，除了赋值时右到左，函数参数的求值顺序未指定。
- en: However, remember that your code might be compiled with a pre-C++17 compiler
    (e.g., through cut-and-paste) so don’t be too clever.
  id: totrans-3829
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记住你的代码可能使用预C++17的编译器编译（例如，通过剪切和粘贴）所以不要太过聪明。
- en: Example
  id: totrans-3830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE500]'
  id: totrans-3831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: A good rule of thumb is that you should not read a value twice in an expression
    where you write to it.
  id: totrans-3832
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是，你不应该在写入表达式中两次读取值。
- en: Enforcement
  id: totrans-3833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Can be detected by a good analyzer.
  id: totrans-3834
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过一个好的分析器检测到。
- en: 'ES.44: Don’t depend on order of evaluation of function arguments'
  id: totrans-3835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.44：不要依赖于函数参数的求值顺序
- en: Reason
  id: totrans-3836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Because that order is unspecified.
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个顺序是未指定的。
- en: Note
  id: totrans-3838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: C++17 tightens up the rules for the order of evaluation, but the order of evaluation
    of function arguments is still unspecified.
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: C++17加强了求值顺序的规则，但函数参数的求值顺序仍然未指定。
- en: Example
  id: totrans-3840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE501]'
  id: totrans-3841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: Before C++17, the behavior is undefined, so the behavior could be anything (e.g.,
    `f(2, 2)`). Since C++17, this code does not have undefined behavior, but it is
    still not specified which argument is evaluated first. The call will be `f(1,
    2)` or `f(2, 1)`, but you don’t know which.
  id: totrans-3842
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，行为是未定义的，所以行为可以是任何东西（例如，`f(2, 2)`）。自从C++17以来，这段代码没有未定义的行为，但它仍然没有指定哪个参数首先被求值。调用将是`f(1,
    2)`或`f(2, 1)`，但你不知道哪个。
- en: Example
  id: totrans-3843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Overloaded operators can lead to order of evaluation problems:'
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符重载可能导致求值顺序问题：
- en: '[PRE502]'
  id: totrans-3845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: In C++17, these examples work as expected (left to right) and assignments are
    evaluated right to left (just as =’s binding is right-to-left)
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，这些示例按预期（从左到右）工作，赋值是按右到左求值的（正如=的绑定是右到左）
- en: '[PRE503]'
  id: totrans-3847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: Enforcement
  id: totrans-3848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Can be detected by a good analyzer.
  id: totrans-3849
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过一个好的分析器检测到。
- en: 'ES.45: Avoid “magic constants”; use symbolic constants'
  id: totrans-3850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.45：避免“魔法常数”；使用符号常数
- en: Reason
  id: totrans-3851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Unnamed constants embedded in expressions are easily overlooked and often hard
    to understand:'
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入表达式中的未命名常量很容易被忽视，并且通常很难理解：
- en: Example
  id: totrans-3853
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE504]'
  id: totrans-3854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: 'No, we don’t all know that there are 12 months, numbered 1..12, in a year.
    Better:'
  id: totrans-3855
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们并不是都知道一年中有12个月，编号为1..12。更好的是：
- en: '[PRE505]'
  id: totrans-3856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: 'Better still, don’t expose constants:'
  id: totrans-3857
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地，不要暴露常数：
- en: '[PRE506]'
  id: totrans-3858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: Enforcement
  id: totrans-3859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag literals in code. Give a pass to `0`, `1`, `nullptr`, `\n`, `""`, and others
    on a positive list.
  id: totrans-3860
  prefs: []
  type: TYPE_NORMAL
  zh: 标记代码中的字面量。在正列表上放过`0`、`1`、`nullptr`、`\n`、`""`和其他。
- en: 'ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions'
  id: totrans-3861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.46：避免有损（狭义、截断）算术转换
- en: Reason
  id: totrans-3862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A narrowing conversion destroys information, often unexpectedly so.
  id: totrans-3863
  prefs: []
  type: TYPE_NORMAL
  zh: 狭义转换会破坏信息，通常是不预期的。
- en: Example, bad
  id: totrans-3864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: 'A key example is basic narrowing:'
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键示例是基本的狭义转换：
- en: '[PRE507]'
  id: totrans-3866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: Note
  id: totrans-3867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The guidelines support library offers a `narrow_cast` operation for specifying
    that narrowing is acceptable and a `narrow` (“narrow if”) that throws an exception
    if a narrowing would throw away legal values:'
  id: totrans-3868
  prefs: []
  type: TYPE_NORMAL
  zh: 'The guidelines support library offers a `narrow_cast` operation for specifying
    that narrowing is acceptable and a `narrow` (“narrow if”) that throws an exception
    if a narrowing would throw away legal values:'
- en: '[PRE508]'
  id: totrans-3869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'We also include lossy arithmetic casts, such as from a negative floating point
    type to an unsigned integral type:'
  id: totrans-3870
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括有损算术转换，例如从负浮点类型到无符号整型：
- en: '[PRE509]'
  id: totrans-3871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: Note
  id: totrans-3872
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This rule does not apply to [contextual conversions to bool](https://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions):'
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则不适用于 [上下文转换到 bool](https://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions)：
- en: '[PRE510]'
  id: totrans-3874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: Enforcement
  id: totrans-3875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'A good analyzer can detect all narrowing conversions. However, flagging all
    narrowing conversions will lead to a lot of false positives. Suggestions:'
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的分析器可以检测到所有缩窄转换。然而，标记所有缩窄转换会导致大量误报。建议：
- en: Flag all floating-point to integer conversions. (Maybe only `float`->`char`
    and `double`->`int`. Here be dragons! We need data.)
  id: totrans-3877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有浮点数到整数的转换。（可能只有 `float`->`char` 和 `double`->`int`。这里可能有龙！我们需要数据。）
- en: Flag all `long`->`char`. (I suspect `int`->`char` is very common. Here be dragons!
    We need data.)
  id: totrans-3878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有 `long`->`char`。 (我怀疑 `int`->`char` 非常常见。这里可能有龙！我们需要数据。)
- en: Consider narrowing conversions for function arguments especially suspect.
  id: totrans-3879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尤其要怀疑函数参数的缩窄转换。
- en: 'ES.47: Use `nullptr` rather than `0` or `NULL`'
  id: totrans-3880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.47：使用 `nullptr` 而不是 `0` 或 `NULL`
- en: Reason
  id: totrans-3881
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Readability. Minimize surprises: `nullptr` cannot be confused with an `int`.
    `nullptr` also has a well-specified (very restrictive) type, and thus works in
    more scenarios where type deduction might do the wrong thing on `NULL` or `0`.'
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。最小化意外：`nullptr` 不能与 `int` 混淆。`nullptr` 也有一个明确指定的（非常严格的）类型，因此可以在更多场景中工作，在这些场景中类型推导可能会在
    `NULL` 或 `0` 上出错。
- en: Example
  id: totrans-3883
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE511]'
  id: totrans-3885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: Enforcement
  id: totrans-3886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag uses of `0` and `NULL` for pointers. The transformation might be helped
    by simple program transformation.
  id: totrans-3887
  prefs: []
  type: TYPE_NORMAL
  zh: 标记 `0` 和 `NULL` 作为指针的使用。这种转换可能有助于简单的程序转换。
- en: 'ES.48: Avoid casts'
  id: totrans-3888
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.48：避免转换
- en: Reason
  id: totrans-3889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Casts are a well-known source of errors and make some optimizations unreliable.
  id: totrans-3890
  prefs: []
  type: TYPE_NORMAL
  zh: 转换是已知错误来源，并使某些优化不可靠。
- en: Example, bad
  id: totrans-3891
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE512]'
  id: totrans-3892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: What would you think this fragment prints? The result is at best implementation
    defined. I got
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这个片段会打印什么？结果最多是实现定义的。我得到了
- en: '[PRE513]'
  id: totrans-3894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: Adding
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
  zh: 增加
- en: '[PRE514]'
  id: totrans-3896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: I got
  id: totrans-3897
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了
- en: '[PRE515]'
  id: totrans-3898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: Surprised? It is actually undefined behavior, and so could also have crashed
    the program.
  id: totrans-3899
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶吗？这实际上是未定义的行为，因此也可能导致程序崩溃。
- en: Note
  id: totrans-3900
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Programmers who write casts typically assume that they know what they are doing,
    or that writing a cast makes the program “easier to read”. In fact, they often
    disable the general rules for using values. Overload resolution and template instantiation
    usually pick the right function if there is a right function to pick. If there
    is not, maybe there ought to be, rather than applying a local fix (cast).
  id: totrans-3901
  prefs: []
  type: TYPE_NORMAL
  zh: 编写转换的程序员通常假设他们知道自己在做什么，或者认为编写转换可以使程序“更容易阅读”。实际上，他们经常禁用使用值的通用规则。重载解析和模板实例化通常会在有正确函数可供选择时选择正确的函数。如果没有，也许应该有，而不是应用局部修复（转换）。
- en: Notes
  id: totrans-3902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Casts are necessary in a systems programming language. For example, how else
    would we get the address of a device register into a pointer? However, casts are
    seriously overused as well as a major source of errors.
  id: totrans-3903
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程语言中，转换是必要的。例如，我们如何才能将设备寄存器的地址转换成指针？然而，转换被过度使用，也是错误的主要来源。
- en: If you feel the need for a lot of casts, there might be a fundamental design
    problem.
  id: totrans-3904
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得需要很多转换，可能存在根本的设计问题。
- en: The [type profile](#pro-type-reinterpretcast) bans `reinterpret_cast` and C-style
    casts.
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
  zh: '[类型配置文件](#pro-type-reinterpretcast) 禁止 `reinterpret_cast` 和 C 风格的转换。'
- en: Never cast to `(void)` to ignore a `[[nodiscard]]`return value. If you deliberately
    want to discard such a result, first think hard about whether that is really a
    good idea (there is usually a good reason the author of the function or of the
    return type used `[[nodiscard]]` in the first place). If you still think it’s
    appropriate and your code reviewer agrees, use `std::ignore =` to turn off the
    warning which is simple, portable, and easy to grep.
  id: totrans-3906
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将 `(void)` 转换以忽略 `[[nodiscard]]` 返回值。如果你故意想要丢弃这样的结果，首先仔细考虑这是否真的是一个好主意（通常有很好的理由，函数的作者或返回类型最初使用
    `[[nodiscard]]`）。如果你仍然认为这是合适的，并且你的代码审查员同意，请使用 `std::ignore =` 来关闭警告，这很简单、可移植且易于
    grep。
- en: Alternatives
  id: totrans-3907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Casts are widely (mis)used. Modern C++ has rules and constructs that eliminate
    the need for casts in many contexts, such as
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
  zh: 转换操作被广泛（错误地）使用。现代 C++ 有规则和结构，可以在许多情况下消除对转换的需求，例如
- en: Use templates
  id: totrans-3909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板
- en: Use `std::variant`
  id: totrans-3910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::variant`
- en: Rely on the well-defined, safe, implicit conversions between pointer types
  id: totrans-3911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于指针类型之间定义良好、安全的隐式转换
- en: Use `std::ignore =` to ignore `[[nodiscard]]` values.
  id: totrans-3912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::ignore =` 来忽略 `[[nodiscard]]` 值。
- en: Enforcement
  id: totrans-3913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag all C-style casts, including to `void`.
  id: totrans-3914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有 C 风格的转换，包括到 `void`。
- en: Flag functional style casts using `Type(value)`. Use `Type{value}` instead which
    is not narrowing. (See [ES.64](#res-construct).)
  id: totrans-3915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Type(value)` 标记函数式风格的转换。请使用 `Type{value}` 代替，它不会缩小类型。 （参见 [ES.64](#res-construct)。）
- en: Flag [identity casts](#pro-type-identitycast) between pointer types, where the
    source and target types are the same (#pro-type-identitycast).
  id: totrans-3916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记指针类型之间的 [恒等转换](#pro-type-identitycast)，其中源类型和目标类型相同 (#pro-type-identitycast)。
- en: Flag an explicit pointer cast that could be [implicit](#pro-type-implicitpointercast).
  id: totrans-3917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个可能是隐式转换的显式指针转换 ([隐式转换](#pro-type-implicitpointercast))。
- en: 'ES.49: If you must use a cast, use a named cast'
  id: totrans-3918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.49: 如果必须使用转换，请使用命名转换'
- en: Reason
  id: totrans-3919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Error avoidance. Named casts are more specific than a C-style or
    functional cast, allowing the compiler to catch some errors.
  id: totrans-3920
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。错误避免。命名转换比 C 风格或函数式转换更具体，允许编译器捕获一些错误。
- en: 'The named casts are:'
  id: totrans-3921
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的转换类型包括：
- en: '`static_cast`'
  id: totrans-3922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static_cast`'
- en: '`const_cast`'
  id: totrans-3923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const_cast`'
- en: '`reinterpret_cast`'
  id: totrans-3924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast`'
- en: '`dynamic_cast`'
  id: totrans-3925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic_cast`'
- en: '`std::move` // `move(x)` is an rvalue reference to `x`'
  id: totrans-3926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::move` // `move(x)` 是 `x` 的右值引用'
- en: '`std::forward` // `forward<T>(x)` is an rvalue or an lvalue reference to `x`
    depending on `T`'
  id: totrans-3927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward` // `forward<T>(x)` 根据 `T` 是右值引用或左值引用'
- en: '`gsl::narrow_cast` // `narrow_cast<T>(x)` is `static_cast<T>(x)`'
  id: totrans-3928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gsl::narrow_cast` // `narrow_cast<T>(x)` 是 `static_cast<T>(x)`'
- en: '`gsl::narrow` // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x)
    == x` or it throws `narrowing_error`'
  id: totrans-3929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gsl::narrow` // `narrow<T>(x)` 是 `static_cast<T>(x)` 如果 `static_cast<T>(x)
    == x` 或它抛出 `narrowing_error`'
- en: Example
  id: totrans-3930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE516]'
  id: totrans-3931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: The example was synthesized from real-world bugs where `D` used to be derived
    from `B`, but someone refactored the hierarchy. The C-style cast is dangerous
    because it can do any kind of conversion, depriving us of any protection from
    mistakes (now or in the future).
  id: totrans-3932
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例是从现实世界中的错误中合成的，其中 `D` 以前是从 `B` 派生的，但有人重构了层次结构。C 风格的转换是危险的，因为它可以进行任何类型的转换，剥夺了我们从错误（现在或未来）中获取保护的机会。
- en: Note
  id: totrans-3933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When converting between types with no information loss (e.g. from `float` to
    `double` or from `int32` to `int64`), brace initialization might be used instead.
  id: totrans-3934
  prefs: []
  type: TYPE_NORMAL
  zh: 当在不会丢失信息（例如从 `float` 转换到 `double` 或从 `int32` 转换到 `int64`）的类型之间转换时，可以使用花括号初始化。
- en: '[PRE517]'
  id: totrans-3935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: This makes it clear that the type conversion was intended and also prevents
    conversions between types that might result in loss of precision. (It is a compilation
    error to try to initialize a `float` from a `double` in this fashion, for example.)
  id: totrans-3936
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得类型转换的意图变得明确，并防止了可能导致精度损失的类型之间的转换。 （例如，以这种方式尝试从 `double` 初始化 `float` 是编译错误。）
- en: Note
  id: totrans-3937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`reinterpret_cast` can be essential, but the essential uses (e.g., turning
    a machine address into pointer) are not type safe:'
  id: totrans-3938
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret_cast` 可能是必需的，但必需的使用（例如，将机器地址转换为指针）不是类型安全的：'
- en: '[PRE518]'
  id: totrans-3939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: Enforcement
  id: totrans-3940
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag all C-style casts, including to `void`.
  id: totrans-3941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记所有 C 风格的转换，包括到 `void`。
- en: Flag functional style casts using `Type(value)`. Use `Type{value}` instead which
    is not narrowing. (See [ES.64](#res-construct).)
  id: totrans-3942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Type(value)` 标记函数式风格的转换。请使用 `Type{value}` 代替，它不会缩小类型。 （参见 [ES.64](#res-construct)。）
- en: The [type profile](#pro-type-reinterpretcast) bans `reinterpret_cast`.
  id: totrans-3943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类型配置文件](#pro-type-reinterpretcast) 禁止使用 `reinterpret_cast`。'
- en: The [type profile](#pro-type-arithmeticcast) warns when using `static_cast`
    between arithmetic types.
  id: totrans-3944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在算术类型之间使用 `static_cast` 时，[类型配置文件](#pro-type-arithmeticcast) 会发出警告。
- en: 'ES.50: Don’t cast away `const`'
  id: totrans-3945
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.50: 不要取消 `const`'
- en: Reason
  id: totrans-3946
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It makes a lie out of `const`. If the variable is actually declared `const`,
    modifying it results in undefined behavior.
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: 它使 `const` 变得虚假。如果变量实际上被声明为 `const`，则修改它会导致未定义的行为。
- en: Example, bad
  id: totrans-3948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE519]'
  id: totrans-3949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: Example
  id: totrans-3950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Sometimes, you might be tempted to resort to `const_cast` to avoid code duplication,
    such as when two accessor functions that differ only in `const`-ness have similar
    implementations. For example:'
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会倾向于使用 `const_cast` 来避免代码重复，例如当两个访问器函数仅在 `const`-ness 上有所不同且实现相似时。例如：
- en: '[PRE520]'
  id: totrans-3952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: 'Instead, prefer to share implementations. Normally, you can just have the non-`const`
    function call the `const` function. However, when there is complex logic this
    can lead to the following pattern that still resorts to a `const_cast`:'
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最好共享实现。通常，非 `const` 函数可以直接调用 `const` 函数。然而，当存在复杂逻辑时，这可能导致以下模式，仍然需要使用 `const_cast`：
- en: '[PRE521]'
  id: totrans-3954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: Although this pattern is safe when applied correctly, because the caller must
    have had a non-`const` object to begin with, it’s not ideal because the safety
    is hard to enforce automatically as a checker rule.
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当正确应用时这个模式是安全的，因为调用者最初必须有一个非 `const` 对象，但它并不理想，因为安全性很难作为检查规则自动强制执行。
- en: 'Instead, prefer to put the common code in a common helper function – and make
    it a template so that it deduces `const`. This doesn’t use any `const_cast` at
    all:'
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，最好将常用代码放在一个公共辅助函数中——并将其做成模板，以便推断 `const`。这根本不使用任何 `const_cast`：
- en: '[PRE522]'
  id: totrans-3957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: 'Note: Don’t do large non-dependent work inside a template, which leads to code
    bloat. For example, a further improvement would be if all or part of `get_bar_impl`
    can be non-dependent and factored out into a common non-template function, for
    a potentially big reduction in code size.'
  id: totrans-3958
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：不要在模板内部进行大量非相关工作，这会导致代码膨胀。例如，如果 `get_bar_impl` 的所有或部分可以是非相关的，并且可以分解为公共的非模板函数，这将可能大大减少代码大小。
- en: Exception
  id: totrans-3959
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: You might need to cast away `const` when calling `const`-incorrect functions.
    Prefer to wrap such functions in inline `const`-correct wrappers to encapsulate
    the cast in one place.
  id: totrans-3960
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用不正确的 `const` 函数时，可能需要移除 `const`。最好将这些函数包装在内联 `const`-正确包装器中，以将转换封装在一个地方。
- en: Example
  id: totrans-3961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Sometimes, “cast away `const`” is to allow the updating of some transient information
    of an otherwise immutable object. Examples are caching, memoization, and precomputation.
    Such examples are often handled as well or better using `mutable` or an indirection
    than with a `const_cast`.
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，“移除 `const`” 是为了允许更新一个不可变对象的某些瞬态信息。例如是缓存、记忆化和预计算。这样的例子通常使用 `mutable` 或间接引用处理得更好或更有效，而不是使用
    `const_cast`。
- en: 'Consider keeping previously computed results around for a costly operation:'
  id: totrans-3963
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑保留之前计算的结果以供昂贵操作使用：
- en: '[PRE523]'
  id: totrans-3964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: 'Here, `get_val()` is logically constant, so we would like to make it a `const`
    member. To do this we still need to mutate `cache`, so people sometimes resort
    to a `const_cast`:'
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`get_val()` 在逻辑上是常量，所以我们希望将其作为 `const` 成员。为此，我们仍然需要修改 `cache`，因此人们有时会求助于
    `const_cast`：
- en: '[PRE524]'
  id: totrans-3966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: 'Fortunately, there is a better solution: State that `cache` is mutable even
    for a `const` object:'
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个更好的解决方案：声明 `cache` 即使对于 `const` 对象也是可变的：
- en: '[PRE525]'
  id: totrans-3968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: 'An alternative solution would be to store a pointer to the `cache`:'
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是存储 `cache` 的指针：
- en: '[PRE526]'
  id: totrans-3970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: That solution is the most flexible, but requires explicit construction and destruction
    of `*cache` (most likely in the constructor and destructor of `X`).
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
  zh: 那个解决方案是最灵活的，但需要显式地构建和销毁 `*缓存`（最可能在 `X` 的构造函数和析构函数中）。
- en: In any variant, we must guard against data races on the `cache` in multi-threaded
    code, possibly using a `std::mutex`.
  id: totrans-3972
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们必须在多线程代码中保护 `cache` 的数据竞争，可能使用 `std::mutex`。
- en: Enforcement
  id: totrans-3973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `const_cast`s.
  id: totrans-3974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 `const_cast`s。
- en: This rule is part of the [type-safety profile](#pro-type-constcast) for the
    related Profile.
  id: totrans-3975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该规则是相关配置文件 `[type-safety profile](#pro-type-constcast)` 的一部分。
- en: 'ES.55: Avoid the need for range checking'
  id: totrans-3976
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.55：避免需要范围检查
- en: Reason
  id: totrans-3977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Constructs that cannot overflow do not overflow (and usually run faster):'
  id: totrans-3978
  prefs: []
  type: TYPE_NORMAL
  zh: 不能溢出的构造不会溢出（并且通常运行更快）：
- en: Example
  id: totrans-3979
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE527]'
  id: totrans-3980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: Enforcement
  id: totrans-3981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look for explicit range checks and heuristically suggest alternatives.
  id: totrans-3982
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找显式的范围检查，并启发式地提出替代方案。
- en: 'ES.56: Write `std::move()` only when you need to explicitly move an object
    to another scope'
  id: totrans-3983
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.56：仅在需要显式将对象移动到另一个作用域时使用 `std::move()`
- en: Reason
  id: totrans-3984
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: We move, rather than copy, to avoid duplication and for improved performance.
  id: totrans-3985
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移动而不是复制，以避免重复并提高性能。
- en: A move typically leaves behind an empty object ([C.64](#rc-move-semantic)),
    which can be surprising or even dangerous, so we try to avoid moving from lvalues
    (they might be accessed later).
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
  zh: 移动通常会在后面留下一个空对象 ([C.64](#rc-move-semantic))，这可能会令人惊讶，甚至危险，所以我们尽量避免从左值（它们可能稍后会被访问）移动。
- en: Notes
  id: totrans-3987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Moving is done implicitly when the source is an rvalue (e.g., value in a `return`
    treatment or a function result), so don’t pointlessly complicate code in those
    cases by writing `move` explicitly. Instead, write short functions that return
    values, and both the function’s return and the caller’s accepting of the return
    will be optimized naturally.
  id: totrans-3988
  prefs: []
  type: TYPE_NORMAL
  zh: 当源是右值时（例如，`return`处理中的值或函数结果），移动是隐式进行的，所以不要在这些情况下无谓地通过显式编写`move`来使代码复杂化。相反，编写返回值的短函数，函数的返回和调用者的接受都会自然地得到优化。
- en: In general, following the guidelines in this document (including not making
    variables’ scopes needlessly large, writing short functions that return values,
    returning local variables) help eliminate most need for explicit `std::move`.
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，遵循本文件中的指南（包括不使变量的作用域无谓地增大，编写返回值的短函数，返回局部变量）有助于消除对显式`std::move`的大多数需求。
- en: Explicit `move` is needed to explicitly move an object to another scope, notably
    to pass it to a “sink” function and in the implementations of the move operations
    themselves (move constructor, move assignment operator) and swap operations.
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
  zh: 显式移动需要将对象显式地移动到另一个作用域，特别是传递给“汇入”函数以及在移动操作本身的实现（移动构造函数、移动赋值运算符）和交换操作中。
- en: Example, bad
  id: totrans-3991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE528]'
  id: totrans-3992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: Usually, a `std::move()` is used as an argument to an `&&` parameter. And after
    you do that, assume the object has been moved from (see [C.64](#rc-move-semantic))
    and don’t read its state again until you first set it to a new value.
  id: totrans-3993
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`std::move()`用作`&&`参数的参数。在你这样做之后，假设对象已经被移动（参见[C.64](#rc-move-semantic)）并且在你首先将其设置为新的值之前不要再次读取其状态。
- en: '[PRE529]'
  id: totrans-3994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: Example
  id: totrans-3995
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE530]'
  id: totrans-3996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: Notes
  id: totrans-3997
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: '`std::move()` is a cast to `&&` in disguise; it doesn’t itself move anything,
    but marks a named object as a candidate that can be moved from. The language already
    knows the common cases where objects can be moved from, especially when returning
    values from functions, so don’t complicate code with redundant `std::move()`s.'
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::move()`是一种伪装成`&&`的转换；它本身不移动任何东西，但标记一个命名对象为可以移动的对象。语言已经知道可以移动的对象的常见情况，尤其是在从函数返回值时，所以不要通过冗余的`std::move()`使代码复杂化。'
- en: Never write `std::move()` just because you’ve heard “it’s more efficient.” In
    general, don’t believe claims of “efficiency” without data (???). In general,
    don’t complicate your code without reason (??). Never write `std::move()` on a
    const object, it is silently transformed into a copy (see Item 23 in [Meyers15](#Meyers15))
  id: totrans-3999
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要仅仅因为听说“它更有效”就写`std::move()`。一般来说，在没有数据（？？？）的情况下不要相信“效率”的声明。一般来说，不要无理由地使代码复杂化（？？）。永远不要在const对象上写`std::move()`，它会被静默转换为副本（参见[Meyers15](#Meyers15)中的第23项）。
- en: Example, bad
  id: totrans-4000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE531]'
  id: totrans-4001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: Never write `return move(local_variable);`, because the language already knows
    the variable is a move candidate. Writing `move` in this code won’t help, and
    can actually be detrimental because on some compilers it interferes with RVO (the
    return value optimization) by creating an additional reference alias to the local
    variable.
  id: totrans-4002
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要写`return move(local_variable);`，因为语言已经知道该变量是一个移动候选者。在这段代码中写入`move`不会有所帮助，实际上可能是有害的，因为在一些编译器上它可能会干扰RVO（返回值优化）通过创建对局部变量的额外引用别名。
- en: Example, bad
  id: totrans-4003
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE532]'
  id: totrans-4004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: Never write `move` on a returned value such as `x = move(f());` where `f` returns
    by value. The language already knows that a returned value is a temporary object
    that can be moved from.
  id: totrans-4005
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在返回值上写`move`，例如`x = move(f());`，其中`f`按值返回。语言已经知道返回值是一个可以移动的临时对象。
- en: Example
  id: totrans-4006
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE533]'
  id: totrans-4007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: Enforcement
  id: totrans-4008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag use of `std::move(x)` where `x` is an rvalue or the language will already
    treat it as an rvalue, including `return std::move(local_variable);` and `std::move(f())`
    on a function that returns by value.
  id: totrans-4009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记使用`std::move(x)`的情况，其中`x`是右值或语言已经将其视为右值，包括在按值返回的函数上`return std::move(local_variable);`和`std::move(f())`。
- en: Flag functions taking an `S&&` parameter if there is no `const S&` overload
    to take care of lvalues.
  id: totrans-4010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有`const S&`重载来处理左值，则标记接受`S&&`参数的函数。
- en: Flag a `std::move`d argument passed to a parameter, except when the parameter
    type is an `X&&` rvalue reference or the type is move-only and the parameter is
    passed by value.
  id: totrans-4011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记传递给参数的`std::move`化参数，除非参数类型是`X&&`右值引用或类型是仅移动类型且参数按值传递。
- en: Flag when `std::move` is applied to a forwarding reference (`T&&` where `T`
    is a template parameter type). Use `std::forward` instead.
  id: totrans-4012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`std::move`应用于前向引用（`T&&`，其中`T`是模板参数类型）时，标记。请使用`std::forward`代替。
- en: Flag when `std::move` is applied to other than an rvalue reference to non-const.
    (More general case of the previous rule to cover the non-forwarding cases.)
  id: totrans-4013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`std::move`应用于非const的右值引用时标记。这是上一条规则的更一般情况，以涵盖非转发的情况。
- en: Flag when `std::forward` is applied to an rvalue reference (`X&&` where `X`
    is a non-template parameter type). Use `std::move` instead.
  id: totrans-4014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`std::forward`应用于右值引用（`X&&`，其中`X`是非模板参数类型）时标记。使用`std::move`代替。
- en: Flag when `std::forward` is applied to other than a forwarding reference. (More
    general case of the previous rule to cover the non-moving cases.)
  id: totrans-4015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`std::forward`应用于非转发引用时标记。这是上一条规则的更一般情况，以涵盖非移动的情况。
- en: Flag when an object is potentially moved from and the next operation is a `const`
    operation; there should first be an intervening non-`const` operation, ideally
    assignment, to first reset the object’s value.
  id: totrans-4016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象可能被移动，并且下一个操作是`const`操作；应该首先有一个非`const`操作作为中间操作，理想情况下是赋值，以首先重置对象的价值。
- en: 'ES.60: Avoid `new` and `delete` outside resource management functions'
  id: totrans-4017
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.60：避免在资源管理函数外部使用`new`和`delete`
- en: Reason
  id: totrans-4018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Direct resource management in application code is error-prone and tedious.
  id: totrans-4019
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序代码中直接管理资源容易出错且繁琐。
- en: Note
  id: totrans-4020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: This is also known as the rule of “No naked `new`!”
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为“无裸露`new`！”规则。
- en: Example, bad
  id: totrans-4022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE534]'
  id: totrans-4023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: There can be code in the `...` part that causes the `delete` never to happen.
  id: totrans-4024
  prefs: []
  type: TYPE_NORMAL
  zh: 在`...`部分可能有代码导致`delete`永远不会发生。
- en: '**See also**: [R: Resource management](#s-resource)'
  id: totrans-4025
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[R：资源管理](#s-resource)'
- en: Enforcement
  id: totrans-4026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag naked `new`s and naked `delete`s.
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
  zh: 标记裸露的`new`和裸露的`delete`。
- en: 'ES.61: Delete arrays using `delete[]` and non-arrays using `delete`'
  id: totrans-4028
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.61：使用`delete[]`删除数组，使用`delete`删除非数组
- en: Reason
  id: totrans-4029
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That’s what the language requires, and mismatches can lead to resource release
    errors and/or memory corruption.
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是语言所要求的，不匹配可能导致资源释放错误和/或内存损坏。
- en: Example, bad
  id: totrans-4031
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE535]'
  id: totrans-4032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: Note
  id: totrans-4033
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: This example not only violates the [no naked `new` rule](#res-new) as in the
    previous example, it has many more problems.
  id: totrans-4034
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子不仅违反了[无裸露`new`规则](#res-new)，就像上一个例子一样，还有更多的问题。
- en: Enforcement
  id: totrans-4035
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag mismatched `new` and `delete` if they are in the same scope.
  id: totrans-4036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`new`和`delete`在同一个作用域中，则标记不匹配。
- en: Flag mismatched `new` and `delete` if they are in a constructor/destructor pair.
  id: totrans-4037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`new`和`delete`在构造函数/析构函数对中不匹配，则标记。
- en: 'ES.62: Don’t compare pointers into different arrays'
  id: totrans-4038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.62：不要比较来自不同数组的指针
- en: Reason
  id: totrans-4039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The result of doing so is undefined.
  id: totrans-4040
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的结果是未定义的。
- en: Example, bad
  id: totrans-4041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE536]'
  id: totrans-4042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: Note
  id: totrans-4043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: This example has many more problems.
  id: totrans-4044
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有更多的问题。
- en: Enforcement
  id: totrans-4045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: ???
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.63: Don’t slice'
  id: totrans-4047
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.63：不要切片
- en: Reason
  id: totrans-4048
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Slicing – that is, copying only part of an object using assignment or initialization
    – most often leads to errors because the object was meant to be considered as
    a whole. In the rare cases where the slicing was deliberate the code can be surprising.
  id: totrans-4049
  prefs: []
  type: TYPE_NORMAL
  zh: 切片，即使用赋值或初始化仅复制对象的一部分，通常会导致错误，因为对象原本应该被视为一个整体。在切片是故意的罕见情况下，代码可能会令人惊讶。
- en: Example
  id: totrans-4050
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE537]'
  id: totrans-4051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: The result will be meaningless because the center and radius will not be copied
    from `c` into `s`. The first defense against this is to [define the base class
    `Shape` not to allow this](#rc-copy-virtual).
  id: totrans-4052
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将没有意义，因为中心和半径将不会从`c`复制到`s`。对此的第一个防御措施是[定义基类`Shape`不允许这样做](#rc-copy-virtual)。
- en: Alternative
  id: totrans-4053
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'If you mean to slice, define an explicit operation to do so. This saves readers
    from confusion. For example:'
  id: totrans-4054
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算切片，定义一个显式的操作来执行切片。这可以避免读者产生困惑。例如：
- en: '[PRE538]'
  id: totrans-4055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: Enforcement
  id: totrans-4056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Warn against slicing.
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
  zh: 警告切片。
- en: 'ES.64: Use the `T{e}`notation for construction'
  id: totrans-4058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.64：使用`T{e}`表示法进行构造
- en: Reason
  id: totrans-4059
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The `T{e}` construction syntax makes it explicit that construction is desired.
    The `T{e}` construction syntax doesn’t allow narrowing. `T{e}` is the only safe
    and general expression for constructing a value of type `T` from an expression
    `e`. The casts notations `T(e)` and `(T)e` are neither safe nor general.
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
  zh: '`T{e}`构造语法明确表示希望构造。`T{e}`构造语法不允许缩窄。`T{e}`是从表达式`e`构造类型`T`值的唯一安全且通用的表达式。`T(e)`和`(T)e`的转换表示法既不安全也不通用。'
- en: Example
  id: totrans-4061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: For built-in types, the construction notation protects against narrowing and
    reinterpretation
  id: totrans-4062
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内置类型，构造表示法可以防止缩窄和重新解释。
- en: '[PRE539]'
  id: totrans-4063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: The integer to/from pointer conversions are implementation defined when using
    the `T(e)` or `(T)e` notations, and non-portable between platforms with different
    integer and pointer sizes.
  id: totrans-4064
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`T(e)`或`(T)e`表示法时，整数到指针的转换是实现定义的，并且在不同整数和指针大小平台之间不可移植。
- en: Note
  id: totrans-4065
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Avoid casts](#res-casts) (explicit type conversion) and if you must [prefer
    named casts](#res-casts-named).'
  id: totrans-4066
  prefs: []
  type: TYPE_NORMAL
  zh: '[避免类型转换](#res-casts)（显式类型转换），如果必须，则[优先使用命名转换](#res-casts-named)。'
- en: Note
  id: totrans-4067
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When unambiguous, the `T` can be left out of `T{e}`.
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有歧义时，`T`可以省略在`T{e}`中。
- en: '[PRE540]'
  id: totrans-4069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: Note
  id: totrans-4070
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The construction notation is the most general [initializer notation](#res-list).
  id: totrans-4071
  prefs: []
  type: TYPE_NORMAL
  zh: 构造表示法是最通用的[初始化表示法](#res-list)。
- en: Exception
  id: totrans-4072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: '`std::vector` and other containers were defined before we had `{}` as a notation
    for construction. Consider:'
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`和其他容器在我们有`{}`作为构造表示法之前就已经定义了。考虑以下示例：'
- en: '[PRE541]'
  id: totrans-4074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: How do we get a `vector` of 10 default initialized `int`s?
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到一个包含10个默认初始化`int`的`vector`？
- en: '[PRE542]'
  id: totrans-4076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: 'The use of `()` rather than `{}` for number of elements is conventional (going
    back to the early 1980s), hard to change, but still a design error: for a container
    where the element type can be confused with the number of elements, we have an
    ambiguity that must be resolved. The conventional resolution is to interpret `{10}`
    as a list of one element and use `(10)` to distinguish a size.'
  id: totrans-4077
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号`()`而不是花括号`{}`来表示元素数量是一种传统做法（追溯到20世纪80年代初），虽然难以改变，但仍然是一个设计错误：对于一个容器，其中元素类型可能会与元素数量混淆，我们存在一个必须解决的歧义。传统的解决方法是解释`{10}`为一个包含一个元素的列表，并使用`(10)`来区分大小。
- en: 'This mistake need not be repeated in new code. We can define a type to represent
    the number of elements:'
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误在新代码中不必重复。我们可以定义一个类型来表示元素数量：
- en: '[PRE543]'
  id: totrans-4079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: The main problem left is to find a suitable name for `Count`.
  id: totrans-4080
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的主要问题是为`Count`找到一个合适的名称。
- en: Enforcement
  id: totrans-4081
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag the C-style `(T)e` and functional-style `T(e)` casts.
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
  zh: 标记C风格的`(T)e`和函数风格的`T(e)`类型转换。
- en: 'ES.65: Don’t dereference an invalid pointer'
  id: totrans-4083
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.65：不要解引用无效指针
- en: Reason
  id: totrans-4084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Dereferencing an invalid pointer, such as `nullptr`, is undefined behavior,
    typically leading to immediate crashes, wrong results, or memory corruption.
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用无效指针，如`nullptr`，是未定义行为，通常会导致立即崩溃、错误结果或内存损坏。
- en: Note
  id: totrans-4086
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By pointer here we mean any indirection to an object, including equivalently
    an iterator or view.
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们所说的指针是指对任何对象的任何间接引用，包括等价的迭代器或视图。
- en: Note
  id: totrans-4088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This rule is an obvious and well-known language rule, but can be hard to follow.
    It takes good coding style, library support, and static analysis to eliminate
    violations without major overhead. This is a major part of the discussion of [C++’s
    model for type- and resource-safety](#Stroustrup15).
  id: totrans-4089
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条明显且众所周知的语言规则，但可能难以遵循。这需要良好的编码风格、库支持和静态分析，才能在不产生重大开销的情况下消除违规。这是[C++类型和资源安全模型](#Stroustrup15)讨论的一个重要部分。
- en: '**See also**:'
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：'
- en: Use [RAII](#rr-raii) to avoid lifetime problems.
  id: totrans-4091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[RAII](#rr-raii)来避免生命周期问题。
- en: Use [unique_ptr](#rf-unique_ptr) to avoid lifetime problems.
  id: totrans-4092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[unique_ptr](#rf-unique_ptr)来避免生命周期问题。
- en: Use [shared_ptr](#rf-shared_ptr) to avoid lifetime problems.
  id: totrans-4093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[shared_ptr](#rf-shared_ptr)来避免生命周期问题。
- en: Use [references](#rf-ptr-ref) when `nullptr` isn’t a possibility.
  id: totrans-4094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`nullptr`不是可能的情况时，使用[引用](#rf-ptr-ref)。
- en: Use [not_null](#rf-nullptr) to catch unexpected `nullptr` early.
  id: totrans-4095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[not_null](#rf-nullptr)来尽早捕获意外的`nullptr`。
- en: Use the [bounds profile](#ss-bounds) to avoid range errors.
  id: totrans-4096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[边界配置文件](#ss-bounds)以避免范围错误。
- en: Example
  id: totrans-4097
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE544]'
  id: totrans-4098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: To resolve the problem, either extend the lifetime of the object the pointer
    is intended to refer to, or shorten the lifetime of the pointer (move the dereference
    to before the pointed-to object’s lifetime ends).
  id: totrans-4099
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，要么延长指针所指向的对象的生命周期，要么缩短指针的生命周期（将解引用移到指向的对象的生命周期结束之前）。
- en: '[PRE545]'
  id: totrans-4100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: Unfortunately, most invalid pointer problems are harder to spot and harder to
    fix.
  id: totrans-4101
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数无效指针问题更难发现和修复。
- en: Example
  id: totrans-4102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE546]'
  id: totrans-4103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: 'There is a huge amount of such code. Most works – after lots of testing – but
    in isolation it is impossible to tell whether `p` could be the `nullptr`. Consequently,
    this is also a major source of errors. There are many approaches to dealing with
    this potential problem:'
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码有很多。大多数工作在经过大量测试后是可行的，但单独来看，很难判断`p`是否可能是`nullptr`。因此，这也是错误的一个主要来源。处理这个潜在问题的方法有很多：
- en: '[PRE547]'
  id: totrans-4105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: 'There are two potential problems with testing for `nullptr`:'
  id: totrans-4106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`nullptr`可能存在两个潜在问题：
- en: it is not always obvious what to do if we find `nullptr`
  id: totrans-4107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们找到`nullptr`，并不总是明显知道该做什么
- en: the test can be redundant and/or relatively expensive
  id: totrans-4108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试可能是多余的，或者相对昂贵
- en: it is not obvious if the test is to protect against a violation or part of the
    required logic.
  id: totrans-4109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是否是为了防止违规或作为所需逻辑的一部分并不明显。
- en: '[PRE548]'
  id: totrans-4110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: 'This would carry a cost only when the assertion checking was enabled and would
    give a compiler/analyzer useful information. This would work even better if/when
    C++ gets direct support for contracts:'
  id: totrans-4111
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会当断言检查被启用时才产生成本，并且会给编译器/分析器提供有用的信息。如果C++得到对合同的直接支持，这将工作得更好：
- en: '[PRE549]'
  id: totrans-4112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: Alternatively, we could use `gsl::not_null` to ensure that `p` is not the `nullptr`.
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`gsl::not_null`来确保`p`不是`nullptr`。
- en: '[PRE550]'
  id: totrans-4114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: These remedies take care of `nullptr` only. Remember that there are other ways
    of getting an invalid pointer.
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些补救措施只关注`nullptr`。记住还有其他方式可以得到无效的指针。
- en: Example
  id: totrans-4116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE551]'
  id: totrans-4117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: Example
  id: totrans-4118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE552]'
  id: totrans-4119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: Enforcement
  id: totrans-4120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: This rule is part of the [lifetime safety profile](#ss-lifetime)
  id: totrans-4121
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则是[生命周期安全配置文件](#ss-lifetime)的一部分
- en: Flag a dereference of a pointer that points to an object that has gone out of
    scope
  id: totrans-4122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记指向已超出作用域的对象的指针解引用
- en: Flag a dereference of a pointer that might have been invalidated by assigning
    a `nullptr`
  id: totrans-4123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个指针解引用，该指针可能因赋值为`nullptr`而失效
- en: Flag a dereference of a pointer that might have been invalidated by a `delete`
  id: totrans-4124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个指针解引用，该指针可能因`delete`操作而失效
- en: Flag a dereference to a pointer to a container element that might have been
    invalidated by dereference
  id: totrans-4125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记指向容器元素的指针解引用，该指针可能因解引用而失效
- en: 'ES.stmt: Statements'
  id: totrans-4126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES.stmt：语句
- en: Statements control the flow of control (except for function calls and exception
    throws, which are expressions).
  id: totrans-4127
  prefs: []
  type: TYPE_NORMAL
  zh: 语句控制控制流（除了函数调用和异常抛出，它们是表达式）。
- en: 'ES.70: Prefer a `switch`-statement to an `if`-statement when there is a choice'
  id: totrans-4128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.70：当有选择时，优先使用`switch`语句而不是`if`语句
- en: Reason
  id: totrans-4129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability.
  id: totrans-4130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性。
- en: 'Efficiency: A `switch` compares against constants and is usually better optimized
    than a series of tests in an `if`-`then`-`else` chain.'
  id: totrans-4131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率：`switch`比较的是常量，通常比一系列的`if`-`then`-`else`链测试优化得更好。
- en: A `switch` enables some heuristic consistency checking. For example, have all
    values of an `enum` been covered? If not, is there a `default`?
  id: totrans-4132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`允许进行一些启发式一致性检查。例如，`enum`的所有值都被覆盖了吗？如果没有，是否有`default`？'
- en: Example
  id: totrans-4133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE553]'
  id: totrans-4134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: 'rather than:'
  id: totrans-4135
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE554]'
  id: totrans-4136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: Enforcement
  id: totrans-4137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `if`-`then`-`else` chains that check against constants (only).
  id: totrans-4138
  prefs: []
  type: TYPE_NORMAL
  zh: 标记检查常量的`if`-`then`-`else`链
- en: 'ES.71: Prefer a range-`for`-statement to a `for`-statement when there is a
    choice'
  id: totrans-4139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.71：当有选择时，优先使用范围`for`循环语句而不是`for`循环语句
- en: Reason
  id: totrans-4140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Error prevention. Efficiency.
  id: totrans-4141
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。错误预防。效率。
- en: Example
  id: totrans-4142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE555]'
  id: totrans-4143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: A human or a good static analyzer might determine that there really isn’t a
    side effect on `v` in `f(v, &v[i])` so that the loop can be rewritten.
  id: totrans-4144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人类或一个好的静态分析器可能会确定在`f(v, &v[i])`中对`v`没有副作用，因此可以重写循环。
- en: “Messing with the loop variable” in the body of a loop is typically best avoided.
  id: totrans-4145
  prefs: []
  type: TYPE_NORMAL
  zh: “在循环体中操作循环变量”通常最好避免。
- en: Note
  id: totrans-4146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: 'Don’t use expensive copies of the loop variable of a range-`for` loop:'
  id: totrans-4147
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用范围`for`循环中循环变量的昂贵复制：
- en: '[PRE556]'
  id: totrans-4148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: 'This will copy each element of `vs` into `s`. Better:'
  id: totrans-4149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`vs`中的每个元素复制到`s`中。更好的做法：
- en: '[PRE557]'
  id: totrans-4150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: 'Better still, if the loop variable isn’t modified or copied:'
  id: totrans-4151
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，如果循环变量没有被修改或复制：
- en: '[PRE558]'
  id: totrans-4152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: Enforcement
  id: totrans-4153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look at loops, if a traditional loop just looks at each element of a sequence,
    and there are no side effects on what it does with the elements, rewrite the loop
    to a ranged-`for` loop.
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
  zh: 看看循环，如果传统的循环只是查看序列的每个元素，并且对元素的操作没有副作用，可以将循环重写为范围`for`循环。
- en: 'ES.72: Prefer a `for`-statement to a `while`-statement when there is an obvious
    loop variable'
  id: totrans-4155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.72：当存在明显的循环变量时，优先使用`for`循环语句而不是`while`循环语句
- en: Reason
  id: totrans-4156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Readability: the complete logic of the loop is visible “up front”. The scope
    of the loop variable can be limited.'
  id: totrans-4157
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性：循环的完整逻辑在“前端”可见。循环变量的作用域可以被限制。
- en: Example
  id: totrans-4158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE559]'
  id: totrans-4159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: Example, bad
  id: totrans-4160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE560]'
  id: totrans-4161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: Enforcement
  id: totrans-4162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.73: Prefer a `while`-statement to a `for`-statement when there is no obvious
    loop variable'
  id: totrans-4164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.73：当没有明显的循环变量时，优先使用`while`循环语句而不是`for`循环语句
- en: Reason
  id: totrans-4165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability.
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。
- en: Example
  id: totrans-4167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE561]'
  id: totrans-4168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: The “event loop” is misleading because the `events` counter has nothing to do
    with the loop condition (`wait_for_event()`). Better
  id: totrans-4169
  prefs: []
  type: TYPE_NORMAL
  zh: “事件循环”这个术语是误导性的，因为`events`计数器与循环条件（`wait_for_event()`）无关。更好的做法
- en: '[PRE562]'
  id: totrans-4170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: Enforcement
  id: totrans-4171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag actions in `for`-initializers and `for`-increments that do not relate to
    the `for`-condition.
  id: totrans-4172
  prefs: []
  type: TYPE_NORMAL
  zh: 标记`for`初始化器和`for`增量中与`for`条件不相关的操作
- en: 'ES.74: Prefer to declare a loop variable in the initializer part of a `for`-statement'
  id: totrans-4173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.74：优先在`for`循环语句的初始化部分声明循环变量
- en: See [ES.6](#res-cond)
  id: totrans-4174
  prefs: []
  type: TYPE_NORMAL
  zh: 见[ES.6](#res-cond)
- en: 'ES.75: Avoid `do`-statements'
  id: totrans-4175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.75：避免使用`do`语句
- en: Reason
  id: totrans-4176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability, avoidance of errors. The termination condition is at the end (where
    it can be overlooked) and the condition is not checked the first time through.
  id: totrans-4177
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性，避免错误。终止条件在末尾（可能被忽略的地方），并且条件不是第一次通过时检查的。
- en: Example
  id: totrans-4178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE563]'
  id: totrans-4179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: Note
  id: totrans-4180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Yes, there are genuine examples where a `do`-statement is a clear statement
    of a solution, but also many bugs.
  id: totrans-4181
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实有一些例子中`do`语句是解决方案的明确声明，但也有许多错误。
- en: Enforcement
  id: totrans-4182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `do`-statements.
  id: totrans-4183
  prefs: []
  type: TYPE_NORMAL
  zh: 标记`do`语句。
- en: 'ES.76: Avoid `goto`'
  id: totrans-4184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.76：避免使用`goto`
- en: Reason
  id: totrans-4185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability, avoidance of errors. There are better control structures for humans;
    `goto` is for machine generated code.
  id: totrans-4186
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性，避免错误。对于人类来说，有更好的控制结构；`goto`是用于机器生成代码的。
- en: Exception
  id: totrans-4187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Breaking out of a nested loop. In that case, always jump forwards.
  id: totrans-4188
  prefs: []
  type: TYPE_NORMAL
  zh: 跳出嵌套循环。在这种情况下，总是向前跳转。
- en: '[PRE564]'
  id: totrans-4189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: Example, bad
  id: totrans-4190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: 'There is a fair amount of use of the C goto-exit idiom:'
  id: totrans-4191
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中`goto-exit`惯用法得到了相当多的使用：
- en: '[PRE565]'
  id: totrans-4192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: This is an ad-hoc simulation of destructors. Declare your resources with handles
    with destructors that clean up. If for some reason you cannot handle all cleanup
    with destructors for the variables used, consider `gsl::finally()` as a cleaner
    and more reliable alternative to `goto exit`
  id: totrans-4193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对析构函数的临时模拟。使用具有清理功能的句柄声明资源。如果由于某种原因，您无法使用析构函数处理所有变量的清理，请考虑使用`gsl::finally()`作为`goto
    exit`的更清洁和更可靠的替代方案。
- en: Enforcement
  id: totrans-4194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `goto`. Better still flag all `goto`s that do not jump from a nested loop
    to the statement immediately after a nest of loops.
  id: totrans-4195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`goto`。更好的是标记所有不从一个嵌套循环跳转到紧随其后的语句的`goto`。
- en: 'ES.77: Minimize the use of `break` and `continue` in loops'
  id: totrans-4196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.77：最小化循环中使用`break`和`continue`的情况
- en: Reason
  id: totrans-4197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: In a non-trivial loop body, it is easy to overlook a `break` or a `continue`.
  id: totrans-4198
  prefs: []
  type: TYPE_NORMAL
  zh: 在非平凡的循环体中，很容易忽略`break`或`continue`。
- en: A `break` in a loop has a dramatically different meaning than a `break` in a
    `switch`-statement (and you can have `switch`-statement in a loop and a loop in
    a `switch`-case).
  id: totrans-4199
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的`break`与`switch`语句中的`break`有截然不同的意义（您可以在循环中包含`switch`语句，以及在`switch`-case中包含循环）。
- en: Example
  id: totrans-4200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE566]'
  id: totrans-4201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: Alternative
  id: totrans-4202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Often, a loop that requires a `break` is a good candidate for a function (algorithm),
    in which case the `break` becomes a `return`.
  id: totrans-4203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要`break`的循环是函数（算法）的良好候选者，在这种情况下，`break`变为`return`。
- en: '[PRE567]'
  id: totrans-4204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: Often, a loop that uses `continue` can equivalently and as clearly be expressed
    by an `if`-statement.
  id: totrans-4205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用`continue`的循环可以用等价且更清晰的方式通过`if`语句表达。
- en: '[PRE568]'
  id: totrans-4206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: Note
  id: totrans-4207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you really need to break out a loop, a `break` is typically better than
    alternatives such as [modifying the loop variable](#res-loop-counter) or a [`goto`](#res-goto):'
  id: totrans-4208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的需要跳出循环，通常`break`比修改循环变量（[res-loop-counter](#res-loop-counter)）或使用`goto`（[res-goto](#res-goto)）等替代方案更好：
- en: Enforcement
  id: totrans-4209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4210
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.78: Don’t rely on implicit fallthrough in `switch` statements'
  id: totrans-4211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.78：不要在`switch`语句中依赖隐式`fallthrough`
- en: Reason
  id: totrans-4212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Always end a non-empty `case` with a `break`. Accidentally leaving out a `break`
    is a fairly common bug. A deliberate fallthrough can be a maintenance hazard and
    should be rare and explicit.
  id: totrans-4213
  prefs: []
  type: TYPE_NORMAL
  zh: 总是非空`case`以`break`结束。不小心遗漏`break`是一个相当常见的错误。故意使用`fallthrough`可能是一个维护隐患，应该很少见且明确。
- en: Example
  id: totrans-4214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE569]'
  id: totrans-4215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: 'Multiple case labels of a single statement is OK:'
  id: totrans-4216
  prefs: []
  type: TYPE_NORMAL
  zh: 单个语句的多个`case`标签是可以的：
- en: '[PRE570]'
  id: totrans-4217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: 'Return statements in a case label are also OK:'
  id: totrans-4218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`case`标签中的返回语句也是可以的：
- en: '[PRE571]'
  id: totrans-4219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: Exceptions
  id: totrans-4220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'In rare cases if fallthrough is deemed appropriate, be explicit and use the
    `[[fallthrough]]` annotation:'
  id: totrans-4221
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果认为`fallthrough`是合适的，请明确并使用`[[fallthrough]]`注解：
- en: '[PRE572]'
  id: totrans-4222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: Note
  id: totrans-4223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Enforcement
  id: totrans-4224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all implicit fallthroughs from non-empty `case`s.
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有非空`case`中的隐式`fallthrough`。
- en: 'ES.79: Use `default` to handle common cases (only)'
  id: totrans-4226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.79：使用`default`处理常见情况（仅限）
- en: Reason
  id: totrans-4227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Code clarity. Improved opportunities for error detection.
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清晰度。提高了错误检测的机会。
- en: Example
  id: totrans-4229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE573]'
  id: totrans-4230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: Here it is clear that there is a default action and that cases `a` and `b` are
    special.
  id: totrans-4231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里很明显有一个默认操作，并且情况`a`和`b`是特殊的。
- en: Example
  id: totrans-4232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'But what if there is no default action and you mean to handle only specific
    cases? In that case, have an empty default or else it is impossible to know if
    you meant to handle all cases:'
  id: totrans-4233
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果没有默认操作，并且您只想处理特定情况怎么办？在这种情况下，请使用空默认值，否则无法知道您是否想处理所有情况：
- en: '[PRE574]'
  id: totrans-4234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: 'If you leave out the `default`, a maintainer and/or a compiler might reasonably
    assume that you intended to handle all cases:'
  id: totrans-4235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您省略了`default`，维护者或编译器可能会合理地假设您打算处理所有情况：
- en: '[PRE575]'
  id: totrans-4236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: Did you forget case `d` or deliberately leave it out? Forgetting a case typically
    happens when a case is added to an enumeration and the person doing so fails to
    add it to every switch over the enumerators.
  id: totrans-4237
  prefs: []
  type: TYPE_NORMAL
  zh: 你是忘记case `d`还是故意省略了它？忘记一个情况通常发生在向枚举添加情况时，而执行此操作的人未能将其添加到每个枚举的switch中。
- en: Enforcement
  id: totrans-4238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `switch`-statements over an enumeration that don’t handle all enumerators
    and do not have a `default`. This might yield too many false positives in some
    code bases; if so, flag only `switch`es that handle most but not all cases (that
    was the strategy of the very first C++ compiler).
  id: totrans-4239
  prefs: []
  type: TYPE_NORMAL
  zh: 标记覆盖枚举的`switch`语句，这些语句没有处理所有枚举项且没有`default`。这可能在某些代码库中产生过多的误报；如果是这样，则仅标记处理大多数但不是所有情况的`switch`（这是非常第一个C++编译器的策略）。
- en: 'ES.84: Don’t try to declare a local variable with no name'
  id: totrans-4240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.84：不要尝试声明一个没有名字的局部变量
- en: Reason
  id: totrans-4241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: There is no such thing. What looks to a human like a variable without a name
    is to the compiler a statement consisting of a temporary that immediately goes
    out of scope.
  id: totrans-4242
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的事情。对人类来说，一个没有名字的变量在编译器中是一个包含临时变量的语句，该临时变量立即超出作用域。
- en: Example, bad
  id: totrans-4243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE576]'
  id: totrans-4244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: This declares an unnamed `lock_guard` object that immediately goes out of scope
    at the point of the semicolon. This is not an uncommon mistake. In particular,
    this particular example can lead to hard-to-find race conditions.
  id: totrans-4245
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个无名的`lock_guard`对象，该对象在分号处立即超出作用域。这不是一个不常见的错误。特别是，这个特定的例子可能导致难以发现的竞态条件。
- en: Note
  id: totrans-4246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unnamed function arguments are fine.
  id: totrans-4247
  prefs: []
  type: TYPE_NORMAL
  zh: 无名函数参数是可以的。
- en: Enforcement
  id: totrans-4248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag statements that are just a temporary.
  id: totrans-4249
  prefs: []
  type: TYPE_NORMAL
  zh: 标记仅仅是临时的语句。
- en: 'ES.85: Make empty statements visible'
  id: totrans-4250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.85：使空语句可见
- en: Reason
  id: totrans-4251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability.
  id: totrans-4252
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。
- en: Example
  id: totrans-4253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE577]'
  id: totrans-4254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: Enforcement
  id: totrans-4255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag empty statements that are not blocks and don’t contain comments.
  id: totrans-4256
  prefs: []
  type: TYPE_NORMAL
  zh: 标记不是块且不包含注释的空语句。
- en: 'ES.86: Avoid modifying loop control variables inside the body of raw for-loops'
  id: totrans-4257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.86：避免在原始for循环体中修改循环控制变量
- en: Reason
  id: totrans-4258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The loop control up front should enable correct reasoning about what is happening
    inside the loop. Modifying loop counters in both the iteration-expression and
    inside the body of the loop is a perennial source of surprises and bugs.
  id: totrans-4259
  prefs: []
  type: TYPE_NORMAL
  zh: 循环控制应该在前面，以便正确推理循环内部发生的事情。在迭代表达式和循环体中修改循环计数器是意外和错误的一个常见来源。
- en: Example
  id: totrans-4260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE578]'
  id: totrans-4261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: Enforcement
  id: totrans-4262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag variables that are potentially updated (have a non-`const` use) in both
    the loop control iteration-expression and the loop body.
  id: totrans-4263
  prefs: []
  type: TYPE_NORMAL
  zh: 标记在循环控制迭代表达式和循环体中可能被更新的（具有非`const`使用）的变量。
- en: 'ES.87: Don’t add redundant `==` or `!=` to conditions'
  id: totrans-4264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ES.87：不要在条件中添加冗余的`==`或`!=`
- en: Reason
  id: totrans-4265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Doing so avoids verbosity and eliminates some opportunities for mistakes. Helps
    make style consistent and conventional.
  id: totrans-4266
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以避免冗长并消除一些错误的机会。有助于使风格一致和传统。
- en: Example
  id: totrans-4267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: By definition, a condition in an `if`-statement, `while`-statement, or a `for`-statement
    selects between `true` and `false`. A numeric value is compared to `0` and a pointer
    value to `nullptr`.
  id: totrans-4268
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`if`语句、`while`语句或`for`语句中的条件在`true`和`false`之间进行选择。数值与`0`进行比较，指针值与`nullptr`进行比较。
- en: '[PRE579]'
  id: totrans-4269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: Often, `if (p)` is read as “if `p` is valid” which is a direct expression of
    the programmers intent, whereas `if (p != nullptr)` would be a long-winded workaround.
  id: totrans-4270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，“if (p)”被读作“如果`p`有效”，这是程序员意图的直接表达，而“if (p != nullptr)”则是一个冗长的解决方案。
- en: Example
  id: totrans-4271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: This rule is especially useful when a declaration is used as a condition
  id: totrans-4272
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则在声明用作条件时特别有用。
- en: '[PRE580]'
  id: totrans-4273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: Example
  id: totrans-4274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Note that implicit conversions to bool are applied in conditions. For example:'
  id: totrans-4275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，条件中应用了隐式转换为bool。例如：
- en: '[PRE581]'
  id: totrans-4276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: This invokes `istream`’s `operator bool()`.
  id: totrans-4277
  prefs: []
  type: TYPE_NORMAL
  zh: 这调用了`istream`的`operator bool()`。
- en: Note
  id: totrans-4278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Explicit comparison of an integer to `0` is in general not redundant. The reason
    is that (as opposed to pointers and Booleans) an integer often has more than two
    reasonable values. Furthermore `0` (zero) is often used to indicate success. Consequently,
    it is best to be specific about the comparison.
  id: totrans-4279
  prefs: []
  type: TYPE_NORMAL
  zh: 显式地将整数与`0`进行比较通常不是冗余的。原因是（与指针和布尔值不同）整数通常有多个合理的值。此外，`0`（零）通常用于表示成功。因此，最好对比较进行具体说明。
- en: '[PRE582]'
  id: totrans-4280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: Always remember that an integer can have more than two values.
  id: totrans-4281
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住一个整数可以有多于两个值。
- en: Example, bad
  id: totrans-4282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: It has been noted that
  id: totrans-4283
  prefs: []
  type: TYPE_NORMAL
  zh: 已有记录指出
- en: '[PRE583]'
  id: totrans-4284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: is a common beginners error. If you use C-style strings, you must know the `<cstring>`
    functions well. Being verbose and writing
  id: totrans-4285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个初学者的常见错误。如果你使用C风格字符串，你必须很好地了解`<cstring>`函数。冗长且编写
- en: '[PRE584]'
  id: totrans-4286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: would not in itself save you.
  id: totrans-4287
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身并不能救你。
- en: Note
  id: totrans-4288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The opposite condition is most easily expressed using a negation:'
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用否定最容易表达相反的条件：
- en: '[PRE585]'
  id: totrans-4290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: Enforcement
  id: totrans-4291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Easy, just check for redundant use of `!=` and `==` in conditions.
  id: totrans-4292
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，只需检查条件中`!=`和`==`的冗余使用。
- en: Arithmetic
  id: totrans-4293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术
- en: 'ES.100: Don’t mix signed and unsigned arithmetic'
  id: totrans-4294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.100: 不要混合有符号和无符号算术'
- en: Reason
  id: totrans-4295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoid wrong results.
  id: totrans-4296
  prefs: []
  type: TYPE_NORMAL
  zh: 避免错误的结果。
- en: Example
  id: totrans-4297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE586]'
  id: totrans-4298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: It is harder to spot the problem in more realistic examples.
  id: totrans-4299
  prefs: []
  type: TYPE_NORMAL
  zh: 在更现实的例子中，更难发现问题。
- en: Note
  id: totrans-4300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, C++ uses signed integers for array subscripts and the standard
    library uses unsigned integers for container subscripts. This precludes consistency.
    Use `gsl::index` for subscripts; [see ES.107](#res-subscripts).
  id: totrans-4301
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++使用有符号整数作为数组下标，而标准库使用无符号整数作为容器下标。这导致了不一致。使用`gsl::index`作为下标；[参见ES.107](#res-subscripts)。
- en: Enforcement
  id: totrans-4302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Compilers already know and sometimes warn.
  id: totrans-4303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器已经知道，有时会发出警告。
- en: (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one
    of the arguments is `sizeof` or a call to container `.size()` and the other is
    `ptrdiff_t`.
  id: totrans-4304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （为了避免噪声）不要在有符号/无符号混合比较中标记，其中一个参数是`sizeof`或对容器`.size()`的调用，而另一个是`ptrdiff_t`。
- en: 'ES.101: Use unsigned types for bit manipulation'
  id: totrans-4305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.101: 使用无符号类型进行位操作'
- en: Reason
  id: totrans-4306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Unsigned types support bit manipulation without surprises from sign bits.
  id: totrans-4307
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号类型支持位操作，不会从符号位产生意外。
- en: Example
  id: totrans-4308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE587]'
  id: totrans-4309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: Note
  id: totrans-4310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unsigned types can also be useful for modular arithmetic. However, if you want
    modular arithmetic add comments as necessary noting the reliance on wraparound
    behavior, as such code can be surprising for many programmers.
  id: totrans-4311
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号类型也可以用于模运算。然而，如果您想使用模运算，根据需要添加注释，指出依赖于回绕行为，因为这样的代码可能会让许多程序员感到惊讶。
- en: Enforcement
  id: totrans-4312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Just about impossible in general because of the use of unsigned subscripts in
    the standard library
  id: totrans-4313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于标准库中使用了无符号下标，这在一般情况下几乎是不可能的。
- en: ???
  id: totrans-4314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.102: Use signed types for arithmetic'
  id: totrans-4315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.102: 使用有符号类型进行算术'
- en: Reason
  id: totrans-4316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Because most arithmetic is assumed to be signed; `x - y` yields a negative number
    when `y > x` except in the rare cases where you really want modular arithmetic.
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数算术都假定是有符号的；当`y > x`时，`x - y`会产生负数，除非在极少数情况下您真的想使用模运算。
- en: Example
  id: totrans-4318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Unsigned arithmetic can yield surprising results if you are not expecting it.
    This is even more true for mixed signed and unsigned arithmetic.
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有预料到，无符号算术可能会产生令人惊讶的结果。对于混合有符号和无符号算术来说，这一点尤其正确。
- en: '[PRE588]'
  id: totrans-4320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: Here we have been very explicit about what’s happening, but if you had seen
    `us - (s + 2)` or `s += 2; ...; us - s`, would you reliably have suspected that
    the result would print as `4294967294`?
  id: totrans-4321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经非常明确地说明了正在发生的事情，但如果你看到了`us - (s + 2)`或`s += 2; ...; us - s`，你是否会可靠地怀疑结果会打印为`4294967294`？
- en: Exception
  id: totrans-4322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例外
- en: Use unsigned types if you really want modular arithmetic - add comments as necessary
    noting the reliance on overflow behavior, as such code is going to be surprising
    for many programmers.
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想使用模运算，请使用无符号类型 - 根据需要添加注释，指出依赖于溢出行为，因为这样的代码可能会让许多程序员感到惊讶。
- en: Example
  id: totrans-4324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: The standard library uses unsigned types for subscripts. The built-in array
    uses signed types for subscripts. This makes surprises (and bugs) inevitable.
  id: totrans-4325
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库使用无符号类型作为下标。内置数组使用有符号类型作为下标。这导致意外（和错误）不可避免。
- en: '[PRE589]'
  id: totrans-4326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: Use `gsl::index` for subscripts; [see ES.107](#res-subscripts).
  id: totrans-4327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gsl::index`作为下标；[参见ES.107](#res-subscripts)。
- en: Enforcement
  id: totrans-4328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag mixed signed and unsigned arithmetic
  id: totrans-4329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记混合有符号和无符号算术
- en: Flag results of unsigned arithmetic assigned to or printed as signed.
  id: totrans-4330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记赋值给或打印为有符号的结果的无符号算术。
- en: Flag negative literals (e.g. `-2`) used as container subscripts.
  id: totrans-4331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记用作容器下标的负字面量（例如 `-2`）。
- en: (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one
    of the arguments is `sizeof` or a call to container `.size()` and the other is
    `ptrdiff_t`.
  id: totrans-4332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （为了避免噪声）不要在有符号/无符号混合比较中标记，其中一个参数是`sizeof`或对容器`.size()`的调用，而另一个是`ptrdiff_t`。
- en: 'ES.103: Don’t overflow'
  id: totrans-4333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.103: 不要溢出'
- en: Reason
  id: totrans-4334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Overflow usually makes your numeric algorithm meaningless. Incrementing a value
    beyond a maximum value can lead to memory corruption and undefined behavior.
  id: totrans-4335
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出通常会使您的数值算法变得没有意义。将值增加超过最大值可能导致内存损坏和未定义的行为。
- en: Example, bad
  id: totrans-4336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE590]'
  id: totrans-4337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: Example, bad
  id: totrans-4338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE591]'
  id: totrans-4339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: Example, bad
  id: totrans-4340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE592]'
  id: totrans-4341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: Exception
  id: totrans-4342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例外
- en: Use unsigned types if you really want modular arithmetic.
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想使用模运算，请使用无符号类型。
- en: '**Alternative**: For critical applications that can afford some overhead, use
    a range-checked integer and/or floating-point type.'
  id: totrans-4344
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：对于可以承受一些开销的关键应用，使用经过范围检查的整数和/或浮点类型。'
- en: Enforcement
  id: totrans-4345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.104: Don’t underflow'
  id: totrans-4347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.104: 不要下溢'
- en: Reason
  id: totrans-4348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Decrementing a value beyond a minimum value can lead to memory corruption and
    undefined behavior.
  id: totrans-4349
  prefs: []
  type: TYPE_NORMAL
  zh: 将值递减到最小值以下可能导致内存损坏和未定义行为。
- en: Example, bad
  id: totrans-4350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE593]'
  id: totrans-4351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: Exception
  id: totrans-4352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例外
- en: Use unsigned types if you really want modular arithmetic.
  id: totrans-4353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想要模运算，请使用无符号类型。
- en: Enforcement
  id: totrans-4354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'ES.105: Don’t divide by integer zero'
  id: totrans-4356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.105: 不要除以整数零'
- en: Reason
  id: totrans-4357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The result is undefined and probably a crash.
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是未定义的，可能崩溃。
- en: Note
  id: totrans-4359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This also applies to `%`.
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于 `%`。
- en: Example, bad
  id: totrans-4361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE594]'
  id: totrans-4362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: Example, good
  id: totrans-4363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE595]'
  id: totrans-4364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '**Alternative**: For critical applications that can afford some overhead, use
    a range-checked integer and/or floating-point type.'
  id: totrans-4365
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：对于可以承受一些开销的关键应用，使用经过范围检查的整数和/或浮点类型。'
- en: Enforcement
  id: totrans-4366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag division by an integral value that could be zero
  id: totrans-4367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记除以可能为零的整数值
- en: 'ES.106: Don’t try to avoid negative values by using `unsigned`'
  id: totrans-4368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.106: 不要通过使用 `unsigned` 来尝试避免负值'
- en: Reason
  id: totrans-4369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Choosing `unsigned` implies many changes to the usual behavior of integers,
    including modular arithmetic, can suppress warnings related to overflow, and opens
    the door for errors related to signed/unsigned mixes. Using `unsigned` doesn’t
    actually eliminate the possibility of negative values.
  id: totrans-4370
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `unsigned` 意味着需要对整数的常规行为进行许多更改，包括模运算，可以抑制与溢出相关的警告，并为与有符号/无符号混合相关的错误打开大门。使用
    `unsigned` 并不会真正消除负值的可能性。
- en: Example
  id: totrans-4371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE596]'
  id: totrans-4372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: 'These problems with such (perfectly legal) constructs are hard to spot in real
    code and are the source of many real-world errors. Consider:'
  id: totrans-4373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与（完全合法）构造相关的问题在真实代码中很难被发现，并且是许多现实世界错误的来源。考虑：
- en: '[PRE597]'
  id: totrans-4374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: Remember that `-1` when assigned to an `unsigned int` becomes the largest `unsigned
    int`. Also, since unsigned arithmetic is modular arithmetic the multiplication
    didn’t overflow, it wrapped around.
  id: totrans-4375
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当 `-1` 赋值给 `unsigned int` 时，它成为最大的 `unsigned int`。此外，由于无符号算术是模算术，乘法没有溢出，而是回绕。
- en: Example
  id: totrans-4376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE598]'
  id: totrans-4377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: Had `x` been a signed `short`, we could have warned about the undefined behavior
    upon overflow.
  id: totrans-4378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 是有符号的 `short`，我们可以在溢出时警告未定义行为。
- en: Alternatives
  id: totrans-4379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: use signed integers and check for `x >= 0`
  id: totrans-4380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有符号整数并检查 `x >= 0`
- en: use a positive integer type
  id: totrans-4381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正整数类型
- en: use an integer subrange type
  id: totrans-4382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用整数子范围类型
- en: '`Assert(-1 < x)`'
  id: totrans-4383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert(-1 < x)`'
- en: For example
  id: totrans-4384
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: '[PRE599]'
  id: totrans-4385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: Note
  id: totrans-4386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: ???
  id: totrans-4387
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Enforcement
  id: totrans-4388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: See ES.100 Enforcements.
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 ES.100 执法。
- en: 'ES.107: Don’t use `unsigned` for subscripts, prefer `gsl::index`'
  id: totrans-4390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'ES.107: 不要使用 `unsigned` 作为下标，优先使用 `gsl::index`'
- en: Reason
  id: totrans-4391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid signed/unsigned confusion. To enable better optimization. To enable
    better error detection. To avoid the pitfalls with `auto` and `int`.
  id: totrans-4392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免有符号/无符号混淆。为了实现更好的优化。为了实现更好的错误检测。为了避免与 `auto` 和 `int` 相关的陷阱。
- en: Example, bad
  id: totrans-4393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE600]'
  id: totrans-4394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: Example, good
  id: totrans-4395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE601]'
  id: totrans-4396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: Note
  id: totrans-4397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The built-in array allows signed subscripts. The standard-library containers
    use unsigned subscripts. Thus, no perfect and fully compatible solution is possible
    (unless and until the standard-library containers change to use signed subscripts
    someday in the future). Given the known problems with unsigned and signed/unsigned
    mixtures, better stick to (signed) integers of a sufficient size, which is guaranteed
    by `gsl::index`.
  id: totrans-4398
  prefs: []
  type: TYPE_NORMAL
  zh: 内置数组允许有符号下标。标准库容器使用无符号下标。因此，不可能有一个完美且完全兼容的解决方案（除非和直到标准库容器在未来某天改为使用有符号下标）。鉴于已知的无符号和有符号/无符号混合问题，最好坚持使用足够大小的（有符号）整数，这由
    `gsl::index` 保证。
- en: Example
  id: totrans-4399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE602]'
  id: totrans-4400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: Example
  id: totrans-4401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE603]'
  id: totrans-4402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: Alternatives
  id: totrans-4403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Alternatives for users
  id: totrans-4404
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的替代方案
- en: use algorithms
  id: totrans-4405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用算法
- en: use range-for
  id: totrans-4406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用范围-for
- en: use iterators/pointers
  id: totrans-4407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器/指针
- en: Enforcement
  id: totrans-4408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Very tricky as long as the standard-library containers get it wrong.
  id: totrans-4409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要标准库容器出错，就会非常棘手。
- en: (To avoid noise) Do not flag on a mixed signed/unsigned comparison where one
    of the arguments is `sizeof` or a call to container `.size()` and the other is
    `ptrdiff_t`.
  id: totrans-4410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （为了避免噪声）不要在混合有符号/无符号比较中标记，其中一个参数是 `sizeof` 或容器 `.size()` 的调用，另一个是 `ptrdiff_t`。
- en: 'Per: Performance'
  id: totrans-4411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能：性能
- en: ??? should this section be in the main guide???
  id: totrans-4412
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 应该将此部分包含在主要指南中吗???
- en: 'This section contains rules for people who need high performance or low-latency.
    That is, these are rules that relate to how to use as little time and as few resources
    as possible to achieve a task in a predictably short time. The rules in this section
    are more restrictive and intrusive than what is needed for many (most) applications.
    Do not naïvely try to follow them in general code: achieving the goals of low
    latency requires extra work.'
  id: totrans-4413
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含适用于需要高性能或低延迟的人的规则。也就是说，这些规则与如何尽可能少地使用时间和资源，在可预测的短时间内完成任务有关。本节中的规则比许多（大多数）应用所需的规则更为严格和侵入性。不要天真地试图在通用代码中遵循它们：实现低延迟的目标需要额外的工作。
- en: 'Performance rule summary:'
  id: totrans-4414
  prefs: []
  type: TYPE_NORMAL
  zh: 性能规则摘要：
- en: '[Per.1: Don’t optimize without reason](#rper-reason)'
  id: totrans-4415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.1: 不要没有理由进行优化](#rper-reason)'
- en: '[Per.2: Don’t optimize prematurely](#rper-knuth)'
  id: totrans-4416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.2: 不要过早优化](#rper-knuth)'
- en: '[Per.3: Don’t optimize something that’s not performance critical](#rper-critical)'
  id: totrans-4417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.3: 不要优化非性能关键的部分](#rper-critical)'
- en: '[Per.4: Don’t assume that complicated code is necessarily faster than simple
    code](#rper-simple)'
  id: totrans-4418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.4: 不要假设复杂的代码必然比简单的代码快](#rper-simple)'
- en: '[Per.5: Don’t assume that low-level code is necessarily faster than high-level
    code](#rper-low)'
  id: totrans-4419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.5: 不要假设底层代码必然比高层代码快](#rper-low)'
- en: '[Per.6: Don’t make claims about performance without measurements](#rper-measure)'
  id: totrans-4420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.6: 没有测量不要对性能做出断言](#rper-measure)'
- en: '[Per.7: Design to enable optimization](#rper-efficiency)'
  id: totrans-4421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.7: 设计以启用优化](#rper-efficiency)'
- en: '[Per.10: Rely on the static type system](#rper-type)'
  id: totrans-4422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.10: 依赖静态类型系统](#rper-type)'
- en: '[Per.11: Move computation from run time to compile time](#rper-comp)'
  id: totrans-4423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.11: 将计算从运行时移到编译时](#rper-comp)'
- en: '[Per.12: Eliminate redundant aliases](#rper-alias)'
  id: totrans-4424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.12: 消除冗余别名](#rper-alias)'
- en: '[Per.13: Eliminate redundant indirections](#rper-indirect)'
  id: totrans-4425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.13: 消除冗余间接引用](#rper-indirect)'
- en: '[Per.14: Minimize the number of allocations and deallocations](#rper-alloc)'
  id: totrans-4426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.14: 最小化分配和释放的数量](#rper-alloc)'
- en: '[Per.15: Do not allocate on a critical branch](#rper-alloc0)'
  id: totrans-4427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.15: 不要在关键分支上进行分配](#rper-alloc0)'
- en: '[Per.16: Use compact data structures](#rper-compact)'
  id: totrans-4428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.16: 使用紧凑的数据结构](#rper-compact)'
- en: '[Per.17: Declare the most used member of a time-critical struct first](#rper-struct)'
  id: totrans-4429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.17: 首先声明时间关键结构中最常用的成员](#rper-struct)'
- en: '[Per.18: Space is time](#rper-space)'
  id: totrans-4430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.18: 空间即时间](#rper-space)'
- en: '[Per.19: Access memory predictably](#rper-access)'
  id: totrans-4431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.19: 可预测地访问内存](#rper-access)'
- en: '[Per.30: Avoid context switches on the critical path](#rper-context)'
  id: totrans-4432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Per.30: 避免在关键路径上进行上下文切换](#rper-context)'
- en: 'Per.1: Don’t optimize without reason'
  id: totrans-4433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.1: 不要没有理由进行优化'
- en: Reason
  id: totrans-4434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If there is no need for optimization, the main result of the effort will be
    more errors and higher maintenance costs.
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要优化，努力的主要结果将是更多的错误和更高的维护成本。
- en: Note
  id: totrans-4436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some people optimize out of habit or because it’s fun.
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人出于习惯或因为有趣而进行优化。
- en: ???
  id: totrans-4438
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.2: Don’t optimize prematurely'
  id: totrans-4439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.2: 不要过早优化'
- en: Reason
  id: totrans-4440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Elaborately optimized code is usually larger and harder to change than unoptimized
    code.
  id: totrans-4441
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细优化的代码通常比未优化的代码更大，更难更改。
- en: ???
  id: totrans-4442
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.3: Don’t optimize something that’s not performance critical'
  id: totrans-4443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.3: 不要优化非性能关键的部分'
- en: Reason
  id: totrans-4444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Optimizing a non-performance-critical part of a program has no effect on system
    performance.
  id: totrans-4445
  prefs: []
  type: TYPE_NORMAL
  zh: 优化程序的非性能关键部分对系统性能没有影响。
- en: Note
  id: totrans-4446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If your program spends most of its time waiting for the web or for a human,
    optimization of in-memory computation is probably useless.
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序大部分时间都在等待网络或人类，优化内存计算可能毫无用处。
- en: 'Put another way: If your program spends 4% of its processing time doing computation
    A and 40% of its time doing computation B, a 50% improvement on A is only as impactful
    as a 5% improvement on B. (If you don’t even know how much time is spent on A
    or B, see [Per.1](#rper-reason) and [Per.2](#rper-knuth).)'
  id: totrans-4448
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：如果你的程序在计算A上花费了4%的处理时间，在计算B上花费了40%的时间，A上50%的改进只相当于B上5%的改进。（如果你甚至不知道在A或B上花费了多少时间，请参阅[Per.1](#rper-reason)和[Per.2](#rper-knuth)。）
- en: 'Per.4: Don’t assume that complicated code is necessarily faster than simple
    code'
  id: totrans-4449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.4: 不要假设复杂的代码必然比简单的代码快'
- en: Reason
  id: totrans-4450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Simple code can be very fast. Optimizers sometimes do marvels with simple code
  id: totrans-4451
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的代码可以非常快。优化器有时会对简单的代码做出奇迹。
- en: Example, good
  id: totrans-4452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，好
- en: '[PRE604]'
  id: totrans-4453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: Example, bad
  id: totrans-4454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE605]'
  id: totrans-4455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: Note
  id: totrans-4456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: ???
  id: totrans-4457
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: ???
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.5: Don’t assume that low-level code is necessarily faster than high-level
    code'
  id: totrans-4459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.5: 不要假设底层代码必然比高层代码快'
- en: Reason
  id: totrans-4460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Low-level code sometimes inhibits optimizations. Optimizers sometimes do marvels
    with high-level code.
  id: totrans-4461
  prefs: []
  type: TYPE_NORMAL
  zh: 低级代码有时会阻碍优化。优化器有时会对高级代码做出奇迹。
- en: Note
  id: totrans-4462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注释
- en: ???
  id: totrans-4463
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: ???
  id: totrans-4464
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.6: Don’t make claims about performance without measurements'
  id: totrans-4465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6页：不要在没有测量的情况下对性能做出断言
- en: Reason
  id: totrans-4466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The field of performance is littered with myth and bogus folklore. Modern hardware
    and optimizers defy naive assumptions; even experts are regularly surprised.
  id: totrans-4467
  prefs: []
  type: TYPE_NORMAL
  zh: 性能领域充满了神话和虚假的传说。现代硬件和优化器挑战了简单的假设；即使是专家也经常感到惊讶。
- en: Note
  id: totrans-4468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注释
- en: Getting good performance measurements can be hard and require specialized tools.
  id: totrans-4469
  prefs: []
  type: TYPE_NORMAL
  zh: 获取良好的性能测量可能很困难，需要专门的工具。
- en: Note
  id: totrans-4470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注释
- en: A few simple microbenchmarks using Unix `time` or the standard-library `<chrono>`
    can help dispel the most obvious myths. If you can’t measure your complete system
    accurately, at least try to measure a few of your key operations and algorithms.
    A profiler can help tell you which parts of your system are performance critical.
    Often, you will be surprised.
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unix `time`或标准库`<chrono>`进行的一些简单的微基准测试可以帮助消除最明显的神话。如果你不能准确测量你的整个系统，至少尝试测量几个关键操作和算法。分析器可以帮助告诉你系统的哪些部分是性能关键。通常，你会感到惊讶。
- en: ???
  id: totrans-4472
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.7: Design to enable optimization'
  id: totrans-4473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7页：设计以实现优化
- en: Reason
  id: totrans-4474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Because we often need to optimize the initial design. Because a design that
    ignores the possibility of later improvement is hard to change.
  id: totrans-4475
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们经常需要优化初始设计。因为忽视后期改进可能性的设计很难改变。
- en: Example
  id: totrans-4476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'From the C (and C++) standard:'
  id: totrans-4477
  prefs: []
  type: TYPE_NORMAL
  zh: 来自C（和C++）标准的：
- en: '[PRE606]'
  id: totrans-4478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: When did you even want to sort memory? Really, we sort sequences of elements,
    typically stored in containers. A call to `qsort` throws away much useful information
    (e.g., the element type), forces the user to repeat information already known
    (e.g., the element size), and forces the user to write extra code (e.g., a function
    to compare `double`s). This implies added work for the programmer, is error-prone,
    and deprives the compiler of information needed for optimization.
  id: totrans-4479
  prefs: []
  type: TYPE_NORMAL
  zh: 你什么时候想要对内存进行排序？实际上，我们排序的是存储在容器中的元素序列。调用`qsort`会丢弃许多有用的信息（例如，元素类型），迫使用户重复已知信息（例如，元素大小），并迫使用户编写额外的代码（例如，比较`double`的函数）。这给程序员增加了额外的工作，容易出错，并剥夺了编译器进行优化所需的信息。
- en: '[PRE607]'
  id: totrans-4480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: From the point of view of interface design, `qsort` throws away useful information.
  id: totrans-4481
  prefs: []
  type: TYPE_NORMAL
  zh: 从接口设计的角度来看，`qsort`丢弃了有用的信息。
- en: We can do better (in C++98)
  id: totrans-4482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好（在C++98中）
- en: '[PRE608]'
  id: totrans-4483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: Here, we use the compiler’s knowledge about the size of the array, the type
    of elements, and how to compare `double`s.
  id: totrans-4484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了编译器关于数组大小、元素类型以及如何比较`double`的知识。
- en: With C++20, we can do better still
  id: totrans-4485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++20，我们还能做得更好
- en: '[PRE609]'
  id: totrans-4486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: 'The key is to pass sufficient information for a good implementation to be chosen.
    In this, the `sort` interfaces shown here still have a weakness: They implicitly
    rely on the element type having less-than (`<`) defined. To complete the interface,
    we need a second version that accepts a comparison criterion:'
  id: totrans-4487
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是传递足够的信息，以便选择一个好的实现。在这方面，这里显示的`sort`接口仍然存在弱点：它们隐式地依赖于元素类型已定义小于（`<`）操作。为了完善接口，我们需要第二个版本，它接受比较标准：
- en: '[PRE610]'
  id: totrans-4488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: The standard-library specification of `sort` offers those two versions, and
    more.
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库对`sort`的规范提供了这两个版本，以及更多。
- en: Note
  id: totrans-4490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注释
- en: Premature optimization is said to be [the root of all evil](#rper-knuth), but
    that’s not a reason to despise performance. It is never premature to consider
    what makes a design amenable to improvement, and improved performance is a commonly
    desired improvement. Aim to build a set of habits that by default results in efficient,
    maintainable, and optimizable code. In particular, when you write a function that
    is not a one-off implementation detail, consider
  id: totrans-4491
  prefs: []
  type: TYPE_NORMAL
  zh: 过早的优化被认为是所有邪恶的根源（#rper-knuth），但这并不是轻视性能的理由。考虑什么使设计易于改进永远不会太早，改进的性能是一个普遍期望的改进。旨在建立一个习惯，默认情况下会产生高效、可维护和可优化的代码。特别是，当你编写一个不是一次性实现细节的函数时，考虑
- en: 'Information passing: Prefer clean [interfaces](#s-interfaces) carrying sufficient
    information for later improvement of implementation. Note that information flows
    into and out of an implementation through the interfaces we provide.'
  id: totrans-4492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息传递：优先选择携带足够信息以便以后改进实现的清晰[接口](#s-interfaces)。请注意，信息通过我们提供的接口流入和流出实现。
- en: 'Compact data: By default, [use compact data](#rper-compact), such as `std::vector`
    and [access it in a systematic fashion](#rper-access). If you think you need a
    linked structure, try to craft the interface so that this structure isn’t seen
    by users.'
  id: totrans-4493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧凑数据：默认情况下，[使用紧凑数据](#rper-compact)，例如 `std::vector`，并以系统化的方式[访问它](#rper-access)。如果你认为你需要一个链接结构，尝试设计接口以便用户看不到这个结构。
- en: 'Function argument passing and return: Distinguish between mutable and non-mutable
    data. Don’t impose a resource management burden on your users. Don’t impose spurious
    run-time indirections on your users. Use [conventional ways](#rf-conventional)
    of passing information through an interface; unconventional and/or “optimized”
    ways of passing data can seriously complicate later reimplementation.'
  id: totrans-4494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数传递和返回：区分可变数据和不可变数据。不要给用户强加资源管理负担。不要在用户上强加虚假的运行时间接引用。使用[传统方式](#rf-conventional)通过接口传递信息；非传统和/或“优化”的传递数据方式可能会严重复杂化后续的重实现。
- en: 'Abstraction: Don’t overgeneralize; a design that tries to cater for every possible
    use (and misuse) and defers every design decision for later (using compile-time
    or run-time indirections) is usually a complicated, bloated, hard-to-understand
    mess. Generalize from concrete examples, preserving performance as we generalize.
    Do not generalize based on mere speculation about future needs. The ideal is zero-overhead
    generalization.'
  id: totrans-4495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象：不要过度泛化；一个试图满足所有可能用途（包括误用）并推迟每个设计决策（使用编译时或运行时间接引用）的设计通常是一个复杂、臃肿、难以理解的混乱。从具体例子中泛化，在泛化的同时保留性能。不要基于对未来需求的纯粹推测进行泛化。理想的情况是零开销泛化。
- en: 'Libraries: Use libraries with good interfaces. If no library is available build
    one yourself and imitate the interface style from a good library. The [standard
    library](#sl-the-standard-library) is a good first place to look for inspiration.'
  id: totrans-4496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库：使用具有良好接口的库。如果没有可用的库，自己构建一个并模仿一个良好库的接口风格。[标准库](#sl-the-standard-library)是一个寻找灵感的良好起点。
- en: 'Isolation: Isolate your code from messy and/or old-style code by providing
    an interface of your choosing to it. This is sometimes called “providing a wrapper”
    for the useful/necessary but messy code. Don’t let bad designs “bleed into” your
    code.'
  id: totrans-4497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离：通过提供你选择的接口来隔离你的代码与混乱和/或旧式代码。这有时被称为为有用/必要但混乱的代码“提供包装”。不要让不良设计“渗透”到你的代码中。
- en: Example
  id: totrans-4498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider:'
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE611]'
  id: totrans-4500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '`binary_search(begin(c), end(c), 7)` will tell you whether `7` is in `c` or
    not. However, it will not tell you where that `7` is or whether there are more
    than one `7`.'
  id: totrans-4501
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_search(begin(c), end(c), 7)` 将告诉你 `7` 是否在 `c` 中。然而，它不会告诉你那个 `7` 在哪里，或者是否有多个
    `7`。'
- en: Sometimes, just passing the minimal amount of information back (here, `true`
    or `false`) is sufficient, but a good interface passes needed information back
    to the caller. Therefore, the standard library also offers
  id: totrans-4502
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅仅传递最少量的信息（在这里是 `true` 或 `false`）就足够了，但一个好的接口会将所需信息传递回调用者。因此，标准库也提供了
- en: '[PRE612]'
  id: totrans-4503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '`lower_bound` returns an iterator to the first match if any, otherwise to the
    first element greater than `val`, or `last` if no such element is found.'
  id: totrans-4504
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower_bound` 如果有任何匹配项，返回第一个匹配项的迭代器，否则返回大于 `val` 的第一个元素的迭代器，如果没有这样的元素，则返回 `last`。'
- en: However, `lower_bound` still doesn’t return enough information for all uses,
    so the standard library also offers
  id: totrans-4505
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`lower_bound` 仍然没有为所有用途提供足够的信息，因此标准库还提供了
- en: '[PRE613]'
  id: totrans-4506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '`equal_range` returns a `pair` of iterators specifying the first and one beyond
    last match.'
  id: totrans-4507
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal_range` 返回一个迭代器对，指定第一个匹配项和超出最后一个匹配项的迭代器。'
- en: '[PRE614]'
  id: totrans-4508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: Obviously, these three interfaces are implemented by the same basic code. They
    are simply three ways of presenting the basic binary search algorithm to users,
    ranging from the simplest (“make simple things simple!”) to returning complete,
    but not always needed, information (“don’t hide useful information”). Naturally,
    crafting such a set of interfaces requires experience and domain knowledge.
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这三个接口是由相同的基本代码实现的。它们只是向用户展示基本二分搜索算法的三种方式，从最简单的（“使简单的事情简单！”）到返回完整但并非总是需要的信息（“不要隐藏有用的信息”）。自然地，制作这样一套接口需要经验和领域知识。
- en: Note
  id: totrans-4510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Do not simply craft the interface to match the first implementation and the
    first use case you think of. Once your first initial implementation is complete,
    review it; once you deploy it, mistakes will be hard to remedy.
  id: totrans-4511
  prefs: []
  type: TYPE_NORMAL
  zh: 不要简单地根据第一个实现和第一个想到的使用案例来设计接口。一旦你的第一个初始实现完成，请对其进行审查；一旦部署，错误将难以修复。
- en: Note
  id: totrans-4512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A need for efficiency does not imply a need for [low-level code](#rper-low).
    High-level code isn’t necessarily slow or bloated.
  id: totrans-4513
  prefs: []
  type: TYPE_NORMAL
  zh: 需要效率并不一定意味着需要[低级代码](#rper-low)。高级代码并不一定慢或臃肿。
- en: Note
  id: totrans-4514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Things have costs. Don’t be paranoid about costs (modern computers really are
    very fast), but have a rough idea of the order of magnitude of cost of what you
    use. For example, have a rough idea of the cost of a memory access, a function
    call, a string comparison, a system call, a disk access, and a message through
    a network.
  id: totrans-4515
  prefs: []
  type: TYPE_NORMAL
  zh: 事物都有成本。不要对成本过于担忧（现代计算机确实非常快），但要对你所使用的成本的大致数量级有一个粗略的了解。例如，对内存访问、函数调用、字符串比较、系统调用、磁盘访问以及通过网络的消息的成本有一个大致的了解。
- en: Note
  id: totrans-4516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you can only think of one implementation, you probably don’t have something
    for which you can devise a stable interface. Maybe, it is just an implementation
    detail - not every piece of code needs a stable interface - but pause and consider.
    One question that can be useful is “what interface would be needed if this operation
    should be implemented using multiple threads? be vectorized?”
  id: totrans-4517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只能想到一种实现方式，你可能没有可以设计稳定接口的东西。也许，它只是实现细节——并不是每一块代码都需要稳定接口——但请停下来思考。一个可能有用的问题是：“如果这个操作应该使用多线程或向量化的方式实现，需要什么样的接口？”
- en: Note
  id: totrans-4518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This rule does not contradict the [Don’t optimize prematurely](#rper-knuth)
    rule. It complements it, encouraging developers to enable later - appropriate
    and non-premature - optimization, if and where needed.
  id: totrans-4519
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则并不与[不要过早优化](#rper-knuth)规则相矛盾。它是其补充，鼓励开发者根据需要启用后续——适当且非过早——的优化。
- en: Enforcement
  id: totrans-4520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Tricky. Maybe looking for `void*` function arguments will find examples of interfaces
    that hinder later optimization.
  id: totrans-4521
  prefs: []
  type: TYPE_NORMAL
  zh: 难以捉摸。也许寻找`void*`函数参数将找到阻碍后续优化的接口示例。
- en: 'Per.10: Rely on the static type system'
  id: totrans-4522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10点：依赖静态类型系统
- en: Reason
  id: totrans-4523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Type violations, weak types (e.g. `void*`s), and low-level code (e.g., manipulation
    of sequences as individual bytes) make the job of the optimizer much harder. Simple
    code often optimizes better than hand-crafted complex code.
  id: totrans-4524
  prefs: []
  type: TYPE_NORMAL
  zh: 类型违规、弱类型（例如`void*`）和低级代码（例如，将序列作为单个字节进行操作）使优化器的工作变得更加困难。简单的代码通常比手工编写的复杂代码优化得更好。
- en: ???
  id: totrans-4525
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.11: Move computation from run time to compile time'
  id: totrans-4526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第11点：将计算从运行时移至编译时
- en: Reason
  id: totrans-4527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To decrease code size and run time. To avoid data races by using constants.
    To catch errors at compile time (and thus eliminate the need for error-handling
    code).
  id: totrans-4528
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减小代码大小和运行时间。通过使用常量来避免数据竞争。在编译时捕获错误（从而消除错误处理代码的需求）。
- en: Example
  id: totrans-4529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE615]'
  id: totrans-4530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: 'Code like the initialization of `s2` isn’t uncommon, especially for initialization
    that’s a bit more complicated than `square()`. However, compared to the initialization
    of `s3` there are two problems:'
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`s2`初始化的代码并不少见，尤其是对于比`square()`稍微复杂一点的初始化。然而，与`s3`的初始化相比，有两个问题：
- en: we suffer the overhead of a function call at run time
  id: totrans-4532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在运行时承担了函数调用的开销
- en: '`s2` just might be accessed by another thread before the initialization happens.'
  id: totrans-4533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s2`在初始化发生之前可能被另一个线程访问。'
- en: 'Note: you can’t have a data race on a constant.'
  id: totrans-4534
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在常量上不能发生数据竞争。
- en: Example
  id: totrans-4535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Consider a popular technique for providing a handle for storing small objects
    in the handle itself and larger ones on the heap.
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种流行的技术，即通过句柄本身存储小对象，在堆上存储大对象。
- en: '[PRE616]'
  id: totrans-4537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: Assume that `Scoped` and `On_heap` provide compatible user interfaces. Here
    we compute the optimal type to use at compile time. There are similar techniques
    for selecting the optimal function to call.
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Scoped`和`On_heap`提供了兼容的用户接口。在这里，我们在编译时计算最优的类型。还有类似的技术用于选择要调用的最优函数。
- en: Note
  id: totrans-4539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The ideal is *not* to try to execute everything at compile time. Obviously,
    most computations depend on inputs, so they can’t be moved to compile time, but
    beyond that logical constraint is the fact that complex compile-time computation
    can seriously increase compile times and complicate debugging. It is even possible
    to slow down code by compile-time computation. This is admittedly rare, but by
    factoring out a general computation into separate optimal sub-calculations, it
    is possible to render the instruction cache less effective.
  id: totrans-4540
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的情况不是尝试在编译时执行一切。显然，大多数计算依赖于输入，因此它们不能移至编译时，但除此之外还有这样一个事实：复杂的编译时计算可能会严重增加编译时间并使调试复杂化。甚至可能通过编译时计算来减慢代码。这虽然很少见，但通过将通用计算分解为单独的最优子计算，可以使指令缓存变得不那么有效。
- en: Enforcement
  id: totrans-4541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Look for simple functions that might be constexpr (but are not).
  id: totrans-4542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找可能是constexpr（但不是）的简单函数。
- en: Look for functions called with all constant-expression arguments.
  id: totrans-4543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找所有参数都是常量表达式参数的函数。
- en: Look for macros that could be constexpr.
  id: totrans-4544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找可以声明为constexpr的宏。
- en: 'Per.12: Eliminate redundant aliases'
  id: totrans-4545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.12: 消除冗余别名'
- en: ???
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.13: Eliminate redundant indirections'
  id: totrans-4547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.13: 消除冗余间接引用'
- en: ???
  id: totrans-4548
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.14: Minimize the number of allocations and deallocations'
  id: totrans-4549
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.14: 最小化分配和释放的数量'
- en: ???
  id: totrans-4550
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.15: Do not allocate on a critical branch'
  id: totrans-4551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.15: 不要在关键分支上分配'
- en: ???
  id: totrans-4552
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.16: Use compact data structures'
  id: totrans-4553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.16: 使用紧凑的数据结构'
- en: Reason
  id: totrans-4554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Performance is typically dominated by memory access times.
  id: totrans-4555
  prefs: []
  type: TYPE_NORMAL
  zh: 性能通常由内存访问时间主导。
- en: ???
  id: totrans-4556
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.17: Declare the most used member of a time-critical struct first'
  id: totrans-4557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.17: 首先声明时间关键结构中最常用的成员'
- en: ???
  id: totrans-4558
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.18: Space is time'
  id: totrans-4559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.18: 空间即时间'
- en: Reason
  id: totrans-4560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Performance is typically dominated by memory access times.
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
  zh: 性能通常由内存访问时间主导。
- en: ???
  id: totrans-4562
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Per.19: Access memory predictably'
  id: totrans-4563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.19: 可预测地访问内存'
- en: Reason
  id: totrans-4564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Performance is very sensitive to cache performance, and cache algorithms favor
    simple (usually linear) access to adjacent data.
  id: totrans-4565
  prefs: []
  type: TYPE_NORMAL
  zh: 性能对缓存性能非常敏感，缓存算法倾向于简单（通常是线性的）访问相邻数据。
- en: Example
  id: totrans-4566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE617]'
  id: totrans-4567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: 'Per.30: Avoid context switches on the critical path'
  id: totrans-4568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Per.30: 避免在关键路径上进行上下文切换'
- en: ???
  id: totrans-4569
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP: Concurrency and parallelism'
  id: totrans-4570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'CP: 并发和并行'
- en: We often want our computers to do many tasks at the same time (or at least appear
    to do them at the same time). The reasons for doing so vary (e.g., waiting for
    many events using only a single processor, processing many data streams simultaneously,
    or utilizing many hardware facilities) and so do the basic facilities for expressing
    concurrency and parallelism. Here, we articulate principles and rules for using
    the ISO standard C++ facilities for expressing basic concurrency and parallelism.
  id: totrans-4571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望计算机同时执行许多任务（或者至少看起来是同时执行），这样做的原因多种多样（例如，仅使用单个处理器等待许多事件，同时处理多个数据流，或利用许多硬件设施），表达并发和并行的基本设施也是如此。在这里，我们阐述了使用ISO标准C++设施表达基本并发和并行的原则和规则。
- en: Threads are the machine-level foundation for concurrent and parallel programming.
    Threads allow running multiple sections of a program independently, while sharing
    the same memory. Concurrent programming is tricky, because protecting shared data
    between threads is easier said than done. Making existing single-threaded code
    execute concurrently can be as trivial as adding `std::async` or `std::thread`
    strategically, or it can necessitate a full rewrite, depending on whether the
    original code was written in a thread-friendly way.
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是并发和并行编程的机器级基础。线程允许独立运行程序的多个部分，同时共享相同的内存。并发编程很棘手，因为保护线程间的共享数据说起来容易做起来难。使现有的单线程代码以并发方式执行可能只需战略性地添加`std::async`或`std::thread`，或者可能需要完全重写，这取决于原始代码是否以线程友好的方式编写。
- en: 'The concurrency/parallelism rules in this document are designed with three
    goals in mind:'
  id: totrans-4573
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档中的并发/并行规则旨在实现三个目标：
- en: To help in writing code that is amenable to being used in a threaded environment
  id: totrans-4574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了帮助编写适用于线程环境的代码
- en: To show clean, safe ways to use the threading primitives offered by the standard
    library
  id: totrans-4575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了展示使用标准库提供的线程原语干净、安全的使用方式
- en: To offer guidance on what to do when concurrency and parallelism aren’t giving
    the performance gains needed
  id: totrans-4576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当并发和并行性没有带来所需的性能提升时，提供指导说明应该做什么
- en: It is also important to note that concurrency in C++ is an unfinished story.
    C++11 introduced many core concurrency primitives, C++14 and C++17 improved on
    them, and there is much interest in making the writing of concurrent programs
    in C++ even easier. We expect some of the library-related guidance here to change
    significantly over time.
  id: totrans-4577
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，C++中的并发是一个未完成的故事。C++11引入了许多核心并发原语，C++14和C++17对其进行了改进，并且有许多兴趣使C++中的并发程序编写更加容易。我们预计这里的一些库相关指导随着时间的推移将发生重大变化。
- en: This section needs a lot of work (obviously). Please note that we start with
    rules for relative non-experts. Real experts must wait a bit; contributions are
    welcome, but please think about the majority of programmers who are struggling
    to get their concurrent programs correct and performant.
  id: totrans-4578
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节需要大量工作（显然）。请注意，我们首先从针对相对非专家的规则开始。真正的专家必须稍等一下；欢迎贡献，但请考虑大多数努力使并发程序正确且性能良好的程序员。
- en: 'Concurrency and parallelism rule summary:'
  id: totrans-4579
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行规则摘要：
- en: '[CP.1: Assume that your code will run as part of a multi-threaded program](#rconc-multi)'
  id: totrans-4580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.1: 假设你的代码将作为多线程程序的一部分运行](#rconc-multi)'
- en: '[CP.2: Avoid data races](#rconc-races)'
  id: totrans-4581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.2: 避免数据竞争](#rconc-races)'
- en: '[CP.3: Minimize explicit sharing of writable data](#rconc-data)'
  id: totrans-4582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.3: 最小化可写数据的显式共享](#rconc-data)'
- en: '[CP.4: Think in terms of tasks, rather than threads](#rconc-task)'
  id: totrans-4583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.4: 以任务而非线程为思考单位](#rconc-task)'
- en: '[CP.8: Don’t try to use `volatile` for synchronization](#rconc-volatile)'
  id: totrans-4584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.8: 不要尝试使用 `volatile` 进行同步](#rconc-volatile)'
- en: '[CP.9: Whenever feasible use tools to validate your concurrent code](#rconc-tools)'
  id: totrans-4585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.9: 在可行的情况下使用工具验证你的并发代码](#rconc-tools)'
- en: '**See also**:'
  id: totrans-4586
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**：'
- en: '[CP.con: Concurrency](#sscp-con)'
  id: totrans-4587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.con: 并发](#sscp-con)'
- en: '[CP.coro: Coroutines](#sscp-coro)'
  id: totrans-4588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.coro: 协程](#sscp-coro)'
- en: '[CP.par: Parallelism](#sscp-par)'
  id: totrans-4589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.par: 并行](#sscp-par)'
- en: '[CP.mess: Message passing](#sscp-mess)'
  id: totrans-4590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.mess: 消息传递](#sscp-mess)'
- en: '[CP.vec: Vectorization](#sscp-vec)'
  id: totrans-4591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.vec: 向量化](#sscp-vec)'
- en: '[CP.free: Lock-free programming](#sscp-free)'
  id: totrans-4592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.free: 无锁编程](#sscp-free)'
- en: '[CP.etc: Etc. concurrency rules](#sscp-etc)'
  id: totrans-4593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.etc: 等等并发规则](#sscp-etc)'
- en: 'CP.1: Assume that your code will run as part of a multi-threaded program'
  id: totrans-4594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.1: 假设你的代码将作为多线程程序的一部分运行'
- en: Reason
  id: totrans-4595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s hard to be certain that concurrency isn’t used now or won’t be used sometime
    in the future. Code gets reused. Libraries not using threads might be used from
    some other part of a program that does use threads. Note that this rule applies
    most urgently to library code and least urgently to stand-alone applications.
    However, over time, code fragments can turn up in unexpected places.
  id: totrans-4596
  prefs: []
  type: TYPE_NORMAL
  zh: 很难确定并发现在没有被使用，或者将来某个时候不会被使用。代码会被重用。不使用线程的库可能被程序的其他部分使用，而这些部分使用线程。请注意，这条规则对库代码的适用性最为紧迫，对独立应用程序的适用性最不紧迫。然而，随着时间的推移，代码片段可能会出现在意想不到的地方。
- en: Example, bad
  id: totrans-4597
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE618]'
  id: totrans-4598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: Although `cached_computation` works perfectly in a single-threaded environment,
    in a multi-threaded environment the two `static` variables result in data races
    and thus undefined behavior.
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `cached_computation` 在单线程环境中工作得很好，但在多线程环境中，两个 `static` 变量会导致数据竞争，从而产生未定义的行为。
- en: Example, good
  id: totrans-4600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE619]'
  id: totrans-4601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: 'Here the cache is stored as member data of a `ComputationCache` object, rather
    than as shared static state. This refactoring essentially delegates the concern
    upward to the caller: a single-threaded program might still choose to have one
    global `ComputationCache`, while a multi-threaded program might have one `ComputationCache`
    instance per thread, or one per “context” for any definition of “context.” The
    refactored function no longer attempts to manage the allocation of `cached_x`.
    In that sense, this is an application of the Single Responsibility Principle.'
  id: totrans-4602
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，缓存被存储为 `ComputationCache` 对象的成员数据，而不是作为共享的静态状态。这种重构本质上是将关注点向上委托给调用者：单线程程序可能仍然选择有一个全局的
    `ComputationCache`，而多线程程序可能每个线程有一个 `ComputationCache` 实例，或者每个“上下文”有一个实例（这里的“上下文”可以定义为任何含义）。重构后的函数不再尝试管理
    `cached_x` 的分配。从这个意义上说，这是一个单职责原则的应用。
- en: In this specific example, refactoring for thread-safety also improved reusability
    in single-threaded programs. It’s not hard to imagine that a single-threaded program
    might want two `ComputationCache` instances for use in different parts of the
    program, without having them overwrite each other’s cached data.
  id: totrans-4603
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，为了线程安全进行的重构也提高了单线程程序的可重用性。不难想象，单线程程序可能希望在程序的不同部分使用两个 `ComputationCache`
    实例，而不让它们覆盖彼此的缓存数据。
- en: 'There are several other ways one might add thread-safety to code written for
    a standard multi-threaded environment (that is, one where the only form of concurrency
    is `std::thread`):'
  id: totrans-4604
  prefs: []
  type: TYPE_NORMAL
  zh: 为标准多线程环境（即，只有 `std::thread` 形式的并发）编写的代码添加线程安全性的方法有几个：
- en: Mark the state variables as `thread_local` instead of `static`.
  id: totrans-4605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态变量标记为 `thread_local` 而不是 `static`。
- en: Implement concurrency control, for example, protecting access to the two `static`
    variables with a `static std::mutex`.
  id: totrans-4606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现并发控制，例如，使用 `static std::mutex` 保护对两个 `static` 变量的访问。
- en: Refuse to build and/or run in a multi-threaded environment.
  id: totrans-4607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝在多线程环境中构建和/或运行。
- en: 'Provide two implementations: one for single-threaded environments and another
    for multi-threaded environments.'
  id: totrans-4608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供两个实现：一个用于单线程环境，另一个用于多线程环境。
- en: Exception
  id: totrans-4609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Code that is never run in a multi-threaded environment.
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
  zh: 从未在多线程环境中运行的代码。
- en: 'Be careful: there are many examples where code that was “known” to never run
    in a multi-threaded program was run as part of a multi-threaded program, often
    years later. Typically, such programs lead to a painful effort to remove data
    races. Therefore, code that is never intended to run in a multi-threaded environment
    should be clearly labeled as such and ideally come with compile or run-time enforcement
    mechanisms to catch those usage bugs early.'
  id: totrans-4611
  prefs: []
  type: TYPE_NORMAL
  zh: 小心：有许多例子表明，那些“已知”永远不会在多线程程序中运行的代码，作为多线程程序的一部分运行，通常是在多年之后。通常，这样的程序会导致痛苦的努力来移除数据竞争。因此，那些从未打算在多线程环境中运行的代码应该清楚地标记为这样的，并且最好带有编译或运行时强制机制，以尽早捕获这些使用错误。
- en: 'CP.2: Avoid data races'
  id: totrans-4612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.2：避免数据竞争
- en: Reason
  id: totrans-4613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Unless you do, nothing is guaranteed to work and subtle errors will persist.
  id: totrans-4614
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你这样做，否则没有什么可以保证工作，微妙的错误将持续存在。
- en: Note
  id: totrans-4615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In a nutshell, if two threads can access the same object concurrently (without
    synchronization), and at least one is a writer (performing a non-`const` operation),
    you have a data race. For further information of how to use synchronization well
    to eliminate data races, please consult a good book about concurrency (see [Carefully
    study the literature](#rconc-literature)).
  id: totrans-4616
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果两个线程可以并发地访问同一个对象（没有同步），并且至少有一个是写者（执行非`const`操作），那么你就有一个数据竞争。有关如何使用同步来消除数据竞争的更多信息，请查阅一本关于并发的优秀书籍（参见[仔细研究文献](#rconc-literature)）。
- en: Example, bad
  id: totrans-4617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好
- en: 'There are many examples of data races that exist, some of which are running
    in production software at this very moment. One very simple example:'
  id: totrans-4618
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多数据竞争的例子，其中一些目前正在生产软件中运行。一个非常简单的例子：
- en: '[PRE620]'
  id: totrans-4619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: 'The increment here is an example of a data race. This can go wrong in many
    ways, including:'
  id: totrans-4620
  prefs: []
  type: TYPE_NORMAL
  zh: 这里增加的例子是一个数据竞争的例子。这可能会以许多方式出错，包括：
- en: Thread A loads the value of `id`, the OS context switches A out for some period,
    during which other threads create hundreds of IDs. Thread A is then allowed to
    run again, and `id` is written back to that location as A’s read of `id` plus
    one.
  id: totrans-4621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程A加载`id`的值，操作系统将A切换出去一段时间，在这段时间内，其他线程创建了数百个ID。然后允许线程A再次运行，并将`id`写回到该位置，作为A读取`id`并加一的值。
- en: Thread A and B load `id` and increment it simultaneously. They both get the
    same ID.
  id: totrans-4622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程A和B同时加载`id`并增加它。它们都得到相同的ID。
- en: Local static variables are a common source of data races.
  id: totrans-4623
  prefs: []
  type: TYPE_NORMAL
  zh: 局部静态变量是数据竞争的常见来源。
- en: 'Example, bad:'
  id: totrans-4624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好：
- en: '[PRE621]'
  id: totrans-4625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: Here, we have a (nasty) data race on the elements of `buf` (`sort` will both
    read and write). All data races are nasty. Here, we managed to get a data race
    on data on the stack. Not all data races are as easy to spot as this one.
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在`buf`的元素上有一个（讨厌的）数据竞争（`sort`将同时读取和写入）。所有数据竞争都很讨厌。在这里，我们设法在栈上的数据上得到了一个数据竞争。并不是所有的数据竞争都像这个那么容易发现。
- en: 'Example, bad:'
  id: totrans-4627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好：
- en: '[PRE622]'
  id: totrans-4628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: 'Now, a compiler that does not know that `val` can change will most likely implement
    that `switch` using a jump table with five entries. Then, a `val` outside the
    `[0..4]` range will cause a jump to an address that could be anywhere in the program,
    and execution would proceed there. Really, “all bets are off” if you get a data
    race. Actually, it can be worse still: by looking at the generated code you might
    be able to determine where the stray jump will go for a given value; this can
    be a security risk.'
  id: totrans-4629
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个不知道`val`可以改变的编译器很可能会使用具有五个条目的跳转表来实现那个`switch`。然后，一个超出`[0..4]`范围的`val`将导致跳转到程序中的任何地址，执行将从这个地址开始。实际上，如果你遇到数据竞争，“所有赌注都取消了”。实际上，情况可能更糟：通过查看生成的代码，你可能会确定给定值中随机跳转将去哪里；这可能会带来安全风险。
- en: Enforcement
  id: totrans-4630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Some is possible, do at least something. There are commercial and open-source
    tools that try to address this problem, but be aware that solutions have costs
    and blind spots. Static tools often have many false positives and run-time tools
    often have a significant cost. We hope for better tools. Using multiple tools
    can catch more problems than a single one.
  id: totrans-4631
  prefs: []
  type: TYPE_NORMAL
  zh: 有些是可能的，至少做点什么。有商业和开源工具试图解决这个问题，但请注意，解决方案有成本和盲点。静态工具通常有很多误报，而运行时工具通常有显著的成本。我们希望有更好的工具。使用多个工具可以比单个工具捕获更多的问题。
- en: 'There are other ways you can mitigate the chance of data races:'
  id: totrans-4632
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有其他方法可以减轻数据竞争的可能性：
- en: Avoid global data
  id: totrans-4633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免全局数据
- en: Avoid `static` variables
  id: totrans-4634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用`static`变量
- en: More use of concrete types on the stack (and don’t pass pointers around too
    much)
  id: totrans-4635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈上使用更多具体类型（并且不要过多传递指针）
- en: More use of immutable data (literals, `constexpr`, and `const`)
  id: totrans-4636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多使用不可变数据（字面量、`constexpr`和`const`）
- en: 'CP.3: Minimize explicit sharing of writable data'
  id: totrans-4637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.3：最小化可写数据的显式共享
- en: Reason
  id: totrans-4638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you don’t share writable data, you can’t have a data race. The less sharing
    you do, the less chance you have to forget to synchronize access (and get data
    races). The less sharing you do, the less chance you have to wait on a lock (so
    performance can improve).
  id: totrans-4639
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有共享可写数据，你就不会发生数据竞争。你共享得越少，忘记同步访问（并得到数据竞争）的机会就越小。你共享得越少，等待锁的机会就越小（因此性能可以提升）。
- en: Example
  id: totrans-4640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE623]'
  id: totrans-4641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: Without those `const`s, we would have to review every asynchronously invoked
    function for potential data races on `surface_readings`. Making `surface_readings`
    be `const` (with respect to this function) allows reasoning using only the function
    body.
  id: totrans-4642
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些 `const`，我们就必须审查每个异步调用的函数，以检查 `surface_readings` 上可能的数据竞争。使 `surface_readings`
    成为 `const`（相对于这个函数）允许只使用函数体进行推理。
- en: Note
  id: totrans-4643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Immutable data can be safely and efficiently shared. No locking is needed:
    You can’t have a data race on a constant. See also [CP.mess: Message Passing](#sscp-mess)
    and [CP.31: prefer pass by value](#rconc-data-by-value).'
  id: totrans-4644
  prefs: []
  type: TYPE_NORMAL
  zh: '不可变数据可以安全且高效地共享。不需要加锁：你不可能在常量上发生数据竞争。参见[CP.mess: 消息传递](#sscp-mess)和[CP.31：优先使用值传递](#rconc-data-by-value)。'
- en: Enforcement
  id: totrans-4645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4646
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.4: Think in terms of tasks, rather than threads'
  id: totrans-4647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.4：用任务而不是线程来思考
- en: Reason
  id: totrans-4648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A `thread` is an implementation concept, a way of thinking about the machine.
    A task is an application notion, something you’d like to do, preferably concurrently
    with other tasks. Application concepts are easier to reason about.
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `线程` 是一种实现概念，是思考机器的一种方式。一个 `任务` 是一种应用概念，是你想做的事情，最好是与其他任务同时进行。应用概念更容易推理。
- en: Example
  id: totrans-4650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE624]'
  id: totrans-4651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: Note
  id: totrans-4652
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'With the exception of `async()`, the standard-library facilities are low-level,
    machine-oriented, threads-and-lock level. This is a necessary foundation, but
    we have to try to raise the level of abstraction: for productivity, for reliability,
    and for performance. This is a potent argument for using higher level, more applications-oriented
    libraries (if possible, built on top of standard-library facilities).'
  id: totrans-4653
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `async()` 之外，标准库设施是低级的，面向机器的，线程和锁级别的。这是一个必要的基石，但我们必须努力提高抽象级别：为了生产力，为了可靠性，为了性能。这是使用更高级、更面向应用的库（如果可能的话，建立在标准库设施之上）的有力论据。
- en: Enforcement
  id: totrans-4654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4655
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.8: Don’t try to use `volatile` for synchronization'
  id: totrans-4656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.8：不要尝试使用 `volatile` 进行同步
- en: Reason
  id: totrans-4657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: In C++, unlike some other languages, `volatile` does not provide atomicity,
    does not synchronize between threads, and does not prevent instruction reordering
    (neither compiler nor hardware). It simply has nothing to do with concurrency.
  id: totrans-4658
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，与某些其他语言不同，`volatile` 不提供原子性，不在线程之间同步，也不防止指令重排（既不是编译器也不是硬件）。它只是与并发无关。
- en: 'Example, bad:'
  id: totrans-4659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好：
- en: '[PRE625]'
  id: totrans-4660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: 'Here we have a problem: This is perfectly good code in a single-threaded program,
    but have two threads execute this and there is a race condition on `free_slots`
    so that two threads might get the same value and `free_slots`. That’s (obviously)
    a bad data race, so people trained in other languages might try to fix it like
    this:'
  id: totrans-4661
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个问题：这是一个单线程程序中的完美代码，但如果有两个线程执行这个操作，那么在 `free_slots` 上就会发生竞争条件，因此两个线程可能会得到相同的值和
    `free_slots`。这显然是一个坏的数据竞争，所以受过其他语言训练的人可能会尝试像这样修复它：
- en: '[PRE626]'
  id: totrans-4662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: 'This has no effect on synchronization: The data race is still there!'
  id: totrans-4663
  prefs: []
  type: TYPE_NORMAL
  zh: 这对同步没有影响：数据竞争仍然存在！
- en: 'The C++ mechanism for this is `atomic` types:'
  id: totrans-4664
  prefs: []
  type: TYPE_NORMAL
  zh: C++中实现这一机制的是 `atomic` 类型：
- en: '[PRE627]'
  id: totrans-4665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: Now the `--` operation is atomic, rather than a read-increment-write sequence
    where another thread might get in-between the individual operations.
  id: totrans-4666
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `--` 操作是原子的，而不是一个读取-增加-写入序列，在这个过程中另一个线程可能会在各个操作之间插入。
- en: Alternative
  id: totrans-4667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Use `atomic` types where you might have used `volatile` in some other language.
    Use a `mutex` for more complicated examples.
  id: totrans-4668
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可能使用其他语言中的 `volatile` 的情况下使用 `atomic` 类型。对于更复杂的例子，使用 `mutex`。
- en: See also
  id: totrans-4669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参见
- en: '[(rare) proper uses of `volatile`](#rconc-volatile2)'
  id: totrans-4670
  prefs: []
  type: TYPE_NORMAL
  zh: '[(罕见的) `volatile` 的正确使用](#rconc-volatile2)'
- en: 'CP.9: Whenever feasible use tools to validate your concurrent code'
  id: totrans-4671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.9：在可行的情况下使用工具验证你的并发代码
- en: Experience shows that concurrent code is exceptionally hard to get right and
    that compile-time checking, run-time checks, and testing are less effective at
    finding concurrency errors than they are at finding errors in sequential code.
    Subtle concurrency errors can have dramatically bad effects, including memory
    corruption, deadlocks, and security vulnerabilities.
  id: totrans-4672
  prefs: []
  type: TYPE_NORMAL
  zh: 经验表明，并发代码特别难以正确实现，而编译时检查、运行时检查和测试在发现并发错误方面不如发现顺序代码错误有效。微妙的并发错误可能产生严重影响，包括内存损坏、死锁和安全漏洞。
- en: Example
  id: totrans-4673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE628]'
  id: totrans-4674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: Note
  id: totrans-4675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Thread safety is challenging, often getting the better of experienced programmers:
    tooling is an important strategy to mitigate those risks. There are many tools
    “out there”, both commercial and open-source tools, both research and production
    tools. Unfortunately people’s needs and constraints differ so dramatically that
    we cannot make specific recommendations, but we can mention:'
  id: totrans-4676
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全具有挑战性，经常让经验丰富的程序员陷入困境：工具是减轻这些风险的重要策略。有许多工具“在那里”，包括商业和开源工具，研究和生产工具。不幸的是，由于人们的需求和约束差异很大，我们无法提出具体的建议，但我们可以提到：
- en: 'Static enforcement tools: both [clang](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html)
    and some older versions of [GCC](https://gcc.gnu.org/wiki/ThreadSafetyAnnotation)
    have some support for static annotation of thread safety properties. Consistent
    use of this technique turns many classes of thread-safety errors into compile-time
    errors. The annotations are generally local (marking a particular data member
    as guarded by a particular mutex), and are usually easy to learn. However, as
    with many static tools, it can often present false negatives; cases that should
    have been caught but were allowed.'
  id: totrans-4677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态强制工具：[clang](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html) 和一些较老的
    [GCC](https://gcc.gnu.org/wiki/ThreadSafetyAnnotation) 版本都提供对线程安全属性静态注解的支持。一致地使用这种技术可以将许多类别的线程安全错误转换为编译时错误。这些注解通常是局部的（标记特定的数据成员由特定的互斥锁保护），并且通常容易学习。然而，就像许多静态工具一样，它往往会出现假阴性；应该被捕获但被允许的情况。
- en: 'dynamic enforcement tools: Clang’s [Thread Sanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)
    (aka TSAN) is a powerful example of dynamic tools: it changes the build and execution
    of your program to add bookkeeping on memory access, absolutely identifying data
    races in a given execution of your binary. The cost for this is both memory (5-10x
    in most cases) and CPU slowdown (2-20x). Dynamic tools like this are best when
    applied to integration tests, canary pushes, or unit tests that operate on multiple
    threads. Workload matters: When TSAN identifies a problem, it is effectively always
    an actual data race, but it can only identify races seen in a given execution.'
  id: totrans-4678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态强制工具：Clang 的 [Thread Sanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)（简称
    TSAN）是动态工具的一个强大例子：它更改了程序的构建和执行，以在内存访问上添加账本，在给定二进制执行中绝对识别数据竞争。这种做法的代价是内存（在大多数情况下为
    5-10 倍）和 CPU 速度降低（2-20 倍）。这种类型的动态工具最好应用于集成测试、金丝雀推送或操作多线程的单元测试。工作负载很重要：当 TSAN 识别到问题时，它实际上总是实际的数据竞争，但它只能识别在给定执行中看到的竞争。
- en: Enforcement
  id: totrans-4679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: It is up to an application builder to choose which support tools are valuable
    for a particular application.
  id: totrans-4680
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪些支持工具对特定应用程序有价值取决于应用程序构建者。
- en: 'CP.con: Concurrency'
  id: totrans-4681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CP.con：并发
- en: This section focuses on relatively ad-hoc uses of multiple threads communicating
    through shared data.
  id: totrans-4682
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点关注相对临时的多线程通过共享数据通信的使用。
- en: For parallel algorithms, see [parallelism](#sscp-par)
  id: totrans-4683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于并行算法，请参阅 [parallelism](#sscp-par)
- en: For inter-task communication without explicit sharing, see [messaging](#sscp-mess)
  id: totrans-4684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不涉及显式共享的跨任务通信，请参阅[messaging](#sscp-mess)
- en: For vector parallel code, see [vectorization](#sscp-vec)
  id: totrans-4685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于向量并行代码，请参阅 [vectorization](#sscp-vec)
- en: For lock-free programming, see [lock free](#sscp-free)
  id: totrans-4686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于无锁编程，请参阅 [lock free](#sscp-free)
- en: 'Concurrency rule summary:'
  id: totrans-4687
  prefs: []
  type: TYPE_NORMAL
  zh: 并发规则摘要：
- en: '[CP.20: Use RAII, never plain `lock()`/`unlock()`](#rconc-raii)'
  id: totrans-4688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.20：使用 RAII，而不是 plain `lock()`/`unlock()`](#rconc-raii)'
- en: '[CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es](#rconc-lock)'
  id: totrans-4689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.21：使用 `std::lock()` 或 `std::scoped_lock` 来获取多个 `mutex`](#rconc-lock)'
- en: '[CP.22: Never call unknown code while holding a lock (e.g., a callback)](#rconc-unknown)'
  id: totrans-4690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.22：在持有锁的情况下不要调用未知代码（例如，回调）](#rconc-unknown)'
- en: '[CP.23: Think of a joining `thread` as a scoped container](#rconc-join)'
  id: totrans-4691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.23：将连接的 `thread` 视为一个作用域容器](#rconc-join)'
- en: '[CP.24: Think of a `thread` as a global container](#rconc-detach)'
  id: totrans-4692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.24：将 `thread` 视为一个全局容器](#rconc-detach)'
- en: '[CP.25: Prefer `gsl::joining_thread` over `std::thread`](#rconc-joining_thread)'
  id: totrans-4693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.25: 优先使用`gsl::joining_thread`而不是`std::thread`](#rconc-joining_thread)'
- en: '[CP.26: Don’t `detach()` a thread](#rconc-detached_thread)'
  id: totrans-4694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.26: 不要`detach()`线程](#rconc-detached_thread)'
- en: '[CP.31: Pass small amounts of data between threads by value, rather than by
    reference or pointer](#rconc-data-by-value)'
  id: totrans-4695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.31: 通过值传递少量数据而不是通过引用或指针在线程之间传递数据](#rconc-data-by-value)'
- en: '[CP.32: To share ownership between unrelated `thread`s use `shared_ptr`](#rconc-shared)'
  id: totrans-4696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.32: 在无关的`thread`之间共享所有权时使用`shared_ptr`](#rconc-shared)'
- en: '[CP.40: Minimize context switching](#rconc-switch)'
  id: totrans-4697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.40: 最小化上下文切换](#rconc-switch)'
- en: '[CP.41: Minimize thread creation and destruction](#rconc-create)'
  id: totrans-4698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.41: 最小化线程的创建和销毁](#rconc-create)'
- en: '[CP.42: Don’t `wait` without a condition](#rconc-wait)'
  id: totrans-4699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.42: 不要无条件地`等待`](#rconc-wait)'
- en: '[CP.43: Minimize time spent in a critical section](#rconc-time)'
  id: totrans-4700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.43: 最小化在临界区的时间](#rconc-time)'
- en: '[CP.44: Remember to name your `lock_guard`s and `unique_lock`s](#rconc-name)'
  id: totrans-4701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.44: 记得给你的`lock_guard`s和`unique_lock`s命名](#rconc-name)'
- en: '[CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>`
    where possible](#rconc-mutex)'
  id: totrans-4702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.50: 定义一个与保护的数据一起的`mutex`。尽可能使用`synchronized_value<T>`](#rconc-mutex)'
- en: ??? when to use a spinlock
  id: totrans-4703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? 何时使用自旋锁
- en: ??? when to use `try_lock()`
  id: totrans-4704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? 何时使用`try_lock()`
- en: ??? when to prefer `lock_guard` over `unique_lock`
  id: totrans-4705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? 何时优先使用`lock_guard`而不是`unique_lock`
- en: ??? Time multiplexing
  id: totrans-4706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? 时间多路复用
- en: ??? when/how to use `new thread`
  id: totrans-4707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? 何时/如何使用`new thread`
- en: 'CP.20: Use RAII, never plain `lock()`/`unlock()`'
  id: totrans-4708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.20: 使用RAII，永远不要使用纯`lock()`/`unlock()`'
- en: Reason
  id: totrans-4709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoids nasty errors from unreleased locks.
  id: totrans-4710
  prefs: []
  type: TYPE_NORMAL
  zh: 避免未释放锁的讨厌错误。
- en: Example, bad
  id: totrans-4711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE629]'
  id: totrans-4712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: Sooner or later, someone will forget the `mtx.unlock()`, place a `return` in
    the `... do stuff ...`, throw an exception, or something.
  id: totrans-4713
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，有人会忘记`mtx.unlock()`，在`... do stuff ...`中放置一个`return`，抛出一个异常，或者类似的事情。
- en: '[PRE630]'
  id: totrans-4714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: Enforcement
  id: totrans-4715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag calls of member `lock()` and `unlock()`. ???
  id: totrans-4716
  prefs: []
  type: TYPE_NORMAL
  zh: 标记成员`lock()`和`unlock()`的调用。 ???
- en: 'CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es'
  id: totrans-4717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.21: 使用`std::lock()`或`std::scoped_lock`来获取多个`mutex`'
- en: Reason
  id: totrans-4718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid deadlocks on multiple `mutex`es.
  id: totrans-4719
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免多个`mutex`上的死锁。
- en: Example
  id: totrans-4720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'This is asking for deadlock:'
  id: totrans-4721
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在请求死锁：
- en: '[PRE631]'
  id: totrans-4722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: 'Instead, use `lock()`:'
  id: totrans-4723
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用`lock()`：
- en: '[PRE632]'
  id: totrans-4724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: 'or (better, but C++17 only):'
  id: totrans-4725
  prefs: []
  type: TYPE_NORMAL
  zh: 或者（更好，但仅限C++17）：
- en: '[PRE633]'
  id: totrans-4726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: Here, the writers of `thread1` and `thread2` are still not agreeing on the order
    of the `mutex`es, but order no longer matters.
  id: totrans-4727
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`thread1`和`thread2`的编写者仍然没有就`mutex`的顺序达成一致，但顺序不再重要。
- en: Note
  id: totrans-4728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: In real code, `mutex`es are rarely named to conveniently remind the programmer
    of an intended relation and intended order of acquisition. In real code, `mutex`es
    are not always conveniently acquired on consecutive lines.
  id: totrans-4729
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，`mutex`很少被命名，以便方便地提醒程序员预期的关系和预期的获取顺序。在实际代码中，`mutex`并不总是在连续的行上方便地获取。
- en: Note
  id: totrans-4730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: In C++17 it’s possible to write plain
  id: totrans-4731
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，可以简单地编写
- en: '[PRE634]'
  id: totrans-4732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: and have the `mutex` type deduced.
  id: totrans-4733
  prefs: []
  type: TYPE_NORMAL
  zh: 并让`mutex`类型推导出来。
- en: Enforcement
  id: totrans-4734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Detect the acquisition of multiple `mutex`es. This is undecidable in general,
    but catching common simple examples (like the one above) is easy.
  id: totrans-4735
  prefs: []
  type: TYPE_NORMAL
  zh: 检测多个`mutex`的获取。这在一般情况下是不可判定的，但捕捉常见的简单例子（如上面的例子）是容易的。
- en: 'CP.22: Never call unknown code while holding a lock (e.g., a callback)'
  id: totrans-4736
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.22: 永远不要在持有锁的情况下调用未知代码（例如，回调）'
- en: Reason
  id: totrans-4737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you don’t know what a piece of code does, you are risking deadlock.
  id: totrans-4738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道一段代码的功能，你正在冒着死锁的风险。
- en: Example
  id: totrans-4739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE635]'
  id: totrans-4740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: If you don’t know what `Foo::act` does (maybe it is a virtual function invoking
    a derived class member of a class not yet written), it might call `do_this` (recursively)
    and cause a deadlock on `my_mutex`. Maybe it will lock on a different mutex and
    not return in a reasonable time, causing delays to any code calling `do_this`.
  id: totrans-4741
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道`Foo::act`的功能（可能是一个虚拟函数，调用尚未编写的类的一个派生类的成员），它可能会调用`do_this`（递归地）并在`my_mutex`上造成死锁。它可能会锁定在不同的`mutex`上，并且不会在合理的时间内返回，导致调用`do_this`的任何代码延迟。
- en: Example
  id: totrans-4742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'A common example of the “calling unknown code” problem is a call to a function
    that tries to gain locked access to the same object. Such problem can often be
    solved by using a `recursive_mutex`. For example:'
  id: totrans-4743
  prefs: []
  type: TYPE_NORMAL
  zh: “调用未知代码”问题的常见例子是调用一个尝试获取相同对象锁定访问权限的函数。此类问题通常可以通过使用`recursive_mutex`来解决。例如：
- en: '[PRE636]'
  id: totrans-4744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: If, as it is likely, `f()` invokes operations on `*this`, we must make sure
    that the object’s invariant holds before the call.
  id: totrans-4745
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，正如很可能的，`f()`在`*this`上调用操作，我们必须确保在调用之前对象的不变性保持不变。
- en: Enforcement
  id: totrans-4746
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag calling a virtual function with a non-recursive `mutex` held
  id: totrans-4747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记使用非递归`mutex`调用虚拟函数
- en: Flag calling a callback with a non-recursive `mutex` held
  id: totrans-4748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志在持有非递归 `mutex` 时调用回调
- en: 'CP.23: Think of a joining `thread` as a scoped container'
  id: totrans-4749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.23：将连接的 `thread` 视为一个作用域容器
- en: Reason
  id: totrans-4750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To maintain pointer safety and avoid leaks, we need to consider what pointers
    are used by a `thread`. If a `thread` joins, we can safely pass pointers to objects
    in the scope of the `thread` and its enclosing scopes.
  id: totrans-4751
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持指针安全并避免泄漏，我们需要考虑 `thread` 使用了哪些指针。如果 `thread` 被连接，我们可以安全地传递 `thread` 及其封装作用域中对象的指针。
- en: Example
  id: totrans-4752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE637]'
  id: totrans-4753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: A `gsl::joining_thread` is a `std::thread` with a destructor that joins and
    that cannot be `detached()`. By “OK” we mean that the object will be in scope
    (“live”) for as long as a `thread` can use the pointer to it. The fact that `thread`s
    run concurrently doesn’t affect the lifetime or ownership issues here; these `thread`s
    can be seen as just a function object called from `some_fct`.
  id: totrans-4754
  prefs: []
  type: TYPE_NORMAL
  zh: '`gsl::joining_thread` 是一个具有连接析构函数且不能 `detach()` 的 `std::thread`。当我们说“OK”时，意味着该对象的作用域（“存活”）将持续到
    `thread` 可以使用其指针为止。`thread` 并行运行的事实不会影响这里的生命周期或所有权问题；这些 `thread` 可以被视为从 `some_fct`
    调用的函数对象。'
- en: Enforcement
  id: totrans-4755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Ensure that `joining_thread`s don’t `detach()`. After that, the usual lifetime
    and ownership (for local objects) enforcement applies.
  id: totrans-4756
  prefs: []
  type: TYPE_NORMAL
  zh: 确保连接的 `thread` 不 `detach()`。之后，通常的生命周期和所有权（对于局部对象）执行适用。
- en: 'CP.24: Think of a `thread` as a global container'
  id: totrans-4757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.24：将 `thread` 视为一个全局容器
- en: Reason
  id: totrans-4758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To maintain pointer safety and avoid leaks, we need to consider what pointers
    are used by a `thread`. If a `thread` is detached, we can safely pass pointers
    to static and free store objects (only).
  id: totrans-4759
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持指针安全并避免泄漏，我们需要考虑 `thread` 使用了哪些指针。如果 `thread` 被分离，我们可以安全地传递指向静态和自由存储对象的指针（仅限）。
- en: Example
  id: totrans-4760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE638]'
  id: totrans-4761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: By “OK” we mean that the object will be in scope (“live”) for as long as a `thread`
    can use the pointers to it. By “bad” we mean that a `thread` might use a pointer
    after the pointed-to object is destroyed. The fact that `thread`s run concurrently
    doesn’t affect the lifetime or ownership issues here; these `thread`s can be seen
    as just a function object called from `some_fct`.
  id: totrans-4762
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“OK”时，意味着该对象的作用域（“存活”）将持续到 `thread` 可以使用其指针为止。当我们说“bad”时，意味着 `thread` 可能会在指向的对象被销毁后使用指针。`thread`
    并行运行的事实不会影响这里的生命周期或所有权问题；这些 `thread` 可以被视为从 `some_fct` 调用的函数对象。
- en: Note
  id: totrans-4763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Even objects with static storage duration can be problematic if used from detached
    threads: if the thread continues until the end of the program, it might be running
    concurrently with the destruction of objects with static storage duration, and
    thus accesses to such objects might race.'
  id: totrans-4764
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是具有静态存储期的对象，如果从分离的线程中使用，也可能有问题：如果线程继续到程序结束，它可能会与具有静态存储期的对象的销毁并行运行，因此对这些对象的访问可能会发生竞态。
- en: Note
  id: totrans-4765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This rule is redundant if you [don’t `detach()`](#rconc-detached_thread) and
    [use `gsl::joining_thread`](#rconc-joining_thread). However, converting code to
    follow those guidelines could be difficult and even impossible for third-party
    libraries. In such cases, the rule becomes essential for lifetime safety and type
    safety.
  id: totrans-4766
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用 `detach()` 并使用 `gsl::joining_thread`，则此规则是多余的。[不调用 `detach()`](#rconc-detached_thread)
    和 [使用 `gsl::joining_thread`](#rconc-joining_thread)。然而，将代码转换为遵循这些指南可能很困难，甚至对于第三方库来说可能是不可能的。在这种情况下，此规则对于生命周期安全和类型安全至关重要。
- en: In general, it is undecidable whether a `detach()` is executed for a `thread`,
    but simple common cases are easily detected. If we cannot prove that a `thread`
    does not `detach()`, we must assume that it does and that it outlives the scope
    in which it was constructed; after that, the usual lifetime and ownership (for
    global objects) enforcement applies.
  id: totrans-4767
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，是否为 `thread` 执行 `detach()` 是不可判定的，但简单常见的情况很容易检测。如果我们不能证明 `thread` 不会 `detach()`，我们必须假设它会，并且它会超出其构造的作用域；之后，通常的生命周期和所有权（对于全局对象）执行适用。
- en: Enforcement
  id: totrans-4768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag attempts to pass local variables to a thread that might `detach()`.
  id: totrans-4769
  prefs: []
  type: TYPE_NORMAL
  zh: 标志尝试将局部变量传递给可能 `detach()` 的线程。
- en: 'CP.25: Prefer `gsl::joining_thread` over `std::thread`'
  id: totrans-4770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.25：优先使用 `gsl::joining_thread` 而不是 `std::thread`
- en: Reason
  id: totrans-4771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A `joining_thread` is a thread that joins at the end of its scope. Detached
    threads are hard to monitor. It is harder to ensure absence of errors in detached
    threads (and potentially detached threads).
  id: totrans-4772
  prefs: []
  type: TYPE_NORMAL
  zh: '`joining_thread` 是在作用域结束时连接的线程。分离的线程难以监控。确保分离线程（和潜在的分离线程）中不存在错误更困难。'
- en: Example, bad
  id: totrans-4773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE639]'
  id: totrans-4774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: Example
  id: totrans-4775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE640]'
  id: totrans-4776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: Note
  id: totrans-4777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Make “immortal threads” globals, put them in an enclosing scope, or put them
    on the free store rather than `detach()`. [Don’t `detach`](#rconc-detached_thread).
  id: totrans-4778
  prefs: []
  type: TYPE_NORMAL
  zh: 将“不朽的线程”作为全局变量，将其放入封装作用域中，或者将其放入自由存储空间而不是使用`detach()`。[不要`detach`](#rconc-detached_thread)。
- en: Note
  id: totrans-4779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Because of old code and third party libraries using `std::thread`, this rule
    can be hard to introduce.
  id: totrans-4780
  prefs: []
  type: TYPE_NORMAL
  zh: 由于旧代码和第三方库使用`std::thread`，这个规则可能难以引入。
- en: Enforcement
  id: totrans-4781
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag uses of `std::thread`:'
  id: totrans-4782
  prefs: []
  type: TYPE_NORMAL
  zh: 标记`std::thread`的使用：
- en: Suggest use of `gsl::joining_thread` or C++20 `std::jthread`.
  id: totrans-4783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用`gsl::joining_thread`或C++20的`std::jthread`。
- en: Suggest [“exporting ownership”](#rconc-detached_thread) to an enclosing scope
    if it detaches.
  id: totrans-4784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分离，建议将“导出拥有权”到封装作用域中。
- en: Warn if it is not obvious whether a thread joins or detaches.
  id: totrans-4785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不明显是否将线程连接或分离，则发出警告。
- en: 'CP.26: Don’t `detach()` a thread'
  id: totrans-4786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.26：不要`detach()`线程
- en: Reason
  id: totrans-4787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Often, the need to outlive the scope of its creation is inherent in the `thread`s
    task, but implementing that idea by `detach` makes it harder to monitor and communicate
    with the detached thread. In particular, it is harder (though not impossible)
    to ensure that the thread completed as expected or lives for as long as expected.
  id: totrans-4788
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，线程需要超出其创建作用域的需求是固有的，但通过`detach`实现这个想法会使监控和与分离的线程通信变得更加困难。特别是，确保线程按预期完成或存活预期的时间更困难（尽管不是不可能）。
- en: Example
  id: totrans-4789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE641]'
  id: totrans-4790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: This is a reasonable use of a thread, for which `detach()` is commonly used.
    There are problems, though. How do we monitor the detached thread to see if it
    is alive? Something might go wrong with the heartbeat, and losing a heartbeat
    can be very serious in a system for which it is needed. So, we need to communicate
    with the heartbeat thread (e.g., through a stream of messages or notification
    events using a `condition_variable`).
  id: totrans-4791
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对线程的合理使用，通常使用`detach()`。尽管如此，也存在问题。我们如何监控已分离的线程以查看它是否存活？心跳可能出错，丢失心跳在需要它的系统中可能非常严重。因此，我们需要与心跳线程进行通信（例如，通过消息流或使用`condition_variable`的通知事件）。
- en: 'An alternative, and usually superior solution is to control its lifetime by
    placing it in a scope outside its point of creation (or activation). For example:'
  id: totrans-4792
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方案，通常是更好的解决方案是将它放在创建点（或激活点）之外的作用域中控制其生命周期。例如：
- en: '[PRE642]'
  id: totrans-4793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: This heartbeat will (barring error, hardware problems, etc.) run for as long
    as the program does.
  id: totrans-4794
  prefs: []
  type: TYPE_NORMAL
  zh: 这个心跳（除非出现错误、硬件问题等）将运行与程序一样长的时间。
- en: 'Sometimes, we need to separate the point of creation from the point of ownership:'
  id: totrans-4795
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要将创建点与拥有点分开：
- en: '[PRE643]'
  id: totrans-4796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: Enforcement
  id: totrans-4797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `detach()`.
  id: totrans-4798
  prefs: []
  type: TYPE_NORMAL
  zh: 标记`detach()`。
- en: 'CP.31: Pass small amounts of data between threads by value, rather than by
    reference or pointer'
  id: totrans-4799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.31：通过值传递而不是通过引用或指针在线程之间传递少量数据
- en: Reason
  id: totrans-4800
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A small amount of data is cheaper to copy and access than to share it using
    some locking mechanism. Copying naturally gives unique ownership (simplifies code)
    and eliminates the possibility of data races.
  id: totrans-4801
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于使用某种锁定机制共享，少量数据在复制和访问上更便宜。复制自然提供唯一的拥有权（简化代码）并消除数据竞争的可能性。
- en: Note
  id: totrans-4802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Defining “small amount” precisely is impossible.
  id: totrans-4803
  prefs: []
  type: TYPE_NORMAL
  zh: 准确定义“少量”是不可能的。
- en: Example
  id: totrans-4804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE644]'
  id: totrans-4805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: The call of `modify1` involves copying two `string` values; the call of `modify2`
    does not. On the other hand, the implementation of `modify1` is exactly as we
    would have written it for single-threaded code, whereas the implementation of
    `modify2` will need some form of locking to avoid data races. If the string is
    short (say 10 characters), the call of `modify1` can be surprisingly fast; essentially
    all the cost is in the `thread` switch. If the string is long (say 1,000,000 characters),
    copying it twice is probably not a good idea.
  id: totrans-4806
  prefs: []
  type: TYPE_NORMAL
  zh: '`modify1`的调用涉及复制两个`string`值；`modify2`的调用则不涉及。另一方面，`modify1`的实现与我们为单线程代码编写的实现完全相同，而`modify2`的实现则需要某种形式的锁定来避免数据竞争。如果字符串较短（例如10个字符），`modify1`的调用可能会非常快；本质上所有的成本都在线程切换上。如果字符串较长（例如1,000,000个字符），复制两次可能不是好主意。'
- en: Note that this argument has nothing to do with `async` as such. It applies equally
    to considerations about whether to use message passing or shared memory.
  id: totrans-4807
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个论点与`async`本身无关。它同样适用于是否使用消息传递或共享内存的考虑。
- en: Enforcement
  id: totrans-4808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4809
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.32: To share ownership between unrelated `thread`s use `shared_ptr`'
  id: totrans-4810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.32：要在无关的`thread`之间共享所有权，请使用`shared_ptr`
- en: Reason
  id: totrans-4811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If threads are unrelated (that is, not known to be in the same scope or one
    within the lifetime of the other) and they need to share free store memory that
    needs to be deleted, a `shared_ptr` (or equivalent) is the only safe way to ensure
    proper deletion.
  id: totrans-4812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程无关（即，不知道是否在同一个作用域内或一个在另一个的生存期内），并且它们需要共享需要被删除的堆内存，那么 `shared_ptr`（或等效）是确保正确删除的唯一安全方式。
- en: Example
  id: totrans-4813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE645]'
  id: totrans-4814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: Note
  id: totrans-4815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A static object (e.g. a global) can be shared because it is not owned in the
    sense that some thread is responsible for its deletion.
  id: totrans-4816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个静态对象（例如全局对象）可以共享，因为它不是以某种线程负责其删除的方式拥有的。
- en: An object on free store that is never to be deleted can be shared.
  id: totrans-4817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个永远不会被删除的堆对象可以共享。
- en: An object owned by one thread can be safely shared with another as long as that
    second thread doesn’t outlive the owner.
  id: totrans-4818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个线程拥有的对象可以安全地与另一个线程共享，只要第二个线程不会比拥有者存活时间更长。
- en: Enforcement
  id: totrans-4819
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4820
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.40: Minimize context switching'
  id: totrans-4821
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.40：最小化上下文切换
- en: Reason
  id: totrans-4822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Context switches are expensive.
  id: totrans-4823
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换是昂贵的。
- en: Example
  id: totrans-4824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE646]'
  id: totrans-4825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: Enforcement
  id: totrans-4826
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4827
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.41: Minimize thread creation and destruction'
  id: totrans-4828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.41：最小化线程的创建和销毁
- en: Reason
  id: totrans-4829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Thread creation is expensive.
  id: totrans-4830
  prefs: []
  type: TYPE_NORMAL
  zh: 线程创建是昂贵的。
- en: Example
  id: totrans-4831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE647]'
  id: totrans-4832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: This spawns a `thread` per message, and the `run_list` is presumably managed
    to destroy those tasks once they are finished.
  id: totrans-4833
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每条消息创建一个 `thread`，并且假设 `run_list` 被管理以在任务完成后销毁这些任务。
- en: Instead, we could have a set of pre-created worker threads processing the messages
  id: totrans-4834
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以有一组预先创建的线程池来处理消息
- en: '[PRE648]'
  id: totrans-4835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: Note
  id: totrans-4836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If your system has a good thread pool, use it. If your system has a good message
    queue, use it.
  id: totrans-4837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统有一个好的线程池，请使用它。如果你的系统有一个好的消息队列，请使用它。
- en: Enforcement
  id: totrans-4838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4839
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.42: Don’t `wait` without a condition'
  id: totrans-4840
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.42：不要在没有条件的情况下 `wait`
- en: Reason
  id: totrans-4841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A `wait` without a condition can miss a wakeup or wake up simply to find that
    there is no work to do.
  id: totrans-4842
  prefs: []
  type: TYPE_NORMAL
  zh: 没有条件的 `wait` 可能会错过唤醒或仅仅是为了发现没有工作可做而唤醒。
- en: Example, bad
  id: totrans-4843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE649]'
  id: totrans-4844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: Here, if some other `thread` consumes `thread1`’s notification, `thread2` can
    wait forever.
  id: totrans-4845
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果其他 `thread` 消费了 `thread1` 的通知，`thread2` 可以永远等待。
- en: Example
  id: totrans-4846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE650]'
  id: totrans-4847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: Now if the queue is empty when a thread executing `get()` wakes up (e.g., because
    another thread has gotten to `get()` before it), it will immediately go back to
    sleep, waiting.
  id: totrans-4848
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个执行 `get()` 的线程在队列为空时醒来（例如，因为另一个线程在它之前到达 `get()`），它将立即返回休眠状态，等待。
- en: Enforcement
  id: totrans-4849
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all `wait`s without conditions.
  id: totrans-4850
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有没有条件的 `wait`。
- en: 'CP.43: Minimize time spent in a critical section'
  id: totrans-4851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.43：最小化在临界区段内花费的时间
- en: Reason
  id: totrans-4852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The less time is spent with a `mutex` taken, the less chance that another `thread`
    has to wait, and `thread` suspension and resumption are expensive.
  id: totrans-4853
  prefs: []
  type: TYPE_NORMAL
  zh: 花在 `mutex` 上的时间越少，另一个 `thread` 等待的机会就越少，线程的挂起和恢复都是昂贵的。
- en: Example
  id: totrans-4854
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE651]'
  id: totrans-4855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: 'Here, we are holding the lock for longer than necessary: We should not have
    taken the lock before we needed it and should have released it again before starting
    the cleanup. We could rewrite this to'
  id: totrans-4856
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们持有的锁超过了必要的时长：我们不应该在我们需要它之前就获取锁，也不应该在开始清理之前再次释放它。我们可以重写为
- en: '[PRE652]'
  id: totrans-4857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: 'But that compromises safety and violates the [use RAII](#rconc-raii) rule.
    Instead, add a block for the critical section:'
  id: totrans-4858
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会妥协安全性并违反[使用RAII](#rconc-raii)规则。相反，为临界区段添加一个代码块：
- en: '[PRE653]'
  id: totrans-4859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: Enforcement
  id: totrans-4860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Impossible in general. Flag “naked” `lock()` and `unlock()`.
  id: totrans-4861
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下不可能。标记“裸露”的 `lock()` 和 `unlock()`。
- en: 'CP.44: Remember to name your `lock_guard`s and `unique_lock`s'
  id: totrans-4862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.44：记得给你的 `lock_guard`s 和 `unique_lock`s 命名
- en: Reason
  id: totrans-4863
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An unnamed local object is a temporary that immediately goes out of scope.
  id: totrans-4864
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未命名的局部对象是一个立即超出作用域的临时对象。
- en: Example
  id: totrans-4865
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE654]'
  id: totrans-4866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: This looks innocent enough, but it isn’t. At (A), `m1` is a default-constructed
    local `unique_lock`, which shadows the global `::m1` (and does not lock it). At
    (B) an unnamed temporary `lock_guard` is constructed and locks `::m2`, but immediately
    goes out of scope and unlocks `::m2` again. For the rest of the function `f()`
    neither mutex is locked.
  id: totrans-4867
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能无害，但实际上并非如此。在（A）处，`m1` 是一个默认构造的局部 `unique_lock`，它遮蔽了全局 `::m1`（并且没有锁定它）。在（B）处，一个未命名的临时
    `lock_guard` 被构造并锁定了 `::m2`，但立即超出作用域并再次解锁 `::m2`。在函数 `f()` 的其余部分，没有锁定任何互斥锁。
- en: Enforcement
  id: totrans-4868
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all unnamed `lock_guard`s and `unique_lock`s.
  id: totrans-4869
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有未命名的 `lock_guard` 和 `unique_lock`。
- en: 'CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>`
    where possible'
  id: totrans-4870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.50：定义一个与保护的数据一起的 `mutex`。尽可能使用 `synchronized_value<T>`
- en: Reason
  id: totrans-4871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It should be obvious to a reader that the data is to be guarded and how. This
    decreases the chance of the wrong mutex being locked, or the mutex not being locked.
  id: totrans-4872
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读者来说，应该很明显数据需要被保护以及如何保护。这减少了错误锁定互斥锁或未锁定互斥锁的可能性。
- en: Using a `synchronized_value<T>` ensures that the data has a mutex, and the right
    mutex is locked when the data is accessed. See the [WG21 proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0290r4.html)
    to add `synchronized_value` to a future TS or revision of the C++ standard.
  id: totrans-4873
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `synchronized_value<T>` 确保数据有一个互斥锁，并且在访问数据时锁定正确的互斥锁。请参阅 [WG21 提案](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0290r4.html)，了解如何将
    `synchronized_value` 添加到未来的 TS 或 C++ 标准的修订版中。
- en: Example
  id: totrans-4874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE655]'
  id: totrans-4875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: Enforcement
  id: totrans-4876
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ??? Possible?
  id: totrans-4877
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 可能性？
- en: 'CP.coro: Coroutines'
  id: totrans-4878
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'CP.coro: 协程'
- en: This section focuses on uses of coroutines.
  id: totrans-4879
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍协程的使用。
- en: 'Coroutine rule summary:'
  id: totrans-4880
  prefs: []
  type: TYPE_NORMAL
  zh: 协程规则摘要：
- en: '[CP.51: Do not use capturing lambdas that are coroutines](#rcoro-capture)'
  id: totrans-4881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.51：不要使用捕获的协程 lambda](#rcoro-capture)'
- en: '[CP.52: Do not hold locks or other synchronization primitives across suspension
    points](#rcoro-locks)'
  id: totrans-4882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.52：不要在挂起点之间持有锁或其他同步原语](#rcoro-locks)'
- en: '[CP.53: Parameters to coroutines should not be passed by reference](#rcoro-reference-parameters)'
  id: totrans-4883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.53：协程的参数不应通过引用传递](#rcoro-reference-parameters)'
- en: 'CP.51: Do not use capturing lambdas that are coroutines'
  id: totrans-4884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.51：不要使用捕获的协程 lambda
- en: Reason
  id: totrans-4885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Usage patterns that are correct with normal lambdas are hazardous with coroutine
    lambdas. The obvious pattern of capturing variables will result in accessing freed
    memory after the first suspension point, even for refcounted smart pointers and
    copyable types.
  id: totrans-4886
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常 lambda 一起使用的正确用法模式在协程 lambda 中是危险的。捕获变量的明显模式会导致在第一个挂起点之后访问已释放的内存，即使对于引用计数智能指针和可复制类型也是如此。
- en: A lambda results in a closure object with storage, often on the stack, that
    will go out of scope at some point. When the closure object goes out of scope
    the captures will also go out of scope. Normal lambdas will have finished executing
    by this time so it is not a problem. Coroutine lambdas may resume from suspension
    after the closure object has destructed and at that point all captures will be
    use-after-free memory access.
  id: totrans-4887
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 会导致一个具有存储的闭包对象，通常在栈上，该对象将在某个时刻超出作用域。当闭包对象超出作用域时，捕获也将超出作用域。此时，正常 lambda
    将已执行完毕，所以这不是问题。协程 lambda 可能会在闭包对象已析构后从挂起状态恢复，此时所有捕获都将是对已释放内存的访问。
- en: Example, Bad
  id: totrans-4888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE656]'
  id: totrans-4889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: Example, Better
  id: totrans-4890
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，更好
- en: '[PRE657]'
  id: totrans-4891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: Example, Best
  id: totrans-4892
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，最佳
- en: Use a function for coroutines.
  id: totrans-4893
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数进行协程。
- en: '[PRE658]'
  id: totrans-4894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: Enforcement
  id: totrans-4895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag a lambda that is a coroutine and has a non-empty capture list.
  id: totrans-4896
  prefs: []
  type: TYPE_NORMAL
  zh: 标记一个具有非空捕获列表的协程 lambda。
- en: 'CP.52: Do not hold locks or other synchronization primitives across suspension
    points'
  id: totrans-4897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.52：不要在挂起点之间持有锁或其他同步原语
- en: Reason
  id: totrans-4898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This pattern creates a significant risk of deadlocks. Some types of waits will
    allow the current thread to perform additional work until the asynchronous operation
    has completed. If the thread holding the lock performs work that requires the
    same lock then it will deadlock because it is trying to acquire a lock that it
    is already holding.
  id: totrans-4899
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式会创建显著的死锁风险。某些类型的等待将允许当前线程在异步操作完成之前执行更多工作。如果持有锁的线程执行需要相同锁的工作，则它将发生死锁，因为它正在尝试获取它已经持有的锁。
- en: If the coroutine completes on a different thread from the thread that acquired
    the lock then that is undefined behavior. Even with an explicit return to the
    original thread an exception might be thrown before coroutine resumes and the
    result will be that the lock guard is not destructed.
  id: totrans-4900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果协程在不同的线程上完成，而不是获取锁的线程，则这是未定义的行为。即使有明确的返回到原始线程，协程恢复之前也可能抛出异常，结果将是锁保护未析构。
- en: Example, Bad
  id: totrans-4901
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE659]'
  id: totrans-4902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: Example, Good
  id: totrans-4903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE660]'
  id: totrans-4904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: Note
  id: totrans-4905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This pattern is also bad for performance. When a suspension point is reached,
    such as co_await, execution of the current function stops and other code begins
    to run. It may be a long period of time before the coroutine resumes. For that
    entire duration the lock will be held and cannot be acquired by other threads
    to perform work.
  id: totrans-4906
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对性能也不利。当达到挂起点，例如 co_await 时，当前函数的执行将停止，其他代码开始运行。协程恢复可能需要很长时间。在整个这段时间内，锁将被持有，其他线程无法获取锁来执行工作。
- en: Enforcement
  id: totrans-4907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all lock guards that are not destructed before a coroutine suspends.
  id: totrans-4908
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程挂起之前标记所有未析构的锁保护。
- en: 'CP.53: Parameters to coroutines should not be passed by reference'
  id: totrans-4909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CP.53：协程的参数不应通过引用传递
- en: Reason
  id: totrans-4910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Once a coroutine reaches the first suspension point, such as a co_await, the
    synchronous portion returns. After that point any parameters passed by reference
    are dangling. Any usage beyond that is undefined behavior which may include writing
    to freed memory.
  id: totrans-4911
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦协程达到第一个挂起点，例如 co_await，同步部分返回。在此之后，任何通过引用传递的参数都是悬垂的。任何超出此范围的用法都是未定义的行为，可能包括写入已释放的内存。
- en: Example, Bad
  id: totrans-4912
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE661]'
  id: totrans-4913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: Example, Good
  id: totrans-4914
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE662]'
  id: totrans-4915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: Note
  id: totrans-4916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This problem does not apply to reference parameters that are only accessed before
    the first suspension point. Subsequent changes to the function may add or move
    suspension points which would reintroduce this class of bug. Some types of coroutines
    have the suspension point before the first line of code in the coroutine executes,
    in which case reference parameters are always unsafe. It is safer to always pass
    by value because the copied parameter will live in the coroutine frame that is
    safe to access throughout the coroutine.
  id: totrans-4917
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题不适用于仅在第一个挂起点之前访问的引用参数。函数后续的更改可能会添加或移动挂起点，从而重新引入此类错误。某些类型的协程在协程执行的第一行代码之前就有挂起点，在这种情况下，引用参数始终是不安全的。始终通过值传递更安全，因为复制的参数将存在于协程帧中，在整个协程中都可以安全访问。
- en: Note
  id: totrans-4918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The same danger applies to output parameters. [F.20: For “out” output values,
    prefer return values to output parameters](#rf-out) discourages output parameters.
    Coroutines should avoid them entirely.'
  id: totrans-4919
  prefs: []
  type: TYPE_NORMAL
  zh: '同样的危险也适用于输出参数。[F.20: 对于“out”输出值，优先返回值而不是输出参数](#rf-out) 建议避免使用输出参数。协程应完全避免它们。'
- en: Enforcement
  id: totrans-4920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all reference parameters to a coroutine.
  id: totrans-4921
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有引用参数标记为协程。
- en: 'CP.par: Parallelism'
  id: totrans-4922
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'CP.par: 并行'
- en: By “parallelism” we refer to performing a task (more or less) simultaneously
    (“in parallel with”) on many data items.
  id: totrans-4923
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“并行”我们指的是在许多数据项上（或多或少）同时执行任务（“与...并行”）。
- en: 'Parallelism rule summary:'
  id: totrans-4924
  prefs: []
  type: TYPE_NORMAL
  zh: 并行规则摘要：
- en: ???
  id: totrans-4925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: ???
  id: totrans-4926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??
- en: Where appropriate, prefer the standard-library parallel algorithms
  id: totrans-4927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的情况下，优先使用标准库的并行算法
- en: Use algorithms that are designed for parallelism, not algorithms with unnecessary
    dependency on linear evaluation
  id: totrans-4928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用为并行化设计的算法，而不是对线性评估有不必要的依赖的算法
- en: 'CP.mess: Message passing'
  id: totrans-4929
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'CP.mess: 消息传递'
- en: 'The standard-library facilities are quite low-level, focused on the needs of
    close-to-the-hardware critical programming using `thread`s, `mutex`es, `atomic`
    types, etc. Most people shouldn’t work at this level: it’s error-prone and development
    is slow. If possible, use a higher level facility: messaging libraries, parallel
    algorithms, and vectorization. This section looks at passing messages so that
    a programmer doesn’t have to do explicit synchronization.'
  id: totrans-4930
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库设施相当低级，专注于使用 `thread`s、`mutex`es、`atomic` 类型等进行的接近硬件的临界编程需求。大多数人不应在此级别工作：它容易出错且开发缓慢。如果可能，请使用高级设施：消息库、并行算法和向量化。本节探讨传递消息，以便程序员不必进行显式同步。
- en: 'Message passing rules summary:'
  id: totrans-4931
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递规则摘要：
- en: '[CP.60: Use a `future` to return a value from a concurrent task](#rconc-future)'
  id: totrans-4932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.60: 使用 `future` 从并发任务返回值](#rconc-future)'
- en: '[CP.61: Use `async()` to spawn concurrent tasks](#rconc-async)'
  id: totrans-4933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.61: 使用 `async()` 来启动并发任务](#rconc-async)'
- en: message queues
  id: totrans-4934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列
- en: messaging libraries
  id: totrans-4935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息库
- en: ???? should there be a “use X rather than `std::async`” where X is something
    that would use a better specified thread pool?
  id: totrans-4936
  prefs: []
  type: TYPE_NORMAL
  zh: ???? 是否应该有一个“使用 X 而不是 `std::async`”的建议，其中 X 是某种会使用更好指定的线程池的东西？
- en: ??? Is `std::async` worth using in light of future (and even existing, as libraries)
    parallelism facilities? What should the guidelines recommend if someone wants
    to parallelize, e.g., `std::accumulate` (with the additional precondition of commutativity),
    or merge sort?
  id: totrans-4937
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 考虑到未来的（甚至现有的，如库）并行设施，`std::async` 是否值得使用？如果有人想要并行化，例如 `std::accumulate`（具有额外的交换性前提条件），或归并排序，指南应该推荐什么？
- en: 'CP.60: Use a `future` to return a value from a concurrent task'
  id: totrans-4938
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.60: 使用 `future` 从并发任务返回值'
- en: Reason
  id: totrans-4939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A `future` preserves the usual function call return semantics for asynchronous
    tasks. There is no explicit locking and both correct (value) return and error
    (exception) return are handled simply.
  id: totrans-4940
  prefs: []
  type: TYPE_NORMAL
  zh: '`future` 保留了异步任务通常的函数调用返回语义。没有显式的锁定，并且正确（值）返回和错误（异常）返回都得到简单处理。'
- en: Example
  id: totrans-4941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE663]'
  id: totrans-4942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: Note
  id: totrans-4943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: ???
  id: totrans-4944
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Enforcement
  id: totrans-4945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-4946
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.61: Use `async()` to spawn concurrent tasks'
  id: totrans-4947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.61: 使用 `async()` 来启动并发任务'
- en: Reason
  id: totrans-4948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Similar to [R.12](#rr-immediate-alloc), which tells you to avoid raw owning
    pointers, you should also avoid raw threads and raw promises where possible. Use
    a factory function such as `std::async`, which handles spawning or reusing a thread
    without exposing raw threads to your own code.
  id: totrans-4949
  prefs: []
  type: TYPE_NORMAL
  zh: 与[R.12](#rr-immediate-alloc)类似，它告诉你避免使用原始拥有指针，你也应该尽可能避免使用原始线程和原始承诺。使用像`std::async`这样的工厂函数，它处理线程的创建或重用，而不将原始线程暴露给你的代码。
- en: Example
  id: totrans-4950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE664]'
  id: totrans-4951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: Note
  id: totrans-4952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, `std::async` is not perfect. For example, it doesn’t use a thread
    pool, which means that it might fail due to resource exhaustion, rather than queuing
    up your tasks to be executed later. However, even if you cannot use `std::async`,
    you should prefer to write your own `future`-returning factory function, rather
    than using raw promises.
  id: totrans-4953
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`std::async`并不完美。例如，它不使用线程池，这意味着它可能会因为资源耗尽而失败，而不是将任务排队以供稍后执行。然而，即使你不能使用`std::async`，你也应该优先编写自己的返回`future`的工厂函数，而不是使用原始的承诺。
- en: Example (bad)
  id: totrans-4954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例（不良）
- en: This example shows two different ways to succeed at using `std::future`, but
    to fail at avoiding raw `std::thread` management.
  id: totrans-4955
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了两种成功使用`std::future`的不同方法，但失败于避免原始`std::thread`管理。
- en: '[PRE665]'
  id: totrans-4956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: Example (good)
  id: totrans-4957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例（良好）
- en: This example shows one way you could follow the general pattern set by `std::async`,
    in a context where `std::async` itself was unacceptable for use in production.
  id: totrans-4958
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了你可以遵循`std::async`设定的一般模式的一种方式，在`std::async`本身在生产环境中不可接受使用的情况下。
- en: '[PRE666]'
  id: totrans-4959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: Any threads spawned to execute the code of `read_value` are hidden behind the
    call to `WorkQueue::enqueue`. The user code deals only with `future` objects,
    never with raw `thread`, `promise`, or `packaged_task` objects.
  id: totrans-4960
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`read_value`代码所创建的任何线程都隐藏在`WorkQueue::enqueue`调用之后。用户代码仅处理`future`对象，而不是原始的`thread`、`promise`或`packaged_task`对象。
- en: Enforcement
  id: totrans-4961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: ???
  id: totrans-4962
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.vec: Vectorization'
  id: totrans-4963
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'CP.vec: 向量化'
- en: Vectorization is a technique for executing a number of tasks concurrently without
    introducing explicit synchronization. An operation is simply applied to elements
    of a data structure (a vector, an array, etc.) in parallel. Vectorization has
    the interesting property of often requiring no non-local changes to a program.
    However, vectorization works best with simple data structures and with algorithms
    specifically crafted to enable it.
  id: totrans-4964
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化是一种在不引入显式同步的情况下并发执行多个任务的技术。操作简单地应用于数据结构（如向量、数组等）的元素。向量化有一个有趣的特性，即通常不需要对程序进行非局部更改。然而，向量化与简单数据结构和专门设计以启用它的算法结合得最好。
- en: 'Vectorization rule summary:'
  id: totrans-4965
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化规则总结：
- en: ???
  id: totrans-4966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: ???
  id: totrans-4967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.free: Lock-free programming'
  id: totrans-4968
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'CP.free: 无锁编程'
- en: Synchronization using `mutex`es and `condition_variable`s can be relatively
    expensive. Furthermore, it can lead to deadlock. For performance and to eliminate
    the possibility of deadlock, we sometimes have to use the tricky low-level “lock-free”
    facilities that rely on briefly gaining exclusive (“atomic”) access to memory.
    Lock-free programming is also used to implement higher-level concurrency mechanisms,
    such as `thread`s and `mutex`es.
  id: totrans-4969
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mutex`和`condition_variable`进行同步可能相对昂贵。此外，它可能导致死锁。为了性能和消除死锁的可能性，我们有时必须使用依赖短暂获得内存独占（“原子”）访问的低级“无锁”设施。无锁编程也用于实现高级并发机制，如`thread`和`mutex`。
- en: 'Lock-free programming rule summary:'
  id: totrans-4970
  prefs: []
  type: TYPE_NORMAL
  zh: 无锁编程规则总结：
- en: '[CP.100: Don’t use lock-free programming unless you absolutely have to](#rconc-lockfree)'
  id: totrans-4971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.100: 除非你绝对必须，否则不要使用无锁编程](#rconc-lockfree)'
- en: '[CP.101: Distrust your hardware/compiler combination](#rconc-distrust)'
  id: totrans-4972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.101: 不信任你的硬件/编译器组合](#rconc-distrust)'
- en: '[CP.102: Carefully study the literature](#rconc-literature)'
  id: totrans-4973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.102: 仔细研究文献](#rconc-literature)'
- en: how/when to use atomics
  id: totrans-4974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何/何时使用原子操作
- en: avoid starvation
  id: totrans-4975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免饥饿
- en: use a lock-free data structure rather than hand-crafting specific lock-free
    access
  id: totrans-4976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无锁数据结构而不是手工制作特定的无锁访问
- en: '[CP.110: Do not write your own double-checked locking for initialization](#rconc-double)'
  id: totrans-4977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.110: 不要自己编写用于初始化的双检查锁定](#rconc-double)'
- en: '[CP.111: Use a conventional pattern if you really need double-checked locking](#rconc-double-pattern)'
  id: totrans-4978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.111: 如果你确实需要双检查锁定，请使用传统模式](#rconc-double-pattern)'
- en: how/when to compare and swap
  id: totrans-4979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何/何时比较和交换
- en: 'CP.100: Don’t use lock-free programming unless you absolutely have to'
  id: totrans-4980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.100: 除非你绝对必须，否则不要使用无锁编程'
- en: Reason
  id: totrans-4981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s error-prone and requires expert level knowledge of language features, machine
    architecture, and data structures.
  id: totrans-4982
  prefs: []
  type: TYPE_NORMAL
  zh: 它容易出错，并且需要语言特性、机器架构和数据结构的高级知识。
- en: Example, bad
  id: totrans-4983
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE667]'
  id: totrans-4984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: Spot the bug. It would be really hard to find through testing. Read up on the
    ABA problem.
  id: totrans-4985
  prefs: []
  type: TYPE_NORMAL
  zh: 发现错误。通过测试很难找到。了解ABA问题。
- en: Exception
  id: totrans-4986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: '[Atomic variables](#???) can be used simply and safely, as long as you are
    using the sequentially consistent memory model (memory_order_seq_cst), which is
    the default.'
  id: totrans-4987
  prefs: []
  type: TYPE_NORMAL
  zh: '[原子变量](#???) 可以简单地、安全地使用，只要你使用的是顺序一致内存模型（memory_order_seq_cst），这是默认的。'
- en: Note
  id: totrans-4988
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Higher-level concurrency mechanisms, such as `thread`s and `mutex`es are implemented
    using lock-free programming.
  id: totrans-4989
  prefs: []
  type: TYPE_NORMAL
  zh: 高级并发机制，如`thread`和`mutex`，是通过无锁编程实现的。
- en: '**Alternative**: Use lock-free data structures implemented by others as part
    of some library.'
  id: totrans-4990
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：使用其他人实现的库中的无锁数据结构。'
- en: 'CP.101: Distrust your hardware/compiler combination'
  id: totrans-4991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.101: 不信任你的硬件/编译器组合'
- en: Reason
  id: totrans-4992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The low-level hardware interfaces used by lock-free programming are among the
    hardest to implement well and among the areas where the most subtle portability
    problems occur. If you are doing lock-free programming for performance, you need
    to check for regressions.
  id: totrans-4993
  prefs: []
  type: TYPE_NORMAL
  zh: 无锁编程使用的高级硬件接口是实施难度最大的部分之一，也是出现最微妙可移植性问题的地方。如果你为了性能进行无锁编程，你需要检查回归。
- en: Note
  id: totrans-4994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Instruction reordering (static and dynamic) makes it hard for us to think effectively
    at this level (especially if you use relaxed memory models). Experience, (semi)formal
    models and model checking can be useful. Testing - often to an extreme extent
    - is essential. “Don’t fly too close to the sun.”
  id: totrans-4995
  prefs: []
  type: TYPE_NORMAL
  zh: 指令重排（静态和动态）使得我们在这个层面上难以有效思考（特别是如果你使用松散的内存模型）。经验、（半）形式模型和模型检查可能是有用的。测试——通常是极端程度——是必不可少的。“不要飞得太近太阳。”
- en: Enforcement
  id: totrans-4996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Have strong rules for re-testing in place that covers any change in hardware,
    operating system, compiler, and libraries.
  id: totrans-4997
  prefs: []
  type: TYPE_NORMAL
  zh: 建立强大的规则，以便在硬件、操作系统、编译器和库的任何更改中进行重新测试。
- en: 'CP.102: Carefully study the literature'
  id: totrans-4998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.102: 仔细研究文献'
- en: Reason
  id: totrans-4999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: With the exception of atomics and a few other standard patterns, lock-free programming
    is really an expert-only topic. Become an expert before shipping lock-free code
    for others to use.
  id: totrans-5000
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原子操作和少数其他标准模式外，无锁编程实际上是一个专家级别的主题。在为他人使用无锁代码之前，请先成为专家。
- en: References
  id: totrans-5001
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Anthony Williams: C++ concurrency in action. Manning Publications.'
  id: totrans-5002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Anthony Williams: C++并发实战。Manning Publications。'
- en: Boehm, Adve, You Don’t Know Jack About Shared Variables or Memory Models, Communications
    of the ACM, Feb 2012.
  id: totrans-5003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boehm, Adve, 你对共享变量或内存模型一无所知，ACM通讯，2012年2月。
- en: Boehm, “Threads Basics”, HPL TR 2009-259.
  id: totrans-5004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boehm, “线程基础”，HPL TR 2009-259。
- en: 'Adve, Boehm, “Memory Models: A Case for Rethinking Parallel Languages and Hardware”,
    Communications of the ACM, August 2010.'
  id: totrans-5005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adve, Boehm, “内存模型：重新思考并行语言和硬件的案例”，ACM通讯，2010年8月。
- en: Boehm, Adve, “Foundations of the C++ Concurrency Memory Model”, PLDI 08.
  id: totrans-5006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boehm, Adve, “C++并发内存模型的基础”，PLDI 08。
- en: Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, “Mathematizing
    C++ Concurrency”, POPL 2011.
  id: totrans-5007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell 和 Tjark Weber, “数学化C++并发”，POPL
    2011。
- en: 'Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and
    Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs.
    13th IEEE Computer Society ISORC 2010 Symposium. May 2010.'
  id: totrans-5008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Damian Dechev, Peter Pirkelbauer 和 Bjarne Stroustrup: 理解和有效预防基于描述符的无锁设计中的ABA问题。第13届IEEE计算机学会ISORC
    2010研讨会。2010年5月。'
- en: 'Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects
    for Mission Critical Code. ACM OOPSLA’09\. October 2009'
  id: totrans-5009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Damian Dechev 和 Bjarne Stroustrup: 可扩展的非阻塞并发对象，用于关键任务代码。ACM OOPSLA’09。2009年10月'
- en: 'Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup:
    Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th
    Annual IEEE International Conference and Workshop on the Engineering of Computer
    Based Systems (IEEE ECBS). April 2009.'
  id: totrans-5010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette 和 Bjarne Stroustrup: 用于并发实时系统的语义增强容器。第16届IEEE国际计算机基于系统工程会议和研讨会（IEEE
    ECBS）。2009年4月。'
- en: Maurice Herlihy, Nir Shavit, Victor Luchangco, Michael Spear, “The Art of Multiprocessor
    Programming”, 2nd ed. September 2020
  id: totrans-5011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maurice Herlihy, Nir Shavit, Victor Luchangco, Michael Spear, “多处理器编程的艺术”，第2版。2020年9月
- en: 'CP.110: Do not write your own double-checked locking for initialization'
  id: totrans-5012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.110: 不要自己编写用于初始化的双检查锁定'
- en: Reason
  id: totrans-5013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Since C++11, static local variables are now initialized in a thread-safe way.
    When combined with the RAII pattern, static local variables can replace the need
    for writing your own double-checked locking for initialization. std::call_once
    can also achieve the same purpose. Use either static local variables of C++11
    or std::call_once instead of writing your own double-checked locking for initialization.
  id: totrans-5014
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，静态局部变量现在以线程安全的方式初始化。当与RAII模式结合使用时，静态局部变量可以取代编写自己的双重检查锁定初始化的需要。std::call_once也可以达到相同的目的。使用C++11的静态局部变量或std::call_once代替编写自己的双重检查锁定初始化。
- en: Example
  id: totrans-5015
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Example with std::call_once.
  id: totrans-5016
  prefs: []
  type: TYPE_NORMAL
  zh: 使用std::call_once的示例。
- en: '[PRE668]'
  id: totrans-5017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: Example with thread-safe static local variables of C++11.
  id: totrans-5018
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++11线程安全的静态局部变量的示例。
- en: '[PRE669]'
  id: totrans-5019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: Enforcement
  id: totrans-5020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ??? Is it possible to detect the idiom?
  id: totrans-5021
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 是否可以检测到这种习语？
- en: 'CP.111: Use a conventional pattern if you really need double-checked locking'
  id: totrans-5022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.111: 如果你真的需要双重检查锁定，请使用传统模式'
- en: Reason
  id: totrans-5023
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Double-checked locking is easy to mess up. If you really need to write your
    own double-checked locking, in spite of the rules [CP.110: Do not write your own
    double-checked locking for initialization](#rconc-double) and [CP.100: Don’t use
    lock-free programming unless you absolutely have to](#rconc-lockfree), then do
    it in a conventional pattern.'
  id: totrans-5024
  prefs: []
  type: TYPE_NORMAL
  zh: '双重检查锁定很容易出错。如果你真的需要编写自己的双重检查锁定，尽管有规则[CP.110: 不要为初始化编写自己的双重检查锁定](#rconc-double)和[CP.100:
    除非你绝对需要，否则不要使用无锁编程](#rconc-lockfree)，那么请按照传统模式进行。'
- en: 'The uses of the double-checked locking pattern that are not in violation of
    [CP.110: Do not write your own double-checked locking for initialization](#rconc-double)
    arise when a non-thread-safe action is both hard and rare, and there exists a
    fast thread-safe test that can be used to guarantee that the action is not needed,
    but cannot be used to guarantee the converse.'
  id: totrans-5025
  prefs: []
  type: TYPE_NORMAL
  zh: '不违反[CP.110: 不要为初始化编写自己的双重检查锁定](#rconc-double)的双重检查锁定模式的使用出现在一个非线程安全操作既困难又罕见，并且存在一个快速的线程安全测试可以用来保证该操作不需要，但不能用来保证相反的情况。'
- en: Example, bad
  id: totrans-5026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: 'The use of volatile does not make the first check thread-safe, see also [CP.200:
    Use `volatile` only to talk to non-C++ memory](#rconc-volatile2)'
  id: totrans-5027
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`volatile`并不能使第一次检查线程安全，参见[CP.200: 仅使用`volatile`与非C++内存通信](#rconc-volatile2)'
- en: '[PRE670]'
  id: totrans-5028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: Example, good
  id: totrans-5029
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE671]'
  id: totrans-5030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: Fine-tuned memory order might be beneficial where acquire load is more efficient
    than sequentially-consistent load
  id: totrans-5031
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取加载比顺序一致加载更有效的地方，微调内存顺序可能是有益的
- en: '[PRE672]'
  id: totrans-5032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: Enforcement
  id: totrans-5033
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ??? Is it possible to detect the idiom?
  id: totrans-5034
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 是否可以检测到这种习语？
- en: 'CP.etc: Etc. concurrency rules'
  id: totrans-5035
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'CP.etc: 等等并发规则'
- en: 'These rules defy simple categorization:'
  id: totrans-5036
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则难以简单分类：
- en: '[CP.200: Use `volatile` only to talk to non-C++ memory](#rconc-volatile2)'
  id: totrans-5037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.200: 仅使用`volatile`与非C++内存通信](#rconc-volatile2)'
- en: '[CP.201: ??? Signals](#rconc-signal)'
  id: totrans-5038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CP.201: ??? 信号](#rconc-signal)'
- en: 'CP.200: Use `volatile` only to talk to non-C++ memory'
  id: totrans-5039
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.200: 仅使用`volatile`与非C++内存通信'
- en: Reason
  id: totrans-5040
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`volatile` is used to refer to objects that are shared with “non-C++” code
    or hardware that does not follow the C++ memory model.'
  id: totrans-5041
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`用于指代与“非-C++”代码或不符合C++内存模型的硬件共享的对象。'
- en: Example
  id: totrans-5042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE673]'
  id: totrans-5043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: 'This describes a register constantly updated by a clock circuit. `clock` is
    `volatile` because its value will change without any action from the C++ program
    that uses it. For example, reading `clock` twice will often yield two different
    values, so the optimizer had better not optimize away the second read in this
    code:'
  id: totrans-5044
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了一个由时钟电路不断更新的寄存器。`clock`是`volatile`的，因为它的值会改变，而不会受到使用它的C++程序采取的任何行动。例如，读取`clock`两次通常会得到两个不同的值，所以优化器最好不要优化掉这段代码中的第二次读取：
- en: '[PRE674]'
  id: totrans-5045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '`clock` is `const` because the program should not try to write to `clock`.'
  id: totrans-5046
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock`是`const`的，因为程序不应该尝试写入`clock`。'
- en: Note
  id: totrans-5047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unless you are writing the lowest level code manipulating hardware directly,
    consider `volatile` an esoteric feature that is best avoided.
  id: totrans-5048
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在编写直接操作硬件的最低级代码，否则请考虑`volatile`是一个最好避免的晦涩特性。
- en: Example
  id: totrans-5049
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Usually C++ code receives `volatile` memory that is owned elsewhere (hardware
    or another language):'
  id: totrans-5050
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C++代码接收到的`volatile`内存是由其他地方（硬件或另一种语言）拥有的：
- en: '[PRE675]'
  id: totrans-5051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: 'Sometimes C++ code allocates the `volatile` memory and shares it with “elsewhere”
    (hardware or another language) by deliberately escaping a pointer:'
  id: totrans-5052
  prefs: []
  type: TYPE_NORMAL
  zh: 有时C++代码会分配`volatile`内存，并通过故意逃逸指针与“其他地方”（硬件或另一种语言）共享：
- en: '[PRE676]'
  id: totrans-5053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: Example, bad
  id: totrans-5054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '`volatile` local variables are nearly always wrong – how can they be shared
    with other languages or hardware if they’re ephemeral? The same applies almost
    as strongly to data members, for the same reason.'
  id: totrans-5055
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile` 本地变量几乎总是错误的——如果它们是瞬时的，它们如何与其他语言或硬件共享？同样的情况几乎同样强烈地适用于数据成员，原因相同。'
- en: '[PRE677]'
  id: totrans-5056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: Note
  id: totrans-5057
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In C++, unlike in some other languages, `volatile` has [nothing to do with synchronization](#rconc-volatile).
  id: totrans-5058
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，与某些其他语言不同，`volatile` 与同步无关(#rconc-volatile)。
- en: Enforcement
  id: totrans-5059
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `volatile T` local and data members; almost certainly you intended to use
    `atomic<T>` instead.
  id: totrans-5060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 `volatile T` 本地成员和数据成员；你几乎肯定是想使用 `atomic<T>` 而不是 `volatile`。
- en: ???
  id: totrans-5061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'CP.201: ??? Signals'
  id: totrans-5062
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'CP.201: ??? 信号'
- en: ???UNIX signal handling???. Might be worth reminding how little is async-signal-safe,
    and how to communicate with a signal handler (best is probably “not at all”)
  id: totrans-5063
  prefs: []
  type: TYPE_NORMAL
  zh: ???UNIX 信号处理???. 可能值得提醒 async-signal-safe 的内容很少，以及如何与信号处理程序通信（最好的可能是“根本不”）
- en: 'E: Error handling'
  id: totrans-5064
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'E: 错误处理'
- en: 'Error handling involves:'
  id: totrans-5065
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理包括：
- en: Detecting an error
  id: totrans-5066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测错误
- en: Transmitting information about an error to some handler code
  id: totrans-5067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误信息传递给某些处理代码
- en: Preserving a valid state of the program
  id: totrans-5068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持程序的有效状态
- en: Avoiding resource leaks
  id: totrans-5069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免资源泄露
- en: It is not possible to recover from all errors. If recovery from an error is
    not possible, it is important to quickly “get out” in a well-defined way. A strategy
    for error handling must be simple, or it becomes a source of even worse errors.
    Untested and rarely executed error-handling code is itself the source of many
    bugs.
  id: totrans-5070
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有错误都可以恢复。如果无法从错误中恢复，那么以定义良好的方式快速“退出”就很重要。错误处理策略必须简单，否则它将成为更严重错误的来源。未经测试且很少执行的错误处理代码本身就是许多错误的来源。
- en: 'The rules are designed to help avoid several kinds of errors:'
  id: totrans-5071
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则旨在帮助避免几种类型的错误：
- en: Type violations (e.g., misuse of `union`s and casts)
  id: totrans-5072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型违规（例如，`union` 和类型转换的误用）
- en: Resource leaks (including memory leaks)
  id: totrans-5073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源泄露（包括内存泄露）
- en: Bounds errors
  id: totrans-5074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围错误
- en: Lifetime errors (e.g., accessing an object after it has been `delete`d)
  id: totrans-5075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期错误（例如，在对象被 `delete` 后访问对象）
- en: Complexity errors (logical errors made likely by overly complex expression of
    ideas)
  id: totrans-5076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性错误（由于想法表达过于复杂而可能产生的逻辑错误）
- en: Interface errors (e.g., an unexpected value is passed through an interface)
  id: totrans-5077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口错误（例如，通过接口传递的意外值）
- en: 'Error-handling rule summary:'
  id: totrans-5078
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理规则摘要：
- en: '[E.1: Develop an error-handling strategy early in a design](#re-design)'
  id: totrans-5079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.1: 在设计早期制定错误处理策略](#re-design)'
- en: '[E.2: Throw an exception to signal that a function can’t perform its assigned
    task](#re-throw)'
  id: totrans-5080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.2: 抛出异常以表示函数无法执行其分配的任务](#re-throw)'
- en: '[E.3: Use exceptions for error handling only](#re-errors)'
  id: totrans-5081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.3: 仅使用异常进行错误处理](#re-errors)'
- en: '[E.4: Design your error-handling strategy around invariants](#re-design-invariants)'
  id: totrans-5082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.4: 围绕不变量设计你的错误处理策略](#re-design-invariants)'
- en: '[E.5: Let a constructor establish an invariant, and throw if it cannot](#re-invariant)'
  id: totrans-5083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.5: 让构造函数建立不变量，如果无法建立则抛出异常](#re-invariant)'
- en: '[E.6: Use RAII to prevent leaks](#re-raii)'
  id: totrans-5084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.6: 使用 RAII 防止泄露](#re-raii)'
- en: '[E.7: State your preconditions](#re-precondition)'
  id: totrans-5085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.7: 陈述你的前置条件](#re-precondition)'
- en: '[E.8: State your postconditions](#re-postcondition)'
  id: totrans-5086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.8: 陈述你的后置条件](#re-postcondition)'
- en: '[E.12: Use `noexcept` when exiting a function because of a `throw` is impossible
    or unacceptable](#re-noexcept)'
  id: totrans-5087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.12: 当退出函数因为抛出是不可能的或不可接受时使用 `noexcept`](#re-noexcept)'
- en: '[E.13: Never throw while being the direct owner of an object](#re-never-throw)'
  id: totrans-5088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.13: 永远不要在直接拥有对象时抛出异常](#re-never-throw)'
- en: '[E.14: Use purpose-designed user-defined types as exceptions (not built-in
    types)](#re-exception-types)'
  id: totrans-5089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.14: 使用专门设计的用户定义类型作为异常（而不是内置类型）](#re-exception-types)'
- en: '[E.15: Throw by value, catch exceptions from a hierarchy by reference](#re-exception-ref)'
  id: totrans-5090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.15: 按值抛出，通过引用捕获异常层次结构中的异常](#re-exception-ref)'
- en: '[E.16: Destructors, deallocation, `swap`, and exception type copy/move construction
    must never fail](#re-never-fail)'
  id: totrans-5091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.16: 析构函数、释放、`swap` 和异常类型复制/移动构造函数绝不能失败](#re-never-fail)'
- en: '[E.17: Don’t try to catch every exception in every function](#re-not-always)'
  id: totrans-5092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.17: 不要尝试在每一个函数中捕获每一个异常](#re-not-always)'
- en: '[E.18: Minimize the use of explicit `try`/`catch`](#re-catch)'
  id: totrans-5093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.18: 最小化显式 `try`/`catch` 的使用](#re-catch)'
- en: '[E.19: Use a `final_action` object to express cleanup if no suitable resource
    handle is available](#re-finally)'
  id: totrans-5094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.19: 使用 `final_action` 对象表达在没有合适的资源句柄时的清理操作](#re-finally)'
- en: '[E.25: If you can’t throw exceptions, simulate RAII for resource management](#re-no-throw-raii)'
  id: totrans-5095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.25: 如果不能抛出异常，模拟 RAII 进行资源管理](#re-no-throw-raii)'
- en: '[E.26: If you can’t throw exceptions, consider failing fast](#re-no-throw-crash)'
  id: totrans-5096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.26: 如果不能抛出异常，考虑快速失败](#re-no-throw-crash)'
- en: '[E.27: If you can’t throw exceptions, use error codes systematically](#re-no-throw-codes)'
  id: totrans-5097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.27: 如果不能抛出异常，则系统地使用错误代码](#re-no-throw-codes)'
- en: '[E.28: Avoid error handling based on global state (e.g. `errno`)](#re-no-throw)'
  id: totrans-5098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.28: 避免基于全局状态的错误处理（例如 `errno`）](#re-no-throw)'
- en: '[E.30: Don’t use exception specifications](#re-specifications)'
  id: totrans-5099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.30: 不要使用异常规范](#re-specifications)'
- en: '[E.31: Properly order your `catch`-clauses](#re_catch)'
  id: totrans-5100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[E.31: 正确排序你的 `catch` 子句](#re_catch)'
- en: 'E.1: Develop an error-handling strategy early in a design'
  id: totrans-5101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.1: 在设计早期开发错误处理策略'
- en: Reason
  id: totrans-5102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A consistent and complete strategy for handling errors and resource leaks is
    hard to retrofit into a system.
  id: totrans-5103
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中实现一致且完整的错误处理和资源泄露策略是困难的。
- en: 'E.2: Throw an exception to signal that a function can’t perform its assigned
    task'
  id: totrans-5104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.2: 抛出异常以表示函数无法执行其分配的任务'
- en: Reason
  id: totrans-5105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To make error handling systematic, robust, and non-repetitive.
  id: totrans-5106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使错误处理系统化、健壮且非重复。
- en: Example
  id: totrans-5107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE678]'
  id: totrans-5108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: Here, `vector` and `string`s constructors might not be able to allocate sufficient
    memory for their elements, `vector`s constructor might not be able to copy the
    `Thing`s in its initializer list, and `File_handle` might not be able to open
    the required file. In each case, they throw an exception for `use()`’s caller
    to handle. If `use()` could handle the failure to construct `bar` it can take
    control using `try`/`catch`. In either case, `Foo`’s constructor correctly destroys
    constructed members before passing control to whatever tried to create a `Foo`.
    Note that there is no return value that could contain an error code.
  id: totrans-5109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`vector` 和 `string` 的构造函数可能无法为其元素分配足够的内存，`vector` 的构造函数可能无法复制其初始化列表中的 `Thing`，而
    `File_handle` 可能无法打开所需的文件。在每种情况下，它们都会抛出异常供 `use()` 的调用者处理。如果 `use()` 能够处理构建 `bar`
    失败，它可以使用 `try`/`catch` 来接管控制。在任何情况下，`Foo` 的构造函数都会在将控制权传递给尝试创建 `Foo` 的任何东西之前正确地销毁已构建的成员。请注意，没有返回值可以包含错误代码。
- en: 'The `File_handle` constructor might be defined like this:'
  id: totrans-5110
  prefs: []
  type: TYPE_NORMAL
  zh: '`File_handle` 构造函数可能定义如下：'
- en: '[PRE679]'
  id: totrans-5111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: Note
  id: totrans-5112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is often said that exceptions are meant to signal exceptional events and
    failures. However, that’s a bit circular because “what is exceptional?” Examples:'
  id: totrans-5113
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，异常是用来表示异常事件和失败的。然而，这有点循环，因为“什么是异常？”例子：
- en: A precondition that cannot be met
  id: totrans-5114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法满足的先决条件
- en: A constructor that cannot construct an object (failure to establish its class’s
    [invariant](#rc-struct))
  id: totrans-5115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法构建对象的构造函数（无法建立其类的 [invariant](#rc-struct)）
- en: An out-of-range error (e.g., `v[v.size()] = 7`)
  id: totrans-5116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越界错误（例如，`v[v.size()] = 7`）
- en: Inability to acquire a resource (e.g., the network is down)
  id: totrans-5117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法获取资源（例如，网络断开）
- en: In contrast, termination of an ordinary loop is not exceptional. Unless the
    loop was meant to be infinite, termination is normal and expected.
  id: totrans-5118
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，普通循环的终止不是异常的。除非循环被设计成无限循环，否则终止是正常和预期的。
- en: Note
  id: totrans-5119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t use a `throw` as simply an alternative way of returning a value from a
    function.
  id: totrans-5120
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将 `throw` 仅作为从函数中返回值的替代方式。
- en: Exception
  id: totrans-5121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Some systems, such as hard-real-time systems require a guarantee that an action
    is taken in a (typically short) constant maximum time known before execution starts.
    Such systems can use exceptions only if there is tool support for accurately predicting
    the maximum time to recover from a `throw`.
  id: totrans-5122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统，例如硬实时系统，需要保证在执行开始前采取一个（通常是短）恒定的最大时间来执行一个动作。这样的系统只有在有工具支持准确预测从 `throw` 中恢复的最大时间时才能使用异常。
- en: '**See also**: [RAII](#re-raii)'
  id: totrans-5123
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [RAII](#re-raii)'
- en: '**See also**: [discussion](#sd-noexcept)'
  id: totrans-5124
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [讨论](#sd-noexcept)'
- en: Note
  id: totrans-5125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Before deciding that you cannot afford or don’t like exception-based error handling,
    have a look at the [alternatives](#re-no-throw-raii); they have their own complexities
    and problems. Also, as far as possible, measure before making claims about efficiency.
  id: totrans-5126
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定你负担不起或不喜欢异常处理之前，先看看[替代方案](#re-no-throw-raii)；它们有自己的复杂性和问题。此外，尽可能在做出关于效率的声明之前进行测量。
- en: 'E.3: Use exceptions for error handling only'
  id: totrans-5127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.3: 仅用于错误处理的异常'
- en: Reason
  id: totrans-5128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To keep error handling separated from “ordinary code.” C++ implementations tend
    to be optimized based on the assumption that exceptions are rare.
  id: totrans-5129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将错误处理与“普通代码”分开。C++ 实现往往基于异常很少的假设进行优化。
- en: Example, don’t
  id: totrans-5130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不要
- en: '[PRE680]'
  id: totrans-5131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: This is more complicated and most likely runs much slower than the obvious alternative.
    There is nothing exceptional about finding a value in a `vector`.
  id: totrans-5132
  prefs: []
  type: TYPE_NORMAL
  zh: 这更复杂，并且很可能比明显的替代方案运行得慢得多。在`vector`中找到一个值并没有什么异常。
- en: Enforcement
  id: totrans-5133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Would need to be heuristic. Look for exception values “leaked” out of `catch`
    clauses.
  id: totrans-5134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用启发式方法。寻找“泄漏”出`catch`子句的异常值。
- en: 'E.4: Design your error-handling strategy around invariants'
  id: totrans-5135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.4：围绕不变性设计你的错误处理策略
- en: Reason
  id: totrans-5136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To use an object it must be in a valid state (defined formally or informally
    by an invariant) and to recover from an error every object not destroyed must
    be in a valid state.
  id: totrans-5137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个对象，它必须处于有效状态（正式或非正式地由不变性定义），并且为了从错误中恢复，每个未被销毁的对象都必须处于有效状态。
- en: Note
  id: totrans-5138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An [invariant](#rc-struct) is a logical condition for the members of an object
    that a constructor must establish for the public member functions to assume.
  id: totrans-5139
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性是一个逻辑条件，构造函数必须为对象的成员建立，以便公共成员函数可以假设。
- en: Enforcement
  id: totrans-5140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5141
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'E.5: Let a constructor establish an invariant, and throw if it cannot'
  id: totrans-5142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.5：让构造函数建立不变性，如果无法建立则抛出异常
- en: Reason
  id: totrans-5143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Leaving an object without its invariant established is asking for trouble. Not
    all member functions can be called.
  id: totrans-5144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象没有建立其不变性，就会带来麻烦。并不是所有成员函数都可以调用。
- en: Example
  id: totrans-5145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE681]'
  id: totrans-5146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: The class invariant - here stated as a comment - is established by the constructors.
    `new` throws if it cannot allocate the required memory. The operators, notably
    the subscript operator, rely on the invariant.
  id: totrans-5147
  prefs: []
  type: TYPE_NORMAL
  zh: 类的不变性——这里以注释的形式说明——由构造函数建立。`new`如果无法分配所需的内存则抛出。运算符，特别是下标运算符，依赖于不变性。
- en: '**See also**: [If a constructor cannot construct a valid object, throw an exception](#rc-throw)'
  id: totrans-5148
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[如果构造函数无法构造一个有效的对象，则抛出异常](#rc-throw)'
- en: Enforcement
  id: totrans-5149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag classes with `private` state without a constructor (public, protected,
    or private).
  id: totrans-5150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用没有构造函数的`private`状态标记类（公共、受保护或私有）。
- en: 'E.6: Use RAII to prevent leaks'
  id: totrans-5151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.6：使用RAII防止漏洞
- en: Reason
  id: totrans-5152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Leaks are typically unacceptable. Manual resource release is error-prone. RAII
    (“Resource Acquisition Is Initialization”) is the simplest, most systematic way
    of preventing leaks.
  id: totrans-5153
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞通常是不可接受的。手动资源释放容易出错。RAII（“资源获取即初始化”）是防止漏洞最简单、最系统的方法。
- en: Example
  id: totrans-5154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE682]'
  id: totrans-5155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: 'We could carefully release the resource before the throw:'
  id: totrans-5156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在抛出之前谨慎地释放资源：
- en: '[PRE683]'
  id: totrans-5157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: This is verbose. In larger code with multiple possible `throw`s explicit releases
    become repetitive and error-prone.
  id: totrans-5158
  prefs: []
  type: TYPE_NORMAL
  zh: 这很冗长。在较大的代码中，有多个可能的`throw`时，显式释放会变得重复且容易出错。
- en: '[PRE684]'
  id: totrans-5159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: 'Note that this works even when the `throw` is implicit because it happened
    in a called function:'
  id: totrans-5160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使`throw`是隐式的，因为它是发生在调用函数中，这也同样适用：
- en: '[PRE685]'
  id: totrans-5161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: 'Unless you really need pointer semantics, use a local resource object:'
  id: totrans-5162
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你真的需要指针语义，否则请使用局部资源对象：
- en: '[PRE686]'
  id: totrans-5163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: That’s even simpler and safer, and often more efficient.
  id: totrans-5164
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至更简单、更安全，并且通常更有效。
- en: Note
  id: totrans-5165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If there is no obvious resource handle and for some reason defining a proper
    RAII object/handle is infeasible, as a last resort, cleanup actions can be represented
    by a [`final_action`](#re-finally) object.
  id: totrans-5166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明显的资源句柄，并且由于某种原因定义适当的RAII对象/句柄不可行，作为最后的手段，清理操作可以通过一个`final_action`对象来表示。
- en: Note
  id: totrans-5167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'But what do we do if we are writing a program where exceptions cannot be used?
    First challenge that assumption; there are many anti-exceptions myths around.
    We know of only a few good reasons:'
  id: totrans-5168
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们正在编写不能使用异常的程序，我们该怎么办？首先挑战这个假设；关于反异常的神话有很多。我们只知道几个好的理由：
- en: We are on a system so small that the exception support would eat up most of
    our 2K memory.
  id: totrans-5169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在一个如此小的系统上，异常支持会占用我们大部分的2K内存。
- en: We are in a hard-real-time system and we don’t have tools that guarantee us
    that an exception is handled within the required time.
  id: totrans-5170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们处于一个硬实时系统，我们没有工具可以保证我们在所需的时间内处理异常。
- en: We are in a system with tons of legacy code using lots of pointers in difficult-to-understand
    ways (in particular without a recognizable ownership strategy) so that exceptions
    could cause leaks.
  id: totrans-5171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们处于一个使用大量指针且难以理解的系统（特别是没有可识别的所有权策略）中，因此异常可能会引起漏洞。
- en: Our implementation of the C++ exception mechanisms is unreasonably poor (slow,
    memory consuming, failing to work correctly for dynamically linked libraries,
    etc.). Complain to your implementation purveyor; if no user complains, no improvement
    will happen.
  id: totrans-5172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的C++异常机制实现不合理地差（慢、消耗内存、对于动态链接库无法正确工作等）。向你的实现提供商投诉；如果没有用户投诉，就不会发生改进。
- en: We get fired if we challenge our manager’s ancient wisdom.
  id: totrans-5173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们挑战我们经理的古老智慧，我们就会被解雇。
- en: 'Only the first of these reasons is fundamental, so whenever possible, use exceptions
    to implement RAII, or design your RAII objects to never fail. When exceptions
    cannot be used, simulate RAII. That is, systematically check that objects are
    valid after construction and still release all resources in the destructor. One
    strategy is to add a `valid()` operation to every resource handle:'
  id: totrans-5174
  prefs: []
  type: TYPE_NORMAL
  zh: 只有第一个原因是根本性的，因此只要可能，就使用异常来实现 RAII，或者设计你的 RAII 对象以确保永远不会失败。当无法使用异常时，模拟 RAII。也就是说，系统地检查对象在构造后仍然有效，并在析构函数中释放所有资源。一种策略是为每个资源句柄添加一个
    `valid()` 操作：
- en: '[PRE687]'
  id: totrans-5175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: Obviously, this increases the size of the code, doesn’t allow for implicit propagation
    of “exceptions” (`valid()` checks), and `valid()` checks can be forgotten. Prefer
    to use exceptions.
  id: totrans-5176
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这会增加代码的大小，不允许隐式传播“异常”（`valid()` 检查），并且可能会忘记 `valid()` 检查。最好使用异常。
- en: '**See also**: [Use of `noexcept`](#re-noexcept)'
  id: totrans-5177
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**: [使用 `noexcept`](#re-noexcept)'
- en: Enforcement
  id: totrans-5178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5179
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'E.7: State your preconditions'
  id: totrans-5180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.7: 明确你的前置条件'
- en: Reason
  id: totrans-5181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid interface errors.
  id: totrans-5182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免接口错误。
- en: '**See also**: [precondition rule](#ri-pre)'
  id: totrans-5183
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**: [前置条件规则](#ri-pre)'
- en: 'E.8: State your postconditions'
  id: totrans-5184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.8: 明确你的后置条件'
- en: Reason
  id: totrans-5185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid interface errors.
  id: totrans-5186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免接口错误。
- en: '**See also**: [postcondition rule](#ri-post)'
  id: totrans-5187
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**: [后置条件规则](#ri-post)'
- en: 'E.12: Use `noexcept` when exiting a function because of a `throw` is impossible
    or unacceptable'
  id: totrans-5188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.12: 当由于 `throw` 不可能或不可接受而退出函数时使用 `noexcept`'
- en: Reason
  id: totrans-5189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To make error handling systematic, robust, and efficient.
  id: totrans-5190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使错误处理系统化、健壮和高效。
- en: Example
  id: totrans-5191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE688]'
  id: totrans-5192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: Here, we know that `compute` will not throw because it is composed out of operations
    that don’t throw. By declaring `compute` to be `noexcept`, we give the compiler
    and human readers information that can make it easier for them to understand and
    manipulate `compute`.
  id: totrans-5193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们知道 `compute` 不会抛出异常，因为它由不抛出异常的操作组成。通过将 `compute` 声明为 `noexcept`，我们向编译器和人类读者提供了可以让他们更容易理解和操作
    `compute` 的信息。
- en: Note
  id: totrans-5194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Many standard-library functions are `noexcept` including all the standard-library
    functions “inherited” from the C Standard Library.
  id: totrans-5195
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准库函数都是 `noexcept`，包括所有从 C 标准库“继承”的标准库函数。
- en: Example
  id: totrans-5196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE689]'
  id: totrans-5197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: The `noexcept` here states that I am not willing or able to handle the situation
    where I cannot construct the local `vector`. That is, I consider memory exhaustion
    a serious design error (on par with hardware failures) so that I’m willing to
    crash the program if it happens.
  id: totrans-5198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `noexcept` 表示我不愿意或能够处理无法构造局部 `vector` 的情况。也就是说，我认为内存耗尽是一个严重的错误设计（与硬件故障相当），因此如果发生这种情况，我愿意让程序崩溃。
- en: Note
  id: totrans-5199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use traditional [exception-specifications](#re-specifications).
  id: totrans-5200
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用传统的 [异常指定](#re-specifications)。
- en: See also
  id: totrans-5201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参见
- en: '[discussion](#sd-noexcept).'
  id: totrans-5202
  prefs: []
  type: TYPE_NORMAL
  zh: '[讨论](#sd-noexcept)。'
- en: 'E.13: Never throw while being the direct owner of an object'
  id: totrans-5203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.13: 在直接拥有对象时永远不要抛出异常'
- en: Reason
  id: totrans-5204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That would be a leak.
  id: totrans-5205
  prefs: []
  type: TYPE_NORMAL
  zh: 那将是一个泄漏。
- en: Example
  id: totrans-5206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE690]'
  id: totrans-5207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'One way of avoiding such problems is to use resource handles consistently:'
  id: totrans-5208
  prefs: []
  type: TYPE_NORMAL
  zh: 避免此类问题的方法是一致地使用资源句柄：
- en: '[PRE691]'
  id: totrans-5209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: 'Another solution (often better) would be to use a local variable to eliminate
    explicit use of pointers:'
  id: totrans-5210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更好的解决方案是使用局部变量来消除对指针的显式使用：
- en: '[PRE692]'
  id: totrans-5211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: Note
  id: totrans-5212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you have a local “thing” that requires cleanup, but is not represented by
    an object with a destructor, such cleanup must also be done before a `throw`.
    Sometimes, [`finally()`](#re-finally) can make such unsystematic cleanup a bit
    more manageable.
  id: totrans-5213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要清理的本地“东西”，但它不是由具有析构函数的对象表示，那么这种清理也必须在 `throw` 之前完成。有时，`finally()`（#re-finally）可以使这种不系统的清理更容易管理。
- en: 'E.14: Use purpose-designed user-defined types as exceptions (not built-in types)'
  id: totrans-5214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.14: 使用专门设计的用户定义类型作为异常（而不是内置类型）'
- en: Reason
  id: totrans-5215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A user-defined type can better transmit information about an error to a handler.
    Information can be encoded into the type itself and the type is unlikely to clash
    with other people’s exceptions.
  id: totrans-5216
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的类型可以更好地将有关错误的信息传递给处理程序。信息可以编码到类型本身，并且类型不太可能与他人的异常冲突。
- en: Example
  id: totrans-5217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE693]'
  id: totrans-5218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: 'Deriving from `std::exception` gives the flexibility to catch the specific
    exception or handle generally through `std::exception`:'
  id: totrans-5219
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `std::exception` 派生提供了捕获特定异常或通过 `std::exception` 通用处理的灵活性：
- en: '[PRE694]'
  id: totrans-5220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'Exceptions do not need to be derived from `std::exception`:'
  id: totrans-5221
  prefs: []
  type: TYPE_NORMAL
  zh: 异常不需要从 `std::exception` 派生：
- en: '[PRE695]'
  id: totrans-5222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: 'Library types derived from `std::exception` can be used as generic exceptions
    if no useful information can be added at the point of detection:'
  id: totrans-5223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从 `std::exception` 派生的库类型在检测点无法添加有用信息，则可以用作通用异常：
- en: '[PRE696]'
  id: totrans-5224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '`enum` classes are also allowed:'
  id: totrans-5225
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 类也是允许的：'
- en: '[PRE697]'
  id: totrans-5226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: Enforcement
  id: totrans-5227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Catch `throw` of built-in types and `std::exception`.
  id: totrans-5228
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获 `throw` 的内置类型和 `std::exception`。
- en: 'E.15: Throw by value, catch exceptions from a hierarchy by reference'
  id: totrans-5229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.15: 通过值抛出，通过引用捕获来自继承体系的异常'
- en: Reason
  id: totrans-5230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Throwing by value (not by pointer) and catching by reference prevents copying,
    especially slicing base subobjects.
  id: totrans-5231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值抛出（而不是通过指针）和通过引用捕获防止复制，特别是切片基子对象。
- en: Example; bad
  id: totrans-5232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例；不好
- en: '[PRE698]'
  id: totrans-5233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: 'Instead, use a reference:'
  id: totrans-5234
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用一个引用：
- en: '[PRE699]'
  id: totrans-5235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: 'or - typically better still - a `const` reference:'
  id: totrans-5236
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 - 通常更好 - 一个 `const` 引用：
- en: '[PRE700]'
  id: totrans-5237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: Most handlers do not modify their exception and in general we [recommend use
    of `const`](#res-const).
  id: totrans-5238
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数处理程序不会修改它们的异常，通常我们[推荐使用 `const`](#res-const)。
- en: Note
  id: totrans-5239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Catch by value can be appropriate for a small value type such as an `enum` value.
  id: totrans-5240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值捕获对于小值类型，如 `enum` 值，可能是合适的。
- en: Note
  id: totrans-5241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To rethrow a caught exception use `throw;` not `throw e;`. Using `throw e;`
    would throw a new copy of `e` (sliced to the static type `std::exception`, when
    the exception is caught by `catch (const std::exception& e)`) instead of rethrowing
    the original exception of type `std::runtime_error`. (But keep [Don’t try to catch
    every exception in every function](#re-not-always) and [Minimize the use of explicit
    `try`/`catch`](#re-catch) in mind.)
  id: totrans-5242
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新抛出一个捕获的异常，请使用 `throw;` 而不是 `throw e;`。使用 `throw e;` 会抛出一个新的 `e` 的副本（当异常被
    `catch (const std::exception& e)` 捕获时，会被裁剪到静态类型 `std::exception`），而不是重新抛出原始的 `std::runtime_error`
    类型的异常。（但请记住[不要在每一个函数中尝试捕获每一个异常](#re-not-always)和[最小化显式 `try`/`catch` 的使用](#re-catch)）
- en: Enforcement
  id: totrans-5243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag catching by value of a type that has a virtual function.
  id: totrans-5244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记捕获具有虚拟函数的类型。
- en: Flag throwing raw pointers.
  id: totrans-5245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记抛出原始指针。
- en: 'E.16: Destructors, deallocation, `swap`, and exception type copy/move construction
    must never fail'
  id: totrans-5246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.16: 析构函数、释放资源、`swap`操作和异常类型拷贝/移动构造函数绝不能失败'
- en: Reason
  id: totrans-5247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: We don’t know how to write reliable programs if a destructor, a swap, a memory
    deallocation, or attempting to copy/move-construct an exception object fails;
    that is, if it exits by an exception or simply doesn’t perform its required action.
  id: totrans-5248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果析构函数、swap、内存释放或尝试复制/移动构造异常对象失败；即，如果它通过异常退出或简单地没有执行其所需操作，我们就不知道如何编写可靠的程序。
- en: Example, don’t
  id: totrans-5249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不要
- en: '[PRE701]'
  id: totrans-5250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: Note
  id: totrans-5251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Many have tried to write reliable code violating this rule for examples, such
    as a network connection that “refuses to close”. To the best of our knowledge
    nobody has found a general way of doing this. Occasionally, for very specific
    examples, you can get away with setting some state for future cleanup. For example,
    we might put a socket that does not want to close on a “bad socket” list, to be
    examined by a regular sweep of the system state. Every example we have seen of
    this is error-prone, specialized, and often buggy.
  id: totrans-5252
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人试图编写遵守此规则的可靠代码，例如一个“拒绝关闭”的网络连接。据我们所知，没有人找到一种通用的方法来做这件事。偶尔，对于非常具体的例子，你可以通过设置一些状态以供将来清理来避免这种情况。例如，我们可能将一个不想关闭的套接字放在“坏套接字”列表中，以便在系统状态的常规扫描中被检查。我们所看到的每一个例子都是易出错的、专门的，并且通常有错误。
- en: Note
  id: totrans-5253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The standard library assumes that destructors, deallocation functions (e.g.,
    `operator delete`), and `swap` do not throw. If they do, basic standard-library
    invariants are broken.
  id: totrans-5254
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库假设析构函数、释放资源函数（例如，`operator delete`）和 `swap` 不会抛出异常。如果它们抛出异常，基本标准库的不变性就会被破坏。
- en: Note
  id: totrans-5255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Deallocation functions, including `operator delete`, must be `noexcept`.
  id: totrans-5256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放资源函数，包括 `operator delete`，必须是 `noexcept`。
- en: '`swap` functions must be `noexcept`.'
  id: totrans-5257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap` 函数必须是 `noexcept`。'
- en: Most destructors are implicitly `noexcept` by default.
  id: totrans-5258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数析构函数默认情况下隐式地是 `noexcept`。
- en: Also, [make move operations `noexcept`](#rc-move-noexcept).
  id: totrans-5259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，[使移动操作 `noexcept`](#rc-move-noexcept)。
- en: If writing a type intended to be used as an exception type, ensure its copy
    constructor is `noexcept`. In general we cannot mechanically enforce this, because
    we do not know whether a type is intended to be used as an exception type.
  id: totrans-5260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编写一个打算用作异常类型的类型，请确保其拷贝构造函数是 `noexcept`。通常我们无法机械地强制执行此操作，因为我们不知道一个类型是否打算用作异常类型。
- en: Try not to `throw` a type whose copy constructor is not `noexcept`. In general
    we cannot mechanically enforce this, because even `throw std::string(...)` could
    throw but does not in practice.
  id: totrans-5261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量不要抛出一个其拷贝构造函数不是 `noexcept` 的类型。通常我们无法机械地强制执行此操作，因为即使是 `throw std::string(...)`
    也可能抛出异常，但在实践中并不抛出。
- en: Enforcement
  id: totrans-5262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Catch destructors, deallocation operations, and `swap`s that `throw`.
  id: totrans-5263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获抛出异常的析构函数、释放操作和 `swap`。
- en: Catch such operations that are not `noexcept`.
  id: totrans-5264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获那些不是 `noexcept` 的操作。
- en: '**See also**: [discussion](#sd-never-fail)'
  id: totrans-5265
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[讨论](#sd-never-fail)'
- en: 'E.17: Don’t try to catch every exception in every function'
  id: totrans-5266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.17：不要尝试在每一个函数中捕获每一个异常
- en: Reason
  id: totrans-5267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Catching an exception in a function that cannot take a meaningful recovery action
    leads to complexity and waste. Let an exception propagate until it reaches a function
    that can handle it. Let cleanup actions on the unwinding path be handled by [RAII](#re-raii).
  id: totrans-5268
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法采取有意义恢复动作的函数中捕获异常会导致复杂性和浪费。让异常传播，直到它到达可以处理的函数。让路径上的清理操作由 [RAII](#re-raii)
    处理。
- en: Example, don’t
  id: totrans-5269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不要
- en: '[PRE702]'
  id: totrans-5270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: Enforcement
  id: totrans-5271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag nested try-blocks.
  id: totrans-5272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记嵌套的 try 块。
- en: 'Flag source code files with a too high ratio of try-blocks to functions. (???
    Problem: define “too high”)'
  id: totrans-5273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 try 块与函数比例过高的源代码文件。（??? 问题：定义“过高”）
- en: 'E.18: Minimize the use of explicit `try`/`catch`'
  id: totrans-5274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.18：最小化显式 `try`/`catch` 的使用
- en: Reason
  id: totrans-5275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`try`/`catch` is verbose and non-trivial uses are error-prone. `try`/`catch`
    can be a sign of unsystematic and/or low-level resource management or error handling.'
  id: totrans-5276
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`catch` 语句较为冗长且非简单使用容易出错。`try`/`catch` 可能是缺乏系统性和/或低级别资源管理或错误处理的标志。'
- en: Example, Bad
  id: totrans-5277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE703]'
  id: totrans-5278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: 'This code is messy. There could be a leak from the naked pointer in the `try`
    block. Not all exceptions are handled. `deleting` an object that failed to construct
    is almost certainly a mistake. Better:'
  id: totrans-5279
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很混乱。`try` 块中的裸指针可能存在泄漏。并非所有异常都得到了处理。`删除` 未成功构造的对象几乎肯定是一个错误。更好的做法：
- en: '[PRE704]'
  id: totrans-5280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: Alternatives
  id: totrans-5281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: proper resource handles and [RAII](#re-raii)
  id: totrans-5282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的资源句柄和 [RAII](#re-raii)
- en: '[`finally`](#re-finally)'
  id: totrans-5283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`finally`](#re-finally)'
- en: Enforcement
  id: totrans-5284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ??? hard, needs a heuristic
  id: totrans-5285
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 困难，需要启发式方法
- en: 'E.19: Use a `final_action` object to express cleanup if no suitable resource
    handle is available'
  id: totrans-5286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.19：使用 `final_action` 对象表达清理，如果没有合适的资源句柄
- en: Reason
  id: totrans-5287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`finally` from the [GSL](#gsl-guidelines-support-library) is less verbose and
    harder to get wrong than `try`/`catch`.'
  id: totrans-5288
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [GSL](#gsl-guidelines-support-library) 的 `finally` 比传统的 `try`/`catch` 更简洁，也更不容易出错。
- en: Example
  id: totrans-5289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE705]'
  id: totrans-5290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: Note
  id: totrans-5291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`finally` is not as messy as `try`/`catch`, but it is still ad-hoc. Prefer
    [proper resource management objects](#re-raii). Consider `finally` a last resort.'
  id: totrans-5292
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 比起 `try`/`catch` 来说不太混乱，但它仍然是临时的。优先考虑 [适当的资源管理对象](#re-raii)。将 `finally`
    视为最后的手段。'
- en: Note
  id: totrans-5293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Use of `finally` is a systematic and reasonably clean alternative to the old
    [`goto exit;` technique](#re-no-throw-codes) for dealing with cleanup where resource
    management is not systematic.
  id: totrans-5294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `finally` 是处理清理的一种系统化和相对干净的替代方法，这种方法适用于资源管理不系统的情况。
- en: Enforcement
  id: totrans-5295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Heuristic: Detect `goto exit;`'
  id: totrans-5296
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式：检测 `goto exit;`
- en: 'E.25: If you can’t throw exceptions, simulate RAII for resource management'
  id: totrans-5297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.25：如果你不能抛出异常，模拟 RAII 以进行资源管理
- en: Reason
  id: totrans-5298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Even without exceptions, [RAII](#re-raii) is usually the best and most systematic
    way of dealing with resources.
  id: totrans-5299
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有异常，[RAII](#re-raii) 通常也是处理资源的最优和最系统化的方法。
- en: Note
  id: totrans-5300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Error handling using exceptions is the only complete and systematic way of handling
    non-local errors in C++. In particular, non-intrusively signaling failure to construct
    an object requires an exception. Signaling errors in a way that cannot be ignored
    requires exceptions. If you can’t use exceptions, simulate their use as best you
    can.
  id: totrans-5301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，使用异常处理非局部错误是唯一完整和系统化的方法。特别是，要无侵入地指示对象构造失败，需要使用异常。以无法忽略的方式指示错误也需要使用异常。如果你不能使用异常，尽可能模拟其使用。
- en: 'A lot of fear of exceptions is misguided. When used for exceptional circumstances
    in code that is not littered with pointers and complicated control structures,
    exception handling is almost always affordable (in time and space) and almost
    always leads to better code. This, of course, assumes a good implementation of
    the exception handling mechanisms, which is not available on all systems. There
    are also cases where the problems above do not apply, but exceptions cannot be
    used for other reasons. Some hard-real-time systems are an example: An operation
    has to be completed within a fixed time with an error or a correct answer. In
    the absence of appropriate time estimation tools, this is hard to guarantee for
    exceptions. Such systems (e.g. flight control software) typically also ban the
    use of dynamic (heap) memory.'
  id: totrans-5302
  prefs: []
  type: TYPE_NORMAL
  zh: 对异常的很多恐惧都是没有根据的。当用于没有指针和复杂控制结构的代码中的异常情况时，异常处理几乎总是负担得起的（在时间和空间上）并且几乎总是导致更好的代码。当然，这假设了良好的异常处理机制实现，这并非所有系统都具备。也存在上述问题不适用，但出于其他原因不能使用异常的情况。一些硬实时系统就是一个例子：操作必须在固定时间内完成，否则会有错误或正确答案。在没有适当的时间估计工具的情况下，这很难保证异常。这样的系统（例如，飞行控制系统）通常也禁止使用动态（堆）内存。
- en: So, the primary guideline for error handling is “use exceptions and [RAII](#re-raii).”
    This section deals with the cases where you either do not have an efficient implementation
    of exceptions, or have such a rat’s nest of old-style code (e.g., lots of pointers,
    ill-defined ownership, and lots of unsystematic error handling based on tests
    of error codes) that it is infeasible to introduce simple and systematic exception
    handling.
  id: totrans-5303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，错误处理的初级指南是“使用异常和[RAII](#re-raii)。”本节讨论的是你既没有有效的异常实现，或者有如此混乱的老式代码（例如，大量指针、未定义的所有权以及大量基于错误代码测试的非系统化错误处理）以至于引入简单和系统的异常处理是不切实际的案例。
- en: Before condemning exceptions or complaining too much about their cost, consider
    examples of the use of [error codes](#re-no-throw-codes). Consider the cost and
    complexity of the use of error codes. If performance is your worry, measure.
  id: totrans-5304
  prefs: []
  type: TYPE_NORMAL
  zh: 在谴责异常或过多抱怨它们的成本之前，考虑使用[错误代码](#re-no-throw-codes)的例子。考虑使用错误代码的成本和复杂性。如果你担心性能，进行测量。
- en: Example
  id: totrans-5305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Assume you wanted to write
  id: totrans-5306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写
- en: '[PRE706]'
  id: totrans-5307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: 'If the `gadget` isn’t correctly constructed, `func` exits with an exception.
    If we cannot throw an exception, we can simulate this RAII style of resource handling
    by adding a `valid()` member function to `Gadget`:'
  id: totrans-5308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`gadget`没有正确构建，`func`会通过异常退出。如果我们不能抛出异常，我们可以通过向`Gadget`添加一个`valid()`成员函数来模拟这种RAII风格的资源处理：
- en: '[PRE707]'
  id: totrans-5309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: The problem is of course that the caller now has to remember to test the return
    value. To encourage doing so, consider adding a `[[nodiscard]]`.
  id: totrans-5310
  prefs: []
  type: TYPE_NORMAL
  zh: 当然的问题是调用者现在必须记住检查返回值。为了鼓励这样做，考虑添加一个`[[nodiscard]]`。
- en: '**See also**: [Discussion](#sd-???)'
  id: totrans-5311
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[讨论](#sd-???)'
- en: Enforcement
  id: totrans-5312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Possible (only) for specific versions of this idea: e.g., test for systematic
    test of `valid()` after resource handle construction'
  id: totrans-5313
  prefs: []
  type: TYPE_NORMAL
  zh: 可能（仅）适用于这个想法的特定版本：例如，在资源句柄构建后系统地测试`valid()`
- en: 'E.26: If you can’t throw exceptions, consider failing fast'
  id: totrans-5314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.26：如果你不能抛出异常，考虑快速失败
- en: Reason
  id: totrans-5315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you can’t do a good job at recovering, at least you can get out before too
    much consequential damage is done.
  id: totrans-5316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能很好地恢复，至少你可以在造成太多后果性损害之前退出。
- en: '**See also**: [Simulating RAII](#re-no-throw-raii)'
  id: totrans-5317
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[模拟RAII](#re-no-throw-raii)'
- en: Note
  id: totrans-5318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you cannot be systematic about error handling, consider “crashing” as a response
    to any error that cannot be handled locally. That is, if you cannot recover from
    an error in the context of the function that detected it, call `abort()`, `quick_exit()`,
    or a similar function that will trigger some sort of system restart.
  id: totrans-5319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能系统地处理错误，考虑将“崩溃”作为对任何无法本地处理的错误的响应。也就是说，如果你不能从检测到错误的函数的上下文中恢复，调用`abort()`、`quick_exit()`或类似的函数，这将触发某种形式的系统重启。
- en: In systems where you have lots of processes and/or lots of computers, you need
    to expect and handle fatal crashes anyway, say from hardware failures. In such
    cases, “crashing” is simply leaving error handling to the next level of the system.
  id: totrans-5320
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有大量进程和/或大量计算机的系统上，你需要预期并处理致命崩溃，例如来自硬件故障。在这种情况下，“崩溃”只是将错误处理留给系统的下一级。
- en: Example
  id: totrans-5321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE708]'
  id: totrans-5322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: Most programs cannot handle memory exhaustion gracefully anyway. This is roughly
    equivalent to
  id: totrans-5323
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序无论如何都无法优雅地处理内存耗尽。这大致相当于
- en: '[PRE709]'
  id: totrans-5324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: Typically, it is a good idea to log the reason for the “crash” before exiting.
  id: totrans-5325
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在退出之前记录“崩溃”的原因是一个好主意。
- en: Enforcement
  id: totrans-5326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Awkward
  id: totrans-5327
  prefs: []
  type: TYPE_NORMAL
  zh: 令人尴尬
- en: 'E.27: If you can’t throw exceptions, use error codes systematically'
  id: totrans-5328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.27: 如果不能抛出异常，则系统地使用错误代码'
- en: Reason
  id: totrans-5329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Systematic use of any error-handling strategy minimizes the chance of forgetting
    to handle an error.
  id: totrans-5330
  prefs: []
  type: TYPE_NORMAL
  zh: 系统性地使用任何错误处理策略可以最小化忘记处理错误的机会。
- en: '**See also**: [Simulating RAII](#re-no-throw-raii)'
  id: totrans-5331
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [模拟RAII](#re-no-throw-raii)'
- en: Note
  id: totrans-5332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are several issues to be addressed:'
  id: totrans-5333
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个问题需要解决：
- en: How do you transmit an error indicator from out of a function?
  id: totrans-5334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何从函数外部传递错误指示器？
- en: How do you release all resources from a function before doing an error exit?
  id: totrans-5335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在错误退出之前从函数中释放所有资源？
- en: What do you use as an error indicator?
  id: totrans-5336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用什么作为错误指示器？
- en: 'In general, returning an error indicator implies returning two values: The
    result and an error indicator. The error indicator can be part of the object,
    e.g. an object can have a `valid()` indicator or a pair of values can be returned.'
  id: totrans-5337
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，返回错误指示器意味着返回两个值：结果和错误指示器。错误指示器可以是对象的一部分，例如，对象可以有一个`valid()`指示器，或者可以返回一对值。
- en: Example
  id: totrans-5338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE710]'
  id: totrans-5339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: This approach fits with [simulated RAII resource management](#re-no-throw-raii).
    The `valid()` function could return an `error_indicator` (e.g. a member of an
    `error_indicator` enumeration).
  id: totrans-5340
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与[模拟RAII资源管理](#re-no-throw-raii)相匹配。`valid()`函数可以返回一个`error_indicator`（例如，`error_indicator`枚举的一个成员）。
- en: Example
  id: totrans-5341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'What if we cannot or do not want to modify the `Gadget` type? In that case,
    we must return a pair of values. For example:'
  id: totrans-5342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法或不想修改`Gadget`类型怎么办？在这种情况下，我们必须返回一对值。例如：
- en: '[PRE711]'
  id: totrans-5343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: 'As shown, `std::pair` is a possible return type. Some people prefer a specific
    type. For example:'
  id: totrans-5344
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`std::pair`是一个可能的返回类型。有些人更喜欢特定类型。例如：
- en: '[PRE712]'
  id: totrans-5345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: One reason to prefer a specific return type is to have names for its members,
    rather than the somewhat cryptic `first` and `second` and to avoid confusion with
    other uses of `std::pair`.
  id: totrans-5346
  prefs: []
  type: TYPE_NORMAL
  zh: 偏好特定返回类型的一个原因是为其成员提供名称，而不是有点神秘的`first`和`second`，以及避免与其他`std::pair`的使用混淆。
- en: Example
  id: totrans-5347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'In general, you must clean up before an error exit. This can be messy:'
  id: totrans-5348
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在错误退出之前必须清理。这可能会很混乱：
- en: '[PRE713]'
  id: totrans-5349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'Simulating RAII can be non-trivial, especially in functions with multiple resources
    and multiple possible errors. A not uncommon technique is to gather cleanup at
    the end of the function to avoid repetition (note that the extra scope around
    `g2` is undesirable but necessary to make the `goto` version compile):'
  id: totrans-5350
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟RAII可能相当复杂，尤其是在具有多个资源和多个可能错误的函数中。一种不常见的技巧是在函数末尾收集清理以避免重复（请注意，围绕`g2`的额外作用域是不理想的但必要的，以便使`goto`版本编译）：
- en: '[PRE714]'
  id: totrans-5351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: The larger the function, the more tempting this technique becomes. `finally`
    can [ease the pain a bit](#re-finally). Also, the larger the program becomes the
    harder it is to apply an error-indicator-based error-handling strategy systematically.
  id: totrans-5352
  prefs: []
  type: TYPE_NORMAL
  zh: 函数越大，这种技术就越诱人。`finally`可以[稍微减轻痛苦](#re-finally)。此外，程序越大，系统地应用基于错误指示器的错误处理策略就越困难。
- en: We [prefer exception-based error handling](#re-throw) and recommend [keeping
    functions short](#rf-single).
  id: totrans-5353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们[更喜欢基于异常的错误处理](#re-throw)并建议[保持函数简短](#rf-single)。
- en: '**See also**: [Discussion](#sd-???)'
  id: totrans-5354
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [讨论](#sd-???)'
- en: '**See also**: [Returning multiple values](#rf-out-multi)'
  id: totrans-5355
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [返回多个值](#rf-out-multi)'
- en: Enforcement
  id: totrans-5356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Awkward.
  id: totrans-5357
  prefs: []
  type: TYPE_NORMAL
  zh: 令人尴尬。
- en: 'E.28: Avoid error handling based on global state (e.g. `errno`)'
  id: totrans-5358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.28: 避免基于全局状态的错误处理（例如`errno`）'
- en: Reason
  id: totrans-5359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Global state is hard to manage and it is easy to forget to check it. When did
    you last test the return value of `printf()`?
  id: totrans-5360
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态难以管理，很容易忘记检查它。你上次测试`printf()`的返回值是什么时候？
- en: '**See also**: [Simulating RAII](#re-no-throw-raii)'
  id: totrans-5361
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [模拟RAII](#re-no-throw-raii)'
- en: Example, bad
  id: totrans-5362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE715]'
  id: totrans-5363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: Note
  id: totrans-5364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: C-style error handling is based on the global variable `errno`, so it is essentially
    impossible to avoid this style completely.
  id: totrans-5365
  prefs: []
  type: TYPE_NORMAL
  zh: C样式错误处理基于全局变量`errno`，因此基本上不可能完全避免这种风格。
- en: Enforcement
  id: totrans-5366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Awkward.
  id: totrans-5367
  prefs: []
  type: TYPE_NORMAL
  zh: 令人尴尬。
- en: 'E.30: Don’t use exception specifications'
  id: totrans-5368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'E.30: 不要使用异常指定'
- en: Reason
  id: totrans-5369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Exception specifications make error handling brittle, impose a run-time cost,
    and have been removed from the C++ standard.
  id: totrans-5370
  prefs: []
  type: TYPE_NORMAL
  zh: 异常指定使错误处理变得脆弱，增加了运行时成本，并且已被从C++标准中删除。
- en: Example
  id: totrans-5371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE716]'
  id: totrans-5372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: If `f()` throws an exception different from `X` and `Y` the unexpected handler
    is invoked, which by default terminates. That’s OK, but say that we have checked
    that this cannot happen and `f` is changed to throw a new exception `Z`, we now
    have a crash on our hands unless we change `use()` (and re-test everything). The
    snag is that `f()` might be in a library we do not control and the new exception
    is not anything that `use()` can do anything about or is in any way interested
    in. We can change `use()` to pass `Z` through, but now `use()`’s callers probably
    need to be modified. This quickly becomes unmanageable. Alternatively, we can
    add a `try`-`catch` to `use()` to map `Z` into an acceptable exception. This,
    too, quickly becomes unmanageable. Note that changes to the set of exceptions
    often happen at the lowest level of a system (e.g., because of changes to a network
    library or some middleware), so changes “bubble up” through long call chains.
    In a large code base, this could mean that nobody could update to a new version
    of a library until the last user was modified. If `use()` is part of a library,
    it might not be possible to update it because a change could affect unknown clients.
  id: totrans-5373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`f()`抛出与`X`和`Y`不同的异常，则调用意外处理程序，默认情况下会终止。这没问题，但假设我们已经检查了这种情况不会发生，并将`f`更改为抛出一个新的异常`Z`，我们现在遇到了崩溃，除非我们更改`use()`（并重新测试一切）。问题是`f()`可能在一个我们无法控制的库中，新的异常不是`use()`可以处理或以任何方式感兴趣的。我们可以将`use()`更改为传递`Z`，但现在`use()`的调用者可能需要被修改。这很快就会变得难以管理。或者，我们可以在`use()`中添加一个`try-catch`来将`Z`映射到可接受的异常。这也很快就会变得难以管理。请注意，异常集的变化通常发生在系统的最低层（例如，由于网络库或某些中间件的变化），因此变化“向上冒泡”通过长的调用链。在一个大型代码库中，这可能意味着没有人能够更新到库的新版本，直到最后一个用户被修改。如果`use()`是库的一部分，可能无法更新它，因为更改可能会影响未知的客户端。
- en: The policy of letting exceptions propagate until they reach a function that
    potentially can handle it has proven itself over the years.
  id: totrans-5374
  prefs: []
  type: TYPE_NORMAL
  zh: 允许异常传播直到它们到达一个可能可以处理它的函数的政策在多年中已经证明了自己的价值。
- en: Note
  id: totrans-5375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: No. This would not be any better had exception specifications been statically
    enforced. For example, see [Stroustrup94](#Stroustrup94).
  id: totrans-5376
  prefs: []
  type: TYPE_NORMAL
  zh: No. 即使异常规范被静态强制执行，这也不会有任何改善。例如，参见[Stroustrup94](#Stroustrup94)。
- en: Note
  id: totrans-5377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If no exception can be thrown, use [`noexcept`](#re-noexcept).
  id: totrans-5378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能抛出异常，请使用`[noexcept](#re-noexcept)`。
- en: Enforcement
  id: totrans-5379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag every exception specification.
  id: totrans-5380
  prefs: []
  type: TYPE_NORMAL
  zh: 标记每个异常规范。
- en: 'E.31: Properly order your `catch`-clauses'
  id: totrans-5381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: E.31：正确排序你的`catch`子句
- en: Reason
  id: totrans-5382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`catch`-clauses are evaluated in the order they appear and one clause can hide
    another.'
  id: totrans-5383
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`子句按它们出现的顺序进行评估，一个子句可以隐藏另一个子句。'
- en: Example, bad
  id: totrans-5384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE717]'
  id: totrans-5385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: If `Derived`is derived from `Base` the `Derived`-handler will never be invoked.
    The “catch everything” handler ensured that the `std::exception`-handler will
    never be invoked.
  id: totrans-5386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Derived`从`Base`派生，则`Derived`处理程序永远不会被调用。 “捕获一切”处理程序确保`std::exception`处理程序永远不会被调用。
- en: Enforcement
  id: totrans-5387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all “hiding handlers”.
  id: totrans-5388
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有“隐藏处理程序”。
- en: 'Con: Constants and immutability'
  id: totrans-5389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Con：常量和不可变性
- en: You can’t have a race condition on a constant. It is easier to reason about
    a program when many of the objects cannot change their values. Interfaces that
    promise “no change” of objects passed as arguments greatly increase readability.
  id: totrans-5390
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在常量上产生竞争条件。当许多对象不能改变它们的值时，更容易对程序进行推理。承诺“不改变”作为参数传递的对象的接口大大增加了可读性。
- en: 'Constant rule summary:'
  id: totrans-5391
  prefs: []
  type: TYPE_NORMAL
  zh: 常量规则摘要：
- en: '[Con.1: By default, make objects immutable](#rconst-immutable)'
  id: totrans-5392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Con.1：默认情况下，使对象不可变](#rconst-immutable)'
- en: '[Con.2: By default, make member functions `const`](#rconst-fct)'
  id: totrans-5393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Con.2：默认情况下，使成员函数`const`](#rconst-fct)'
- en: '[Con.3: By default, pass pointers and references to `const`s](#rconst-ref)'
  id: totrans-5394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Con.3：默认情况下，传递指向`const`的指针和引用](#rconst-ref)'
- en: '[Con.4: Use `const` to define objects with values that do not change after
    construction](#rconst-const)'
  id: totrans-5395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Con.4：使用`const`来定义构造后值不改变的对象](#rconst-const)'
- en: '[Con.5: Use `constexpr` for values that can be computed at compile time](#rconst-constexpr)'
  id: totrans-5396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Con.5：对于可以在编译时计算的值使用`constexpr`](#rconst-constexpr)'
- en: 'Con.1: By default, make objects immutable'
  id: totrans-5397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Con.1：默认情况下，使对象不可变
- en: Reason
  id: totrans-5398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Immutable objects are easier to reason about, so make objects non-`const` only
    when there is a need to change their value. Prevents accidental or hard-to-notice
    change of value.
  id: totrans-5399
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象更容易推理，因此只有在需要更改它们的值时才将对象设置为非`const`。防止意外或难以注意到的值变化。
- en: Example
  id: totrans-5400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE718]'
  id: totrans-5401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: Exceptions
  id: totrans-5402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: A local variable that is returned by value and is cheaper to move than copy
    should not be declared `const` because it can force an unnecessary copy.
  id: totrans-5403
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通过值返回的局部变量，如果移动比复制更便宜，则不应声明为`const`，因为它可能强制进行不必要的复制。
- en: '[PRE719]'
  id: totrans-5404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: Function parameters passed by value are rarely mutated, but also rarely declared
    `const`. To avoid confusion and lots of false positives, don’t enforce this rule
    for function parameters.
  id: totrans-5405
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递的函数参数很少被修改，但也很少声明为`const`。为了避免混淆和大量错误，不要对函数参数强制执行此规则。
- en: '[PRE720]'
  id: totrans-5406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: Note that a function parameter is a local variable so changes to it are local.
  id: totrans-5407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数参数是一个局部变量，因此对其的更改是局部的。
- en: Enforcement
  id: totrans-5408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag non-`const` variables that are not modified (except for parameters to avoid
    many false positives and returned local variables)
  id: totrans-5409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记未修改的（除了参数以避免许多错误和返回的局部变量）非`const`变量
- en: 'Con.2: By default, make member functions `const`'
  id: totrans-5410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Con.2：默认情况下，使成员函数`const`
- en: Reason
  id: totrans-5411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A member function should be marked `const` unless it changes the object’s observable
    state. This gives a more precise statement of design intent, better readability,
    more errors caught by the compiler, and sometimes more optimization opportunities.
  id: totrans-5412
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数应该标记为`const`，除非它改变对象的可观察状态。这给出了更精确的设计意图声明，更好的可读性，编译器捕获的错误更多，有时还有更多的优化机会。
- en: Example, bad
  id: totrans-5413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE721]'
  id: totrans-5414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: Note
  id: totrans-5415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It is not inherently bad to pass a pointer or reference to non-`const`, but
    that should be done only when the called function is supposed to modify the object.
    A reader of code must assume that a function that takes a “plain” `T*` or `T&`
    will modify the object referred to. If it doesn’t now, it might do so later without
    forcing recompilation.
  id: totrans-5416
  prefs: []
  type: TYPE_NORMAL
  zh: 将指针或引用传递给非`const`本身并不是坏事，但只有在被调用的函数应该修改对象时才应该这样做。代码的阅读者必须假设一个接受“普通”`T*`或`T&`的函数将修改所引用的对象。如果现在没有这样做，它可能会在不需要重新编译的情况下稍后这样做。
- en: Note
  id: totrans-5417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are code/libraries that offer functions that declare a `T*` even though
    those functions do not modify that `T`. This is a problem for people modernizing
    code. You can
  id: totrans-5418
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些代码/库提供了声明`T*`的函数，即使这些函数没有修改那个`T`。这对正在现代化代码的人来说是一个问题。你可以
- en: update the library to be `const`-correct; preferred long-term solution
  id: totrans-5419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新库以使其`const`正确；首选的长期解决方案
- en: “cast away `const`”; [best avoided](#res-casts-const)
  id: totrans-5420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “取消`const`的`cast`”；[最好避免](#res-casts-const)
- en: provide a wrapper function
  id: totrans-5421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供包装函数
- en: 'Example:'
  id: totrans-5422
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE722]'
  id: totrans-5423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: Note that this wrapper solution is a patch that should be used only when the
    declaration of `f()` cannot be modified, e.g. because it is in a library that
    you cannot modify.
  id: totrans-5424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种包装解决方案是一个补丁，仅应在无法修改`f()`的声明时使用，例如，因为它在一个你无法修改的库中。
- en: Note
  id: totrans-5425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A `const` member function can modify the value of an object that is `mutable`
    or accessed through a pointer member. A common use is to maintain a cache rather
    than repeatedly do a complicated computation. For example, here is a `Date` that
    caches (memoizes) its string representation to simplify repeated uses:'
  id: totrans-5426
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`const`成员函数可以修改一个`mutable`或通过指针成员访问的对象的值。一个常见的用途是维护一个缓存，而不是反复进行复杂的计算。例如，这里是一个缓存（记忆化）其字符串表示形式的`Date`，以简化重复使用：
- en: '[PRE723]'
  id: totrans-5427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: Another way of saying this is that `const`ness is not transitive. It is possible
    for a `const` member function to change the value of `mutable` members and the
    value of objects accessed through non-`const` pointers. It is the job of the class
    to ensure such mutation is done only when it makes sense according to the semantics
    (invariants) it offers to its users.
  id: totrans-5428
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以说`const`性不是传递的。一个`const`成员函数可以改变`mutable`成员和通过非`const`指针访问的对象的值。确保这种突变仅在根据它提供给用户的语义（不变性）有意义时进行，这是类的职责。
- en: '**See also**: [Pimpl](#ri-pimpl)'
  id: totrans-5429
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**: [Pimpl](#ri-pimpl)'
- en: Enforcement
  id: totrans-5430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag a member function that is not marked `const`, but that does not perform
    a non-`const` operation on any data member.
  id: totrans-5431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个成员函数，该函数未标记为`const`，但不对任何数据成员执行非`const`操作。
- en: 'Con.3: By default, pass pointers and references to `const`s'
  id: totrans-5432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Con.3：默认情况下，传递`const`的指针和引用
- en: Reason
  id: totrans-5433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid a called function unexpectedly changing the value. It’s far easier
    to reason about programs when called functions don’t modify state.
  id: totrans-5434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免被调用的函数意外地改变值。当被调用的函数不修改状态时，对程序进行推理要容易得多。
- en: Example
  id: totrans-5435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE724]'
  id: totrans-5436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: Note
  id: totrans-5437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It is not inherently bad to pass a pointer or reference to non-`const`, but
    that should be done only when the called function is supposed to modify the object.
  id: totrans-5438
  prefs: []
  type: TYPE_NORMAL
  zh: 将指针或引用传递给非`const`本身并不是坏事，但只有在被调用的函数应该修改对象时才应该这样做。
- en: Note
  id: totrans-5439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Do not cast away `const`](#res-casts-const).'
  id: totrans-5440
  prefs: []
  type: TYPE_NORMAL
  zh: '[不要取消`const`的转换](#res-casts-const)。'
- en: Enforcement
  id: totrans-5441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag a function that does not modify an object passed by pointer or reference
    to non-`const`
  id: totrans-5442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个不修改通过指针或引用传递给非`const`的对象的函数
- en: Flag a function that (using a cast) modifies an object passed by pointer or
    reference to `const`
  id: totrans-5443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个（使用类型转换）修改通过指针或引用传递给`const`的对象的函数
- en: 'Con.4: Use `const` to define objects with values that do not change after construction'
  id: totrans-5444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Con.4: 使用`const`来定义构造后值不改变的对象'
- en: Reason
  id: totrans-5445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Prevent surprises from unexpectedly changed object values.
  id: totrans-5446
  prefs: []
  type: TYPE_NORMAL
  zh: 防止意外改变对象值带来的惊喜。
- en: Example
  id: totrans-5447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE725]'
  id: totrans-5448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: As `x` is not `const`, we must assume that it is modified somewhere in the loop.
  id: totrans-5449
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`x`不是`const`，我们必须假设它在循环的某个地方被修改了。
- en: Enforcement
  id: totrans-5450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag unmodified non-`const` variables.
  id: totrans-5451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记未修改的非`const`变量。
- en: 'Con.5: Use `constexpr` for values that can be computed at compile time'
  id: totrans-5452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Con.5: 使用`constexpr`来定义可以在编译时计算的值'
- en: Reason
  id: totrans-5453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Better performance, better compile-time checking, guaranteed compile-time evaluation,
    no possibility of race conditions.
  id: totrans-5454
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的性能，更好的编译时检查，保证编译时评估，没有竞争条件发生的可能性。
- en: Example
  id: totrans-5455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE726]'
  id: totrans-5456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: Note
  id: totrans-5457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: See F.4.
  id: totrans-5458
  prefs: []
  type: TYPE_NORMAL
  zh: 见F.4。
- en: Enforcement
  id: totrans-5459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `const` definitions with constant expression initializers.
  id: totrans-5460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常量表达式初始化器标记`const`定义。
- en: 'T: Templates and generic programming'
  id: totrans-5461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'T: 模板和泛型编程'
- en: Generic programming is programming using types and algorithms parameterized
    by types, values, and algorithms. In C++, generic programming is supported by
    the `template` language mechanisms.
  id: totrans-5462
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程是使用类型和算法参数化的编程，这些类型、值和算法在C++中被`template`语言机制所支持。
- en: Arguments to generic functions are characterized by sets of requirements on
    the argument types and values involved. In C++, these requirements are expressed
    by compile-time predicates called concepts.
  id: totrans-5463
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数的参数由对涉及参数类型和值的要求的集合来表征。在C++中，这些要求通过称为概念的编译时谓词来表示。
- en: Templates can also be used for meta-programming; that is, programs that compose
    code at compile time.
  id: totrans-5464
  prefs: []
  type: TYPE_NORMAL
  zh: 模板也可以用于元编程；也就是说，在编译时组合代码的程序。
- en: A central notion in generic programming is “concepts”; that is, requirements
    on template arguments presented as compile-time predicates. “Concepts” were standardized
    in C++20, although they were first made available, in slightly older syntax, in
    GCC 6.1.
  id: totrans-5465
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程中的一个中心概念是“概念”；即作为编译时谓词呈现的对模板参数的要求。“概念”在C++20中被标准化，尽管它们最初在GCC 6.1中提供，语法略有不同。
- en: 'Template use rule summary:'
  id: totrans-5466
  prefs: []
  type: TYPE_NORMAL
  zh: 模板使用规则摘要：
- en: '[T.1: Use templates to raise the level of abstraction of code](#rt-raise)'
  id: totrans-5467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.1: 使用模板来提高代码的抽象级别](#rt-raise)'
- en: '[T.2: Use templates to express algorithms that apply to many argument types](#rt-algo)'
  id: totrans-5468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.2: 使用模板来表示适用于许多参数类型的算法](#rt-algo)'
- en: '[T.3: Use templates to express containers and ranges](#rt-cont)'
  id: totrans-5469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.3: 使用模板来表示容器和范围](#rt-cont)'
- en: '[T.4: Use templates to express syntax tree manipulation](#rt-expr)'
  id: totrans-5470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.4: 使用模板来表示语法树操作](#rt-expr)'
- en: '[T.5: Combine generic and OO techniques to amplify their strengths, not their
    costs](#rt-generic-oo)'
  id: totrans-5471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.5: 结合泛型和OO技术以增强其优势，而不是成本](#rt-generic-oo)'
- en: 'Concept use rule summary:'
  id: totrans-5472
  prefs: []
  type: TYPE_NORMAL
  zh: 概念使用规则摘要：
- en: '[T.10: Specify concepts for all template arguments](#rt-concepts)'
  id: totrans-5473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.10: 为所有模板参数指定概念](#rt-concepts)'
- en: '[T.11: Whenever possible use standard concepts](#rt-std-concepts)'
  id: totrans-5474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.11: 在可能的情况下使用标准概念](#rt-std-concepts)'
- en: '[T.12: Prefer concept names over `auto` for local variables](#rt-auto)'
  id: totrans-5475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.12: 对于局部变量，优先使用概念名称而不是`auto`](#rt-auto)'
- en: '[T.13: Prefer the shorthand notation for simple, single-type argument concepts](#rt-shorthand)'
  id: totrans-5476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.13: 优先使用简单、单类型参数概念的缩写表示法](#rt-shorthand)'
- en: ???
  id: totrans-5477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'Concept definition rule summary:'
  id: totrans-5478
  prefs: []
  type: TYPE_NORMAL
  zh: 概念定义规则摘要：
- en: '[T.20: Avoid “concepts” without meaningful semantics](#rt-low)'
  id: totrans-5479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.20: 避免无实际语义的“概念”](#rt-low)'
- en: '[T.21: Require a complete set of operations for a concept](#rt-complete)'
  id: totrans-5480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.21: 对概念要求一组完整的操作](#rt-complete)'
- en: '[T.22: Specify axioms for concepts](#rt-axiom)'
  id: totrans-5481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.22: 为概念指定公理](#rt-axiom)'
- en: '[T.23: Differentiate a refined concept from its more general case by adding
    new use patterns](#rt-refine)'
  id: totrans-5482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.23: 通过添加新的使用模式来区分经过细化的概念和其更一般的情况](#rt-refine)'
- en: '[T.24: Use tag classes or traits to differentiate concepts that differ only
    in semantics](#rt-tag)'
  id: totrans-5483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.24: 使用标记类或特性来区分仅在语义上不同的概念](#rt-tag)'
- en: '[T.25: Avoid complementary constraints](#rt-not)'
  id: totrans-5484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.25: 避免互补约束](#rt-not)'
- en: '[T.26: Prefer to define concepts in terms of use-patterns rather than simple
    syntax](#rt-use)'
  id: totrans-5485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.26: 优先使用使用模式来定义概念，而不是简单的语法](#rt-use)'
- en: '[T.30: Use concept negation (`!C<T>`) sparingly to express a minor difference](#rt-???)'
  id: totrans-5486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.30: 节省使用概念否定 (`!C<T>`) 来表达细微差异](#rt-???)'
- en: '[T.31: Use concept disjunction (`C1<T> || C2<T>`) sparingly to express alternatives](#rt-???)'
  id: totrans-5487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.31: 节省使用概念析取 (`C1<T> || C2<T>`) 来表达替代方案](#rt-???)'
- en: ???
  id: totrans-5488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'Template interface rule summary:'
  id: totrans-5489
  prefs: []
  type: TYPE_NORMAL
  zh: 模板接口规则摘要：
- en: '[T.40: Use function objects to pass operations to algorithms](#rt-fo)'
  id: totrans-5490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.40: 使用函数对象将操作传递给算法](#rt-fo)'
- en: '[T.41: Require only essential properties in a template’s concepts](#rt-essential)'
  id: totrans-5491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.41: 在模板的概念中仅要求必要属性](#rt-essential)'
- en: '[T.42: Use template aliases to simplify notation and hide implementation details](#rt-alias)'
  id: totrans-5492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.42: 使用模板别名简化表示并隐藏实现细节](#rt-alias)'
- en: '[T.43: Prefer `using` over `typedef` for defining aliases](#rt-using)'
  id: totrans-5493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.43: 在定义别名时，优先使用 `using` 而不是 `typedef`](#rt-using)'
- en: '[T.44: Use function templates to deduce class template argument types (where
    feasible)](#rt-deduce)'
  id: totrans-5494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.44: 在可行的情况下，使用函数模板推导类模板参数类型](#rt-deduce)'
- en: '[T.46: Require template arguments to be at least semiregular](#rt-regular)'
  id: totrans-5495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.46: 要求模板参数至少是半正则的](#rt-regular)'
- en: '[T.47: Avoid highly visible unconstrained templates with common names](#rt-visible)'
  id: totrans-5496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.47: 避免使用常见名称的高度可见的非约束模板](#rt-visible)'
- en: '[T.48: If your compiler does not support concepts, fake them with `enable_if`](#rt-concept-def)'
  id: totrans-5497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.48: 如果你的编译器不支持概念，则使用 `enable_if` 模拟它们](#rt-concept-def)'
- en: '[T.49: Where possible, avoid type-erasure](#rt-erasure)'
  id: totrans-5498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.49: 在可能的情况下，避免类型擦除](#rt-erasure)'
- en: 'Template definition rule summary:'
  id: totrans-5499
  prefs: []
  type: TYPE_NORMAL
  zh: 模板定义规则摘要：
- en: '[T.60: Minimize a template’s context dependencies](#rt-depend)'
  id: totrans-5500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.60: 最小化模板的上下文依赖](#rt-depend)'
- en: '[T.61: Do not over-parameterize members (SCARY)](#rt-scary)'
  id: totrans-5501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.61: 不要过度参数化成员（令人恐惧）](#rt-scary)'
- en: '[T.62: Place non-dependent class template members in a non-templated base class](#rt-nondependent)'
  id: totrans-5502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.62: 将非依赖的类模板成员放置在非模板基类中](#rt-nondependent)'
- en: '[T.64: Use specialization to provide alternative implementations of class templates](#rt-specialization)'
  id: totrans-5503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.64: 使用特化来提供类模板的替代实现](#rt-specialization)'
- en: '[T.65: Use tag dispatch to provide alternative implementations of functions](#rt-tag-dispatch)'
  id: totrans-5504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.65: 使用标签分派提供函数的替代实现](#rt-tag-dispatch)'
- en: '[T.67: Use specialization to provide alternative implementations for irregular
    types](#rt-specialization2)'
  id: totrans-5505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.67: 使用特化为不规则类型提供替代实现](#rt-specialization2)'
- en: '[T.68: Use `{}` rather than `()` within templates to avoid ambiguities](#rt-cast)'
  id: totrans-5506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.68: 在模板内部使用 `{}` 而不是 `()` 以避免歧义](#rt-cast)'
- en: '[T.69: Inside a template, don’t make an unqualified non-member function call
    unless you intend it to be a customization point](#rt-customization)'
  id: totrans-5507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.69: 在模板内部，除非你打算将其作为定制点，否则不要调用未指定名称的非成员函数](#rt-customization)'
- en: 'Template and hierarchy rule summary:'
  id: totrans-5508
  prefs: []
  type: TYPE_NORMAL
  zh: 模板和层次结构规则摘要：
- en: '[T.80: Do not naively templatize a class hierarchy](#rt-hier)'
  id: totrans-5509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.80: 不要天真地模板化类层次结构](#rt-hier)'
- en: '[T.81: Do not mix hierarchies and arrays](#rt-array) // ??? somewhere in “hierarchies”'
  id: totrans-5510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.81: 不要混合层次结构和数组](#rt-array) // ??? 在“hierarchies”中某处'
- en: '[T.82: Linearize a hierarchy when virtual functions are undesirable](#rt-linear)'
  id: totrans-5511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.82: 当不希望使用虚函数时，线性化层次结构](#rt-linear)'
- en: '[T.83: Do not declare a member function template virtual](#rt-virtual)'
  id: totrans-5512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.83: 不要声明成员函数模板为虚函数](#rt-virtual)'
- en: '[T.84: Use a non-template core implementation to provide an ABI-stable interface](#rt-abi)'
  id: totrans-5513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.84: 使用非模板核心实现来提供 ABI 稳定的接口](#rt-abi)'
- en: '[T.??: ????](#rt-???)'
  id: totrans-5514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.??: ????](#rt-???)'
- en: 'Variadic template rule summary:'
  id: totrans-5515
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板规则摘要：
- en: '[T.100: Use variadic templates when you need a function that takes a variable
    number of arguments of a variety of types](#rt-variadic)'
  id: totrans-5516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.100: 当你需要一个可以接受多种类型变量数量可变的功能时，使用变长模板](#rt-variadic)'
- en: '[T.101: ??? How to pass arguments to a variadic template ???](#rt-variadic-pass)'
  id: totrans-5517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.101: ??? 如何向变长模板传递参数 ???](#rt-variadic-pass)'
- en: '[T.102: ??? How to process arguments to a variadic template ???](#rt-variadic-process)'
  id: totrans-5518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.102: ??? 如何处理变长模板的参数 ???](#rt-variadic-process)'
- en: '[T.103: Don’t use variadic templates for homogeneous argument lists](#rt-variadic-not)'
  id: totrans-5519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.103: 不要为同构参数列表使用变长模板](#rt-variadic-not)'
- en: '[T.??: ????](#rt-???)'
  id: totrans-5520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.??: ????](#rt-???)'
- en: 'Metaprogramming rule summary:'
  id: totrans-5521
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程规则摘要：
- en: '[T.120: Use template metaprogramming only when you really need to](#rt-metameta)'
  id: totrans-5522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.120: 只有在真正需要时才使用模板元编程](#rt-metameta)'
- en: '[T.121: Use template metaprogramming primarily to emulate concepts](#rt-emulate)'
  id: totrans-5523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.121: 主要使用模板元编程来模拟概念](#rt-emulate)'
- en: '[T.122: Use templates (usually template aliases) to compute types at compile
    time](#rt-tmp)'
  id: totrans-5524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.122: 使用模板（通常是模板别名）在编译时计算类型](#rt-tmp)'
- en: '[T.123: Use `constexpr` functions to compute values at compile time](#rt-fct)'
  id: totrans-5525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.123: 使用 `constexpr` 函数在编译时计算值](#rt-fct)'
- en: '[T.124: Prefer to use standard-library TMP facilities](#rt-std-tmp)'
  id: totrans-5526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.124: 优先使用标准库 TMP 功能](#rt-std-tmp)'
- en: '[T.125: If you need to go beyond the standard-library TMP facilities, use an
    existing library](#rt-lib)'
  id: totrans-5527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.125: 如果需要超出标准库 TMP 功能，请使用现有库](#rt-lib)'
- en: '[T.??: ????](#rt-???)'
  id: totrans-5528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.??: ????](#rt-???)'
- en: 'Other template rules summary:'
  id: totrans-5529
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模板规则摘要：
- en: '[T.140: If an operation can be reused, give it a name](#rt-name)'
  id: totrans-5530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.140: 如果一个操作可以被重用，给它起个名字](#rt-name)'
- en: '[T.141: Use an unnamed lambda if you need a simple function object in one place
    only](#rt-lambda)'
  id: totrans-5531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.141: 如果只需要一个简单的函数对象，使用未命名的lambda](#rt-lambda)'
- en: '[T.142: Use template variables to simplify notation](#rt-var)'
  id: totrans-5532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.142: 使用模板变量简化表示](#rt-var)'
- en: '[T.143: Don’t write unintentionally non-generic code](#rt-non-generic)'
  id: totrans-5533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.143: 不要编写无意中非泛型代码](#rt-non-generic)'
- en: '[T.144: Don’t specialize function templates](#rt-specialize-function)'
  id: totrans-5534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.144: 不要专门化函数模板](#rt-specialize-function)'
- en: '[T.150: Check that a class matches a concept using `static_assert`](#rt-check-class)'
  id: totrans-5535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.150: 使用`static_assert`检查类是否匹配概念](#rt-check-class)'
- en: '[T.??: ????](#rt-???)'
  id: totrans-5536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.??: ????](#rt-???)'
- en: 'T.gp: Generic programming'
  id: totrans-5537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'T.gp: 泛型编程'
- en: Generic programming is programming using types and algorithms parameterized
    by types, values, and algorithms.
  id: totrans-5538
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程是使用类型和由类型、值和算法参数化的算法进行编程。
- en: 'T.1: Use templates to raise the level of abstraction of code'
  id: totrans-5539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.1: 使用模板提高代码的抽象层次'
- en: Reason
  id: totrans-5540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Generality. Reuse. Efficiency. Encourages consistent definition of user types.
  id: totrans-5541
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化性。重用。效率。鼓励用户类型的一致定义。
- en: Example, bad
  id: totrans-5542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: 'Conceptually, the following requirements are wrong because what we want of
    `T` is more than just the very low-level concepts of “can be incremented” or “can
    be added”:'
  id: totrans-5543
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，以下要求是错误的，因为我们对`T`的要求不仅仅是“可以递增”或“可以相加”等非常低级的概念：
- en: '[PRE727]'
  id: totrans-5544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: Assuming that `Incrementable` does not support `+` and `Simple_number` does
    not support `+=`, we have overconstrained implementers of `sum1` and `sum2`. And,
    in this case, missed an opportunity for a generalization.
  id: totrans-5545
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Incrementable`不支持`+`，而`Simple_number`不支持`+=`，我们对`sum1`和`sum2`的实现者进行了过度约束。在这种情况下，错过了一个泛化的机会。
- en: Example
  id: totrans-5546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE728]'
  id: totrans-5547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: Assuming that `Arithmetic` requires both `+` and `+=`, we have constrained the
    user of `sum` to provide a complete arithmetic type. That is not a minimal requirement,
    but it gives the implementer of algorithms much needed freedom and ensures that
    any `Arithmetic` type can be used for a wide variety of algorithms.
  id: totrans-5548
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Arithmetic`需要`+`和`+=`，我们对`sum`的使用者施加了提供完整算术类型的约束。这不是最小要求，但它为算法的实现者提供了所需的自由度，并确保任何`Arithmetic`类型都可以用于广泛的算法。
- en: For additional generality and reusability, we could also use a more general
    `Container` or `Range` concept instead of committing to only one container, `vector`.
  id: totrans-5549
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加泛化性和重用性，我们还可以使用更通用的`Container`或`Range`概念，而不是只承诺使用一个容器，即`vector`。
- en: Note
  id: totrans-5550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If we define a template to require exactly the operations required for a single
    implementation of a single algorithm (e.g., requiring just `+=` rather than also
    `=` and `+`) and only those, we have overconstrained maintainers. We aim to minimize
    requirements on template arguments, but the absolutely minimal requirements of
    an implementation is rarely a meaningful concept.
  id: totrans-5551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义一个模板，要求恰好满足单个算法单个实现的所需操作（例如，仅要求`+=`而不是也要求`=`和`+`）并且仅这些，我们就对模板参数施加了过度约束。我们的目标是尽量减少对模板参数的要求，但实现的绝对最小要求很少是一个有意义的概念。
- en: Note
  id: totrans-5552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Templates can be used to express essentially everything (they are Turing complete),
    but the aim of generic programming (as expressed using templates) is to efficiently
    generalize operations/algorithms over a set of types with similar semantic properties.
  id: totrans-5553
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以用来表达几乎所有内容（它们是图灵完备的），但泛型编程（如使用模板表达）的目标是高效地将操作/算法泛化到具有相似语义属性的类型集合上。
- en: Enforcement
  id: totrans-5554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag algorithms with “overly simple” requirements, such as direct use of specific
    operators without a concept.
  id: totrans-5555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记具有“过于简单”要求的算法，例如直接使用特定运算符而不使用概念。
- en: Do not flag the definition of the “overly simple” concepts themselves; they
    might simply be building blocks for more useful concepts.
  id: totrans-5556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要标记“过于简单”的概念定义本身；它们可能只是更有用概念的基础。
- en: 'T.2: Use templates to express algorithms that apply to many argument types'
  id: totrans-5557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.2: 使用模板来表示适用于许多参数类型的算法'
- en: Reason
  id: totrans-5558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Generality. Minimizing the amount of source code. Interoperability. Reuse.
  id: totrans-5559
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化性。最小化源代码量。互操作性。重用。
- en: Example
  id: totrans-5560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'That’s the foundation of the STL. A single `find` algorithm easily works with
    any kind of input range:'
  id: totrans-5561
  prefs: []
  type: TYPE_NORMAL
  zh: 这是STL的基础。单个`find`算法可以轻松地与任何类型的输入范围一起工作：
- en: '[PRE729]'
  id: totrans-5562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: Note
  id: totrans-5563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t use a template unless you have a realistic need for more than one template
    argument type. Don’t overabstract.
  id: totrans-5564
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你确实需要超过一种模板参数类型，否则不要使用模板。不要过度抽象。
- en: Enforcement
  id: totrans-5565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ??? tough, probably needs a human
  id: totrans-5566
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 困难，可能需要人工处理
- en: 'T.3: Use templates to express containers and ranges'
  id: totrans-5567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.3：使用模板来表示容器和范围
- en: Reason
  id: totrans-5568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Containers need an element type, and expressing that as a template argument
    is general, reusable, and type safe. It also avoids brittle or inefficient workarounds.
    Convention: That’s the way the STL does it.'
  id: totrans-5569
  prefs: []
  type: TYPE_NORMAL
  zh: 容器需要一个元素类型，将其表示为模板参数是通用的、可重用的且类型安全的。它还避免了脆弱或不高效的工作方式。惯例：这是STL的做法。
- en: Example
  id: totrans-5570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE730]'
  id: totrans-5571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: Example, bad
  id: totrans-5572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE731]'
  id: totrans-5573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: This doesn’t directly express the intent of the programmer and hides the structure
    of the program from the type system and optimizer.
  id: totrans-5574
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有直接表达程序员的意图，并隐藏了程序的结构从类型系统和优化器中。
- en: Hiding the `void*` behind macros simply obscures the problems and introduces
    new opportunities for confusion.
  id: totrans-5575
  prefs: []
  type: TYPE_NORMAL
  zh: 将`void*`隐藏在宏之后只是掩盖了问题，并引入了新的混淆机会。
- en: '**Exceptions**: If you need an ABI-stable interface, you might have to provide
    a base implementation and express the (type-safe) template in terms of that. See
    [Stable base](#rt-abi).'
  id: totrans-5576
  prefs: []
  type: TYPE_NORMAL
  zh: '**例外情况**：如果你需要一个ABI稳定的接口，你可能必须提供一个基本实现，并以那种方式表达（类型安全的）模板。参见[稳定的基类](#rt-abi)。'
- en: Enforcement
  id: totrans-5577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag uses of `void*`s and casts outside low-level implementation code
  id: totrans-5578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`void*`的使用和低级实现代码之外的类型转换
- en: 'T.4: Use templates to express syntax tree manipulation'
  id: totrans-5579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.4：使用模板来表示语法树操作
- en: Reason
  id: totrans-5580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: ???
  id: totrans-5581
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Example
  id: totrans-5582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE732]'
  id: totrans-5583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '**Exceptions**: ???'
  id: totrans-5584
  prefs: []
  type: TYPE_NORMAL
  zh: '**例外情况**：???'
- en: 'T.5: Combine generic and OO techniques to amplify their strengths, not their
    costs'
  id: totrans-5585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.5：结合泛型和面向对象技术以增强其优势，而不是成本
- en: Reason
  id: totrans-5586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Generic and OO techniques are complementary.
  id: totrans-5587
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型和面向对象技术是互补的。
- en: Example
  id: totrans-5588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Static helps dynamic: Use static polymorphism to implement dynamically polymorphic
    interfaces.'
  id: totrans-5589
  prefs: []
  type: TYPE_NORMAL
  zh: 静态帮助动态：使用静态多态来实现动态多态接口。
- en: '[PRE733]'
  id: totrans-5590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: Example
  id: totrans-5591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Dynamic helps static: Offer a generic, comfortable, statically bound interface,
    but internally dispatch dynamically, so you offer a uniform object layout. Examples
    include type erasure as with `std::shared_ptr`’s deleter (but [don’t overuse type
    erasure](#rt-erasure)).'
  id: totrans-5592
  prefs: []
  type: TYPE_NORMAL
  zh: 动态帮助静态：提供一个通用、舒适、静态绑定的接口，但内部动态调度，以便提供统一的对象布局。例如，类型擦除与`std::shared_ptr`的析构函数一样（但[不要过度使用类型擦除](#rt-erasure)）。
- en: '[PRE734]'
  id: totrans-5593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: Note
  id: totrans-5594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In a class template, non-virtual functions are only instantiated if they’re
    used – but virtual functions are instantiated every time. This can bloat code
    size, and might overconstrain a generic type by instantiating functionality that
    is never needed. Avoid this, even though the standard-library facets made this
    mistake.
  id: totrans-5595
  prefs: []
  type: TYPE_NORMAL
  zh: 在类模板中，只有当非虚拟函数被使用时才会实例化它们——但虚拟函数每次都会实例化。这可能会增加代码大小，并可能通过实例化永远不会需要的功能来过度约束泛型类型。避免这种情况，即使标准库特性也犯了这样的错误。
- en: See also
  id: totrans-5596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参见：
- en: ref ???
  id: totrans-5597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref ???
- en: ref ???
  id: totrans-5598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref ???
- en: ref ???
  id: totrans-5599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref ???
- en: Enforcement
  id: totrans-5600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: See the reference to more specific rules.
  id: totrans-5601
  prefs: []
  type: TYPE_NORMAL
  zh: 参考更具体的规则。
- en: 'T.concepts: Concept rules'
  id: totrans-5602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: T.concepts：概念规则
- en: Concepts is a C++20 facility for specifying requirements for template arguments.
    They are crucial in the thinking about generic programming and the basis of much
    work on future C++ libraries (standard and other).
  id: totrans-5603
  prefs: []
  type: TYPE_NORMAL
  zh: 概念是C++20用于指定模板参数要求的功能。它们在泛型编程的思考中至关重要，也是许多未来C++库（标准和其他）工作的基础。
- en: This section assumes concept support
  id: totrans-5604
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设支持概念
- en: 'Concept use rule summary:'
  id: totrans-5605
  prefs: []
  type: TYPE_NORMAL
  zh: 概念使用规则摘要：
- en: '[T.10: Specify concepts for all template arguments](#rt-concepts)'
  id: totrans-5606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.10：为所有模板参数指定概念](#rt-concepts)'
- en: '[T.11: Whenever possible use standard concepts](#rt-std-concepts)'
  id: totrans-5607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.11：尽可能使用标准概念](#rt-std-concepts)'
- en: '[T.12: Prefer concept names over `auto`](#rt-auto)'
  id: totrans-5608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.12：优先使用概念名称而不是`auto`](#rt-auto)'
- en: '[T.13: Prefer the shorthand notation for simple, single-type argument concepts](#rt-shorthand)'
  id: totrans-5609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.13：优先使用简单、单类型参数概念的缩写表示法](#rt-shorthand)'
- en: ???
  id: totrans-5610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'Concept definition rule summary:'
  id: totrans-5611
  prefs: []
  type: TYPE_NORMAL
  zh: 概念定义规则摘要：
- en: '[T.20: Avoid “concepts” without meaningful semantics](#rt-low)'
  id: totrans-5612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.20：避免没有实际语义的“概念”](#rt-low)'
- en: '[T.21: Require a complete set of operations for a concept](#rt-complete)'
  id: totrans-5613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.21：要求概念有一个完整的操作集](#rt-complete)'
- en: '[T.22: Specify axioms for concepts](#rt-axiom)'
  id: totrans-5614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.22：为概念指定公理](#rt-axiom)'
- en: '[T.23: Differentiate a refined concept from its more general case by adding
    new use patterns](#rt-refine)'
  id: totrans-5615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.23：通过添加新的使用模式来区分细化概念和其更一般的情况](#rt-refine)'
- en: '[T.24: Use tag classes or traits to differentiate concepts that differ only
    in semantics](#rt-tag)'
  id: totrans-5616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.24: 使用标签类或特性来区分只有语义不同的概念](#rt-tag)'
- en: '[T.25: Avoid complimentary constraints](#rt-not)'
  id: totrans-5617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.25: 避免互补约束](#rt-not)'
- en: '[T.26: Prefer to define concepts in terms of use-patterns rather than simple
    syntax](#rt-use)'
  id: totrans-5618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[T.26: 优先使用使用模式来定义概念，而不是简单的语法](#rt-use)'
- en: ???
  id: totrans-5619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'T.con-use: Concept use'
  id: totrans-5620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'T.con-use: 概念使用'
- en: 'T.10: Specify concepts for all template arguments'
  id: totrans-5621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.10: 为所有模板参数指定概念'
- en: Reason
  id: totrans-5622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Correctness and readability. The assumed meaning (syntax and semantics) of a
    template argument is fundamental to the interface of a template. A concept dramatically
    improves documentation and error handling for the template. Specifying concepts
    for template arguments is a powerful design tool.
  id: totrans-5623
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性和可读性。模板参数的假设意义（语法和语义）是模板接口的基本要素。一个概念可以显著提高模板的文档和错误处理能力。为模板参数指定概念是一种强大的设计工具。
- en: Example
  id: totrans-5624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE735]'
  id: totrans-5625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: 'or equivalently and more succinctly:'
  id: totrans-5626
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等价且更简洁地：
- en: '[PRE736]'
  id: totrans-5627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: Note
  id: totrans-5628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Plain `typename` (or `auto`) is the least constraining concept. It should be
    used only rarely when nothing more than “it’s a type” can be assumed. This is
    typically only needed when (as part of template metaprogramming code) we manipulate
    pure expression trees, postponing type checking.
  id: totrans-5629
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`typename`（或`auto`）是最不约束的概念。它应该只在假设“它是一个类型”时很少使用。这通常只在（作为模板元编程代码的一部分）我们操作纯表达式树、推迟类型检查时才需要。
- en: '**References**: TC++PL4'
  id: totrans-5630
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**: TC++PL4'
- en: Enforcement
  id: totrans-5631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag template type arguments without concepts
  id: totrans-5632
  prefs: []
  type: TYPE_NORMAL
  zh: 不带概念的模板类型参数标记
- en: 'T.11: Whenever possible use standard concepts'
  id: totrans-5633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.11: 在可能的情况下使用标准概念'
- en: Reason
  id: totrans-5634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: “Standard” concepts (as provided by the [GSL](#gsl-guidelines-support-library)
    and the ISO standard itself) save us the work of thinking up our own concepts,
    are better thought out than we can manage to do in a hurry, and improve interoperability.
  id: totrans-5635
  prefs: []
  type: TYPE_NORMAL
  zh: “标准”概念（由[GSL](#gsl-guidelines-support-library)和ISO标准本身提供）节省了我们思考自己概念的工作，比我们匆忙中能想到的更好，并提高了互操作性。
- en: Note
  id: totrans-5636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unless you are creating a new generic library, most of the concepts you need
    will already be defined by the standard library.
  id: totrans-5637
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在创建一个新的通用库，否则你需要的多数概念将由标准库定义。
- en: Example
  id: totrans-5638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE737]'
  id: totrans-5639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: 'This `Ordered_container` is quite plausible, but it is very similar to the
    `sortable` concept in the standard library. Is it better? Is it right? Does it
    accurately reflect the standard’s requirements for `sort`? It is better and simpler
    just to use `sortable`:'
  id: totrans-5640
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Ordered_container`相当合理，但它与标准库中的`sortable`概念非常相似。它更好吗？它正确吗？它是否准确反映了标准对`sort`的要求？仅仅使用`sortable`更好且更简单：
- en: '[PRE738]'
  id: totrans-5641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: Note
  id: totrans-5642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The set of “standard” concepts is evolving as we approach an ISO standard including
    concepts.
  id: totrans-5643
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们接近包含概念的ISO标准，"标准"概念集正在演变。
- en: Note
  id: totrans-5644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Designing a useful concept is challenging.
  id: totrans-5645
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个有用的概念具有挑战性。
- en: Enforcement
  id: totrans-5646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Hard.
  id: totrans-5647
  prefs: []
  type: TYPE_NORMAL
  zh: 困难。
- en: Look for unconstrained arguments, templates that use “unusual”/non-standard
    concepts, templates that use “homebrew” concepts without axioms.
  id: totrans-5648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找无约束的参数，使用“不寻常”/非标准概念或没有公理的“自制”概念的模板。
- en: Develop a concept-discovery tool (e.g., see [an early experiment](https://www.stroustrup.com/sle2010_webversion.pdf)).
  id: totrans-5649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个概念发现工具（例如，参见[早期实验](https://www.stroustrup.com/sle2010_webversion.pdf)）。
- en: 'T.12: Prefer concept names over `auto` for local variables'
  id: totrans-5650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.12: 对于局部变量，优先使用概念名称而不是`auto`'
- en: Reason
  id: totrans-5651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`auto` is the weakest concept. Concept names convey more meaning than just
    `auto`.'
  id: totrans-5652
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`是最弱的概念。概念名称传达的意义比仅仅`auto`更多。'
- en: Example
  id: totrans-5653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE739]'
  id: totrans-5654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: Enforcement
  id: totrans-5655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: ???
  id: totrans-5656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'T.13: Prefer the shorthand notation for simple, single-type argument concepts'
  id: totrans-5657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.13: 对于简单、单类型参数的概念，优先使用缩写表示法'
- en: Reason
  id: totrans-5658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Direct expression of an idea.
  id: totrans-5659
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。直接表达一个想法。
- en: Example
  id: totrans-5660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'To say “`T` is `sortable`”:'
  id: totrans-5661
  prefs: []
  type: TYPE_NORMAL
  zh: 要说“`T`是`sortable`”：
- en: '[PRE740]'
  id: totrans-5662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: The shorter versions better match the way we speak. Note that many templates
    don’t need to use the `template` keyword.
  id: totrans-5663
  prefs: []
  type: TYPE_NORMAL
  zh: 简短版本更好地符合我们的说话方式。注意，许多模板不需要使用`template`关键字。
- en: Enforcement
  id: totrans-5664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Not feasible in the short term when people convert from the `<typename T>` and
    `<class T`> notation.
  id: totrans-5665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当人们从`<typename T>`和`<class T>`表示法转换过来时，短期内不可行。
- en: Later, flag declarations that first introduce a typename and then constrain
    it with a simple, single-type-argument concept.
  id: totrans-5666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，标记首先引入`typename`然后使用简单、单类型参数概念约束的声明。
- en: 'T.concepts.def: Concept definition rules'
  id: totrans-5667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'T.concepts.def: 概念定义规则'
- en: Defining good concepts is non-trivial. Concepts are meant to represent fundamental
    concepts in an application domain (hence the name “concepts”). Similarly throwing
    together a set of syntactic constraints to be used for the arguments for a single
    class or algorithm is not what concepts were designed for and will not give the
    full benefits of the mechanism.
  id: totrans-5668
  prefs: []
  type: TYPE_NORMAL
  zh: 定义良好的概念并非易事。概念旨在表示应用领域中的基本概念（因此得名“概念”）。同样，将一组句法约束组合在一起用于单个类或算法的参数也不是概念设计的目的，也不会带来该机制的全部好处。
- en: Obviously, defining concepts is most useful for code that can use an implementation
    (e.g., C++20 or later) but defining concepts is in itself a useful design technique
    and helps catch conceptual errors and clean up the concepts (sic!) of an implementation.
  id: totrans-5669
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，定义概念对于可以使用实现（例如，C++20或更高版本）的代码最有用，但定义概念本身是一种有用的设计技术，有助于捕捉概念错误并清理实现的概念（即！）。
- en: 'T.20: Avoid “concepts” without meaningful semantics'
  id: totrans-5670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.20: 避免无意义的“概念”'
- en: Reason
  id: totrans-5671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Concepts are meant to express semantic notions, such as “a number”, “a range”
    of elements, and “totally ordered.” Simple constraints, such as “has a `+` operator”
    and “has a `>` operator” cannot be meaningfully specified in isolation and should
    be used only as building blocks for meaningful concepts, rather than in user code.
  id: totrans-5672
  prefs: []
  type: TYPE_NORMAL
  zh: 概念旨在表达语义概念，例如“一个数字”、“一组元素的范围”和“完全有序”。简单的约束，如“有`+`运算符”和“有`>`运算符”，不能在孤立的情况下有意义的指定，而应仅作为构建有意义概念的基石，而不是在用户代码中使用。
- en: Example, bad
  id: totrans-5673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE741]'
  id: totrans-5674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: 'Maybe the concatenation was expected. More likely, it was an accident. Defining
    minus equivalently would give dramatically different sets of accepted types. This
    `Addable` violates the mathematical rule that addition is supposed to be commutative:
    `a+b == b+a`.'
  id: totrans-5675
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是预期的连接。更有可能的是，这是一个意外。等效地定义减法将给出截然不同的接受类型集合。这个`Addable`违反了数学规则，即加法应该是可交换的：`a+b
    == b+a`。
- en: Note
  id: totrans-5676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The ability to specify meaningful semantics is a defining characteristic of
    a true concept, as opposed to a syntactic constraint.
  id: totrans-5677
  prefs: []
  type: TYPE_NORMAL
  zh: 能够指定有意义的语义是真正概念的定义特征，而不是句法约束。
- en: Example
  id: totrans-5678
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE742]'
  id: totrans-5679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: Note
  id: totrans-5680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Concepts with multiple operations have far lower chance of accidentally matching
    a type than a single-operation concept.
  id: totrans-5681
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个操作的概念的意外匹配类型的可能性远低于单个操作的概念。
- en: Enforcement
  id: totrans-5682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag single-operation `concepts` when used outside the definition of other `concepts`.
  id: totrans-5683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在其他`概念`的定义之外使用单操作`概念`时，标记单操作`概念`。
- en: Flag uses of `enable_if` that appear to simulate single-operation `concepts`.
  id: totrans-5684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`enable_if`的使用，这些使用似乎模拟了单操作`概念`。
- en: 'T.21: Require a complete set of operations for a concept'
  id: totrans-5685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.21: 要求概念具有完整的运算符集合'
- en: Reason
  id: totrans-5686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Ease of comprehension. Improved interoperability. Helps implementers and maintainers.
  id: totrans-5687
  prefs: []
  type: TYPE_NORMAL
  zh: 理解的容易性。改进的互操作性。有助于实现者和维护者。
- en: Note
  id: totrans-5688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is a specific variant of the general rule that [a concept must make semantic
    sense](#rt-low).
  id: totrans-5689
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通用规则的一个具体变体，即[概念必须具有语义意义](#rt-low)。
- en: Example, bad
  id: totrans-5690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例如，错误的做法
- en: '[PRE743]'
  id: totrans-5691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: This makes no semantic sense. You need at least `+` to make `-` meaningful and
    useful.
  id: totrans-5692
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有语义意义。至少需要`+`来使`-`有意义和有用。
- en: Examples of complete sets are
  id: totrans-5693
  prefs: []
  type: TYPE_NORMAL
  zh: 完整集合的例子包括
- en: '`Arithmetic`: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`'
  id: totrans-5694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Arithmetic`: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`'
- en: '`Comparable`: `<`, `>`, `<=`, `>=`, `==`, `!=`'
  id: totrans-5695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comparable`: `<`, `>`, `<=`, `>=`, `==`, `!=`'
- en: Note
  id: totrans-5696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This rule applies whether we use direct language support for concepts or not.
    It is a general design rule that even applies to non-templates:'
  id: totrans-5697
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否使用直接的语言支持来定义概念，这条规则都适用。这是一个通用设计规则，甚至适用于非模板：
- en: '[PRE744]'
  id: totrans-5698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: This is minimal, but surprising and constraining for users. It could even be
    less efficient.
  id: totrans-5699
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最小的，但出乎意料且对用户有约束性。它甚至可能效率更低。
- en: The rule supports the view that a concept should reflect a (mathematically)
    coherent set of operations.
  id: totrans-5700
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则支持这样的观点，即一个概念应该反映一个（数学上）一致的运算符集合。
- en: Example
  id: totrans-5701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE745]'
  id: totrans-5702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: It can be a nuisance to define all operators, but not hard. Ideally, that rule
    should be language supported by giving you comparison operators by default.
  id: totrans-5703
  prefs: []
  type: TYPE_NORMAL
  zh: 定义所有运算符可能有些麻烦，但并不困难。理想情况下，这条规则应该由语言支持，通过默认提供比较运算符。
- en: Enforcement
  id: totrans-5704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag classes that support “odd” subsets of a set of operators, e.g., `==` but
    not `!=` or `+` but not `-`. Yes, `std::string` is “odd”, but it’s too late to
    change that.
  id: totrans-5705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记支持“奇数”子集的运算符集合的类，例如，`==`但不包括`!=`或`+`但不包括`-`。是的，`std::string`是“奇数”，但现在已经太晚了去改变它。
- en: 'T.22: Specify axioms for concepts'
  id: totrans-5706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.22: 为概念指定公理'
- en: Reason
  id: totrans-5707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A meaningful/useful concept has a semantic meaning. Expressing these semantics
    in an informal, semi-formal, or formal way makes the concept comprehensible to
    readers and the effort to express it can catch conceptual errors. Specifying semantics
    is a powerful design tool.
  id: totrans-5708
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义/有用的概念具有语义意义。以非正式、半正式或正式的方式表达这些语义可以使概念对读者来说易于理解，并且表达这些语义的努力可以捕捉到概念错误。指定语义是一种强大的设计工具。
- en: Example
  id: totrans-5709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE746]'
  id: totrans-5710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: Note
  id: totrans-5711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is an axiom in the mathematical sense: something that can be assumed without
    proof. In general, axioms are not provable, and when they are the proof is often
    beyond the capability of a compiler. An axiom might not be general, but the template
    writer can assume that it holds for all inputs actually used (similar to a precondition).'
  id: totrans-5712
  prefs: []
  type: TYPE_NORMAL
  zh: 这在数学意义上是一个公理：可以假设而不需要证明的东西。通常，公理是不可证明的，当它们是时，证明通常超出了编译器的能力。公理可能不是通用的，但模板编写者可以假设它对所有实际使用的输入都成立（类似于前置条件）。
- en: Note
  id: totrans-5713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this context axioms are Boolean expressions. See the [Palo Alto TR](#s-references)
    for examples. Currently, C++ does not support axioms (even the ISO Concepts TS),
    so we have to make do with comments for a longish while. Once language support
    is available, the `//` in front of the axiom can be removed
  id: totrans-5714
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，公理是布尔表达式。请参阅[Palo Alto TR](#s-references)中的示例。目前，C++不支持公理（即使是ISO Concepts
    TS），因此我们不得不暂时使用注释。一旦语言支持可用，公理前的`//`可以移除。
- en: Note
  id: totrans-5715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges
    TS.
  id: totrans-5716
  prefs: []
  type: TYPE_NORMAL
  zh: GSL概念具有明确的语义；请参阅Palo Alto TR和Ranges TS。
- en: Exception
  id: totrans-5717
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'Early versions of a new “concept” still under development will often just define
    simple sets of constraints without a well-specified semantics. Finding good semantics
    can take effort and time. An incomplete set of constraints can still be very useful:'
  id: totrans-5718
  prefs: []
  type: TYPE_NORMAL
  zh: 新“概念”的早期版本仍在开发中，通常会定义一组简单的约束，而没有明确的语义。找到好的语义可能需要努力和时间。一组不完整的约束仍然可能非常有用：
- en: '[PRE747]'
  id: totrans-5719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: So a `Balancer` must supply at least these operations on a tree `Node`, but
    we are not yet ready to specify detailed semantics because a new kind of balanced
    tree might require more operations and the precise general semantics for all nodes
    is hard to pin down in the early stages of design.
  id: totrans-5720
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个`Balancer`必须至少在树`Node`上提供这些操作，但我们还没有准备好指定详细的语义，因为一种新的平衡树可能需要更多的操作，而在设计的早期阶段，所有节点的精确通用语义很难确定。
- en: A “concept” that is incomplete or without a well-specified semantics can still
    be useful. For example, it allows for some checking during initial experimentation.
    However, it should not be assumed to be stable. Each new use case might require
    such an incomplete concept to be improved.
  id: totrans-5721
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不完整或没有明确指定语义的“概念”仍然可能是有用的。例如，它允许在初始实验中进行一些检查。然而，不应假设它是稳定的。每个新的用例可能都需要改进这种不完整概念。
- en: Enforcement
  id: totrans-5722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Look for the word “axiom” in concept definition comments
  id: totrans-5723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在概念定义注释中寻找“公理”一词
- en: 'T.23: Differentiate a refined concept from its more general case by adding
    new use patterns.'
  id: totrans-5724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.23：通过添加新的使用模式来区分一个精细概念与其更一般的情况。
- en: Reason
  id: totrans-5725
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Otherwise they cannot be distinguished automatically by the compiler.
  id: totrans-5726
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，编译器无法自动区分它们。
- en: Example
  id: totrans-5727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE748]'
  id: totrans-5728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: The compiler can determine refinement based on the sets of required operations
    (here, suffix `++`). This decreases the burden on implementers of these types
    since they do not need any special declarations to “hook into the concept”. If
    two concepts have exactly the same requirements, they are logically equivalent
    (there is no refinement).
  id: totrans-5729
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以根据所需操作集（此处，后缀`++`）来确定精细。这减少了这些类型的实现者的负担，因为他们不需要任何特殊的声明来“挂钩到概念”。如果两个概念具有完全相同的要求，它们在逻辑上是等价的（没有精细）。
- en: Enforcement
  id: totrans-5730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag a concept that has exactly the same requirements as another already-seen
    concept (neither is more refined). To disambiguate them, see [T.24](#rt-tag).
  id: totrans-5731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个与另一个已见概念（两者都不更精细）具有完全相同要求的概念。为了消除歧义，请参阅[T.24](#rt-tag)。
- en: 'T.24: Use tag classes or traits to differentiate concepts that differ only
    in semantics.'
  id: totrans-5732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.24：使用标记类或特性来区分仅在语义上不同的概念。
- en: Reason
  id: totrans-5733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Two concepts requiring the same syntax but having different semantics lead to
    ambiguity unless the programmer differentiates them.
  id: totrans-5734
  prefs: []
  type: TYPE_NORMAL
  zh: 两个需要相同语法但具有不同语义的概念会导致歧义，除非程序员区分它们。
- en: Example
  id: totrans-5735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE749]'
  id: totrans-5736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: The programmer (in a library) must define `is_contiguous` (a trait) appropriately.
  id: totrans-5737
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员（在库中）必须适当地定义`is_contiguous`（一个特性）。
- en: 'Wrapping a tag class into a concept leads to a simpler expression of this idea:'
  id: totrans-5738
  prefs: []
  type: TYPE_NORMAL
  zh: 将标签类包装到概念中可以简化这种想法的表达：
- en: '[PRE750]'
  id: totrans-5739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: The programmer (in a library) must define `is_contiguous` (a trait) appropriately.
  id: totrans-5740
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员（在库中）必须适当地定义`is_contiguous`（一个特性）。
- en: Note
  id: totrans-5741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Traits can be trait classes or type traits. These can be user-defined or standard-library
    ones. Prefer the standard-library ones.
  id: totrans-5742
  prefs: []
  type: TYPE_NORMAL
  zh: 特性可以是特性类或类型特性。这些可以是用户定义的或标准库的。优先选择标准库的。
- en: Enforcement
  id: totrans-5743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: The compiler flags ambiguous use of identical concepts.
  id: totrans-5744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器标记相同概念的模糊使用。
- en: Flag the definition of identical concepts.
  id: totrans-5745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记相同概念的定义。
- en: 'T.25: Avoid complementary constraints'
  id: totrans-5746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.25：避免补充约束
- en: Reason
  id: totrans-5747
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Clarity. Maintainability. Functions with complementary requirements expressed
    using negation are brittle.
  id: totrans-5748
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰性。可维护性。使用否定表达补充要求的函数是脆弱的。
- en: Example
  id: totrans-5749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Initially, people will try to define functions with complementary requirements:'
  id: totrans-5750
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，人们会尝试定义具有补充要求的函数：
- en: '[PRE751]'
  id: totrans-5751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: 'This is better:'
  id: totrans-5752
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好：
- en: '[PRE752]'
  id: totrans-5753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: The compiler will choose the unconstrained template only when `C<T>` is unsatisfied.
    If you do not want to (or cannot) define an unconstrained version of `f()`, then
    delete it.
  id: totrans-5754
  prefs: []
  type: TYPE_NORMAL
  zh: 当`C<T>`不满足时，编译器将仅选择无约束的模板。如果你不想（或不能）定义`f()`的无约束版本，则删除它。
- en: '[PRE753]'
  id: totrans-5755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: The compiler will select the overload, or emit an appropriate error.
  id: totrans-5756
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将选择重载，或发出适当的错误。
- en: Note
  id: totrans-5757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Complementary constraints are unfortunately common in `enable_if` code:'
  id: totrans-5758
  prefs: []
  type: TYPE_NORMAL
  zh: 补充约束在`enable_if`代码中很不幸是常见的：
- en: '[PRE754]'
  id: totrans-5759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: Note
  id: totrans-5760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Complementary requirements on one requirement are sometimes (wrongly) considered
    manageable. However, for two or more requirements the number of definitions needs
    can go up exponentially (2,4,8,16,…):'
  id: totrans-5761
  prefs: []
  type: TYPE_NORMAL
  zh: 有时（错误地）认为对单一要求上的补充要求是可管理的。然而，对于两个或更多要求，定义的需求数量可能呈指数增长（2,4,8,16,…）：
- en: '[PRE755]'
  id: totrans-5762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: Now the opportunities for errors multiply.
  id: totrans-5763
  prefs: []
  type: TYPE_NORMAL
  zh: 现在错误的机会成倍增加。
- en: Enforcement
  id: totrans-5764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag pairs of functions with `C<T>` and `!C<T>` constraints
  id: totrans-5765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记具有`C<T>`和`!C<T>`约束的函数对
- en: 'T.26: Prefer to define concepts in terms of use-patterns rather than simple
    syntax'
  id: totrans-5766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.26：优先使用使用模式而不是简单语法来定义概念
- en: Reason
  id: totrans-5767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The definition is more readable and corresponds directly to what a user has
    to write. Conversions are taken into account. You don’t have to remember the names
    of all the type traits.
  id: totrans-5768
  prefs: []
  type: TYPE_NORMAL
  zh: 定义更易于阅读，并且直接对应于用户必须编写的代码。考虑了转换。你不必记住所有类型特性的名称。
- en: Example
  id: totrans-5769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'You might be tempted to define a concept `Equality` like this:'
  id: totrans-5770
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想定义一个像这样的`Equality`概念：
- en: '[PRE756]'
  id: totrans-5771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: 'Obviously, it would be better and easier just to use the standard `equality_comparable`,
    but - just as an example - if you had to define such a concept, prefer:'
  id: totrans-5772
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，直接使用标准的`equality_comparable`会更好、更容易，但——仅作为一个例子——如果你不得不定义这样的概念，则优先选择：
- en: '[PRE757]'
  id: totrans-5773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: as opposed to defining two meaningless concepts `has_equal` and `has_not_equal`
    just as helpers in the definition of `Equality`. By “meaningless” we mean that
    we cannot specify the semantics of `has_equal` in isolation.
  id: totrans-5774
  prefs: []
  type: TYPE_NORMAL
  zh: 与在“等价性”定义中定义两个无意义的“has_equal”和“has_not_equal”概念作为辅助手段相比。我们所说的“无意义”是指我们无法单独指定“has_equal”的语义。
- en: Enforcement
  id: totrans-5775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5776
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Template interfaces
  id: totrans-5777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板接口
- en: Over the years, programming with templates has suffered from a weak distinction
    between the interface of a template and its implementation. Before concepts, that
    distinction had no direct language support. However, the interface to a template
    is a critical concept - a contract between a user and an implementer - and should
    be carefully designed.
  id: totrans-5778
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，使用模板的编程在模板接口和其实施之间缺乏明确的区分。在概念出现之前，这种区分没有直接的语言支持。然而，模板的接口是一个关键概念——用户和实现者之间的契约——应该仔细设计。
- en: 'T.40: Use function objects to pass operations to algorithms'
  id: totrans-5779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.40：使用函数对象将操作传递给算法
- en: Reason
  id: totrans-5780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Function objects can carry more information through an interface than a “plain”
    pointer to function. In general, passing function objects gives better performance
    than passing pointers to functions.
  id: totrans-5781
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象可以通过接口携带比指向函数的“普通”指针更多的信息。一般来说，传递函数对象比传递函数指针有更好的性能。
- en: Example
  id: totrans-5782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE758]'
  id: totrans-5783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: 'You can, of course, generalize those functions using `auto` or concepts. For
    example:'
  id: totrans-5784
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以使用`auto`或概念来泛化这些函数。例如：
- en: '[PRE759]'
  id: totrans-5785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: Note
  id: totrans-5786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Lambdas generate function objects.
  id: totrans-5787
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 生成函数对象。
- en: Note
  id: totrans-5788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The performance argument depends on compiler and optimizer technology.
  id: totrans-5789
  prefs: []
  type: TYPE_NORMAL
  zh: 性能论点取决于编译器和优化器技术。
- en: Enforcement
  id: totrans-5790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag pointer to function template arguments.
  id: totrans-5791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记指向函数模板参数的指针。
- en: Flag pointers to functions passed as arguments to a template (risk of false
    positives).
  id: totrans-5792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记传递给模板的函数指针（风险为假阳性）。
- en: 'T.41: Require only essential properties in a template’s concepts'
  id: totrans-5793
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.41：在模板的概念中仅要求必要属性
- en: Reason
  id: totrans-5794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Keep interfaces simple and stable.
  id: totrans-5795
  prefs: []
  type: TYPE_NORMAL
  zh: 保持接口简单和稳定。
- en: Example
  id: totrans-5796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider, a `sort` instrumented with (oversimplified) simple debug support:'
  id: totrans-5797
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个（过于简化的）带有简单调试支持的`sort`工具：
- en: '[PRE760]'
  id: totrans-5798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: 'Should this be rewritten to:'
  id: totrans-5799
  prefs: []
  type: TYPE_NORMAL
  zh: 应该重写为：
- en: '[PRE761]'
  id: totrans-5800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: After all, there is nothing in `sortable` that requires `iostream` support.
    On the other hand, there is nothing in the fundamental idea of sorting that says
    anything about debugging.
  id: totrans-5801
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`sortable`中没有要求`iostream`支持的内容。另一方面，排序的基本思想中也没有关于调试的内容。
- en: Note
  id: totrans-5802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we require every operation used to be listed among the requirements, the
    interface becomes unstable: Every time we change the debug facilities, the usage
    data gathering, testing support, error reporting, etc., the definition of the
    template would need change and every use of the template would have to be recompiled.
    This is cumbersome, and in some environments infeasible.'
  id: totrans-5803
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求每个操作都列在要求中，则接口变得不稳定：每次我们更改调试设施、收集使用数据、测试支持、错误报告等，模板的定义都需要更改，并且必须重新编译模板的每个使用。这很麻烦，在某些环境中甚至不可行。
- en: Conversely, if we use an operation in the implementation that is not guaranteed
    by concept checking, we might get a late compile-time error.
  id: totrans-5804
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们使用实现中未由概念检查保证的操作，我们可能会在编译时遇到错误。
- en: By not using concept checking for properties of a template argument that is
    not considered essential, we delay checking until instantiation time. We consider
    this a worthwhile tradeoff.
  id: totrans-5805
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不使用概念检查来延迟检查非必要模板参数属性，我们将检查推迟到实例化时间。我们认为这是一个值得的权衡。
- en: Note that using non-local, non-dependent names (such as `debug` and `cerr`)
    also introduces context dependencies that might lead to “mysterious” errors.
  id: totrans-5806
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用非局部、非依赖的名称（如`debug`和`cerr`）也会引入可能导致“神秘”错误的上下文依赖。
- en: Note
  id: totrans-5807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It can be hard to decide which properties of a type are essential and which
    are not.
  id: totrans-5808
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个类型的哪些属性是必要的，哪些不是，可能很困难。
- en: Enforcement
  id: totrans-5809
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: ???
  id: totrans-5810
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.42: Use template aliases to simplify notation and hide implementation details'
  id: totrans-5811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.42：使用模板别名简化表示并隐藏实现细节
- en: Reason
  id: totrans-5812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Improved readability. Implementation hiding. Note that template aliases replace
    many uses of traits to compute a type. They can also be used to wrap a trait.
  id: totrans-5813
  prefs: []
  type: TYPE_NORMAL
  zh: 提高可读性。隐藏实现。注意，模板别名替换了许多用于计算类型的特质的用法。它们也可以用来包装特质。
- en: Example
  id: totrans-5814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE762]'
  id: totrans-5815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: This saves the user of `Matrix` from having to know that its elements are stored
    in a `vector` and also saves the user from repeatedly typing `typename std::vector<T>::`.
  id: totrans-5816
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`Matrix`的用户不必知道其元素存储在`vector`中，也使得用户不必反复输入`typename std::vector<T>::`。
- en: Example
  id: totrans-5817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE763]'
  id: totrans-5818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: This saves the user of `Value_type` from having to know the technique used to
    implement `value_type`s.
  id: totrans-5819
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`Value_type`的用户不必知道实现`value_type`的技术。
- en: '[PRE764]'
  id: totrans-5820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: Note
  id: totrans-5821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A simple, common use could be expressed: “Wrap traits!”'
  id: totrans-5822
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的、常见的用法可以是：“包装特质！”
- en: Enforcement
  id: totrans-5823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag use of `typename` as a disambiguator outside `using` declarations.
  id: totrans-5824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`typename`作为`using`声明外的歧义消除器。
- en: ???
  id: totrans-5825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'T.43: Prefer `using` over `typedef` for defining aliases'
  id: totrans-5826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.43：在定义别名时优先使用`using`
- en: Reason
  id: totrans-5827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'Improved readability: With `using`, the new name comes first rather than being
    embedded somewhere in a declaration. Generality: `using` can be used for template
    aliases, whereas `typedef`s can’t easily be templates. Uniformity: `using` is
    syntactically similar to `auto`.'
  id: totrans-5828
  prefs: []
  type: TYPE_NORMAL
  zh: 提高可读性：使用`using`，新名称首先出现，而不是嵌入在声明中。通用性：`using`可以用于模板别名，而`typedef`则不容易是模板。一致性：`using`在语法上与`auto`相似。
- en: Example
  id: totrans-5829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE765]'
  id: totrans-5830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: Enforcement
  id: totrans-5831
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag uses of `typedef`. This will give a lot of “hits” :-(
  id: totrans-5832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`typedef`的使用。这将导致很多“命中”:-(
- en: 'T.44: Use function templates to deduce class template argument types (where
    feasible)'
  id: totrans-5833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.44：在可行的情况下使用函数模板推导类模板参数类型
- en: Reason
  id: totrans-5834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Writing the template argument types explicitly can be tedious and unnecessarily
    verbose.
  id: totrans-5835
  prefs: []
  type: TYPE_NORMAL
  zh: 明确写出模板参数类型可能很繁琐且不必要地冗长。
- en: Example
  id: totrans-5836
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE766]'
  id: totrans-5837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: Note the use of the `s` suffix to ensure that the string is a `std::string`,
    rather than a C-style string.
  id: totrans-5838
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`s`后缀以确保字符串是`std::string`，而不是C风格字符串。
- en: Note
  id: totrans-5839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Since you can trivially write a `make_T` function, so could the compiler. Thus,
    `make_T` functions might become redundant in the future.
  id: totrans-5840
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以轻易地编写一个`make_T`函数，编译器也可以这样做。因此，`make_T`函数可能在将来变得冗余。
- en: Exception
  id: totrans-5841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例外
- en: 'Sometimes there isn’t a good way of getting the template arguments deduced
    and sometimes, you want to specify the arguments explicitly:'
  id: totrans-5842
  prefs: []
  type: TYPE_NORMAL
  zh: 有时没有很好的方法来推导模板参数，有时你希望明确指定参数：
- en: '[PRE767]'
  id: totrans-5843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: Note
  id: totrans-5844
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that C++17 will make this rule redundant by allowing the template arguments
    to be deduced directly from constructor arguments: [Template parameter deduction
    for constructors (Rev. 3)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html).
    For example:'
  id: totrans-5845
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C++17 将通过允许直接从构造函数参数推导模板参数来使这条规则变得多余：[构造函数的模板参数推导（修订版 3）](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html)。例如：
- en: '[PRE768]'
  id: totrans-5846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: Enforcement
  id: totrans-5847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag uses where an explicitly specialized type exactly matches the types of
    the arguments used.
  id: totrans-5848
  prefs: []
  type: TYPE_NORMAL
  zh: 标记显式特化的类型与使用的参数类型完全匹配的使用情况。
- en: 'T.46: Require template arguments to be at least semiregular'
  id: totrans-5849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.46: 要求模板参数至少是半正则'
- en: Reason
  id: totrans-5850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Preventing surprises and errors. Most uses support that anyway.
  id: totrans-5851
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。防止意外和错误。大多数使用情况都支持这一点。
- en: Example
  id: totrans-5852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE769]'
  id: totrans-5853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: Note
  id: totrans-5854
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Semiregular requires default constructible.
  id: totrans-5855
  prefs: []
  type: TYPE_NORMAL
  zh: 半正则需要默认可构造。
- en: Enforcement
  id: totrans-5856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag types used as template arguments that are not at least semiregular.
  id: totrans-5857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记用作模板参数且至少不是半正则的类型。
- en: 'T.47: Avoid highly visible unconstrained templates with common names'
  id: totrans-5858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.47: 避免使用常见名称的可见性高的未约束模板'
- en: Reason
  id: totrans-5859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An unconstrained template argument is a perfect match for anything so such a
    template can be preferred over more specific types that require minor conversions.
    This is particularly annoying/dangerous when ADL is used. Common names make this
    problem more likely.
  id: totrans-5860
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未约束的模板参数与任何内容都是完美匹配，因此这样的模板可以优先于需要轻微转换的更具体类型。当使用 ADL 时，这种情况尤其令人烦恼/危险。常见名称使这个问题更可能发生。
- en: Example
  id: totrans-5861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE770]'
  id: totrans-5862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: This prints `T0` and `Bad`.
  id: totrans-5863
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印 `T0` 和 `Bad`.
- en: Now the `==` in `Bad` was designed to cause trouble, but would you have spotted
    the problem in real code? The problem is that `v.size()` returns an `unsigned`
    integer so that a conversion is needed to call the local `==`; the `==` in `Bad`
    requires no conversions. Realistic types, such as the standard-library iterators
    can be made to exhibit similar anti-social tendencies.
  id: totrans-5864
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `Bad` 中的 `==` 被设计成引起麻烦，但你是否会在实际代码中发现问题？问题是 `v.size()` 返回一个 `unsigned` 整数，因此需要转换来调用局部的
    `==`；`Bad` 中的 `==` 不需要转换。现实类型，如标准库迭代器，可以表现出类似的反社会倾向。
- en: Note
  id: totrans-5865
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If an unconstrained template is defined in the same namespace as a type, that
    unconstrained template can be found by ADL (as happened in the example). That
    is, it is highly visible.
  id: totrans-5866
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个未约束的模板与类型定义在同一个命名空间中，那么可以通过 ADL 找到该未约束的模板（如示例中所示）。也就是说，它是高度可见的。
- en: Note
  id: totrans-5867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This rule should not be necessary, but the committee cannot agree to exclude
    unconstrained templates from ADL.
  id: totrans-5868
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则可能不是必要的，但委员会无法达成一致，排除未约束模板从 ADL 中。
- en: Unfortunately this will get many false positives; the standard library violates
    this widely, by putting many unconstrained templates and types into the single
    namespace `std`.
  id: totrans-5869
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这将导致许多误报；标准库广泛违反了这一点，将许多未约束的模板和类型放入单个命名空间 `std`。
- en: Enforcement
  id: totrans-5870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag templates defined in a namespace where concrete types are also defined
    (maybe not feasible until we have concepts).
  id: totrans-5871
  prefs: []
  type: TYPE_NORMAL
  zh: 标记在定义具体类型的命名空间中定义的模板（可能直到我们有概念才可行）。
- en: 'T.48: If your compiler does not support concepts, fake them with `enable_if`'
  id: totrans-5872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.48: 如果你的编译器不支持概念，使用 `enable_if` 欺骗它们'
- en: Reason
  id: totrans-5873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Because that’s the best we can do without direct concept support. `enable_if`
    can be used to conditionally define functions and to select among a set of functions.
  id: totrans-5874
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是在没有直接概念支持的情况下我们能做的最好的事情。`enable_if` 可以用来条件性地定义函数，并在一组函数之间进行选择。
- en: Example
  id: totrans-5875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE771]'
  id: totrans-5876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: Note
  id: totrans-5877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Beware of [complementary constraints](#rt-not). Faking concept overloading using
    `enable_if` sometimes forces us to use that error-prone design technique.
  id: totrans-5878
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕[互补约束](#rt-not)。使用 `enable_if` 欺骗概念重载有时迫使我们使用这种容易出错的设计技术。
- en: Enforcement
  id: totrans-5879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5880
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.49: Where possible, avoid type-erasure'
  id: totrans-5881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.49: 在可能的情况下，避免类型擦除'
- en: Reason
  id: totrans-5882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Type erasure incurs an extra level of indirection by hiding type information
    behind a separate compilation boundary.
  id: totrans-5883
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除通过在单独的编译边界后隐藏类型信息而引入额外的间接层。
- en: Example
  id: totrans-5884
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE772]'
  id: totrans-5885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '**Exceptions**: Type erasure is sometimes appropriate, such as for `std::function`.'
  id: totrans-5886
  prefs: []
  type: TYPE_NORMAL
  zh: '**例外**: 类型擦除有时是合适的，例如对于 `std::function`。'
- en: Enforcement
  id: totrans-5887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5888
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Note
  id: totrans-5889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'T.def: Template definitions'
  id: totrans-5890
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'T.def: 模板定义'
- en: A template definition (class or function) can contain arbitrary code, so only
    a comprehensive review of C++ programming techniques would cover this topic. However,
    this section focuses on what is specific to template implementation. In particular,
    it focuses on a template definition’s dependence on its context.
  id: totrans-5891
  prefs: []
  type: TYPE_NORMAL
  zh: 模板定义（类或函数）可以包含任意代码，因此只有对C++编程技术的全面审查才能涵盖这个主题。然而，本节重点介绍模板实现的具体内容。特别是，它关注模板定义对其上下文的依赖性。
- en: 'T.60: Minimize a template’s context dependencies'
  id: totrans-5892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.60：最小化模板的上下文依赖
- en: Reason
  id: totrans-5893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Eases understanding. Minimizes errors from unexpected dependencies. Eases tool
    creation.
  id: totrans-5894
  prefs: []
  type: TYPE_NORMAL
  zh: 简化理解。最小化意外依赖的错误。简化工具创建。
- en: Example
  id: totrans-5895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE773]'
  id: totrans-5896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: Note
  id: totrans-5897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Templates typically appear in header files so their context dependencies are
    more vulnerable to `#include` order dependencies than functions in `.cpp` files.
  id: totrans-5898
  prefs: []
  type: TYPE_NORMAL
  zh: 模板通常出现在头文件中，因此它们的上下文依赖性比`.cpp`文件中的函数更容易受到`#include`顺序依赖性的影响。
- en: Note
  id: totrans-5899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Having a template operate only on its arguments would be one way of reducing
    the number of dependencies to a minimum, but that would generally be unmanageable.
    For example, algorithms usually use other algorithms and invoke operations that
    do not exclusively operate on arguments. And don’t get us started on macros!
  id: totrans-5900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模板只对其参数进行操作，这将是一种减少依赖性数量的方法，但通常这是不可管理的。例如，算法通常使用其他算法并调用不专门操作参数的操作。更不用说宏了！
- en: '**See also**: [T.69](#rt-customization)'
  id: totrans-5901
  prefs: []
  type: TYPE_NORMAL
  zh: '**参见**: [T.69](#rt-customization)'
- en: Enforcement
  id: totrans-5902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ??? Tricky
  id: totrans-5903
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 复杂
- en: 'T.61: Do not over-parameterize members (SCARY)'
  id: totrans-5904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.61：不要过度参数化成员（SCARY）
- en: Reason
  id: totrans-5905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A member that does not depend on a template parameter cannot be used except
    for a specific template argument. This limits use and typically increases code
    size.
  id: totrans-5906
  prefs: []
  type: TYPE_NORMAL
  zh: 不依赖于模板参数的成员除了特定的模板参数外不能使用。这限制了使用并通常会增加代码大小。
- en: Example, bad
  id: totrans-5907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE774]'
  id: totrans-5908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: This looks innocent enough, but now `Link` formally depends on the allocator
    (even though it doesn’t use the allocator). This forces redundant instantiations
    that can be surprisingly costly in some real-world scenarios. Typically, the solution
    is to make what would have been a nested class non-local, with its own minimal
    set of template parameters.
  id: totrans-5909
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很无辜，但现在`Link`正式依赖于分配器（即使它没有使用分配器）。这强制进行冗余实例化，在某些实际场景中可能会非常昂贵。通常，解决方案是将原本应该是嵌套类的部分非本地化，并拥有自己的最小模板参数集。
- en: '[PRE775]'
  id: totrans-5910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: 'Some people found the idea that the `Link` no longer was hidden inside the
    list scary, so we named the technique [SCARY](https://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf).
    From that academic paper: “The acronym SCARY describes assignments and initializations
    that are Seemingly erroneous (appearing Constrained by conflicting generic parameters),
    but Actually work with the Right implementation (unconstrained bY the conflict
    due to minimized dependencies).”'
  id: totrans-5911
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人发现`Link`不再隐藏在列表中很可怕，所以我们把这个技术命名为[SCARY](https://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf)。从那篇学术论文中：“SCARY这个缩写描述了看似错误的赋值和初始化（看起来受冲突的泛型参数约束），但实际上与正确的实现（不受最小化依赖性的冲突约束）一起工作。”
- en: Note
  id: totrans-5912
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This also applies to lambdas that don’t depend on all of the template parameters.
  id: totrans-5913
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于不依赖于所有模板参数的lambda。
- en: Enforcement
  id: totrans-5914
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag member types that do not depend on every template parameter
  id: totrans-5915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记不依赖于每个模板参数的成员类型
- en: Flag member functions that do not depend on every template parameter
  id: totrans-5916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记不依赖于每个模板参数的成员函数
- en: Flag lambdas or variable templates that do not depend on every template parameter
  id: totrans-5917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记不依赖于每个模板参数的lambda或变量模板
- en: 'T.62: Place non-dependent class template members in a non-templated base class'
  id: totrans-5918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.62：将非依赖的类模板成员放置在非模板基类中
- en: Reason
  id: totrans-5919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Allow the base class members to be used without specifying template arguments
    and without template instantiation.
  id: totrans-5920
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在不指定模板参数和不进行模板实例化的情况下使用基类成员。
- en: Example
  id: totrans-5921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE776]'
  id: totrans-5922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: ???
  id: totrans-5923
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: '[PRE777]'
  id: totrans-5924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: Note
  id: totrans-5925
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A more general version of this rule would be “If a class template member depends
    on only N template parameters out of M, place it in a base class with only N parameters.”
    For N == 1, we have a choice of a base class of a class in the surrounding scope
    as in [T.61](#rt-scary).
  id: totrans-5926
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则的更通用版本可以是“如果一个类模板成员只依赖于M个模板参数中的N个，那么将其放置在一个只有N个参数的非模板基类中。”对于N == 1，我们可以在周围作用域中选择一个类作为基类，如[T.61](#rt-scary)。
- en: ??? What about constants? class statics?
  id: totrans-5927
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 关于常量？类静态成员？
- en: Enforcement
  id: totrans-5928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag ???
  id: totrans-5929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 ???
- en: 'T.64: Use specialization to provide alternative implementations of class templates'
  id: totrans-5930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.64：使用特化来提供类模板的替代实现
- en: Reason
  id: totrans-5931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A template defines a general interface. Specialization offers a powerful mechanism
    for providing alternative implementations of that interface.
  id: totrans-5932
  prefs: []
  type: TYPE_NORMAL
  zh: 模板定义了一个通用接口。特化提供了一个强大的机制来提供该接口的替代实现。
- en: Example
  id: totrans-5933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE778]'
  id: totrans-5934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: Note
  id: totrans-5935
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: ???
  id: totrans-5936
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Enforcement
  id: totrans-5937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5938
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.65: Use tag dispatch to provide alternative implementations of a function'
  id: totrans-5939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.65：使用标签分派提供函数的替代实现
- en: Reason
  id: totrans-5940
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A template defines a general interface.
  id: totrans-5941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板定义了一个通用接口。
- en: Tag dispatch allows us to select implementations based on specific properties
    of an argument type.
  id: totrans-5942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签分派允许我们根据参数类型的特定属性选择实现。
- en: Performance.
  id: totrans-5943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能。
- en: Example
  id: totrans-5944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: This is a simplified version of `std::copy` (ignoring the possibility of non-contiguous
    sequences)
  id: totrans-5945
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`std::copy`的一个简化版本（忽略非连续序列的可能性）
- en: '[PRE779]'
  id: totrans-5946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: This is a general and powerful technique for compile-time algorithm selection.
  id: totrans-5947
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在编译时进行算法选择的通用且强大的技术。
- en: Note
  id: totrans-5948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'With C++20 constraints, such alternatives can be distinguished directly:'
  id: totrans-5949
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++20约束，这些替代方案可以直接区分：
- en: '[PRE780]'
  id: totrans-5950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: Enforcement
  id: totrans-5951
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5952
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.67: Use specialization to provide alternative implementations for irregular
    types'
  id: totrans-5953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.67：使用特化为不规则类型提供替代实现
- en: Reason
  id: totrans-5954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: ???
  id: totrans-5955
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Example
  id: totrans-5956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE781]'
  id: totrans-5957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: Enforcement
  id: totrans-5958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-5959
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.68: Use `{}` rather than `()` within templates to avoid ambiguities'
  id: totrans-5960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.68：在模板中使用`{}`而不是`()`以避免歧义
- en: Reason
  id: totrans-5961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`()` is vulnerable to grammar ambiguities.'
  id: totrans-5962
  prefs: []
  type: TYPE_NORMAL
  zh: '`()`容易产生语法歧义。'
- en: Example
  id: totrans-5963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE782]'
  id: totrans-5964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: Enforcement
  id: totrans-5965
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: flag `()` initializers
  id: totrans-5966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`()`初始化器
- en: flag function-style casts
  id: totrans-5967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记函数样式转换
- en: 'T.69: Inside a template, don’t make an unqualified non-member function call
    unless you intend it to be a customization point'
  id: totrans-5968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.69：在模板内部，除非你打算将其作为定制点，否则不要进行未限定的非成员函数调用
- en: Reason
  id: totrans-5969
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Provide only intended flexibility.
  id: totrans-5970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只提供预期的灵活性。
- en: Avoid vulnerability to accidental environmental changes.
  id: totrans-5971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免对意外环境变化的易受攻击性。
- en: Example
  id: totrans-5972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: There are three major ways to let calling code customize a template.
  id: totrans-5973
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要方式让调用代码定制模板。
- en: '[PRE783]'
  id: totrans-5974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: A trait is usually a type alias to compute a type, a `constexpr` function to
    compute a value, or a traditional traits template to be specialized on the user’s
    type.
  id: totrans-5975
  prefs: []
  type: TYPE_NORMAL
  zh: 特性通常是一个计算类型的类型别名，一个计算值的`constexpr`函数，或者是一个用于用户类型的传统特性模板。
- en: Note
  id: totrans-5976
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you intend to call your own helper function `helper(t)` with a value `t`
    that depends on a template type parameter, put it in a `::detail` namespace and
    qualify the call as `detail::helper(t);`. An unqualified call becomes a customization
    point where any function `helper` in the namespace of `t`’s type can be invoked;
    this can cause problems like [unintentionally invoking unconstrained function
    templates](#rt-visible).
  id: totrans-5977
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用依赖于模板类型参数的值`t`调用你自己的辅助函数`helper(t)`，请将其放在`::detail`命名空间中，并使用`detail::helper(t);`来限定调用。未限定的调用成为一个定制点，其中可以调用`t`的类型命名空间中的任何`helper`函数；这可能导致像[意外调用未约束的函数模板](#rt-visible)这样的问题。
- en: Enforcement
  id: totrans-5978
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: In a template, flag an unqualified call to a non-member function that passes
    a variable of dependent type when there is a non-member function of the same name
    in the template’s namespace.
  id: totrans-5979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中，如果模板的命名空间中存在同名的非成员函数，则标记未限定的对非成员函数的调用，该调用传递一个依赖于类型的变量。
- en: 'T.temp-hier: Template and hierarchy rules:'
  id: totrans-5980
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: T.temp-hier：模板和层次结构规则：
- en: Templates are the backbone of C++’s support for generic programming and class
    hierarchies the backbone of its support for object-oriented programming. The two
    language mechanisms can be used effectively in combination, but a few design pitfalls
    must be avoided.
  id: totrans-5981
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++支持泛型编程的支柱，而类层次结构是其支持面向对象编程的支柱。这两种语言机制可以有效地结合使用，但必须避免一些设计陷阱。
- en: 'T.80: Do not naively templatize a class hierarchy'
  id: totrans-5982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.80：不要天真地模板化类层次结构
- en: Reason
  id: totrans-5983
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Templating a class hierarchy that has many functions, especially many virtual
    functions, can lead to code bloat.
  id: totrans-5984
  prefs: []
  type: TYPE_NORMAL
  zh: 对具有许多函数，尤其是许多虚函数的类层次结构进行模板化可能会导致代码膨胀。
- en: Example, bad
  id: totrans-5985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE784]'
  id: totrans-5986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: It is probably a bad idea to define a `sort` as a member function of a container,
    but it is not unheard of and it makes a good example of what not to do.
  id: totrans-5987
  prefs: []
  type: TYPE_NORMAL
  zh: 将`sort`定义为容器的一个成员函数可能不是一个好主意，但这并非闻所未闻，它是一个很好的例子，说明了不应该做什么。
- en: Given this, the compiler cannot know if `vector<int>::sort()` is called, so
    it must generate code for it. Similar for `vector<string>::sort()`. Unless those
    two functions are called that’s code bloat. Imagine what this would do to a class
    hierarchy with dozens of member functions and dozens of derived classes with many
    instantiations.
  id: totrans-5988
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器无法知道是否调用了`vector<int>::sort()`，因此必须为它生成代码。类似地，对于`vector<string>::sort()`也是如此。除非调用这两个函数，否则就是代码膨胀。想象一下这对具有数十个成员函数和数十个具有许多实例化的派生类的类层次结构会做什么。
- en: Note
  id: totrans-5989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In many cases you can provide a stable interface by not parameterizing a base;
    see [“stable base”](#rt-abi) and [OO and GP](#rt-generic-oo)
  id: totrans-5990
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您可以通过不参数化基类来提供一个稳定的接口；参见[“稳定的基类”](#rt-abi)和[OO和GP](#rt-generic-oo)
- en: Enforcement
  id: totrans-5991
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag virtual functions that depend on a template argument. ??? False positives
  id: totrans-5992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记依赖于模板参数的虚函数。??? 假阳性
- en: 'T.81: Do not mix hierarchies and arrays'
  id: totrans-5993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.81: 不要混合层次结构和数组'
- en: Reason
  id: totrans-5994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: An array of derived classes can implicitly “decay” to a pointer to a base class
    with potential disastrous results.
  id: totrans-5995
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类数组可以隐式地“退化”为指向基类的指针，这可能导致灾难性的后果。
- en: Example
  id: totrans-5996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Assume that `Apple` and `Pear` are two kinds of `Fruit`s.
  id: totrans-5997
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Apple`和`Pear`是两种`Fruit`。
- en: '[PRE785]'
  id: totrans-5998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: Probably, `aa[0]` will be a `Pear` (without the use of a cast!). If `sizeof(Apple)
    != sizeof(Pear)` the access to `aa[1]` will not be aligned to the proper start
    of an object in the array. We have a type violation and possibly (probably) a
    memory corruption. Never write such code.
  id: totrans-5999
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，`aa[0]`将是一个`Pear`（不使用类型转换！）。如果`sizeof(Apple) != sizeof(Pear)`，则对`aa[1]`的访问将不会对齐到数组中对象的正确起始位置。我们有一个类型违规，可能（很可能）是内存损坏。永远不要编写这样的代码。
- en: Note that `maul()` violates the a [`T*` points to an individual object rule](#rf-ptr).
  id: totrans-6000
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`maul()`违反了[一个`T*`指向单个对象规则](#rf-ptr)。
- en: '**Alternative**: Use a proper (templatized) container:'
  id: totrans-6001
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：使用合适的（模板化）容器：'
- en: '[PRE786]'
  id: totrans-6002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: Note that the assignment in `maul2()` violated the [no-slicing rule](#res-slice).
  id: totrans-6003
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`maul2()`中的赋值违反了[无切片规则](#res-slice)。
- en: Enforcement
  id: totrans-6004
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Detect this horror!
  id: totrans-6005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测这个恐怖！
- en: 'T.82: Linearize a hierarchy when virtual functions are undesirable'
  id: totrans-6006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.82: 当不希望使用虚函数时，线性化层次结构'
- en: Reason
  id: totrans-6007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: ???
  id: totrans-6008
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Example
  id: totrans-6009
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE787]'
  id: totrans-6010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: Enforcement
  id: totrans-6011
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6012
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.83: Do not declare a member function template virtual'
  id: totrans-6013
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.83: 不要声明成员函数模板为虚函数'
- en: Reason
  id: totrans-6014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: C++ does not support that. If it did, vtbls could not be generated until link
    time. And in general, implementations must deal with dynamic linking.
  id: totrans-6015
  prefs: []
  type: TYPE_NORMAL
  zh: C++不支持这一点。如果它支持，vtbls将无法在链接时生成。通常，实现必须处理动态链接。
- en: Example, don’t
  id: totrans-6016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不要
- en: '[PRE788]'
  id: totrans-6017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: Note
  id: totrans-6018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We need a rule because people keep asking about this
  id: totrans-6019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一条规则，因为人们总是问这个问题
- en: Alternative
  id: totrans-6020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Double dispatch, visitors, calculate which function to call
  id: totrans-6021
  prefs: []
  type: TYPE_NORMAL
  zh: 双重分派，访问者，计算要调用的函数
- en: Enforcement
  id: totrans-6022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: The compiler handles that.
  id: totrans-6023
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器处理这个问题。
- en: 'T.84: Use a non-template core implementation to provide an ABI-stable interface'
  id: totrans-6024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.84: 使用非模板核心实现来提供ABI稳定的接口'
- en: Reason
  id: totrans-6025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Improve stability of code. Avoid code bloat.
  id: totrans-6026
  prefs: []
  type: TYPE_NORMAL
  zh: 提高代码的稳定性。避免代码膨胀。
- en: Example
  id: totrans-6027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'It could be a base class:'
  id: totrans-6028
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能是一个基类：
- en: '[PRE789]'
  id: totrans-6029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: Now there is only one copy of the operations linking and unlinking elements
    of a `List`. The `Link` and `List` classes do nothing but type manipulation.
  id: totrans-6030
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只有一个`List`元素链接和解除链接操作的副本。`Link`和`List`类除了类型操作什么都不做。
- en: Instead of using a separate “base” type, another common technique is to specialize
    for `void` or `void*` and have the general template for `T` be just the safely-encapsulated
    casts to and from the core `void` implementation.
  id: totrans-6031
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用单独的“基”类型，另一种常见的技术是为`void`或`void*`进行特化，并将通用模板`T`简单地作为对核心`void`实现的封装转换。
- en: '**Alternative**: Use a [Pimpl](#ri-pimpl) implementation.'
  id: totrans-6032
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：使用[Pimpl](#ri-pimpl)实现。'
- en: Enforcement
  id: totrans-6033
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6034
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.var: Variadic template rules'
  id: totrans-6035
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'T.var: 可变参数模板规则'
- en: ???
  id: totrans-6036
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.100: Use variadic templates when you need a function that takes a variable
    number of arguments of a variety of types'
  id: totrans-6037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.100: 当需要接受多种类型可变数量参数的函数时，使用可变参数模板'
- en: Reason
  id: totrans-6038
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Variadic templates is the most general mechanism for that, and is both efficient
    and type-safe. Don’t use C varargs.
  id: totrans-6039
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数模板是最通用的机制，它既高效又类型安全。不要使用C的可变参数。
- en: Example
  id: totrans-6040
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE790]'
  id: totrans-6041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: Enforcement
  id: totrans-6042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag uses of `va_arg` in user code.
  id: totrans-6043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记用户代码中`va_arg`的使用。
- en: 'T.101: ??? How to pass arguments to a variadic template ???'
  id: totrans-6044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.101: ??? 如何向可变参数模板传递参数 ???'
- en: Reason
  id: totrans-6045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: ???
  id: totrans-6046
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Example
  id: totrans-6047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE791]'
  id: totrans-6048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: Enforcement
  id: totrans-6049
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6050
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.102: How to process arguments to a variadic template'
  id: totrans-6051
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.102: 如何处理可变参数模板的参数'
- en: Reason
  id: totrans-6052
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: ???
  id: totrans-6053
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Example
  id: totrans-6054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE792]'
  id: totrans-6055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: Enforcement
  id: totrans-6056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6057
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.103: Don’t use variadic templates for homogeneous argument lists'
  id: totrans-6058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.103：不要为同构参数列表使用变长模板
- en: Reason
  id: totrans-6059
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: There are more precise ways of specifying a homogeneous sequence, such as an
    `initializer_list`.
  id: totrans-6060
  prefs: []
  type: TYPE_NORMAL
  zh: 有更精确的方式来指定同构序列，例如`initializer_list`。
- en: Example
  id: totrans-6061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE793]'
  id: totrans-6062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: Enforcement
  id: totrans-6063
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6064
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.meta: Template metaprogramming (TMP)'
  id: totrans-6065
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: T.meta：模板元编程（TMP）
- en: Templates provide a general mechanism for compile-time programming.
  id: totrans-6066
  prefs: []
  type: TYPE_NORMAL
  zh: 模板提供了一种通用的编译时编程机制。
- en: Metaprogramming is programming where at least one input or one result is a type.
    Templates offer Turing-complete (modulo memory capacity) duck typing at compile
    time. The syntax and techniques needed are pretty horrendous.
  id: totrans-6067
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程是一种编程方式，其中至少一个输入或一个结果是类型。模板在编译时提供Turing-complete（除内存容量外）的鸭子类型。所需的语法和技术相当糟糕。
- en: 'T.120: Use template metaprogramming only when you really need to'
  id: totrans-6068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.120：仅在真正需要时使用模板元编程
- en: Reason
  id: totrans-6069
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Template metaprogramming is hard to get right, slows down compilation, and is
    often very hard to maintain. However, there are real-world examples where template
    metaprogramming provides better performance than any alternative short of expert-level
    assembly code. Also, there are real-world examples where template metaprogramming
    expresses the fundamental ideas better than run-time code. For example, if you
    really need AST manipulation at compile time (e.g., for optional matrix operation
    folding) there might be no other way in C++.
  id: totrans-6070
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程很难做对，会减慢编译速度，并且通常很难维护。然而，有一些现实世界的例子表明，模板元编程的性能优于任何非专家级汇编代码的替代方案。此外，还有一些现实世界的例子表明，模板元编程比运行时代码更好地表达了基本思想。例如，如果你真的需要在编译时进行AST操作（例如，用于可选的矩阵运算折叠），在C++中可能没有其他方法。
- en: Example, bad
  id: totrans-6071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE794]'
  id: totrans-6072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: Example, bad
  id: totrans-6073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE795]'
  id: totrans-6074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: Instead, use concepts. But see [How to emulate concepts if you don’t have language
    support](#rt-emulate).
  id: totrans-6075
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用概念。但请参阅[如果你没有语言支持，如何模拟概念](#rt-emulate)。
- en: Example
  id: totrans-6076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE796]'
  id: totrans-6077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: '**Alternative**: If the result is a value, rather than a type, use a [`constexpr`
    function](#rt-fct).'
  id: totrans-6078
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：如果结果是值而不是类型，请使用一个[`constexpr`函数](#rt-fct)。'
- en: Note
  id: totrans-6079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you feel the need to hide your template metaprogramming in macros, you have
    probably gone too far.
  id: totrans-6080
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得需要在宏中隐藏你的模板元编程，那么你可能已经做得太过分了。
- en: 'T.121: Use template metaprogramming primarily to emulate concepts'
  id: totrans-6081
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.121：主要使用模板元编程来模拟概念
- en: Reason
  id: totrans-6082
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Where C++20 is not available, we need to emulate them using TMP. Use cases that
    require concepts (e.g. overloading based on concepts) are among the most common
    (and simple) uses of TMP.
  id: totrans-6083
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20不可用的情况下，我们需要使用TMP来模拟它们。需要概念的使用案例（例如，基于概念的重载）是TMP最常见（且简单）的使用之一。
- en: Example
  id: totrans-6084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE797]'
  id: totrans-6085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: Note
  id: totrans-6086
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Such code is much simpler using concepts:'
  id: totrans-6087
  prefs: []
  type: TYPE_NORMAL
  zh: 使用概念可以使此类代码更加简单：
- en: '[PRE798]'
  id: totrans-6088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: Enforcement
  id: totrans-6089
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6090
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.122: Use templates (usually template aliases) to compute types at compile
    time'
  id: totrans-6091
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.122：使用模板（通常是模板别名）在编译时计算类型
- en: Reason
  id: totrans-6092
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Template metaprogramming is the only directly supported and half-way principled
    way of generating types at compile time.
  id: totrans-6093
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元编程是唯一直接支持且半原则性的在编译时生成类型的方式。
- en: Note
  id: totrans-6094
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: “Traits” techniques are mostly replaced by template aliases to compute types
    and `constexpr` functions to compute values.
  id: totrans-6095
  prefs: []
  type: TYPE_NORMAL
  zh: “特质”技术大多被模板别名替换，用于计算类型，以及`constexpr`函数用于计算值。
- en: Example
  id: totrans-6096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE799]'
  id: totrans-6097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: Enforcement
  id: totrans-6098
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6099
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.123: Use `constexpr` functions to compute values at compile time'
  id: totrans-6100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.123：使用`constexpr`函数在编译时计算值
- en: Reason
  id: totrans-6101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A function is the most obvious and conventional way of expressing the computation
    of a value. Often a `constexpr` function implies less compile-time overhead than
    alternatives.
  id: totrans-6102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是表达值计算的最明显和传统的方式。通常，`constexpr`函数比其他替代方案具有更少的编译时开销。
- en: Note
  id: totrans-6103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: “Traits” techniques are mostly replaced by template aliases to compute types
    and `constexpr` functions to compute values.
  id: totrans-6104
  prefs: []
  type: TYPE_NORMAL
  zh: “特质”技术大多被模板别名替换，用于计算类型，以及`constexpr`函数用于计算值。
- en: Example
  id: totrans-6105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE800]'
  id: totrans-6106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: Enforcement
  id: totrans-6107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag template metaprograms yielding a value. These should be replaced with `constexpr`
    functions.
  id: totrans-6108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记返回值的模板元程序。这些应该用`constexpr`函数替换。
- en: 'T.124: Prefer to use standard-library TMP facilities'
  id: totrans-6109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.124：优先使用标准库TMP功能
- en: Reason
  id: totrans-6110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Facilities defined in the standard, such as `conditional`, `enable_if`, and
    `tuple`, are portable and can be assumed to be known.
  id: totrans-6111
  prefs: []
  type: TYPE_NORMAL
  zh: 标准中定义的设施，如`conditional`、`enable_if`和`tuple`，是可移植的，并且可以假设是已知的。
- en: Example
  id: totrans-6112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE801]'
  id: totrans-6113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: Enforcement
  id: totrans-6114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6115
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.125: If you need to go beyond the standard-library TMP facilities, use an
    existing library'
  id: totrans-6116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.125：如果你需要超越标准库TMP功能，请使用现有库
- en: Reason
  id: totrans-6117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Getting advanced TMP facilities is not easy and using a library makes you part
    of a (hopefully supportive) community. Write your own “advanced TMP support” only
    if you really have to.
  id: totrans-6118
  prefs: []
  type: TYPE_NORMAL
  zh: 获取高级TMP功能并不容易，使用库让你成为（希望是支持性的）社区的一部分。只有当你真的需要时，才编写自己的“高级TMP支持”。
- en: Example
  id: totrans-6119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE802]'
  id: totrans-6120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: Enforcement
  id: totrans-6121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: ???
  id: totrans-6122
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Other template rules
  id: totrans-6123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他模板规则
- en: 'T.140: If an operation can be reused, give it a name'
  id: totrans-6124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.140：如果一个操作可以被重用，给它一个名字
- en: See [F.10](#rf-name)
  id: totrans-6125
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[F.10](#rf-name)
- en: 'T.141: Use an unnamed lambda if you need a simple function object in one place
    only'
  id: totrans-6126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.141：如果你只需要一个简单的函数对象，使用未命名的lambda
- en: See [F.11](#rf-lambda)
  id: totrans-6127
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[F.11](#rf-lambda)
- en: 'T.142?: Use template variables to simplify notation'
  id: totrans-6128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'T.142?: 使用模板变量简化表示'
- en: Reason
  id: totrans-6129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Improved readability.
  id: totrans-6130
  prefs: []
  type: TYPE_NORMAL
  zh: 提高可读性。
- en: Example
  id: totrans-6131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE803]'
  id: totrans-6132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: Enforcement
  id: totrans-6133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: ???
  id: totrans-6134
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'T.143: Don’t write unintentionally non-generic code'
  id: totrans-6135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.143：不要编写无意中非泛型代码
- en: Reason
  id: totrans-6136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Generality. Reusability. Don’t gratuitously commit to details; use the most
    general facilities available.
  id: totrans-6137
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化。可重用性。不要随意承诺细节；使用最通用的可用功能。
- en: Example
  id: totrans-6138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Use `!=` instead of `<` to compare iterators; `!=` works for more objects because
    it doesn’t rely on ordering.
  id: totrans-6139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`!=`而不是`<`来比较迭代器；`!=`对更多对象有效，因为它不依赖于排序。
- en: '[PRE804]'
  id: totrans-6140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: Of course, range-`for` is better still where it does what you want.
  id: totrans-6141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当`range-for`满足你的需求时，它仍然更好。
- en: Example
  id: totrans-6142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Use the least-derived class that has the functionality you need.
  id: totrans-6143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有所需功能的最低派生类。
- en: '[PRE805]'
  id: totrans-6144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: Enforcement
  id: totrans-6145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag comparison of iterators using `<` instead of `!=`.
  id: totrans-6146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记使用`<`而不是`!=`比较迭代器。
- en: Flag `x.size() == 0` when `x.empty()` or `x.is_empty()` is available. Emptiness
    works for more containers than size(), because some containers don’t know their
    size or are conceptually of unbounded size.
  id: totrans-6147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`x.empty()`或`x.is_empty()`可用时，标记`x.size() == 0`。空性适用于比大小()更多的容器，因为某些容器不知道它们的大小或概念上是无界大小的。
- en: Flag functions that take a pointer or reference to a more-derived type but only
    use functions declared in a base type.
  id: totrans-6148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记接受指向更派生类型指针或引用的函数，但只使用在基类型中声明的函数。
- en: 'T.144: Don’t specialize function templates'
  id: totrans-6149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.144：不要特化函数模板
- en: Reason
  id: totrans-6150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: You can’t partially specialize a function template per language rules. You can
    fully specialize a function template but you almost certainly want to overload
    instead – because function template specializations don’t participate in overloading,
    they don’t act as you probably wanted. Rarely, you should actually specialize
    by delegating to a class template that you can specialize properly.
  id: totrans-6151
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能根据语言规则部分特化一个函数模板。你可以完全特化一个函数模板，但你几乎肯定想要重载——因为函数模板特化不参与重载，它们的行为可能不是你想要的。很少情况下，你应该实际通过委托到一个你可以正确特化的类模板来特化。
- en: Example
  id: totrans-6152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE806]'
  id: totrans-6153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: '**Exceptions**: If you do have a valid reason to specialize a function template,
    just write a single function template that delegates to a class template, then
    specialize the class template (including the ability to write partial specializations).'
  id: totrans-6154
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常**：如果你有正当理由特化一个函数模板，只需编写一个将委托给类模板的单个函数模板，然后特化类模板（包括编写部分特化的能力）。'
- en: Enforcement
  id: totrans-6155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag all specializations of a function template. Overload instead.
  id: totrans-6156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记函数模板的所有特化。改用重载。
- en: 'T.150: Check that a class matches a concept using `static_assert`'
  id: totrans-6157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T.150：使用`static_assert`检查一个类是否与概念匹配
- en: Reason
  id: totrans-6158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: If you intend for a class to match a concept, verifying that early saves users’
    pain.
  id: totrans-6159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算让一个类与概念匹配，验证这一点可以早期节省用户的痛苦。
- en: Example
  id: totrans-6160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE807]'
  id: totrans-6161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: 'Somewhere, possibly in an implementation file, let the compiler check the desired
    properties of `X`:'
  id: totrans-6162
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个地方，可能在实现文件中，让编译器检查`X`的所需属性：
- en: '[PRE808]'
  id: totrans-6163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: Enforcement
  id: totrans-6164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Not feasible.
  id: totrans-6165
  prefs: []
  type: TYPE_NORMAL
  zh: 不可行。
- en: 'CPL: C-style programming'
  id: totrans-6166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPL：C风格编程
- en: C and C++ are closely related languages. They both originate in “Classic C”
    from 1978 and have evolved in ISO committees since then. Many attempts have been
    made to keep them compatible, but neither is a subset of the other.
  id: totrans-6167
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++是紧密相关的语言。它们都起源于1978年的“经典C”，并且从那时起在ISO委员会中不断发展。已经做出了许多努力来保持它们的兼容性，但它们都不是对方的子集。
- en: 'C rule summary:'
  id: totrans-6168
  prefs: []
  type: TYPE_NORMAL
  zh: C规则摘要：
- en: '[CPL.1: Prefer C++ to C](#rcpl-c)'
  id: totrans-6169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CPL.1：优先使用C++](#rcpl-c)'
- en: '[CPL.2: If you must use C, use the common subset of C and C++, and compile
    the C code as C++](#rcpl-subset)'
  id: totrans-6170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CPL.2：如果你必须使用C，请使用C和C++的公共子集，并将C代码作为C++编译](#rcpl-subset)'
- en: '[CPL.3: If you must use C for interfaces, use C++ in the calling code using
    such interfaces](#rcpl-interface)'
  id: totrans-6171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CPL.3：如果你必须使用C进行接口，请在使用这些接口的调用代码中使用C++](#rcpl-interface)'
- en: 'CPL.1: Prefer C++ to C'
  id: totrans-6172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPL.1：优先使用C++
- en: Reason
  id: totrans-6173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: C++ provides better type checking and more notational support. It provides better
    support for high-level programming and often generates faster code.
  id: totrans-6174
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了更好的类型检查和更多的符号支持。它为高级编程提供了更好的支持，并且通常生成更快的代码。
- en: Example
  id: totrans-6175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE809]'
  id: totrans-6176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: The rules for implicit casting to and from `void*` in C are subtle and unenforced.
    In particular, this example violates a rule against converting to a type with
    stricter alignment.
  id: totrans-6177
  prefs: []
  type: TYPE_NORMAL
  zh: C 中对 `void*` 进行隐式转换的规则微妙且未强制执行。特别是，此示例违反了反对转换为具有更严格对齐的类型规则。
- en: Enforcement
  id: totrans-6178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Use a C++ compiler.
  id: totrans-6179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 编译器。
- en: 'CPL.2: If you must use C, use the common subset of C and C++, and compile the
    C code as C++'
  id: totrans-6180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPL.2：如果你必须使用 C，请使用 C 和 C++ 的公共子集，并将 C 代码作为 C++ 编译
- en: Reason
  id: totrans-6181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That subset can be compiled with both C and C++ compilers, and when compiled
    as C++ is better type checked than “pure C.”
  id: totrans-6182
  prefs: []
  type: TYPE_NORMAL
  zh: 该子集可以用 C 和 C++ 编译器编译，并且当作为 C++ 编译时比“纯 C”有更好的类型检查。
- en: Example
  id: totrans-6183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE810]'
  id: totrans-6184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: Enforcement
  id: totrans-6185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Flag if using a build mode that compiles code as C.
  id: totrans-6186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用编译代码为 C 的构建模式，请标记。
- en: The C++ compiler will enforce that the code is valid C++ unless you use C extension
    options.
  id: totrans-6187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 编译器将强制代码是有效的 C++，除非你使用 C 扩展选项。
- en: 'CPL.3: If you must use C for interfaces, use C++ in the calling code using
    such interfaces'
  id: totrans-6188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPL.3：如果你必须使用 C 进行接口，请使用调用这些接口的代码中的 C++ 编译 C 代码
- en: Reason
  id: totrans-6189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: C++ is more expressive than C and offers better support for many types of programming.
  id: totrans-6190
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 比 C 更具表现力，并为许多类型的编程提供更好的支持。
- en: Example
  id: totrans-6191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: For example, to use a 3rd party C library or C systems interface, define the
    low-level interface in the common subset of C and C++ for better type checking.
    Whenever possible encapsulate the low-level interface in an interface that follows
    the C++ guidelines (for better abstraction, memory safety, and resource safety)
    and use that C++ interface in C++ code.
  id: totrans-6192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了使用第三方 C 库或 C 系统接口，请在 C 和 C++ 的公共子集中定义低级接口以获得更好的类型检查。尽可能将低级接口封装在遵循 C++ 指南的接口中（以获得更好的抽象、内存安全和资源安全），并在
    C++ 代码中使用该 C++ 接口。
- en: Example
  id: totrans-6193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'You can call C from C++:'
  id: totrans-6194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 C++ 中调用 C：
- en: '[PRE811]'
  id: totrans-6195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: Example
  id: totrans-6196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'You can call C++ from C:'
  id: totrans-6197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 C 调用 C++：
- en: '[PRE812]'
  id: totrans-6198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: Enforcement
  id: totrans-6199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: None needed
  id: totrans-6200
  prefs: []
  type: TYPE_NORMAL
  zh: 无需
- en: 'SF: Source files'
  id: totrans-6201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SF：源文件
- en: Distinguish between declarations (used as interfaces) and definitions (used
    as implementations). Use header files to represent interfaces and to emphasize
    logical structure.
  id: totrans-6202
  prefs: []
  type: TYPE_NORMAL
  zh: 区分声明（用作接口）和定义（用作实现）。使用头文件来表示接口并强调逻辑结构。
- en: 'Source file rule summary:'
  id: totrans-6203
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件规则摘要：
- en: '[SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your
    project doesn’t already follow another convention](#rs-file-suffix)'
  id: totrans-6204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.1：如果你的项目尚未遵循其他约定，请为代码文件使用 `.cpp` 后缀，为接口文件使用 `.h` 后缀](#rs-file-suffix)'
- en: '[SF.2: A header file must not contain object definitions or non-inline function
    definitions](#rs-inline)'
  id: totrans-6205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.2：头文件不得包含对象定义或非内联函数定义](#rs-inline)'
- en: '[SF.3: Use header files for all declarations used in multiple source files](#rs-declaration-header)'
  id: totrans-6206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.3：为在多个源文件中使用的所有声明使用头文件](#rs-declaration-header)'
- en: '[SF.4: Include header files before other declarations in a file](#rs-include-order)'
  id: totrans-6207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.4：在文件中的其他声明之前包含头文件](#rs-include-order)'
- en: '[SF.5: A `.cpp` file must include the header file(s) that defines its interface](#rs-consistency)'
  id: totrans-6208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.5：`.cpp` 文件必须包含定义其接口的头文件](#rs-consistency)'
- en: '[SF.6: Use `using namespace` directives for transition, for foundation libraries
    (such as `std`), or within a local scope (only)](#rs-using)'
  id: totrans-6209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.6：使用 `using namespace` 指令进行过渡，对于基础库（如 `std`），或局部作用域内（仅限）](#rs-using)'
- en: '[SF.7: Don’t write `using namespace` at global scope in a header file](#rs-using-directive)'
  id: totrans-6210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.7：不要在头文件的全局作用域中写入 `using namespace` 指令](#rs-using-directive)'
- en: '[SF.8: Use `#include` guards for all header files](#rs-guards)'
  id: totrans-6211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.8：为所有头文件使用 `#include` 保护](#rs-guards)'
- en: '[SF.9: Avoid cyclic dependencies among source files](#rs-cycles)'
  id: totrans-6212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.9：避免源文件之间的循环依赖](#rs-cycles)'
- en: '[SF.10: Avoid dependencies on implicitly `#include`d names](#rs-implicit)'
  id: totrans-6213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.10：避免对隐式 `#include` 的名称的依赖](#rs-implicit)'
- en: '[SF.11: Header files should be self-contained](#rs-contained)'
  id: totrans-6214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.11：头文件应该是自包含的](#rs-contained)'
- en: '[SF.12: Prefer the quoted form of `#include` for files relative to the including
    file and the angle bracket form everywhere else](#rs-incform)'
  id: totrans-6215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.12：对于相对于包含文件的文件，优先使用引号形式的 `#include`，在其他所有地方使用尖括号形式](#rs-incform)'
- en: '[SF.13: Use portable header identifiers in `#include` statements](#rs-portable-header-id)'
  id: totrans-6216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.13：在 `#include` 语句中使用可移植的头文件标识符](#rs-portable-header-id)'
- en: '[SF.20: Use `namespace`s to express logical structure](#rs-namespace)'
  id: totrans-6217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.20：使用 `namespace` 表达逻辑结构](#rs-namespace)'
- en: '[SF.21: Don’t use an unnamed (anonymous) namespace in a header](#rs-unnamed)'
  id: totrans-6218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.21：不要在头文件中使用未命名的（匿名）命名空间](#rs-unnamed)'
- en: '[SF.22: Use an unnamed (anonymous) namespace for all internal/non-exported
    entities](#rs-unnamed2)'
  id: totrans-6219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SF.22：对所有内部/非导出实体使用未命名的（匿名）命名空间](#rs-unnamed2)'
- en: 'SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your
    project doesn’t already follow another convention'
  id: totrans-6220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.1：如果你的项目尚未遵循其他约定，则使用`.cpp`后缀为代码文件，`.h`为接口文件
- en: See [NL.27](#rl-file-suffix)
  id: totrans-6221
  prefs: []
  type: TYPE_NORMAL
  zh: 见[NL.27](#rl-file-suffix)
- en: 'SF.2: A header file must not contain object definitions or non-inline function
    definitions'
  id: totrans-6222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.2：头文件不得包含对象定义或非内联函数定义
- en: Reason
  id: totrans-6223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Including entities subject to the one-definition rule leads to linkage errors.
  id: totrans-6224
  prefs: []
  type: TYPE_NORMAL
  zh: 包含受单一定义规则约束的实体会导致链接错误。
- en: Example
  id: totrans-6225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE813]'
  id: totrans-6226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: Linking `file1.cpp` and `file2.cpp` will give two linker errors.
  id: totrans-6227
  prefs: []
  type: TYPE_NORMAL
  zh: 将`file1.cpp`和`file2.cpp`链接在一起将产生两个链接错误。
- en: '**Alternative formulation**: A header file must contain only:'
  id: totrans-6228
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代公式**：头文件必须只包含：'
- en: '`#include`s of other header files (possibly with include guards)'
  id: totrans-6229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含其他头文件（可能带有包含保护符）的`#include`
- en: templates
  id: totrans-6230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: class definitions
  id: totrans-6231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义
- en: function declarations
  id: totrans-6232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明
- en: '`extern` declarations'
  id: totrans-6233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern`声明'
- en: '`inline` function definitions'
  id: totrans-6234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数定义
- en: '`constexpr` definitions'
  id: totrans-6235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr`定义'
- en: '`const` definitions'
  id: totrans-6236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`定义'
- en: '`using` alias definitions'
  id: totrans-6237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using`别名定义'
- en: ???
  id: totrans-6238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: Enforcement
  id: totrans-6239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Check the positive list above.
  id: totrans-6240
  prefs: []
  type: TYPE_NORMAL
  zh: 检查上述积极列表。
- en: 'SF.3: Use header files for all declarations used in multiple source files'
  id: totrans-6241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.3：对于在多个源文件中使用的所有声明使用头文件
- en: Reason
  id: totrans-6242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Maintainability. Readability.
  id: totrans-6243
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性。可读性。
- en: Example, bad
  id: totrans-6244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE814]'
  id: totrans-6245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: A maintainer of `bar` cannot find all declarations of `bar` if its type needs
    changing. The user of `bar` cannot know if the interface used is complete and
    correct. At best, error messages come (late) from the linker.
  id: totrans-6246
  prefs: []
  type: TYPE_NORMAL
  zh: '`bar`的维护者无法找到所有`bar`的声明，如果其类型需要更改。`bar`的使用者无法知道所使用的接口是否完整和正确。最坏的情况是，错误信息（晚些时候）来自链接器。'
- en: Enforcement
  id: totrans-6247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag declarations of entities in other source files not placed in a `.h`.
  id: totrans-6248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其他源文件中的实体标志声明放在`.h`文件外。
- en: 'SF.4: Include header files before other declarations in a file'
  id: totrans-6249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.4：在文件中的其他声明之前包含头文件
- en: Reason
  id: totrans-6250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Minimize context dependencies and increase readability.
  id: totrans-6251
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化上下文依赖并提高可读性。
- en: Example
  id: totrans-6252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE815]'
  id: totrans-6253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: Example, bad
  id: totrans-6254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE816]'
  id: totrans-6255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: Note
  id: totrans-6256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This applies to both `.h` and `.cpp` files.
  id: totrans-6257
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于`.h`和`.cpp`文件。
- en: Note
  id: totrans-6258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There is an argument for insulating code from declarations and macros in header
    files by `#including` headers *after* the code we want to protect (as in the example
    labeled “bad”). However
  id: totrans-6259
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个论点，即通过在想要保护的代码之后`#including`头文件来隔离代码与头文件中的声明和宏（如示例中标记为“bad”的示例所示）。然而
- en: 'that only works for one file (at one level): Use that technique in a header
    included with other headers and the vulnerability reappears.'
  id: totrans-6260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只适用于一个文件（一个级别）：在包含其他头文件的头部中使用该技术，并且漏洞再次出现。
- en: a namespace (an “implementation namespace”) can protect against many context
    dependencies.
  id: totrans-6261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命名空间（一个“实现命名空间”）可以防止许多上下文依赖。
- en: full protection and flexibility require modules.
  id: totrans-6262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全保护和灵活性需要模块。
- en: '**See also**:'
  id: totrans-6263
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：'
- en: '[Working Draft, Extensions to C++ for Modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)'
  id: totrans-6264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模块的C++工作草案扩展](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)'
- en: '[Modules, Componentization, and Transition](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)'
  id: totrans-6265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模块、组件化和过渡](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)'
- en: Enforcement
  id: totrans-6266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Easy.
  id: totrans-6267
  prefs: []
  type: TYPE_NORMAL
  zh: 简单。
- en: 'SF.5: A `.cpp` file must include the header file(s) that defines its interface'
  id: totrans-6268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.5：`.cpp`文件必须包含定义其接口的头文件
- en: Reason
  id: totrans-6269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This enables the compiler to do an early consistency check.
  id: totrans-6270
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得编译器能够进行早期一致性检查。
- en: Example, bad
  id: totrans-6271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE817]'
  id: totrans-6272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: The errors will not be caught until link time for a program calling `bar` or
    `foobar`.
  id: totrans-6273
  prefs: []
  type: TYPE_NORMAL
  zh: 错误直到调用`bar`或`foobar`的程序链接时才会被发现。
- en: Example
  id: totrans-6274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE818]'
  id: totrans-6275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: The return-type error for `foobar` is now caught immediately when `foo.cpp`
    is compiled. The argument-type error for `bar` cannot be caught until link time
    because of the possibility of overloading, but systematic use of `.h` files increases
    the likelihood that it is caught earlier by the programmer.
  id: totrans-6276
  prefs: []
  type: TYPE_NORMAL
  zh: '`foobar`的返回类型错误现在在编译`foo.cpp`时立即被发现。由于重载的可能性，`bar`的参数类型错误无法在链接时捕获，但系统性地使用`.h`文件增加了程序员更早捕获它的可能性。'
- en: Enforcement
  id: totrans-6277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6278
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SF.6: Use `using namespace` directives for transition, for foundation libraries
    (such as `std`), or within a local scope (only)'
  id: totrans-6279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.6：在过渡、基础库（如`std`）或局部作用域内（仅限）使用`using namespace`指令
- en: Reason
  id: totrans-6280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`using namespace` can lead to name clashes, so it should be used sparingly.
    However, it is not always possible to qualify every name from a namespace in user
    code (e.g., during transition) and sometimes a namespace is so fundamental and
    prevalent in a code base, that consistent qualification would be verbose and distracting.'
  id: totrans-6281
  prefs: []
  type: TYPE_NORMAL
  zh: '`using namespace`可能会导致名称冲突，因此应该谨慎使用。然而，在用户代码中（例如在过渡期间）并不总是可能为命名空间中的每个名称进行限定，有时一个命名空间在代码库中如此基本且普遍，一致的限定会显得冗长且分散注意力。'
- en: Example
  id: totrans-6282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE819]'
  id: totrans-6283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: Here (obviously), the standard library is used pervasively and apparently no
    other library is used, so requiring `std::` everywhere could be distracting.
  id: totrans-6284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里（显然），标准库被广泛使用，并且似乎没有使用其他库，因此要求在所有地方使用`std::`可能会分散注意力。
- en: Example
  id: totrans-6285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: The use of `using namespace std;` leaves the programmer open to a name clash
    with a name from the standard library
  id: totrans-6286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`using namespace std;`会使程序员容易与标准库中的名称发生冲突
- en: '[PRE820]'
  id: totrans-6287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: However, this is not particularly likely to lead to a resolution that is not
    an error and people who use `using namespace std` are supposed to know about `std`
    and about this risk.
  id: totrans-6288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不太可能导致非错误性的解决方案，并且使用`using namespace std`的人应该了解`std`以及这个风险。
- en: Note
  id: totrans-6289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A `.cpp` file is a form of local scope. There is little difference in the opportunities
    for name clashes in an N-line `.cpp` containing a `using namespace X`, an N-line
    function containing a `using namespace X`, and M functions each containing a `using
    namespace X` with N lines of code in total.
  id: totrans-6290
  prefs: []
  type: TYPE_NORMAL
  zh: '`.cpp`文件是一种局部作用域。在包含`using namespace X`的N行`.cpp`文件、包含`using namespace X`的N行函数以及包含`using
    namespace X`的M个函数（总共有N行代码）中，名称冲突的机会几乎没有区别。'
- en: Note
  id: totrans-6291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Don’t write `using namespace` at global scope in a header file](#rs-using-directive).'
  id: totrans-6292
  prefs: []
  type: TYPE_NORMAL
  zh: '[不要在头文件的全局作用域中写`using namespace`](#rs-using-directive)。'
- en: 'SF.7: Don’t write `using namespace` at global scope in a header file'
  id: totrans-6293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.7: 不要在头文件的全局作用域中写`using namespace`'
- en: Reason
  id: totrans-6294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Doing so takes away an `#include`r’s ability to effectively disambiguate and
    to use alternatives. It also makes `#include`d headers order-dependent as they
    might have different meaning when included in different orders.
  id: totrans-6295
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会剥夺`#include`者的有效区分能力和使用替代方案的能力。这也使得包含的头部文件依赖于顺序，因为它们在不同的顺序中可能具有不同的含义。
- en: Example
  id: totrans-6296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE821]'
  id: totrans-6297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: Note
  id: totrans-6298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An exception is `using namespace std::literals;`. This is necessary to use string
    literals in header files and given [the rules](https://eel.is/c++draft/over.literal)
    - users are required to name their own UDLs `operator""_x` - they will not collide
    with the standard library.
  id: totrans-6299
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例外是`using namespace std::literals;`。这是在头文件中使用字符串字面量所必需的，根据[规则](https://eel.is/c++draft/over.literal)
    - 用户必须为自己的用户定义字面量命名`operator""_x` - 因此它们不会与标准库冲突。
- en: Enforcement
  id: totrans-6300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `using namespace` at global scope in a header file.
  id: totrans-6301
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件的全局作用域中标记`using namespace`。
- en: 'SF.8: Use `#include` guards for all header files'
  id: totrans-6302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.8: 为所有头文件使用`#include`保护'
- en: Reason
  id: totrans-6303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid files being `#include`d several times.
  id: totrans-6304
  prefs: []
  type: TYPE_NORMAL
  zh: 以避免文件被多次`#include`。
- en: In order to avoid include guard collisions, do not just name the guard after
    the filename. Be sure to also include a key and good differentiator, such as the
    name of library or component the header file is part of.
  id: totrans-6305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免包含保护冲突，不要仅仅根据文件名命名保护。确保还包括一个关键和良好的区分器，例如库或组件的名称，该头文件是其中的一部分。
- en: Example
  id: totrans-6306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE822]'
  id: totrans-6307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: Enforcement
  id: totrans-6308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `.h` files without `#include` guards.
  id: totrans-6309
  prefs: []
  type: TYPE_NORMAL
  zh: 标记没有`#include`保护的`.h`文件。
- en: Note
  id: totrans-6310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some implementations offer vendor extensions like `#pragma once` as alternative
    to include guards. It is not standard and it is not portable. It injects the hosting
    machine’s filesystem semantics into your program, in addition to locking you down
    to a vendor. Our recommendation is to write in ISO C++: See [rule P.2](#rp-cplusplus).'
  id: totrans-6311
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现提供了供应商扩展，如`#pragma once`，作为包含保护的替代方案。这不是标准，也不是可移植的。它将宿主机的文件系统语义注入到你的程序中，并使你锁定到供应商。我们的建议是使用ISO
    C++编写：参见[规则P.2](#rp-cplusplus)。
- en: 'SF.9: Avoid cyclic dependencies among source files'
  id: totrans-6312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.9: 避免源文件之间的循环依赖'
- en: Reason
  id: totrans-6313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Cycles complicate comprehension and slow down compilation. They also complicate
    conversion to use language-supported modules (when they become available).
  id: totrans-6314
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会使理解复杂化并减慢编译速度。它们还会使将代码转换为使用语言支持的模块（当它们可用时）复杂化。
- en: Note
  id: totrans-6315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Eliminate cycles; don’t just break them with `#include` guards.
  id: totrans-6316
  prefs: []
  type: TYPE_NORMAL
  zh: 消除循环；不要仅仅用`#include`保护来打断它们。
- en: Example, bad
  id: totrans-6317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好
- en: '[PRE823]'
  id: totrans-6318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: Enforcement
  id: totrans-6319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all cycles.
  id: totrans-6320
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有循环。
- en: 'SF.10: Avoid dependencies on implicitly `#include`d names'
  id: totrans-6321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.10: 避免对隐式`#include`的名称产生依赖'
- en: Reason
  id: totrans-6322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Avoid surprises. Avoid having to change `#include`s if an `#include`d header
    changes. Avoid accidentally becoming dependent on implementation details and logically
    separate entities included in a header.
  id: totrans-6323
  prefs: []
  type: TYPE_NORMAL
  zh: 避免意外。如果被包含的头文件发生变化，避免需要更改 `#include`。避免意外地依赖于实现细节和逻辑上分开的头文件中包含的实体。
- en: Example, bad
  id: totrans-6324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE824]'
  id: totrans-6325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: '`<iostream>` exposes the definition of `std::string` (“why?” makes for a fun
    trivia question), but it is not required to do so by transitively including the
    entire `<string>` header, resulting in the popular beginner question “why doesn’t
    `getline(cin,s);` work?” or even an occasional “`string`s cannot be compared with
    `==`”).'
  id: totrans-6326
  prefs: []
  type: TYPE_NORMAL
  zh: '`<iostream>` 提供了 `std::string` 的定义（“为什么？”是一个有趣的事实问题），但通过传递性地包含整个 `<string>`
    头文件并不需要这样做，这导致了流行的初学者问题“为什么 `getline(cin,s);` 不工作？”或者偶尔的“`string` 不能用 `==` 比较的问题”）。'
- en: 'The solution is to explicitly `#include <string>`:'
  id: totrans-6327
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是显式地 `#include <string>`：
- en: Example, good
  id: totrans-6328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE825]'
  id: totrans-6329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: Note
  id: totrans-6330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some headers exist exactly to collect a set of consistent declarations from
    a variety of headers. For example:'
  id: totrans-6331
  prefs: []
  type: TYPE_NORMAL
  zh: 一些头文件正是为了从各种头文件中收集一组一致的声明而存在的。例如：
- en: '[PRE826]'
  id: totrans-6332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: a user can now get that set of declarations with a single `#include`
  id: totrans-6333
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以通过单个 `#include` 获取那一组声明
- en: '[PRE827]'
  id: totrans-6334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: This rule against implicit inclusion is not meant to prevent such deliberate
    aggregation.
  id: totrans-6335
  prefs: []
  type: TYPE_NORMAL
  zh: 这项反对隐式包含的规则并不是为了阻止这种故意的聚合。
- en: Enforcement
  id: totrans-6336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Enforcement would require some knowledge about what in a header is meant to
    be “exported” to users and what is there to enable implementation. No really good
    solution is possible until we have modules.
  id: totrans-6337
  prefs: []
  type: TYPE_NORMAL
  zh: 执法需要了解头文件中哪些内容是打算“导出”给用户的，以及哪些内容是为了实现而存在的。在没有模块之前，不可能有真正好的解决方案。
- en: 'SF.11: Header files should be self-contained'
  id: totrans-6338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.11：头文件应该是自包含的
- en: Reason
  id: totrans-6339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Usability, headers should be simple to use and work when included on their own.
    Headers should encapsulate the functionality they provide. Avoid clients of a
    header having to manage that header’s dependencies.
  id: totrans-6340
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性，头文件应该易于使用，并且当单独包含时能够正常工作。头文件应该封装它们提供的功能。避免头文件客户端需要管理该头文件的依赖项。
- en: Example
  id: totrans-6341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE828]'
  id: totrans-6342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: Note
  id: totrans-6343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Failing to follow this results in difficult to diagnose errors for clients of
    a header.
  id: totrans-6344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不遵循此规则，会导致头文件客户端出现难以诊断的错误。
- en: Note
  id: totrans-6345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A header should include all its dependencies. Be careful about using relative
    paths because C++ implementations diverge on their meaning.
  id: totrans-6346
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件应该包含所有其依赖项。注意使用相对路径，因为 C++ 实现对它们的含义有不同的解释。
- en: Enforcement
  id: totrans-6347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: A test should verify that the header file itself compiles or that a cpp file
    which only includes the header file compiles.
  id: totrans-6348
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该验证头文件本身是否可以编译，或者仅包含头文件的 cpp 文件是否可以编译。
- en: 'SF.12: Prefer the quoted form of `#include` for files relative to the including
    file and the angle bracket form everywhere else'
  id: totrans-6349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SF.12：优先使用相对路径文件的引号形式 `#include`，在其他所有地方使用尖括号形式
- en: Reason
  id: totrans-6350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The [standard](https://eel.is/c++draft/cpp.include) provides flexibility for
    compilers to implement the two forms of `#include` selected using the angle (`<>`)
    or quoted (`""`) syntax. Vendors take advantage of this and use different search
    algorithms and methods for specifying the include path.
  id: totrans-6351
  prefs: []
  type: TYPE_NORMAL
  zh: 标准提供了灵活性，允许编译器根据使用尖括号（`<>`）或引号（`""`）语法选择的两种 `#include` 形式来实现。供应商利用这一点，并使用不同的搜索算法和指定包含路径的方法。
- en: Nevertheless, the guidance is to use the quoted form for including files that
    exist at a relative path to the file containing the `#include` statement (from
    within the same component or project) and to use the angle bracket form everywhere
    else, where possible. This encourages being clear about the locality of the file
    relative to files that include it, or scenarios where the different search algorithm
    is required. It makes it easy to understand at a glance whether a header is being
    included from a local relative file versus a standard library header or a header
    from the alternate search path (e.g. a header from another library or a common
    set of includes).
  id: totrans-6352
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，指导方针是对于位于包含 `#include` 语句的文件相对路径的包含文件使用引号形式，在其他所有可能的地方使用尖括号形式。这鼓励清楚地了解文件相对于包含它的文件的位置，或者需要不同搜索算法的场景。它使得一眼就能看出头文件是从本地相对文件包含的，还是从标准库头文件或替代搜索路径（例如，来自另一个库或一组常见包含的头文件）包含的。
- en: Example
  id: totrans-6353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE829]'
  id: totrans-6354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: Note
  id: totrans-6355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Failing to follow this results in difficult to diagnose errors due to picking
    up the wrong file by incorrectly specifying the scope when it is included. For
    example, in a typical case where the `#include ""` search algorithm might search
    for a file existing at a local relative path first, then using this form to refer
    to a file that is not locally relative could mean that if a file ever comes into
    existence at the local relative path (e.g. the including file is moved to a new
    location), it will now be found ahead of the previous include file and the set
    of includes will have been changed in an unexpected way.
  id: totrans-6356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不遵循此建议，则会导致由于在包含时错误地指定作用域而难以诊断的错误，因为会错误地选择文件。例如，在典型情况下，`#include ""`搜索算法可能会首先搜索存在于本地相对路径的文件，然后使用这种形式来引用一个非本地相对的文件，这意味着如果文件在本地相对路径中存在（例如，包含的文件被移动到新位置），现在它将先于之前的包含文件被发现，并且包含集将以意想不到的方式改变。
- en: Library creators should put their headers in a folder and have clients include
    those files using the relative path `#include <some_library/common.h>`
  id: totrans-6357
  prefs: []
  type: TYPE_NORMAL
  zh: 库创建者应将他们的头文件放在一个文件夹中，并让客户端使用相对路径`#include <some_library/common.h>`包含这些文件
- en: Enforcement
  id: totrans-6358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: A test should identify whether headers referenced via `""` could be referenced
    with `<>`.
  id: totrans-6359
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应确定通过`""`引用的头文件是否可以用`<>`引用。
- en: 'SF.13: Use portable header identifiers in `#include` statements'
  id: totrans-6360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.13: 在`#include`语句中使用可移植的头部标识符'
- en: Reason
  id: totrans-6361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The [standard](https://eel.is/c++draft/cpp.include) does not specify how compilers
    uniquely locate headers from an identifier in an `#include` directive, nor does
    it specify what constitutes uniqueness. For example, whether the implementation
    considers the identifiers to be case-sensitive, or whether the identifiers are
    file system paths to a header file, and if so, how a hierarchical file system
    path is delimited.
  id: totrans-6362
  prefs: []
  type: TYPE_NORMAL
  zh: 标准没有指定编译器如何从`#include`指令中的标识符唯一定位头文件，也没有指定构成唯一性的内容。例如，实现是否将标识符视为大小写敏感的，或者标识符是否是头文件的文件系统路径，如果是，那么如何分隔分层文件系统路径。
- en: 'To maximize the portability of `#include` directives across compilers, guidance
    is to:'
  id: totrans-6363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大化`#include`指令在编译器之间的可移植性，建议如下：
- en: use case-sensitivity for the header identifier, matching how the header is defined
    by the standard, specification, implementation, or file that provides the header.
  id: totrans-6364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于头部标识符使用大小写敏感，以匹配标准、规范、实现或提供头文件的文件如何定义该头部。
- en: when the header identifier is a hierarchical file path, use forward-slash `/`
    to delimit path components as this is the most widely-accepted path-delimiting
    character.
  id: totrans-6365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当头部标识符是分层文件路径时，使用正斜杠`/`来分隔路径组件，因为这是最广泛接受的路径分隔字符。
- en: Example
  id: totrans-6366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE830]'
  id: totrans-6367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: Enforcement
  id: totrans-6368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: It is only possible to enforce on implementations where header identifiers are
    case-sensitive and which only support `/` as a file path delimiter.
  id: totrans-6369
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在头文件标识符是大小写敏感的，并且只支持`/`作为文件路径分隔符的实现中，才能执行。
- en: 'SF.20: Use `namespace`s to express logical structure'
  id: totrans-6370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.20: 使用`namespace`来表示逻辑结构'
- en: Reason
  id: totrans-6371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: ???
  id: totrans-6372
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Example
  id: totrans-6373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE831]'
  id: totrans-6374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: Enforcement
  id: totrans-6375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6376
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SF.21: Don’t use an unnamed (anonymous) namespace in a header'
  id: totrans-6377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.21: 不要在头文件中使用无名的（匿名）命名空间'
- en: Reason
  id: totrans-6378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is almost always a bug to mention an unnamed namespace in a header file.
  id: totrans-6379
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中提及无名的命名空间几乎总是错误。
- en: Example
  id: totrans-6380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE832]'
  id: totrans-6381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: Enforcement
  id: totrans-6382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag any use of an anonymous namespace in a header file.
  id: totrans-6383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记头文件中任何无名的命名空间的使用。
- en: 'SF.22: Use an unnamed (anonymous) namespace for all internal/non-exported entities'
  id: totrans-6384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SF.22: 为所有内部/非导出实体使用无名的（匿名）命名空间'
- en: Reason
  id: totrans-6385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Nothing external can depend on an entity in a nested unnamed namespace. Consider
    putting every definition in an implementation source file in an unnamed namespace
    unless that is defining an “external/exported” entity.
  id: totrans-6386
  prefs: []
  type: TYPE_NORMAL
  zh: 任何外部都不能依赖于嵌套无名的命名空间中的实体。考虑将每个定义放在实现源文件中的无名的命名空间中，除非它是定义一个“外部/导出”实体。
- en: Example; bad
  id: totrans-6387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例；错误
- en: '[PRE833]'
  id: totrans-6388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: Example; good
  id: totrans-6389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例；正确
- en: '[PRE834]'
  id: totrans-6390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: Example
  id: totrans-6391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: An API class and its members can’t live in an unnamed namespace; but any “helper”
    class or function that is defined in an implementation source file should be at
    an unnamed namespace scope.
  id: totrans-6392
  prefs: []
  type: TYPE_NORMAL
  zh: API类及其成员不能存在于一个无名的命名空间中；但任何在实现源文件中定义的“辅助”类或函数应该位于无名的命名空间作用域内。
- en: '[PRE835]'
  id: totrans-6393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: Enforcement
  id: totrans-6394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'SL: The Standard Library'
  id: totrans-6396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'SL: 标准库'
- en: Using only the bare language, every task is tedious (in any language). Using
    a suitable library any task can be reasonably simple.
  id: totrans-6397
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用裸语言，每个任务都是繁琐的（在任何语言中）。使用合适的库，任何任务都可以合理地变得简单。
- en: The standard library has steadily grown over the years. Its description in the
    standard is now larger than that of the language features. So, it is likely that
    this library section of the guidelines will eventually grow in size to equal or
    exceed all the rest.
  id: totrans-6398
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库多年来一直在稳步增长。标准中对它的描述现在比语言特性还要长。因此，这个指南的库部分最终可能会在大小上等于或超过其他所有部分。
- en: « ??? We need another level of rule numbering ??? »
  id: totrans-6399
  prefs: []
  type: TYPE_NORMAL
  zh: « ??? 我们需要另一级规则编号 ??? »
- en: 'C++ Standard Library component summary:'
  id: totrans-6400
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库组件摘要：
- en: '[SL.con: Containers](#ss-con)'
  id: totrans-6401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.con: 容器](#ss-con)'
- en: '[SL.str: String](#ss-string)'
  id: totrans-6402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str: 字符串](#ss-string)'
- en: '[SL.io: Iostream](#ss-io)'
  id: totrans-6403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.io: I/O流](#ss-io)'
- en: '[SL.regex: Regex](#ss-regex)'
  id: totrans-6404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.regex: 正则表达式](#ss-regex)'
- en: '[SL.chrono: Time](#ss-chrono)'
  id: totrans-6405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.chrono: 时间](#ss-chrono)'
- en: '[SL.C: The C Standard Library](#ss-clib)'
  id: totrans-6406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.C: C 标准库](#ss-clib)'
- en: 'Standard-library rule summary:'
  id: totrans-6407
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库规则摘要：
- en: '[SL.1: Use libraries wherever possible](#rsl-lib)'
  id: totrans-6408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.1: 在可能的情况下使用库](#rsl-lib)'
- en: '[SL.2: Prefer the standard library to other libraries](#rsl-sl)'
  id: totrans-6409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.2: 优先使用标准库而不是其他库](#rsl-sl)'
- en: '[SL.3: Do not add non-standard entities to namespace `std`](#sl-std)'
  id: totrans-6410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.3: 不要向命名空间 `std` 添加非标准实体](#sl-std)'
- en: '[SL.4: Use the standard library in a type-safe manner](#sl-safe)'
  id: totrans-6411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.4: 以类型安全的方式使用标准库](#sl-safe)'
- en: ???
  id: totrans-6412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.1: Use libraries wherever possible'
  id: totrans-6413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.1: 在可能的情况下使用库'
- en: Reason
  id: totrans-6414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Save time. Don’t re-invent the wheel. Don’t replicate the work of others. Benefit
    from other people’s work when they make improvements. Help other people when you
    make improvements.
  id: totrans-6415
  prefs: []
  type: TYPE_NORMAL
  zh: 节省时间。不要重新发明轮子。不要复制他人的工作。当他人进行改进时，从他人的工作中受益。当你进行改进时，帮助他人。
- en: 'SL.2: Prefer the standard library to other libraries'
  id: totrans-6416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.2: 优先使用标准库而不是其他库'
- en: Reason
  id: totrans-6417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: More people know the standard library. It is more likely to be stable, well-maintained,
    and widely available than your own code or most other libraries.
  id: totrans-6418
  prefs: []
  type: TYPE_NORMAL
  zh: 更多人了解标准库。它比你的代码或大多数其他库更有可能稳定、维护良好且广泛可用。
- en: 'SL.3: Do not add non-standard entities to namespace `std`'
  id: totrans-6419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.3: 不要向命名空间 `std` 添加非标准实体'
- en: Reason
  id: totrans-6420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Adding to `std` might change the meaning of otherwise standards conforming code.
    Additions to `std` might clash with future versions of the standard.
  id: totrans-6421
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `std` 添加内容可能会改变其他符合标准代码的含义。对 `std` 的添加可能与标准未来的版本冲突。
- en: Example
  id: totrans-6422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE836]'
  id: totrans-6423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: Enforcement
  id: totrans-6424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Possible, but messy and likely to cause problems with platforms.
  id: totrans-6425
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，但很混乱，并且可能在不同平台上引起问题。
- en: 'SL.4: Use the standard library in a type-safe manner'
  id: totrans-6426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.4: 以类型安全的方式使用标准库'
- en: Reason
  id: totrans-6427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Because, obviously, breaking this rule can lead to undefined behavior, memory
    corruption, and all kinds of other bad errors.
  id: totrans-6428
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，显然，违反这条规则可能导致未定义的行为、内存损坏以及其他各种错误。
- en: Note
  id: totrans-6429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is a semi-philosophical meta-rule, which needs many supporting concrete
    rules. We need it as an umbrella for the more specific rules.
  id: totrans-6430
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个半哲学性的元规则，需要许多支持的具体规则。我们需要它作为更具体规则的总括。
- en: 'Summary of more specific rules:'
  id: totrans-6431
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体规则摘要：
- en: '[SL.4: Use the standard library in a type-safe manner](#sl-safe)'
  id: totrans-6432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.4: 以类型安全的方式使用标准库](#sl-safe)'
- en: 'SL.con: Containers'
  id: totrans-6433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'SL.con: 容器'
- en: ???
  id: totrans-6434
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Container rule summary:'
  id: totrans-6435
  prefs: []
  type: TYPE_NORMAL
  zh: 容器规则摘要：
- en: '[SL.con.1: Prefer using STL `array` or `vector` instead of a C array](#rsl-arrays)'
  id: totrans-6436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.con.1: 优先使用 STL `array` 或 `vector` 而不是 C 数组](#rsl-arrays)'
- en: '[SL.con.2: Prefer using STL `vector` by default unless you have a reason to
    use a different container](#rsl-vector)'
  id: totrans-6437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.con.2: 除非有理由使用不同的容器，否则请默认使用 STL `vector`](#rsl-vector)'
- en: '[SL.con.3: Avoid bounds errors](#rsl-bounds)'
  id: totrans-6438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.con.3: 避免越界错误](#rsl-bounds)'
- en: '[SL.con.4: don’t use `memset` or `memcpy` for arguments that are not trivially-copyable](#rsl-copy)'
  id: totrans-6439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.con.4: 不要对非平凡可复制的参数使用 `memset` 或 `memcpy`](#rsl-copy)'
- en: 'SL.con.1: Prefer using STL `array` or `vector` instead of a C array'
  id: totrans-6440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.con.1: 优先使用 STL `array` 或 `vector` 而不是 C 数组'
- en: Reason
  id: totrans-6441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: C arrays are less safe, and have no advantages over `array` and `vector`. For
    a fixed-length array, use `std::array`, which does not degenerate to a pointer
    when passed to a function and does know its size. Also, like a built-in array,
    a stack-allocated `std::array` keeps its elements on the stack. For a variable-length
    array, use `std::vector`, which additionally can change its size and handles memory
    allocation.
  id: totrans-6442
  prefs: []
  type: TYPE_NORMAL
  zh: C 数组的安全性较低，并且与 `array` 和 `vector` 没有优势。对于固定长度的数组，请使用 `std::array`，它不会在传递给函数时退化成指针，并且知道它的大小。此外，就像内置数组一样，栈分配的
    `std::array` 将其元素保持在栈上。对于可变长度的数组，请使用 `std::vector`，它还可以更改其大小并处理内存分配。
- en: Example
  id: totrans-6443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE837]'
  id: totrans-6444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: Example
  id: totrans-6445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE838]'
  id: totrans-6446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: Note
  id: totrans-6447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Use `gsl::span` for non-owning references into a container.
  id: totrans-6448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gsl::span` 对容器中的非拥有引用。
- en: Note
  id: totrans-6449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Comparing the performance of a fixed-sized array allocated on the stack against
    a `vector` with its elements on the free store is bogus. You could just as well
    compare a `std::array` on the stack against the result of a `malloc()` accessed
    through a pointer. For most code, even the difference between stack allocation
    and free-store allocation doesn’t matter, but the convenience and safety of `vector`
    does. People working with code for which that difference matters are quite capable
    of choosing between `array` and `vector`.
  id: totrans-6450
  prefs: []
  type: TYPE_NORMAL
  zh: 将在栈上分配的固定大小数组与在自由存储上的 `vector` 元素性能进行比较是没有意义的。你同样可以将栈上的 `std::array` 与通过指针访问的
    `malloc()` 结果进行比较。对于大多数代码，即使是栈分配和堆分配之间的差异也不重要，但 `vector` 的便利性和安全性很重要。对于这种差异很重要的代码，人们完全能够选择在
    `array` 和 `vector` 之间进行选择。
- en: Enforcement
  id: totrans-6451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag declaration of a C array inside a function or class that also declares
    an STL container (to avoid excessive noisy warnings on legacy non-STL code). To
    fix: At least change the C array to a `std::array`.'
  id: totrans-6452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数或类中声明 C 数组时，同时声明 STL 容器（以避免在旧的非 STL 代码上产生过多的噪声警告）。修复方法：至少将 C 数组更改为 `std::array`。
- en: 'SL.con.2: Prefer using STL `vector` by default unless you have a reason to
    use a different container'
  id: totrans-6453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SL.con.2：除非你有理由使用不同的容器，否则默认使用 STL `vector`。
- en: Reason
  id: totrans-6454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`vector` and `array` are the only standard containers that offer the following
    advantages:'
  id: totrans-6455
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 和 `array` 是唯一提供以下优势的标准容器：'
- en: the fastest general-purpose access (random access, including being vectorization-friendly);
  id: totrans-6456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最快的通用访问（随机访问，包括向量化友好）；
- en: the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly);
  id: totrans-6457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最快的默认访问模式（从头到尾或从尾到头对预取器友好）；
- en: the lowest space overhead (contiguous layout has zero per-element overhead,
    which is cache-friendly).
  id: totrans-6458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小的空间开销（连续布局具有零每个元素开销，这对缓存友好）。
- en: Usually you need to add and remove elements from the container, so use `vector`
    by default; if you don’t need to modify the container’s size, use `array`.
  id: totrans-6459
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你需要向容器中添加和删除元素，所以默认使用 `vector`；如果你不需要修改容器的大小，请使用 `array`。
- en: Even when other containers seem more suited, such as `map` for O(log N) lookup
    performance or a `list` for efficient insertion in the middle, a `vector` will
    usually still perform better for containers up to a few KB in size.
  id: totrans-6460
  prefs: []
  type: TYPE_NORMAL
  zh: 即使其他容器似乎更适合，例如 `map` 用于 O(log N) 的查找性能或 `list` 用于中间高效插入，对于大小在几个 KB 以内的容器，`vector`
    通常仍然表现更好。
- en: Note
  id: totrans-6461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`string` should not be used as a container of individual characters. A `string`
    is a textual string; if you want a container of characters, use `vector</*char_type*/>`
    or `array</*char_type*/>` instead.'
  id: totrans-6462
  prefs: []
  type: TYPE_NORMAL
  zh: 不应将 `string` 用作单个字符的容器。`string` 是一个文本字符串；如果你需要一个字符容器，请使用 `vector</*char_type*/>`
    或 `array</*char_type*/>`。
- en: Exceptions
  id: totrans-6463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: 'If you have a good reason to use another container, use that instead. For example:'
  id: totrans-6464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有充分的理由使用其他容器，请使用那个容器。例如：
- en: If `vector` suits your needs but you don’t need the container to be variable
    size, use `array` instead.
  id: totrans-6465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `vector` 满足你的需求，但你不需要容器是可变大小的，请使用 `array` 代替。
- en: If you want a dictionary-style lookup container that guarantees O(K) or O(log
    N) lookups, the container will be larger (more than a few KB) and you perform
    frequent inserts so that the overhead of maintaining a sorted `vector` is infeasible,
    go ahead and use an `unordered_map` or `map` instead.
  id: totrans-6466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想使用一个字典风格的查找容器，该容器保证 O(K) 或 O(log N) 的查找，那么容器将会更大（超过几个 KB），并且你频繁地进行插入，以便维护排序
    `vector` 的开销不可行，那么请使用 `unordered_map` 或 `map`。
- en: Note
  id: totrans-6467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To initialize a vector with a number of elements, use `()`-initialization. To
    initialize a vector with a list of elements, use `{}`-initialization.
  id: totrans-6468
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用指定元素数量的向量，请使用`()`初始化。要使用元素列表初始化向量，请使用`{}`初始化。
- en: '[PRE839]'
  id: totrans-6469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: '[Prefer the {}-initializer syntax](#res-list).'
  id: totrans-6470
  prefs: []
  type: TYPE_NORMAL
  zh: '[优先使用 {}-初始化语法](#res-list)。'
- en: Enforcement
  id: totrans-6471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: 'Flag a `vector` whose size never changes after construction (such as because
    it’s `const` or because no non-`const` functions are called on it). To fix: Use
    an `array` instead.'
  id: totrans-6472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记一个在构造后大小从未改变的 `vector`（例如，因为它是一个 `const`，或者因为没有调用非 `const` 函数），修复方法：使用 `array`
    代替。
- en: 'SL.con.3: Avoid bounds errors'
  id: totrans-6473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SL.con.3：避免越界错误
- en: Reason
  id: totrans-6474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Read or write beyond an allocated range of elements typically leads to bad errors,
    wrong results, crashes, and security violations.
  id: totrans-6475
  prefs: []
  type: TYPE_NORMAL
  zh: 读取或写入超出分配的元素范围通常会导致错误、错误的结果、崩溃和安全违规。
- en: Note
  id: totrans-6476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The standard-library functions that apply to ranges of elements all have (or
    could have) bounds-safe overloads that take `span`. Standard types such as `vector`
    can be modified to perform bounds-checks under the bounds profile (in a compatible
    way, such as by adding contracts), or used with `at()`.
  id: totrans-6477
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于元素范围的标准库函数都具有（或可能具有）接受`span`的边界安全重载。标准类型如`vector`可以被修改以在边界配置文件下执行边界检查（以兼容的方式，例如通过添加合同），或者与`at()`一起使用。
- en: 'Ideally, the in-bounds guarantee should be statically enforced. For example:'
  id: totrans-6478
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，边界保证应该通过静态强制执行。例如：
- en: a range-`for` cannot loop beyond the range of the container to which it is applied
  id: totrans-6479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个范围-`for`循环不能超出其应用的容器范围
- en: a `v.begin(),v.end()` is easily determined to be bounds safe
  id: totrans-6480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`v.begin(),v.end()`很容易被确定为边界安全
- en: Such loops are as fast as any unchecked/unsafe equivalent.
  id: totrans-6481
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的循环与任何未检查/不安全的等效循环一样快。
- en: Often a simple pre-check can eliminate the need for checking of individual indices.
    For example
  id: totrans-6482
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，简单的预检查可以消除对单个索引的检查的需要。例如
- en: for `v.begin(),v.begin()+i` the `i` can easily be checked against `v.size()`
  id: totrans-6483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`v.begin(),v.begin()+i`，`i`可以很容易地与`v.size()`进行比较
- en: Such loops can be much faster than individually checked element accesses.
  id: totrans-6484
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的循环可以比逐个检查元素访问快得多。
- en: Example, bad
  id: totrans-6485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE840]'
  id: totrans-6486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: Also, `std::array<>::fill()` or `std::fill()` or even an empty initializer are
    better candidates than `memset()`.
  id: totrans-6487
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`std::array<>::fill()`或`std::fill()`或甚至一个空的初始化器比`memset()`更好
- en: Example, good
  id: totrans-6488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE841]'
  id: totrans-6489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: Example
  id: totrans-6490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: If code is using an unmodified standard library, then there are still workarounds
    that enable use of `std::array` and `std::vector` in a bounds-safe manner. Code
    can call the `.at()` member function on each class, which will result in an `std::out_of_range`
    exception being thrown. Alternatively, code can call the `at()` free function,
    which will result in fail-fast (or a customized action) on a bounds violation.
  id: totrans-6491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码使用未经修改的标准库，那么仍然有工作区可以启用`std::array`和`std::vector`的边界安全使用。代码可以为每个类调用`.at()`成员函数，这将导致抛出`std::out_of_range`异常。或者，代码可以调用`at()`免费函数，这将导致在边界违规时快速失败（或自定义操作）。
- en: '[PRE842]'
  id: totrans-6492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: Enforcement
  id: totrans-6493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Issue a diagnostic for any call to a standard-library function that is not bounds-checked.
    ??? insert link to a list of banned functions
  id: totrans-6494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何未进行边界检查的标准库函数调用，发出诊断。???插入禁止函数列表的链接
- en: This rule is part of the [bounds profile](#ss-bounds).
  id: totrans-6495
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则是[边界配置文件](#ss-bounds)的一部分。
- en: 'SL.con.4: don’t use `memset` or `memcpy` for arguments that are not trivially-copyable'
  id: totrans-6496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SL.con.4：不要对不是简单可复制的参数使用`memset`或`memcpy`
- en: Reason
  id: totrans-6497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Doing so messes the semantics of the objects (e.g., by overwriting a `vptr`).
  id: totrans-6498
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会破坏对象的语义（例如，通过覆盖一个`vptr`）。
- en: Note
  id: totrans-6499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Similarly for (w)memset, (w)memcpy, (w)memmove, and (w)memcmp
  id: totrans-6500
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于(w)memset、(w)memcpy、(w)memmove和(w)memcmp
- en: Example
  id: totrans-6501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE843]'
  id: totrans-6502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: Instead, define proper default initialization, copy, and comparison functions
  id: totrans-6503
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，定义适当的默认初始化、复制和比较函数
- en: '[PRE844]'
  id: totrans-6504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: Enforcement
  id: totrans-6505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag the use of those functions for types that are not trivially copyable
  id: totrans-6506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记那些对于不是简单可复制的类型的使用
- en: '**TODO Notes**:'
  id: totrans-6507
  prefs: []
  type: TYPE_NORMAL
  zh: '**待办事项**：'
- en: Impact on the standard library will require close coordination with WG21, if
    only to ensure compatibility even if never standardized.
  id: totrans-6508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对标准库的影响需要与WG21密切协调，即使从未标准化，也要确保兼容性。
- en: We are considering specifying bounds-safe overloads for stdlib (especially C
    stdlib) functions like `memcmp` and shipping them in the GSL.
  id: totrans-6509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在考虑为stdlib（特别是Cstdlib）函数如`memcmp`指定边界安全重载，并将它们包含在GSL中。
- en: For existing stdlib functions and types like `vector` that are not fully bounds-checked,
    the goal is for these features to be bounds-checked when called from code with
    the bounds profile on, and unchecked when called from legacy code, possibly using
    contracts (concurrently being proposed by several WG21 members).
  id: totrans-6510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于现有的stdlib函数和类型如`vector`，这些函数没有完全进行边界检查，目标是当从具有边界配置文件的代码中调用时进行边界检查，而从旧代码中调用时则不进行检查，可能使用合同（由几个WG21成员共同提出）。
- en: 'SL.str: String'
  id: totrans-6511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SL.str：字符串
- en: Text manipulation is a huge topic. `std::string` doesn’t cover all of it. This
    section primarily tries to clarify `std::string`’s relation to `char*`, `zstring`,
    `string_view`, and `gsl::span<char>`. The important issue of non-ASCII character
    sets and encodings (e.g., `wchar_t`, Unicode, and UTF-8) will be covered elsewhere.
  id: totrans-6512
  prefs: []
  type: TYPE_NORMAL
  zh: 文本操作是一个很大的主题。`std::string`并不涵盖所有内容。本节主要试图阐明`std::string`与`char*`、`zstring`、`string_view`和`gsl::span<char>`的关系。关于非ASCII字符集和编码（例如，`wchar_t`、Unicode和UTF-8）的重要问题将在其他地方讨论。
- en: '**See also**: [regular expressions](#ss-regex)'
  id: totrans-6513
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[正则表达式](#ss-regex)'
- en: Here, we use “sequence of characters” or “string” to refer to a sequence of
    characters meant to be read as text (somehow, eventually). We don’t consider ???
  id: totrans-6514
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用“字符序列”或“字符串”来指代那些打算作为文本读取的字符序列（以某种方式，最终）。我们不考虑???
- en: 'String summary:'
  id: totrans-6515
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串摘要：
- en: '[SL.str.1: Use `std::string` to own character sequences](#rstr-string)'
  id: totrans-6516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.1: 使用`std::string`来拥有字符序列](#rstr-string)'
- en: '[SL.str.2: Use `std::string_view` or `gsl::span<char>` to refer to character
    sequences](#rstr-view)'
  id: totrans-6517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.2: 使用`std::string_view`或`gsl::span<char>`来引用字符序列](#rstr-view)'
- en: '[SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated,
    sequence of characters](#rstr-zstring)'
  id: totrans-6518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.3: 使用`zstring`或`czstring`来引用C风格、以空字符终止的字符序列](#rstr-zstring)'
- en: '[SL.str.4: Use `char*` to refer to a single character](#rstr-charp)'
  id: totrans-6519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.4: 使用`char*`来引用单个字符](#rstr-charp)'
- en: '[SL.str.5: Use `std::byte` to refer to byte values that do not necessarily
    represent characters](#rstr-byte)'
  id: totrans-6520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.5: 使用`std::byte`来引用不一定表示字符的字节值](#rstr-byte)'
- en: '[SL.str.10: Use `std::string` when you need to perform locale-sensitive string
    operations](#rstr-locale)'
  id: totrans-6521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.10: 当需要执行与区域设置相关的字符串操作时使用`std::string`](#rstr-locale)'
- en: '[SL.str.11: Use `gsl::span<char>` rather than `std::string_view` when you need
    to mutate a string](#rstr-span)'
  id: totrans-6522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.11: 当需要修改字符串时，使用`gsl::span<char>`而不是`std::string_view`](#rstr-span)'
- en: '[SL.str.12: Use the `s` suffix for string literals meant to be standard-library
    `string`s](#rstr-s)'
  id: totrans-6523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.str.12: 使用`string`后缀对于打算作为标准库`string`的字符串字面量](#rstr-s)'
- en: '**See also**:'
  id: totrans-6524
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：'
- en: '[F.24 span](#rf-range)'
  id: totrans-6525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.24 span](#rf-range)'
- en: '[F.25 zstring](#rf-zstring)'
  id: totrans-6526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F.25 zstring](#rf-zstring)'
- en: 'SL.str.1: Use `std::string` to own character sequences'
  id: totrans-6527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.1: 使用`std::string`来拥有字符序列'
- en: Reason
  id: totrans-6528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`string` correctly handles allocation, ownership, copying, gradual expansion,
    and offers a variety of useful operations.'
  id: totrans-6529
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`正确处理分配、所有权、复制、逐步扩展，并提供各种有用的操作。'
- en: Example
  id: totrans-6530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE845]'
  id: totrans-6531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: Note how `>>` and `!=` are provided for `string` (as examples of useful operations)
    and there are no explicit allocations, deallocations, or range checks (`string`
    takes care of those).
  id: totrans-6532
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`>>`和`!=`是如何为`string`提供的（作为有用操作的示例），并且没有显式的分配、释放或范围检查（`string`负责这些）。
- en: 'In C++17, we might use `string_view` as the argument, rather than `const string&`
    to allow more flexibility to callers:'
  id: totrans-6533
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，我们可能会使用`string_view`作为参数，而不是`const string&`，以允许调用者有更多的灵活性：
- en: '[PRE846]'
  id: totrans-6534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: Example, bad
  id: totrans-6535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: Don’t use C-style strings for operations that require non-trivial memory management
  id: totrans-6536
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用C风格字符串进行需要非平凡内存管理的操作
- en: '[PRE847]'
  id: totrans-6537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: Did we get that right? Will the caller remember to `free()` the returned pointer?
    Will this code pass a security review?
  id: totrans-6538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做得对吗？调用者会记得`free()`返回的指针吗？这段代码会通过安全审查吗？
- en: Note
  id: totrans-6539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Do not assume that `string` is slower than lower-level techniques without measurement
    and remember that not all code is performance critical. [Don’t optimize prematurely](#rper-knuth)
  id: totrans-6540
  prefs: []
  type: TYPE_NORMAL
  zh: 不要假设`string`比低级技术慢，除非有测量，并且记住并非所有代码都是性能关键。[不要过早优化](#rper-knuth)
- en: Enforcement
  id: totrans-6541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6542
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.str.2: Use `std::string_view` or `gsl::span<char>` to refer to character
    sequences'
  id: totrans-6543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.2: 使用`std::string_view`或`gsl::span<char>`来引用字符序列'
- en: Reason
  id: totrans-6544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`std::string_view` or `gsl::span<char>` provides simple and (potentially) safe
    access to character sequences independently of how those sequences are allocated
    and stored.'
  id: totrans-6545
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string_view`或`gsl::span<char>`提供了对字符序列简单且（潜在）安全的访问，而不管这些序列是如何分配和存储的。'
- en: Example
  id: totrans-6546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE848]'
  id: totrans-6547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: Note
  id: totrans-6548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`std::string_view` (C++17) is read-only.'
  id: totrans-6549
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string_view`（C++17）是只读的。'
- en: Enforcement
  id: totrans-6550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6551
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated,
    sequence of characters'
  id: totrans-6552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.3: 使用`zstring`或`czstring`来引用C风格、以空字符终止的字符序列'
- en: Reason
  id: totrans-6553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Statement of intent. A plain `char*` can be a pointer to a single
    character, a pointer to an array of characters, a pointer to a C-style (zero-terminated)
    string, or even to a small integer. Distinguishing these alternatives prevents
    misunderstandings and bugs.
  id: totrans-6554
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。意图声明。一个普通的`char*`可以是一个指向单个字符的指针，一个指向字符数组的指针，一个指向C风格（以空字符终止）字符串的指针，甚至是一个指向小整数的指针。区分这些选择可以防止误解和错误。
- en: Example
  id: totrans-6555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE849]'
  id: totrans-6556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: All we know is that it is supposed to be the nullptr or point to at least one
    character
  id: totrans-6557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所知道的是，它应该是指向nullptr或至少指向一个字符的指针
- en: '[PRE850]'
  id: totrans-6558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: Note
  id: totrans-6559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t convert a C-style string to `string` unless there is a reason to.
  id: totrans-6560
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有理由，否则不要将C风格字符串转换为`string`。
- en: Note
  id: totrans-6561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Like any other “plain pointer”, a `zstring` should not represent ownership.
  id: totrans-6562
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他“普通指针”一样，`zstring`不应该表示所有权。
- en: Note
  id: totrans-6563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are billions of lines of C++ “out there”, most use `char*` and `const
    char*` without documenting intent. They are used in a wide variety of ways, including
    to represent ownership and as generic pointers to memory (instead of `void*`).
    It is hard to separate these uses, so this guideline is hard to follow. This is
    one of the major sources of bugs in C and C++ programs, so it is worthwhile to
    follow this guideline wherever feasible.
  id: totrans-6564
  prefs: []
  type: TYPE_NORMAL
  zh: 外面的C++代码有数十亿行，大多数使用`char*`和`const char*`而没有记录意图。它们被广泛使用，包括表示所有权和作为内存的通用指针（而不是`void*`）。这些用途难以区分，因此此指南难以遵循。这是C和C++程序中错误的主要来源之一，因此，在可行的情况下遵循此指南是值得的。
- en: Enforcement
  id: totrans-6565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag uses of `[]` on a `char*`
  id: totrans-6566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`char*`上的`[]`用法
- en: Flag uses of `delete` on a `char*`
  id: totrans-6567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`char*`上的`delete`用法
- en: Flag uses of `free()` on a `char*`
  id: totrans-6568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`char*`上的`free()`用法
- en: 'SL.str.4: Use `char*` to refer to a single character'
  id: totrans-6569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.4: 使用`char*`来引用单个字符'
- en: Reason
  id: totrans-6570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The variety of uses of `char*` in current code is a major source of errors.
  id: totrans-6571
  prefs: []
  type: TYPE_NORMAL
  zh: 当前代码中`char*`的用法种类繁多，是错误的主要来源。
- en: Example, bad
  id: totrans-6572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，错误
- en: '[PRE851]'
  id: totrans-6573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: The array `arr` is not a C-style string because it is not zero-terminated.
  id: totrans-6574
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`arr`不是C风格字符串，因为它不是以空字符终止的。
- en: Alternative
  id: totrans-6575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: See [`zstring`](#rstr-zstring), [`string`](#rstr-string), and [`string_view`](#rstr-view).
  id: totrans-6576
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`zstring`](#rstr-zstring)，[`string`](#rstr-string)，和[`string_view`](#rstr-view)。
- en: Enforcement
  id: totrans-6577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag uses of `[]` on a `char*`
  id: totrans-6578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记`char*`上的`[]`用法
- en: 'SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent
    characters'
  id: totrans-6579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.5: 使用`std::byte`来引用不一定表示字符的字节值'
- en: Reason
  id: totrans-6580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Use of `char*` to represent a pointer to something that is not necessarily a
    character causes confusion and disables valuable optimizations.
  id: totrans-6581
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`char*`来表示指向非字符的指针会导致混淆并禁用有价值的优化。
- en: Example
  id: totrans-6582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE852]'
  id: totrans-6583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: Note
  id: totrans-6584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: C++17
  id: totrans-6585
  prefs: []
  type: TYPE_NORMAL
  zh: C++17
- en: Enforcement
  id: totrans-6586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6587
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.str.10: Use `std::string` when you need to perform locale-sensitive string
    operations'
  id: totrans-6588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.10: 当需要执行区域敏感的字符串操作时使用`std::string`'
- en: Reason
  id: totrans-6589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`std::string` supports standard-library [`locale` facilities](#rstr-locale)'
  id: totrans-6590
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`支持标准库的[`locale`功能](#rstr-locale)'
- en: Example
  id: totrans-6591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE853]'
  id: totrans-6592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: Note
  id: totrans-6593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: ???
  id: totrans-6594
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Enforcement
  id: totrans-6595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6596
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.str.11: Use `gsl::span<char>` rather than `std::string_view` when you need
    to mutate a string'
  id: totrans-6597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.11: 当需要修改字符串时，使用`gsl::span<char>`而不是`std::string_view`'
- en: Reason
  id: totrans-6598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`std::string_view` is read-only.'
  id: totrans-6599
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string_view`是只读的。'
- en: Example
  id: totrans-6600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: ???
  id: totrans-6601
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Note
  id: totrans-6602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: ???
  id: totrans-6603
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Enforcement
  id: totrans-6604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: The compiler will flag attempts to write to a `string_view`.
  id: totrans-6605
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会标记尝试写入`string_view`的尝试。
- en: 'SL.str.12: Use the `s` suffix for string literals meant to be standard-library
    `string`s'
  id: totrans-6606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.str.12: 对于打算用作标准库`string`的字符串字面量，使用`s`后缀'
- en: Reason
  id: totrans-6607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Direct expression of an idea minimizes mistakes.
  id: totrans-6608
  prefs: []
  type: TYPE_NORMAL
  zh: 直接表达一个想法可以最小化错误。
- en: Example
  id: totrans-6609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE854]'
  id: totrans-6610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: Enforcement
  id: totrans-6611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6612
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.io: Iostream'
  id: totrans-6613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'SL.io: Iostream'
- en: '`iostream`s is a type safe, extensible, formatted and unformatted I/O library
    for streaming I/O. It supports multiple (and user extensible) buffering strategies
    and multiple locales. It can be used for conventional I/O, reading and writing
    to memory (string streams), and user-defined extensions, such as streaming across
    networks (asio: not yet standardized).'
  id: totrans-6614
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostream`s是一个类型安全、可扩展、格式化和非格式化的流I/O库。它支持多种（和用户可扩展）缓冲策略和多种区域设置。它可以用于传统的I/O、读取和写入内存（字符串流），以及用户定义的扩展，如通过网络流（asio：尚未标准化）。'
- en: 'Iostream rule summary:'
  id: totrans-6615
  prefs: []
  type: TYPE_NORMAL
  zh: Iostream规则摘要：
- en: '[SL.io.1: Use character-level input only when you have to](#rio-low)'
  id: totrans-6616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.io.1: 只有在必要时才使用字符级输入](#rio-low)'
- en: '[SL.io.2: When reading, always consider ill-formed input](#rio-validate)'
  id: totrans-6617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.io.2: 读取时，始终考虑无效输入](#rio-validate)'
- en: '[SL.io.3: Prefer iostreams for I/O](#rio-streams)'
  id: totrans-6618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.io.3: 优先使用iostreams进行I/O](#rio-streams)'
- en: '[SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`](#rio-sync)'
  id: totrans-6619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.io.10: 除非你使用`printf`族函数，否则调用`ios_base::sync_with_stdio(false)`](#rio-sync)'
- en: '[SL.io.50: Avoid `endl`](#rio-endl)'
  id: totrans-6620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.io.50: 避免使用`endl`](#rio-endl)'
- en: '[???](#???)'
  id: totrans-6621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: 'SL.io.1: Use character-level input only when you have to'
  id: totrans-6622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.io.1: 只有在必要时才使用字符级输入'
- en: Reason
  id: totrans-6623
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Unless you genuinely just deal with individual characters, using character-level
    input leads to the user code performing potentially error-prone and potentially
    inefficient composition of tokens out of characters.
  id: totrans-6624
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你确实只处理单个字符，否则使用字符级输入会导致用户代码执行可能存在错误和可能低效的字符到标记的组合。
- en: Example
  id: totrans-6625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE855]'
  id: totrans-6626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: 'Better (much simpler and probably faster):'
  id: totrans-6627
  prefs: []
  type: TYPE_NORMAL
  zh: 更好（更简单，可能更快）：
- en: '[PRE856]'
  id: totrans-6628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: and the `reserve(128)` is probably not worthwhile.
  id: totrans-6629
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`reserve(128)`可能不值得。
- en: Enforcement
  id: totrans-6630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6631
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.io.2: When reading, always consider ill-formed input'
  id: totrans-6632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.io.2: 在读取时，始终考虑不规范的输入'
- en: Reason
  id: totrans-6633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Errors are typically best handled as soon as possible. If input isn’t validated,
    every function must be written to cope with bad data (and that is not practical).
  id: totrans-6634
  prefs: []
  type: TYPE_NORMAL
  zh: 错误通常最好尽快处理。如果输入没有验证，每个函数都必须编写来处理不良数据（这并不实用）。
- en: Example
  id: totrans-6635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE857]'
  id: totrans-6636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: Enforcement
  id: totrans-6637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6638
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.io.3: Prefer `iostream`s for I/O'
  id: totrans-6639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.io.3: 倾向于使用`iostream`进行I/O'
- en: Reason
  id: totrans-6640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`iostream`s are safe, flexible, and extensible.'
  id: totrans-6641
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostream`是安全的、灵活的且可扩展的。'
- en: Example
  id: totrans-6642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE858]'
  id: totrans-6643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: '`complex` is a user-defined type and its I/O is defined without modifying the
    `iostream` library.'
  id: totrans-6644
  prefs: []
  type: TYPE_NORMAL
  zh: '`complex`是一个用户定义的类型，其I/O是在不修改`iostream`库的情况下定义的。'
- en: Example
  id: totrans-6645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE859]'
  id: totrans-6646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: Exception
  id: totrans-6647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: ??? performance ???
  id: totrans-6648
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 性能 ???
- en: 'Discussion: `iostream`s vs. the `printf()` family'
  id: totrans-6649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论：`iostream`s与`printf()`家族
- en: 'It is often (and often correctly) pointed out that the `printf()` family has
    two advantages compared to `iostream`s: flexibility of formatting and performance.
    This has to be weighed against `iostream`s advantages of extensibility to handle
    user-defined types, resilience against security violations, implicit memory management,
    and `locale` handling.'
  id: totrans-6650
  prefs: []
  type: TYPE_NORMAL
  zh: 经常（并且通常正确）指出，与`iostream`s相比，`printf()`家族有两个优势：格式化的灵活性和性能。这必须与`iostream`s的优势相权衡，即扩展性以处理用户定义的类型、对安全违规的弹性、隐式内存管理和`locale`处理。
- en: If you need I/O performance, you can almost always do better than `printf()`.
  id: totrans-6651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要I/O性能，您几乎总是可以比`printf()`做得更好。
- en: '`gets()`, `scanf()` using `%s`, and `printf()` using `%s` are security hazards
    (vulnerable to buffer overflow and generally error-prone). C11 defines some “optional
    extensions” that do extra checking of their arguments. If present in your C library,
    `gets_s()`, `scanf_s()`, and `printf_s()` might be safer alternatives, but they
    are still not type safe.'
  id: totrans-6652
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gets()`、`scanf()`的`%s`和`printf()`的`%s`是安全风险（易受缓冲区溢出且通常容易出错）。C11定义了一些“可选扩展”，它们会对它们的参数进行额外的检查。如果您的C库中存在，`gets_s()`、`scanf_s()`和`printf_s()`可能更安全，但它们仍然不是类型安全的。
- en: Enforcement
  id: totrans-6653
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Optionally flag `<cstdio>` and `<stdio.h>`.
  id: totrans-6654
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地标记`<cstdio>`和`<stdio.h>`。
- en: 'SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`'
  id: totrans-6655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.io.10: 除非你使用`printf`-家族函数调用`ios_base::sync_with_stdio(false)`'
- en: Reason
  id: totrans-6656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Synchronizing `iostreams` with `printf-style` I/O can be costly. `cin` and `cout`
    are by default synchronized with `printf`.
  id: totrans-6657
  prefs: []
  type: TYPE_NORMAL
  zh: 将`iostream`与`printf-style` I/O同步可能会很昂贵。`cin`和`cout`默认与`printf`同步。
- en: Example
  id: totrans-6658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE860]'
  id: totrans-6659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: Enforcement
  id: totrans-6660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-6661
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'SL.io.50: Avoid `endl`'
  id: totrans-6662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.io.50: 避免使用`endl`'
- en: Reason
  id: totrans-6663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The `endl` manipulator is mostly equivalent to `'\n'` and `"\n"`; as most commonly
    used it simply slows down output by doing redundant `flush()`s. This slowdown
    can be significant compared to `printf`-style output.
  id: totrans-6664
  prefs: []
  type: TYPE_NORMAL
  zh: '`endl`操作符主要等同于`''\n''`和`"\n"`；最常用的方式是简单地通过执行多余的`flush()`操作来减慢输出速度。与`printf`风格的输出相比，这种减速可能是显著的。'
- en: Example
  id: totrans-6665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE861]'
  id: totrans-6666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: Note
  id: totrans-6667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For `cin`/`cout` (and equivalent) interaction, there is no reason to flush;
    that’s done automatically. For writing to a file, there is rarely a need to `flush`.
  id: totrans-6668
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`cin`/`cout`（及其等效）交互，没有必要刷新；这是自动完成的。对于写入文件，很少需要刷新。
- en: Note
  id: totrans-6669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For string streams (specifically `ostringstream`), the insertion of an `endl`
    is entirely equivalent to the insertion of a `'\n'` character, but also in this
    case, `endl` might be significantly slower.
  id: totrans-6670
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串流（特别是`ostringstream`），插入`endl`与插入一个`'\n'`字符完全等价，但在这个情况下，`endl`可能要慢得多。
- en: '`endl` does *not* take care of producing a platform specific end-of-line sequence
    (like `"\r\n"` on Windows). So for a string stream, `s << endl` just inserts a
    *single* character, `''\n''`.'
  id: totrans-6671
  prefs: []
  type: TYPE_NORMAL
  zh: '`endl`并不负责生成特定平台的行结束序列（如Windows上的`"\r\n"`）。因此，对于字符串流，`s << endl`只是插入一个*单个*字符，`''\n''`。'
- en: Note
  id: totrans-6672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Apart from the (occasionally important) issue of performance, the choice between
    `'\n'` and `endl` is almost completely aesthetic.
  id: totrans-6673
  prefs: []
  type: TYPE_NORMAL
  zh: 除了（偶尔重要的）性能问题之外，`'\n'`和`endl`之间的选择几乎完全是美学上的。
- en: 'SL.regex: Regex'
  id: totrans-6674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'SL.regex: 正则表达式'
- en: '`<regex>` is the standard C++ regular expression library. It supports a variety
    of regular expression pattern conventions.'
  id: totrans-6675
  prefs: []
  type: TYPE_NORMAL
  zh: '`<regex>`是标准的C++正则表达式库。它支持各种正则表达式模式约定。'
- en: 'SL.chrono: Time'
  id: totrans-6676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'SL.chrono: 时间'
- en: '`<chrono>` (defined in namespace `std::chrono`) provides the notions of `time_point`
    and `duration` together with functions for outputting time in various units. It
    provides clocks for registering `time_points`.'
  id: totrans-6677
  prefs: []
  type: TYPE_NORMAL
  zh: '`<chrono>`（在`std::chrono`命名空间中定义）提供了`time_point`和`duration`的概念，以及用于以各种单位输出时间的函数。它提供了注册`time_points`的时钟。'
- en: 'SL.C: The C Standard Library'
  id: totrans-6678
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'SL.C: C标准库'
- en: ???
  id: totrans-6679
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'C Standard Library rule summary:'
  id: totrans-6680
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库规则摘要：
- en: '[SL.C.1: Don’t use setjmp/longjmp](#rclib-jmp)'
  id: totrans-6681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SL.C.1: 不要使用setjmp/longjmp](#rclib-jmp)'
- en: '[???](#???)'
  id: totrans-6682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: '[???](#???)'
  id: totrans-6683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: 'SL.C.1: Don’t use setjmp/longjmp'
  id: totrans-6684
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'SL.C.1: 不要坚持在函数顶部声明所有内容'
- en: Reason
  id: totrans-6685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: a `longjmp` ignores destructors, thus invalidating all resource-management strategies
    relying on RAII
  id: totrans-6686
  prefs: []
  type: TYPE_NORMAL
  zh: '`longjmp`忽略了析构函数，从而使得所有依赖RAII的资源管理策略无效。'
- en: Enforcement
  id: totrans-6687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag all occurrences of `longjmp`and `setjmp`
  id: totrans-6688
  prefs: []
  type: TYPE_NORMAL
  zh: 标记所有`longjmp`和`setjmp`的出现
- en: 'A: Architectural ideas'
  id: totrans-6689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'A: 架构思想'
- en: This section contains ideas about higher-level architectural ideas and libraries.
  id: totrans-6690
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含关于高级架构思想和库的想法。
- en: 'Architectural rule summary:'
  id: totrans-6691
  prefs: []
  type: TYPE_NORMAL
  zh: 架构规则摘要：
- en: '[A.1: Separate stable code from less stable code](#ra-stable)'
  id: totrans-6692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A.1: 将稳定代码和不稳定代码分开](#ra-stable)'
- en: '[A.2: Express potentially reusable parts as a library](#ra-lib)'
  id: totrans-6693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A.2: 将可重用部分表达为库](#ra-lib)'
- en: '[A.4: There should be no cycles among libraries](#ra-dag)'
  id: totrans-6694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A.4: 库之间不应存在循环](#ra-dag)'
- en: '[???](#???)'
  id: totrans-6695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: '[???](#???)'
  id: totrans-6696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: '[???](#???)'
  id: totrans-6697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: '[???](#???)'
  id: totrans-6698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: '[???](#???)'
  id: totrans-6699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: '[???](#???)'
  id: totrans-6700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[???](#???)'
- en: 'A.1: Separate stable code from less stable code'
  id: totrans-6701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'A.1: 将稳定代码和不稳定代码分开'
- en: Isolating less stable code facilitates its unit testing, interface improvement,
    refactoring, and eventual deprecation.
  id: totrans-6702
  prefs: []
  type: TYPE_NORMAL
  zh: 将不稳定代码隔离有助于其单元测试、接口改进、重构和最终弃用。
- en: 'A.2: Express potentially reusable parts as a library'
  id: totrans-6703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'A.2: 将可重用部分表达为库'
- en: Reason
  id: totrans-6704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Note
  id: totrans-6705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A library is a collection of declarations and definitions maintained, documented,
    and shipped together. A library could be a set of headers (a “header-only library”)
    or a set of headers plus a set of object files. You can statically or dynamically
    link a library into a program, or you can `#include` a header-only library.
  id: totrans-6706
  prefs: []
  type: TYPE_NORMAL
  zh: 库是一组维护、文档化和一起分发的声明和定义。库可以是一组头文件（“仅头文件库”）或一组头文件和一组目标文件。您可以将库静态或动态链接到程序中，或者您可以将仅头文件库`#include`。
- en: 'A.4: There should be no cycles among libraries'
  id: totrans-6707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'A.4: 库之间不应存在循环'
- en: Reason
  id: totrans-6708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A cycle complicates the build process.
  id: totrans-6709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环会复杂化构建过程。
- en: Cycles are hard to understand and might introduce indeterminism (unspecified
    behavior).
  id: totrans-6710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环难以理解，可能会引入不确定性（未指定行为）。
- en: Note
  id: totrans-6711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'A library can contain cyclic references in the definition of its components.
    For example:'
  id: totrans-6712
  prefs: []
  type: TYPE_NORMAL
  zh: 一个库可以在其组件的定义中包含循环引用。例如：
- en: '[PRE862]'
  id: totrans-6713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: However, a library should not depend on another that depends on it.
  id: totrans-6714
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，库不应依赖于另一个依赖于它的库。
- en: 'NR: Non-Rules and myths'
  id: totrans-6715
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'NR: 非规则和神话'
- en: This section contains rules and guidelines that are popular somewhere, but that
    we deliberately don’t recommend. We know perfectly well that there have been times
    and places where these rules made sense, and we have used them ourselves at times.
    However, in the context of the styles of programming we recommend and support
    with the guidelines, these “non-rules” would do harm.
  id: totrans-6716
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含在某些地方流行的规则和指南，但我们故意不推荐。我们非常清楚，在某些时间和地点，这些规则是有意义的，我们有时也使用过它们。然而，在推荐和支持的编程风格以及指南的背景下，这些“非规则”可能会造成损害。
- en: Even today, there can be contexts where the rules make sense. For example, lack
    of suitable tool support can make exceptions unsuitable in hard-real-time systems,
    but please don’t naïvely trust “common wisdom” (e.g., unsupported statements about
    “efficiency”); such “wisdom” might be based on decades-old information or experiences
    from languages with very different properties than C++ (e.g., C or Java).
  id: totrans-6717
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在今天，也有可能存在使规则有意义的上下文。例如，缺乏合适的工具支持可能会使异常在硬实时系统中不适用，但请不要天真地相信“常识”（例如，关于“效率”的未经证实的陈述）；这种“常识”可能基于几十年前的信息或来自与C++具有非常不同特性的语言（例如，C或Java）的经验。
- en: The positive arguments for alternatives to these non-rules are listed in the
    rules offered as “Alternatives”.
  id: totrans-6718
  prefs: []
  type: TYPE_NORMAL
  zh: 列出这些非规则的替代方案的积极论点在提供的“替代方案”规则中。
- en: 'Non-rule summary:'
  id: totrans-6719
  prefs: []
  type: TYPE_NORMAL
  zh: 非规则摘要：
- en: '[NR.1: Don’t insist that all declarations should be at the top of a function](#rnr-top)'
  id: totrans-6720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR.1: 不要坚持在函数顶部声明所有内容](#rnr-top)'
- en: '[NR.2: Don’t insist on having only a single `return`-statement in a function](#rnr-single-return)'
  id: totrans-6721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR.2: 不要坚持在函数中只有一个`return`语句](#rnr-single-return)'
- en: '[NR.3: Don’t avoid exceptions](#rnr-no-exceptions)'
  id: totrans-6722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR.3: 不要避免异常](#rnr-no-exceptions)'
- en: '[NR.4: Don’t insist on placing each class definition in its own source file](#rnr-lots-of-files)'
  id: totrans-6723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR.4: 不要坚持将每个类定义放在自己的源文件中](#rnr-lots-of-files)'
- en: '[NR.5: Don’t use two-phase initialization](#rnr-two-phase-init)'
  id: totrans-6724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR.5: 不要使用两阶段初始化](#rnr-two-phase-init)'
- en: '[NR.6: Don’t place all cleanup actions at the end of a function and `goto exit`](#rnr-goto-exit)'
  id: totrans-6725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR.6：不要在函数末尾和`goto exit`处放置所有清理操作](#rnr-goto-exit)'
- en: '[NR.7: Don’t make data members `protected`](#rnr-protected-data)'
  id: totrans-6726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NR.7：不要使数据成员为`protected`](#rnr-protected-data)'
- en: ???
  id: totrans-6727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'NR.1: Don’t insist that all declarations should be at the top of a function'
  id: totrans-6728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NR.1：不要坚持要求所有声明都在函数顶部
- en: Reason
  id: totrans-6729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The “all declarations on top” rule is a legacy of old programming languages
    that didn’t allow initialization of variables and constants after a statement.
    This leads to longer programs and more errors caused by uninitialized and wrongly
    initialized variables.
  id: totrans-6730
  prefs: []
  type: TYPE_NORMAL
  zh: “所有声明都在顶部”的规则是旧编程语言的遗留问题，这些语言不允许在语句之后初始化变量和常量。这导致程序更长，并且由于未初始化和错误初始化的变量而引起的错误更多。
- en: Example, bad
  id: totrans-6731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE863]'
  id: totrans-6732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: The larger the distance between the uninitialized variable and its use, the
    larger the chance of a bug. Fortunately, compilers catch many “used before set”
    errors. Unfortunately, compilers cannot catch all such errors and unfortunately,
    the bugs aren’t always as simple to spot as in this small example.
  id: totrans-6733
  prefs: []
  type: TYPE_NORMAL
  zh: 变量与其使用之间的距离越大，出现错误的概率就越大。幸运的是，编译器可以捕获许多“使用前未设置”的错误。不幸的是，编译器无法捕获所有此类错误，而且不幸的是，错误并不总是像这个小例子中那样简单易见。
- en: Alternative
  id: totrans-6734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: '[Always initialize an object](#res-always)'
  id: totrans-6735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[始终初始化对象](#res-always)'
- en: '[ES.21: Don’t introduce a variable (or constant) before you need to use it](#res-introduce)'
  id: totrans-6736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ES.21：在你需要使用变量（或常量）之前不要引入它](#res-introduce)'
- en: 'NR.2: Don’t insist on having only a single `return`-statement in a function'
  id: totrans-6737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NR.2：不要坚持在函数中只有一个`return`语句
- en: Reason
  id: totrans-6738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The single-return rule can lead to unnecessarily convoluted code and the introduction
    of extra state variables. In particular, the single-return rule makes it harder
    to concentrate error checking at the top of a function.
  id: totrans-6739
  prefs: []
  type: TYPE_NORMAL
  zh: 单返回规则可能导致代码过于复杂，并引入额外的状态变量。特别是，单返回规则使得在函数顶部集中进行错误检查变得更加困难。
- en: Example
  id: totrans-6740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE864]'
  id: totrans-6741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: to use a single return only we would have to do something like
  id: totrans-6742
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用单个返回，我们可能需要做些像这样的事情
- en: '[PRE865]'
  id: totrans-6743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: This is both longer and likely to be less efficient. The larger and more complicated
    the function is, the more painful the workarounds get. Of course many simple functions
    will naturally have just one `return` because of their simpler inherent logic.
  id: totrans-6744
  prefs: []
  type: TYPE_NORMAL
  zh: 这既长又可能效率更低。函数越大、越复杂，解决方案就越痛苦。当然，许多简单的函数由于它们固有的逻辑简单，自然会只有一个`return`。
- en: Example
  id: totrans-6745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE866]'
  id: totrans-6746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: If we applied the rule, we’d get something like
  id: totrans-6747
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用这个规则，我们可能会得到类似以下的内容
- en: '[PRE867]'
  id: totrans-6748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: Note that we (deliberately) violated the rule against uninitialized variables
    because this style commonly leads to that. Also, this style is a temptation to
    use the [goto exit](#rnr-goto-exit) non-rule.
  id: totrans-6749
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们（故意）违反了未初始化变量的规则，因为这种风格通常会导致这种情况。此外，这种风格是使用[goto exit](#rnr-goto-exit)非规则的诱惑。
- en: Alternative
  id: totrans-6750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Keep functions short and simple
  id: totrans-6751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持函数简短和简单
- en: Feel free to use multiple `return` statements (and to throw exceptions).
  id: totrans-6752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随意使用多个`return`语句（以及抛出异常）。
- en: 'NR.3: Don’t avoid exceptions'
  id: totrans-6753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NR.3：不要避免异常
- en: Reason
  id: totrans-6754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: 'There seem to be four main reasons given for not using exceptions:'
  id: totrans-6755
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用异常，似乎有四个主要原因：
- en: exceptions are inefficient
  id: totrans-6756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常效率低下
- en: exceptions lead to leaks and errors
  id: totrans-6757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常导致泄漏和错误
- en: exception performance is not predictable
  id: totrans-6758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常性能不可预测
- en: the exception-handling run-time support takes up too much space
  id: totrans-6759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理运行时支持占用空间过多
- en: There is no way we can settle this issue to the satisfaction of everybody. After
    all, the discussions about exceptions have been going on for 40+ years. Some languages
    cannot be used without exceptions, but others do not support them. This leads
    to strong traditions for the use and non-use of exceptions, and to heated debates.
  id: totrans-6760
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法满足所有人的满意来解决这个问题。毕竟，关于异常的讨论已经进行了40多年。有些语言没有异常就无法使用，而有些语言则不支持它们。这导致了关于异常使用和非使用的强烈传统，以及激烈的辩论。
- en: However, we can briefly outline why we consider exceptions the best alternative
    for general-purpose programming and in the context of these guidelines. Simple
    arguments for and against are often inconclusive. There are specialized applications
    where exceptions indeed can be inappropriate (e.g., hard-real-time systems without
    support for reliable estimates of the cost of handling an exception).
  id: totrans-6761
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以简要概述为什么我们认为异常是通用编程和这些指南的最佳替代方案。赞成和反对的简单论点往往没有结论。确实有一些专门的应用程序，异常可能是不适当的（例如，没有支持可靠估计异常处理成本的硬实时系统）。
- en: Consider the major objections to exceptions in turn
  id: totrans-6762
  prefs: []
  type: TYPE_NORMAL
  zh: 依次考虑对异常的主要反对意见
- en: 'Exceptions are inefficient: Compared to what? When comparing make sure that
    the same set of errors are handled and that they are handled equivalently. In
    particular, do not compare a program that immediately terminates on seeing an
    error to a program that carefully cleans up resources before logging an error.
    Yes, some systems have poor exception handling implementations; sometimes, such
    implementations force us to use other error-handling approaches, but that’s not
    a fundamental problem with exceptions. When using an efficiency argument - in
    any context - be careful that you have good data that actually provides insight
    into the problem under discussion.'
  id: totrans-6763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常效率低下：与什么相比？在比较时，请确保处理的是相同的一组错误，并且它们以相同的方式处理。特别是，不要将立即在看到错误时终止的程序与在记录错误之前仔细清理资源的程序进行比较。是的，一些系统有糟糕的异常处理实现；有时，这样的实现迫使我们使用其他错误处理方法，但这不是异常的根本问题。在使用效率论据时——在任何上下文中——请确保你有好的数据，实际上能提供对讨论中的问题的洞察。
- en: Exceptions lead to leaks and errors. They do not. If your program is a rat’s
    nest of pointers without an overall strategy for resource management, you have
    a problem whatever you do. If your system consists of a million lines of such
    code, you probably will not be able to use exceptions, but that’s a problem with
    excessive and undisciplined pointer use, rather than with exceptions. In our opinion,
    you need RAII to make exception-based error handling simple and safe – simpler
    and safer than alternatives.
  id: totrans-6764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常会导致泄漏和错误。它们不会。如果你的程序是一个没有资源管理整体策略的指针混乱的迷宫，无论你做什么都会有问题。如果你的系统由一百万行这样的代码组成，你可能无法使用异常，但这不是异常的问题，而是过度和不加约束的指针使用的问题。在我们看来，你需要RAII来使基于异常的错误处理简单且安全——比其他替代方案更简单、更安全。
- en: Exception performance is not predictable. If you are in a hard-real-time system
    where you must guarantee completion of a task in a given time, you need tools
    to back up such guarantees. As far as we know such tools are not available (at
    least not to most programmers).
  id: totrans-6765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常的性能不可预测。如果你在一个必须保证在给定时间内完成任务的重实时系统中，你需要工具来支持这样的保证。据我们所知，这样的工具是不可用的（至少对大多数程序员来说不可用）。
- en: The exception-handling run-time support takes up too much space. This can be
    the case in small (usually embedded) systems. However, before abandoning exceptions
    consider what space consistent error-handling using error-codes would require
    and what failure to catch an error would cost.
  id: totrans-6766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理的运行时支持占用太多空间。这在小型（通常是嵌入式）系统中可能是这种情况。然而，在放弃异常之前，考虑一下使用错误码进行一致错误处理需要多少空间，以及未捕获错误会带来多少代价。
- en: Many, possibly most, problems with exceptions stem from historical needs to
    interact with messy old code.
  id: totrans-6767
  prefs: []
  type: TYPE_NORMAL
  zh: 许多，可能是大多数，与异常相关的问题源于与混乱的旧代码交互的历史需求。
- en: The fundamental arguments for the use of exceptions are
  id: totrans-6768
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常的基本论点是
- en: They clearly differentiate between erroneous return and ordinary return
  id: totrans-6769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们清楚地区分了错误返回和普通返回
- en: They cannot be forgotten or ignored
  id: totrans-6770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能被忘记或忽略
- en: They can be used systematically
  id: totrans-6771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以系统地使用
- en: Remember
  id: totrans-6772
  prefs: []
  type: TYPE_NORMAL
  zh: 记住
- en: Exceptions are for reporting errors (in C++; other languages can have different
    uses for exceptions).
  id: totrans-6773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常用于报告错误（在C++中；其他语言可以对异常有不同的用途）。
- en: Exceptions are not for errors that can be handled locally.
  id: totrans-6774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常不适用于可以局部处理的错误。
- en: Don’t try to catch every exception in every function (that’s tedious, clumsy,
    and leads to slow code).
  id: totrans-6775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要试图在每一个函数中捕获每一个异常（这很繁琐、笨拙，并且会导致代码运行缓慢）。
- en: Exceptions are not for errors that require instant termination of a module/system
    after a non-recoverable error.
  id: totrans-6776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常不适用于需要模块/系统在非可恢复错误后立即终止的错误。
- en: Example
  id: totrans-6777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE868]'
  id: totrans-6778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: Alternative
  id: totrans-6779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: '[RAII](#re-raii)'
  id: totrans-6780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RAII](#re-raii)'
- en: 'Contracts/assertions: Use GSL’s `Expects` and `Ensures` (until we get language
    support for contracts)'
  id: totrans-6781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同/断言：使用GSL的`Expects`和`Ensures`（直到我们得到对合同的编程语言支持）
- en: 'NR.4: Don’t insist on placing each class definition in its own source file'
  id: totrans-6782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NR.4: 不要坚持将每个类定义放在自己的源文件中'
- en: Reason
  id: totrans-6783
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The resulting number of files from placing each class in its own file are hard
    to manage and can slow down compilation. Individual classes are rarely a good
    logical unit of maintenance and distribution.
  id: totrans-6784
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个类放在自己的文件中产生的文件数量难以管理，可能会减慢编译速度。单个类很少是一个好的逻辑维护和分发单元。
- en: Example
  id: totrans-6785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE869]'
  id: totrans-6786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: Alternative
  id: totrans-6787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Use namespaces containing logically cohesive sets of classes and functions.
  id: totrans-6788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含逻辑上紧密集成的类和函数的命名空间。
- en: 'NR.5: Don’t use two-phase initialization'
  id: totrans-6789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NR.5：不要使用两阶段初始化
- en: Reason
  id: totrans-6790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Splitting initialization into two leads to weaker invariants, more complicated
    code (having to deal with semi-constructed objects), and errors (when we didn’t
    deal correctly with semi-constructed objects consistently).
  id: totrans-6791
  prefs: []
  type: TYPE_NORMAL
  zh: 将初始化分为两个阶段会导致不变量更弱、代码更复杂（必须处理半构造对象），以及错误（当我们没有一致地正确处理半构造对象时）。
- en: Note
  id: totrans-6792
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes also called two-stage construction.
  id: totrans-6793
  prefs: []
  type: TYPE_NORMAL
  zh: 有时也称为两阶段构建。
- en: Example, bad
  id: totrans-6794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE870]'
  id: totrans-6795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: Example, good
  id: totrans-6796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，良好
- en: '[PRE871]'
  id: totrans-6797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: Alternative
  id: totrans-6798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Always establish a class invariant in a constructor.
  id: totrans-6799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是在构造函数中建立一个类不变量。
- en: Don’t define an object before it is needed.
  id: totrans-6800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要之前不要定义对象。
- en: 'NR.6: Don’t place all cleanup actions at the end of a function and `goto exit`'
  id: totrans-6801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NR.6：不要在函数末尾放置所有清理操作并`goto exit`
- en: Reason
  id: totrans-6802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`goto` is error-prone. This technique is a pre-exception technique for RAII-like
    resource and error handling.'
  id: totrans-6803
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`是容易出错的。这是一种用于RAII-like资源和错误处理的预异常技术。'
- en: Example, bad
  id: totrans-6804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不良
- en: '[PRE872]'
  id: totrans-6805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: and spot the bug.
  id: totrans-6806
  prefs: []
  type: TYPE_NORMAL
  zh: 并找出错误。
- en: Alternative
  id: totrans-6807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: Use exceptions and [RAII](#re-raii)
  id: totrans-6808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常和[RAII](#re-raii)
- en: for non-RAII resources, use [`finally`](#re-finally).
  id: totrans-6809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非RAII资源，使用[`finally`](#re-finally)。
- en: 'NR.7: Don’t make data members `protected`'
  id: totrans-6810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NR.7：不要将数据成员设置为`protected`
- en: Reason
  id: totrans-6811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: '`protected` data is a source of errors. `protected` data can be manipulated
    from an unbounded amount of code in various places. `protected` data is the class
    hierarchy equivalent to global data.'
  id: totrans-6812
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`数据是错误的一个来源。`protected`数据可以从各种地方的大量代码中操作。`protected`数据是类层次结构中全局数据的等价物。'
- en: Example
  id: totrans-6813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE873]'
  id: totrans-6814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: Alternative
  id: totrans-6815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 替代方案
- en: '[Avoid `protected` data](#rh-protected)'
  id: totrans-6816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[避免使用`protected`数据](#rh-protected)'
- en: 'RF: References'
  id: totrans-6817
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RF：参考文献
- en: Many coding standards, rules, and guidelines have been written for C++, and
    especially for specialized uses of C++. Many
  id: totrans-6818
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为C++编写了许多编码标准、规则和指南，尤其是为C++的专用用途。许多
- en: focus on lower-level issues, such as the spelling of identifiers
  id: totrans-6819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注底层问题，例如标识符的拼写
- en: are written by C++ novices
  id: totrans-6820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是由C++新手编写的
- en: see “stopping programmers from doing unusual things” as their primary aim
  id: totrans-6821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“阻止程序员做不寻常的事情”视为他们的主要目标
- en: aim at portability across many compilers (some 10 years old)
  id: totrans-6822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 致力于跨许多编译器（有些已有10年历史）的可移植性
- en: are written to preserve decades old code bases
  id: totrans-6823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是为了保留数十年的代码库
- en: aim at a single application domain
  id: totrans-6824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 致力于单一的应用领域
- en: are downright counterproductive
  id: totrans-6825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全适得其反
- en: are ignored (must be ignored by programmers to get their work done well)
  id: totrans-6826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被忽略（程序员为了做好工作必须忽略）
- en: 'A bad coding standard is worse than no coding standard. However an appropriate
    set of guidelines are much better than no standards: “Form is liberating.”'
  id: totrans-6827
  prefs: []
  type: TYPE_NORMAL
  zh: 一个糟糕的编码标准比没有编码标准更糟。然而，一套适当的指南比没有标准要好得多：“形式是解放的。”
- en: Why can’t we just have a language that allows all we want and disallows all
    we don’t want (“a perfect language”)? Fundamentally, because affordable languages
    (and their tool chains) also serve people with needs that differ from yours and
    serve more needs than you have today. Also, your needs change over time and a
    general-purpose language is needed to allow you to adapt. A language that is ideal
    for today would be overly restrictive tomorrow.
  id: totrans-6828
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能有一个允许我们想要的一切并禁止我们不想要的一切（“一种完美的语言”）的语言呢？从根本上说，因为可负担的语言（及其工具链）也服务于与您需求不同的人，并且满足的需求比您今天的需求更多。此外，您的需求会随时间变化，需要一个通用语言来允许您适应。一个今天理想的语言明天就会过于限制。
- en: Coding guidelines adapt the use of a language to specific needs. Thus, there
    cannot be a single coding style for everybody. We expect different organizations
    to provide additions, typically with more restrictions and firmer style rules.
  id: totrans-6829
  prefs: []
  type: TYPE_NORMAL
  zh: 编码指南使语言的使用适应特定的需求。因此，不可能有一种适合所有人的编码风格。我们期望不同的组织提供补充，通常带有更多的限制和更严格的风格规则。
- en: 'Reference sections:'
  id: totrans-6830
  prefs: []
  type: TYPE_NORMAL
  zh: 参考部分：
- en: '[RF.rules: Coding rules](#ss-rules)'
  id: totrans-6831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF.rules：编码规则](#ss-rules)'
- en: '[RF.books: Books with coding guidelines](#ss-books)'
  id: totrans-6832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF.books：包含编码指南的书籍](#ss-books)'
- en: '[RF.C++: C++ Programming (C++11/C++14/C++17)](#ss-cplusplus)'
  id: totrans-6833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF.C++：C++编程（C++11/C++14/C++17）](#ss-cplusplus)'
- en: '[RF.web: Websites](#ss-web)'
  id: totrans-6834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF.web：网站](#ss-web)'
- en: '[RS.video: Videos about “modern C++”](#ss-vid)'
  id: totrans-6835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RS.video：关于“现代C++”的视频](#ss-vid)'
- en: '[RF.man: Manuals](#ss-man)'
  id: totrans-6836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF.man：手册](#ss-man)'
- en: '[RF.core: Core Guidelines materials](#ss-core)'
  id: totrans-6837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RF.core：核心指南材料](#ss-core)'
- en: 'RF.rules: Coding rules'
  id: totrans-6838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RF.rules：编码规则
- en: '[AUTOSAR Guidelines for the use of the C++14 language in critical and safety-related
    systems v22.11](https://www.autosar.org/fileadmin/standards/R22-11/AP/AUTOSAR_RS_CPP14Guidelines.pdf)
    (obsolete, replaced by [MISRA C++:2023](https://misra.org.uk/product/misra-cpp2023/))'
  id: totrans-6839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AUTOSAR 对于在关键和安全性相关系统中使用 C++14 语言的指南 v22.11](https://www.autosar.org/fileadmin/standards/R22-11/AP/AUTOSAR_RS_CPP14Guidelines.pdf)（已过时，由
    [MISRA C++:2023](https://misra.org.uk/product/misra-cpp2023/) 取代）'
- en: '[Boost Library Requirements and Guidelines](https://www.boost.org/development/requirements.html).
    ???.'
  id: totrans-6840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Boost 库需求和指南](https://www.boost.org/development/requirements.html). ???'
- en: '[Bloomberg: BDE C++ Coding](https://github.com/bloomberg/bde/wiki/CodingStandards.pdf).
    Has a strong emphasis on code organization and layout.'
  id: totrans-6841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[彭博：BDE C++ 编码规范](https://github.com/bloomberg/bde/wiki/CodingStandards.pdf).
    强调代码组织和布局。'
- en: 'Facebook: ???'
  id: totrans-6842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook：???
- en: '[GCC Coding Conventions](https://gcc.gnu.org/codingconventions.html). C++03
    and (reasonably) a bit backwards looking.'
  id: totrans-6843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GCC 编码约定](https://gcc.gnu.org/codingconventions.html)。C++03以及（合理地）回顾过去。'
- en: '[Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).
    Geared toward C++17 and (also) older code bases. Google experts are now actively
    collaborating here on helping to improve these Guidelines, and hopefully to merge
    efforts so these can be a modern common set they could also recommend.'
  id: totrans-6844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google C++ 风格指南](https://google.github.io/styleguide/cppguide.html). 针对C++17以及（也）较老的代码库。谷歌专家现在正在积极协作，帮助改进这些指南，并希望合并努力，使这些指南成为他们可以推荐的现代通用集合。'
- en: '[JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS](https://www.stroustrup.com/JSF-AV-rules.pdf).
    Document Number 2RDU00001 Rev C. December 2005. For flight control software. For
    hard-real-time. This means that it is necessarily very restrictive (“if the program
    fails somebody dies”). For example, no free store allocation or deallocation is
    allowed to occur after the plane takes off (no memory overflow and no fragmentation
    allowed). No exception is allowed to be used (because there was no available tool
    for guaranteeing that an exception would be handled within a fixed short time).
    Libraries used have to have been approved for mission critical applications. Any
    similarities to this set of guidelines are unsurprising because Bjarne Stroustrup
    was an author of JSF++. Recommended, but note its very specific focus.'
  id: totrans-6845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JSF++：联合打击战斗机航空器 C++ 编码规范](https://www.stroustrup.com/JSF-AV-rules.pdf). 文件编号
    2RDU00001 Rev C. 2005年12月。用于飞行控制软件。用于硬实时。这意味着它必然非常严格（“如果程序失败，有人会死”）。例如，不允许在飞机起飞后发生自由存储分配或释放（不允许内存溢出和碎片化）。不允许使用异常（因为没有可用的工具来保证异常能在固定短的时间内被处理）。使用的库必须经过任务关键应用的批准。任何与此套指南相似之处都不足为奇，因为
    Bjarne Stroustrup 是 JSF++ 的作者之一。推荐，但请注意其非常具体的焦点。'
- en: '[MISRA C++:2023 Guidelines for the use C++17 in critical systems](https://misra.org.uk/product/misra-cpp2023/).'
  id: totrans-6846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MISRA C++:2023 使用 C++17 在关键系统中的指南](https://misra.org.uk/product/misra-cpp2023/).'
- en: '[Using C++ in Mozilla Code](https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html).
    As the name indicates, this aims for portability across many (old) compilers.
    As such, it is restrictive.'
  id: totrans-6847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在 Mozilla 代码中使用 C++](https://firefox-source-docs.mozilla.org/code-quality/coding-style/using_cxx_in_firefox_code.html)。正如其名所示，它旨在跨许多（旧）编译器实现可移植性。因此，它具有一定的限制性。'
- en: '[Geosoft.no: C++ Programming Style Guidelines](https://geosoft.no/development/cppstyle.html).
    ???.'
  id: totrans-6848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Geosoft.no: C++ 编程风格指南](https://geosoft.no/development/cppstyle.html). ???'
- en: '[Possibility.com: C++ Coding Standard](https://www.possibility.com/Cpp/CppCodingStandard.html).
    ???.'
  id: totrans-6849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Possibility.com：C++ 编码规范](https://www.possibility.com/Cpp/CppCodingStandard.html).
    ???'
- en: '[SEI CERT: Secure C++ Coding Standard](https://wiki.sei.cmu.edu/confluence/x/Wnw-BQ).
    A very nicely done set of rules (with examples and rationales) done for security-sensitive
    code. Many of their rules apply generally.'
  id: totrans-6850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SEI CERT：安全 C++ 编码规范](https://wiki.sei.cmu.edu/confluence/x/Wnw-BQ)。一套非常出色的规则（带有示例和理由），专为对安全敏感的代码而设计。其中许多规则具有普遍适用性。'
- en: '[High Integrity C++ Coding Standard](https://www.codingstandard.com/).'
  id: totrans-6851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[高完整性 C++ 编码规范](https://www.codingstandard.com/).'
- en: '[llvm](https://llvm.org/docs/CodingStandards.html). Somewhat brief, based on
    C++14, and (not unreasonably) adjusted to its domain.'
  id: totrans-6852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[llvm](https://llvm.org/docs/CodingStandards.html). 略为简短，基于 C++14，并且（合理地）调整到其领域。'
- en: ???
  id: totrans-6853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'RF.books: Books with coding guidelines'
  id: totrans-6854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RF.books：带有编码指南的书籍
- en: '[Meyers96](#Meyers96) Scott Meyers: *More Effective C++*. Addison-Wesley 1996.'
  id: totrans-6855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers96](#Meyers96) Scott Meyers：*More Effective C++*。Addison-Wesley 1996。'
- en: '[Meyers97](#Meyers97) Scott Meyers: *Effective C++, Second Edition*. Addison-Wesley
    1997.'
  id: totrans-6856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers97](#Meyers97) Scott Meyers：*Effective C++, 第二版*。Addison-Wesley 1997。'
- en: '[Meyers01](#Meyers01) Scott Meyers: *Effective STL*. Addison-Wesley 2001.'
  id: totrans-6857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers01](#Meyers01) Scott Meyers: *Effective STL*. Addison-Wesley 2001.'
- en: '[Meyers05](#Meyers05) Scott Meyers: *Effective C++, Third Edition*. Addison-Wesley
    2005.'
  id: totrans-6858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers05](#Meyers05) Scott Meyers: *Effective C++, 第三版*. Addison-Wesley 2005.'
- en: '[Meyers15](#Meyers15) Scott Meyers: *Effective Modern C++*. O’Reilly 2015.'
  id: totrans-6859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers15](#Meyers15) Scott Meyers: *Effective Modern C++*. O’Reilly 2015.'
- en: '[SuttAlex05](#SuttAlex05) Sutter and Alexandrescu: *C++ Coding Standards*.
    Addison-Wesley 2005\. More a set of meta-rules than a set of rules. Pre-C++11.'
  id: totrans-6860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SuttAlex05](#SuttAlex05) Sutter和Alexandrescu: *C++编码标准*. Addison-Wesley 2005\.
    更像是一套元规则而不是一套规则。在C++11之前。'
- en: '[Stroustrup05](#Stroustrup05) Bjarne Stroustrup: [A rationale for semantically
    enhanced library languages](https://www.stroustrup.com/SELLrationale.pdf). LCSD05\.
    October 2005.'
  id: totrans-6861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup05](#Stroustrup05) Bjarne Stroustrup: [语义增强库语言的合理性](https://www.stroustrup.com/SELLrationale.pdf).
    LCSD05\. 2005年10月。'
- en: '[Stroustrup14](#Stroustrup05) Stroustrup: [A Tour of C++](https://www.stroustrup.com/Tour.html).
    Addison-Wesley 2014. Each chapter ends with an advice section consisting of a
    set of recommendations.'
  id: totrans-6862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup14](#Stroustrup05) Stroustrup: [C++之旅](https://www.stroustrup.com/Tour.html).
    Addison-Wesley 2014. 每章结尾都有一个建议部分，包括一系列推荐。'
- en: '[Stroustrup13](#Stroustrup13) Stroustrup: [The C++ Programming Language (4th
    Edition)](https://www.stroustrup.com/4th.html). Addison-Wesley 2013. Each chapter
    ends with an advice section consisting of a set of recommendations.'
  id: totrans-6863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup13](#Stroustrup13) Stroustrup: [《C++编程语言（第四版）》](https://www.stroustrup.com/4th.html).
    Addison-Wesley 2013. 每章结尾都有一个建议部分，包括一系列推荐。'
- en: 'Stroustrup: [Style Guide](https://www.stroustrup.com/Programming/PPP-style.pdf)
    for [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html).
    Mostly low-level naming and layout rules. Primarily a teaching tool.'
  id: totrans-6864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Stroustrup: [风格指南](https://www.stroustrup.com/Programming/PPP-style.pdf) for
    [《C++程序设计：原理与实践》](https://www.stroustrup.com/programming.html). 主要包括低级命名和布局规则。主要是一个教学工具。'
- en: 'RF.C++: C++ Programming (C++11/C++14)'
  id: totrans-6865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'RF.C++: C++编程（C++11/C++14）'
- en: '[TC++PL4](https://www.stroustrup.com/4th.html): A thorough description of the
    C++ language and standard libraries for experienced programmers.'
  id: totrans-6866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TC++PL4](https://www.stroustrup.com/4th.html): 为经验丰富的程序员提供的C++语言和标准库的详细描述。'
- en: '[Tour++](https://www.stroustrup.com/Tour.html): An overview of the C++ language
    and standard libraries for experienced programmers.'
  id: totrans-6867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Tour++](https://www.stroustrup.com/Tour.html): 为经验丰富的程序员提供的C++语言和标准库概述。'
- en: '[Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html):
    A textbook for beginners and relative novices.'
  id: totrans-6868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《C++程序设计：原理与实践》](https://www.stroustrup.com/programming.html): 为初学者和相对新手提供的教科书。'
- en: 'RF.web: Websites'
  id: totrans-6869
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'RF.web: 网站'
- en: '[isocpp.org](https://isocpp.org)'
  id: totrans-6870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[isocpp.org](https://isocpp.org)'
- en: '[Bjarne Stroustrup’s home pages](https://www.stroustrup.com)'
  id: totrans-6871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Bjarne Stroustrup的主页](https://www.stroustrup.com)'
- en: '[WG21](https://www.open-std.org/jtc1/sc22/wg21/)'
  id: totrans-6872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[WG21](https://www.open-std.org/jtc1/sc22/wg21/)'
- en: '[Boost](https://www.boost.org)'
  id: totrans-6873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Boost](https://www.boost.org)'
- en: '[Adobe open source](https://opensource.adobe.com/)'
  id: totrans-6874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Adobe开源](https://opensource.adobe.com/)'
- en: '[Poco libraries](https://pocoproject.org/)'
  id: totrans-6875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Poco库](https://pocoproject.org/)'
- en: Sutter’s Mill?
  id: totrans-6876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sutter的磨坊？
- en: ???
  id: totrans-6877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ???
- en: 'RS.video: Videos about “modern C++”'
  id: totrans-6878
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'RS.video: 关于“现代C++”的视频'
- en: 'Bjarne Stroustrup: [C++11 Style](https://learn.microsoft.com/en-us/shows/goingnative-2012/keynote-bjarne-stroustrup-cpp11-style).
    2012.'
  id: totrans-6879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [C++11风格](https://learn.microsoft.com/en-us/shows/goingnative-2012/keynote-bjarne-stroustrup-cpp11-style).
    2012.'
- en: 'Bjarne Stroustrup: [The Essence of C++: With Examples in C++84, C++98, C++11,
    and C++14](https://learn.microsoft.com/en-us/shows/goingnative-2013/opening-keynote-bjarne-stroustrup).
    2013'
  id: totrans-6880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [C++的本质：C++84、C++98、C++11和C++14中的示例](https://learn.microsoft.com/en-us/shows/goingnative-2013/opening-keynote-bjarne-stroustrup).
    2013'
- en: All the talks from [CppCon ’14](https://isocpp.org/blog/2014/11/cppcon-videos-c9)
  id: totrans-6881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CppCon’14](https://isocpp.org/blog/2014/11/cppcon-videos-c9)的所有演讲'
- en: 'Bjarne Stroustrup: [The essence of C++](https://www.youtube.com/watch?v=86xWVb4XIyE)
    at the University of Edinburgh. 2014.'
  id: totrans-6882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [C++的本质](https://www.youtube.com/watch?v=86xWVb4XIyE) at
    the University of Edinburgh. 2014.'
- en: 'Bjarne Stroustrup: [The Evolution of C++ Past, Present and Future](https://www.youtube.com/watch?v=_wzc7a3McOs).
    CppCon 2016 keynote.'
  id: totrans-6883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [C++过去、现在和未来的演变](https://www.youtube.com/watch?v=_wzc7a3McOs).
    CppCon 2016 开场演讲。'
- en: 'Bjarne Stroustrup: [Make Simple Tasks Simple!](https://www.youtube.com/watch?v=nesCaocNjtQ).
    CppCon 2014 keynote.'
  id: totrans-6884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [简化简单任务！](https://www.youtube.com/watch?v=nesCaocNjtQ).
    CppCon 2014 开场演讲。'
- en: 'Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A).
    CppCon 2015 keynote about the Core Guidelines.'
  id: totrans-6885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [编写优秀的C++14](https://www.youtube.com/watch?v=1OEu9C51K2A).
    CppCon 2015 关于核心指南的开场演讲。'
- en: 'Herb Sutter: [Writing Good C++14… By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA).
    CppCon 2015 keynote about the Core Guidelines.'
  id: totrans-6886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Herb Sutter: [默认情况下编写好的C++14…](https://www.youtube.com/watch?v=hEx5DNLWGgA)。2015年CppCon主题演讲关于核心指南。'
- en: CppCon 15
  id: totrans-6887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CppCon 15
- en: ??? C++ Next
  id: totrans-6888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? C++ Next
- en: ??? Meting C++
  id: totrans-6889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? Meting C++
- en: ??? more ???
  id: totrans-6890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ??? 更多 ???
- en: 'RF.man: Manuals'
  id: totrans-6891
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'RF.man: 手册'
- en: ISO C++ Standard C++11.
  id: totrans-6892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO C++标准 C++11。
- en: ISO C++ Standard C++14.
  id: totrans-6893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO C++标准 C++14。
- en: '[ISO C++ Standard C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf).
    Committee Draft.'
  id: totrans-6894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ISO C++标准 C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf)。委员会草案。'
- en: '[Palo Alto “Concepts” TR](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf).'
  id: totrans-6895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Palo Alto “概念”TR](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf)。'
- en: '[ISO C++ Concepts TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).'
  id: totrans-6896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ISO C++概念TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf)。'
- en: '[WG21 Ranges report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf).
    Draft.'
  id: totrans-6897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[WG21范围报告](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)。草案。'
- en: 'RF.core: Core Guidelines materials'
  id: totrans-6898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'RF.core: 核心指南材料'
- en: 'This section contains materials that have been useful for presenting the core
    guidelines and the ideas behind them:'
  id: totrans-6899
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含用于展示核心指南及其背后的思想的材料：
- en: '[Our documents directory](https://github.com/isocpp/CppCoreGuidelines/tree/master/docs)'
  id: totrans-6900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们的文档目录](https://github.com/isocpp/CppCoreGuidelines/tree/master/docs)'
- en: 'Stroustrup, Sutter, and Dos Reis: [A brief introduction to C++’s model for
    type- and resource-safety](https://www.stroustrup.com/resource-model.pdf). A paper
    with lots of examples.'
  id: totrans-6901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Stroustrup, Sutter, and Dos Reis: [C++类型和资源安全模型的简要介绍](https://www.stroustrup.com/resource-model.pdf)。一篇包含大量例子的论文。'
- en: 'Sergey Zubkov: [a Core Guidelines talk](https://www.youtube.com/watch?v=DyLwdl_6vmU)
    and here are the [slides](https://www.slideshare.net/slideshow/c-core-guidelines-72335317/72335317).
    In Russian. 2017.'
  id: totrans-6902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sergey Zubkov: [核心指南演讲](https://www.youtube.com/watch?v=DyLwdl_6vmU) 以及[幻灯片](https://www.slideshare.net/slideshow/c-core-guidelines-72335317/72335317)。俄语。2017年。'
- en: 'Neil MacIntosh: [The Guideline Support Library: One Year Later](https://www.youtube.com/watch?v=_GhNnCuaEjo).
    CppCon 2016.'
  id: totrans-6903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Neil MacIntosh: [《指南支持库：一年之后》(https://www.youtube.com/watch?v=_GhNnCuaEjo)]。2016年CppCon。'
- en: 'Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A).
    CppCon 2015 keynote.'
  id: totrans-6904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [编写好的C++14](https://www.youtube.com/watch?v=1OEu9C51K2A)。2015年CppCon主题演讲。'
- en: 'Herb Sutter: [Writing Good C++14… By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA).
    CppCon 2015 keynote.'
  id: totrans-6905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Herb Sutter: [默认情况下编写好的C++14…](https://www.youtube.com/watch?v=hEx5DNLWGgA)。2015年CppCon主题演讲。'
- en: 'Peter Sommerlad: [C++ Core Guidelines - Modernize your C++ Code Base](https://www.youtube.com/watch?v=fQ926v4ZzAM).
    ACCU 2017.'
  id: totrans-6906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Peter Sommerlad: [C++核心指南 - 现代化你的C++代码库](https://www.youtube.com/watch?v=fQ926v4ZzAM)。2017年ACCU。'
- en: 'Bjarne Stroustrup: [No Littering!](https://www.youtube.com/watch?v=01zI9kV4h8c).
    Bay Area ACCU 2016. It gives some idea of the ambition level for the Core Guidelines.'
  id: totrans-6907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bjarne Stroustrup: [不要乱扔垃圾！](https://www.youtube.com/watch?v=01zI9kV4h8c)。2016年湾区ACCU。它给出了一些关于核心指南雄心水平的概念。'
- en: Note that slides for CppCon presentations are available (links with the posted
    videos).
  id: totrans-6908
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CppCon演讲的幻灯片是可用的（与发布的视频链接）。
- en: Contributions to this list would be most welcome.
  id: totrans-6909
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎对这份名单做出贡献。
- en: Acknowledgements
  id: totrans-6910
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 致谢
- en: 'Thanks to the many people who contributed rules, suggestions, supporting information,
    references, etc.:'
  id: totrans-6911
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢许多人为制定规则、建议、支持信息、参考文献等做出的贡献：
- en: Peter Juhl
  id: totrans-6912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Peter Juhl
- en: Neil MacIntosh
  id: totrans-6913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neil MacIntosh
- en: Axel Naumann
  id: totrans-6914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Axel Naumann
- en: Andrew Pardoe
  id: totrans-6915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Andrew Pardoe
- en: Gabriel Dos Reis
  id: totrans-6916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gabriel Dos Reis
- en: Zhuang, Jiangang (Jeff)
  id: totrans-6917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zhuang, Jiangang (Jeff)
- en: Sergey Zubkov
  id: totrans-6918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sergey Zubkov
- en: and see the contributor list on the github.
  id: totrans-6919
  prefs: []
  type: TYPE_NORMAL
  zh: 在github上查看贡献者名单。
- en: 'Pro: Profiles'
  id: totrans-6920
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Pro: 简介'
- en: Ideally, we would follow all of the guidelines. That would give the cleanest,
    most regular, least error-prone, and often the fastest code. Unfortunately, that
    is usually impossible because we have to fit our code into large code bases and
    use existing libraries. Often, such code has been written over decades and does
    not follow these guidelines. We must aim for [gradual adoption](#s-modernizing).
  id: totrans-6921
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们会遵循所有指南。这将产生最干净、最规范、最不易出错、通常也是最快的代码。不幸的是，这通常是不可能的，因为我们必须将我们的代码适应到大型代码库中并使用现有的库。通常，这样的代码已经编写了几十年，并不遵循这些指南。我们必须争取[逐步采用](#s-modernizing)。
- en: Whatever strategy for gradual adoption we adopt, we need to be able to apply
    sets of related guidelines to address some set of problems first and leave the
    rest until later. A similar idea of “related guidelines” becomes important when
    some, but not all, guidelines are considered relevant to a code base or if a set
    of specialized guidelines is to be applied for a specialized application area.
    We call such a set of related guidelines a “profile”. We aim for such a set of
    guidelines to be coherent so that they together help us reach a specific goal,
    such as “absence of range errors” or “static type safety.” Each profile is designed
    to eliminate a class of errors. Enforcement of “random” rules in isolation is
    more likely to be disruptive to a code base than delivering a definite improvement.
  id: totrans-6922
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们采用何种逐步采用策略，我们都需要能够首先应用一系列相关指南来解决一些问题，其余的留待以后处理。当一些，但不是所有指南被认为与代码库相关，或者要为特定应用领域应用一组专业指南时，这种“相关指南”的想法变得很重要。我们将这样的相关指南集称为“配置文件”。我们的目标是使这些指南保持一致，以便它们共同帮助我们达到一个具体目标，例如“范围错误不存在”或“静态类型安全性”。每个配置文件都是为了消除一类错误而设计的。单独执行“随机”规则可能会比提供明确的改进更可能破坏代码库。
- en: A “profile” is a set of deterministic and portably enforceable subset of rules
    (i.e., restrictions) that are designed to achieve a specific guarantee. “Deterministic”
    means they require only local analysis and could be implemented in a compiler
    (though they don’t need to be). “Portably enforceable” means they are like language
    rules, so programmers can count on different enforcement tools giving the same
    answer for the same code.
  id: totrans-6923
  prefs: []
  type: TYPE_NORMAL
  zh: “配置文件”是一组旨在实现特定保证的确定性和可移植性可执行规则（即，限制）的集合。“确定性”意味着它们只需要本地分析，并且可以在编译器中实现（尽管不一定需要）。
    “可移植性可执行”意味着它们类似于语言规则，因此程序员可以依赖不同的执行工具对相同代码给出相同的答案。
- en: Code written to be warning-free using such a language profile is considered
    to conform to the profile. Conforming code is considered to be safe by construction
    with regard to the safety properties targeted by that profile. Conforming code
    will not be the root cause of errors for that property, although such errors might
    be introduced into a program by other code, libraries or the external environment.
    A profile might also introduce additional library types to ease conformance and
    encourage correct code.
  id: totrans-6924
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类语言配置文件编写的无警告代码被认为符合配置文件。符合配置文件的代码在针对该配置文件目标的安全属性方面被认为是构造上安全的。符合配置文件的代码不会是该属性的根原因，尽管这种错误可能由其他代码、库或外部环境引入程序。配置文件还可能引入额外的库类型，以简化符合性并鼓励编写正确的代码。
- en: 'Profiles summary:'
  id: totrans-6925
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件摘要：
- en: '[Pro.type: Type safety](#ss-type)'
  id: totrans-6926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pro.type: 类型安全性](#ss-type)'
- en: '[Pro.bounds: Bounds safety](#ss-bounds)'
  id: totrans-6927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pro.bounds: 边界安全性](#ss-bounds)'
- en: '[Pro.lifetime: Lifetime safety](#ss-lifetime)'
  id: totrans-6928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pro.lifetime: 生存期安全性](#ss-lifetime)'
- en: 'In the future, we expect to define many more profiles and add more checks to
    existing profiles. Candidates include:'
  id: totrans-6929
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，我们预计将定义更多配置文件并向现有配置文件添加更多检查。候选包括：
- en: narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic
    profile)
  id: totrans-6930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窄化算术提升/转换（可能是单独的安全算术配置文件的一部分）
- en: arithmetic cast from negative floating point to unsigned integral type (ditto)
  id: totrans-6931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从负浮点数到无符号整型的算术转换（同上）
- en: 'selected undefined behavior: Start with Gabriel Dos Reis’s UB list developed
    for the WG21 study group'
  id: totrans-6932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择未定义的行为：从 Gabriel Dos Reis 为 WG21 研究小组开发的 UB 列表开始
- en: 'selected unspecified behavior: Addressing portability concerns.'
  id: totrans-6933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择未指定的行为：解决可移植性问题。
- en: '`const` violations: Mostly done by compilers already, but we can catch inappropriate
    casting and underuse of `const`.'
  id: totrans-6934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const` 违规：主要是由编译器完成的，但我们可以捕获不适当的类型转换和 `const` 的未使用。'
- en: Enabling a profile is implementation defined; typically, it is set in the analysis
    tool used.
  id: totrans-6935
  prefs: []
  type: TYPE_NORMAL
  zh: 启用配置文件是实现定义的；通常，它在分析工具中设置。
- en: 'To suppress enforcement of a profile check, place a `suppress` annotation on
    a language contract. For example:'
  id: totrans-6936
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制配置文件检查的执行，请在语言合同上放置一个 `suppress` 注解。例如：
- en: '[PRE874]'
  id: totrans-6937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: Now `raw_find()` can scramble memory to its heart’s content. Obviously, suppression
    should be very rare.
  id: totrans-6938
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `raw_find()` 可以随心所欲地打乱内存。显然，抑制应该非常罕见。
- en: 'Pro.safety: Type-safety profile'
  id: totrans-6939
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Pro.safety: 类型安全性配置文件'
- en: This profile makes it easier to construct code that uses types correctly and
    avoids inadvertent type punning. It does so by focusing on removing the primary
    sources of type violations, including unsafe uses of casts and unions.
  id: totrans-6940
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件使构建正确使用类型并避免意外类型混淆的代码变得更加容易。它是通过专注于移除类型违规的主要来源来做到这一点的，包括不安全的转换和联合使用。
- en: For the purposes of this section, type-safety is defined to be the property
    that a variable is not used in a way that doesn’t obey the rules for the type
    of its definition. Memory accessed as a type `T` should not be valid memory that
    actually contains an object of an unrelated type `U`. Note that the safety is
    intended to be complete when combined also with [Bounds safety](#ss-bounds) and
    [Lifetime safety](#ss-lifetime).
  id: totrans-6941
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，类型安全被定义为变量不是以不遵守其定义类型规则的方式使用。以类型`T`访问的内存不应是实际包含无关类型`U`对象的无效内存。请注意，当与[边界安全](#ss-bounds)和[生命周期安全](#ss-lifetime)结合时，安全性旨在是完整的。
- en: An implementation of this profile shall recognize the following patterns in
    source code as non-conforming and issue a diagnostic.
  id: totrans-6942
  prefs: []
  type: TYPE_NORMAL
  zh: 本配置文件的实现应识别源代码中的以下模式作为不符合规范，并发出诊断。
- en: 'Type safety profile summary:'
  id: totrans-6943
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全配置文件摘要：
- en: 'Type.1: [Avoid casts](#res-casts):'
  id: totrans-6944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.1: [避免类型转换](#res-casts):'
- en: Don’t use `reinterpret_cast`; A strict version of [Avoid casts](#res-casts)
    and [prefer named casts](#res-casts-named).
  id: totrans-6945
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用`reinterpret_cast`；这是[避免类型转换](#res-casts)和[优先使用命名转换](#res-casts-named)的严格版本。
- en: Don’t use `static_cast` for arithmetic types; A strict version of [Avoid casts](#res-casts)
    and [prefer named casts](#res-casts-named).
  id: totrans-6946
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用`static_cast`进行算术类型转换；这是[避免类型转换](#res-casts)和[优先使用命名转换](#res-casts-named)的严格版本。
- en: Don’t cast between pointer types where the source type and the target type are
    the same; A strict version of [Avoid casts](#res-casts).
  id: totrans-6947
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要在源类型和目标类型相同的情况下在指针类型之间进行转换；这是[避免类型转换](#res-casts)的严格版本。
- en: Don’t cast between pointer types when the conversion could be implicit; A strict
    version of [Avoid casts](#res-casts).
  id: totrans-6948
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当转换可能是隐式的时候，不要在指针类型之间进行转换；这是[避免类型转换](#res-casts)的严格版本。
- en: 'Type.2: Don’t use `static_cast` to downcast: [Use `dynamic_cast` instead](#rh-dynamic_cast).'
  id: totrans-6949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.2: 不要使用`static_cast`进行向下转换：[使用`dynamic_cast`代替](#rh-dynamic_cast)。'
- en: 'Type.3: Don’t use `const_cast` to cast away `const` (i.e., at all): [Don’t
    cast away const](#res-casts-const).'
  id: totrans-6950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.3: 不要使用`const_cast`来取消`const`（即，完全不要）：[不要取消const](#res-casts-const)。'
- en: 'Type.4: Don’t use C-style `(T)expression` or functional `T(expression)` casts:
    Prefer [construction](#res-construct) or [named casts](#res-casts-named) or `T{expression}`.'
  id: totrans-6951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.4: 不要使用C风格的`(T)expression`或函数式`T(expression)`转换：优先使用[构造](#res-construct)或[命名转换](#res-casts-named)或`T{expression}`。'
- en: 'Type.5: Don’t use a variable before it has been initialized: [always initialize](#res-always).'
  id: totrans-6952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.5: 在初始化之前不要使用变量：[总是初始化](#res-always)。'
- en: 'Type.6: Always initialize a data member: [always initialize](#res-always),
    possibly using [default constructors](#rc-default0) or [default member initializers](#rc-in-class-initializer).'
  id: totrans-6953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.6: 总是初始化数据成员：[总是初始化](#res-always)，可能使用[默认构造函数](#rc-default0)或[默认成员初始化器](#rc-in-class-initializer)。'
- en: 'Type.7: Avoid naked union: [Use `variant` instead](#ru-naked).'
  id: totrans-6954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.7: 避免裸联合：[使用`variant`代替](#ru-naked)。'
- en: 'Type.8: Avoid varargs: [Don’t use `va_arg` arguments](#f-varargs).'
  id: totrans-6955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类型.8: 避免变长参数：[不要使用`va_arg`参数](#f-varargs)。'
- en: Impact
  id: totrans-6956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 影响
- en: With the type-safety profile you can trust that every operation is applied to
    a valid object. An exception can be thrown to indicate errors that cannot be detected
    statically (at compile time). Note that this type-safety can be complete only
    if we also have [Bounds safety](#ss-bounds) and [Lifetime safety](#ss-lifetime).
    Without those guarantees, a region of memory could be accessed independent of
    which object, objects, or parts of objects are stored in it.
  id: totrans-6957
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型安全配置文件，您可以相信每个操作都是应用于有效对象。可以通过抛出异常来指示无法在静态（编译时）检测到的错误。请注意，这种类型安全只有在我们也拥有[边界安全](#ss-bounds)和[生命周期安全](#ss-lifetime)的情况下才能是完整的。如果没有这些保证，内存区域可能会独立于存储其中的对象、对象部分或对象而被访问。
- en: 'Pro.bounds: Bounds safety profile'
  id: totrans-6958
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Pro.bounds: 边界安全配置文件'
- en: 'This profile makes it easier to construct code that operates within the bounds
    of allocated blocks of memory. It does so by focusing on removing the primary
    sources of bounds violations: pointer arithmetic and array indexing. One of the
    core features of this profile is to restrict pointers to only refer to single
    objects, not arrays.'
  id: totrans-6959
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件使构建在分配的内存块边界内运行的代码变得更加容易。它是通过专注于移除边界违规的主要来源：指针算术和数组索引来做到这一点的。此配置文件的一个核心特性是限制指针只能引用单个对象，而不是数组。
- en: We define bounds-safety to be the property that a program does not use an object
    to access memory outside of the range that was allocated for it. Bounds safety
    is intended to be complete only when combined with [Type safety](#ss-type) and
    [Lifetime safety](#ss-lifetime), which cover other unsafe operations that allow
    bounds violations.
  id: totrans-6960
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将边界安全定义为程序不使用对象来访问为其分配的范围之外的内存的性质。边界安全旨在与 [类型安全](#ss-type) 和 [生存期安全](#ss-lifetime)
    结合使用，它们涵盖了其他允许边界违规的不安全操作。
- en: 'Bounds safety profile summary:'
  id: totrans-6961
  prefs: []
  type: TYPE_NORMAL
  zh: 边界安全配置文件摘要：
- en: 'Bounds.1: Don’t use pointer arithmetic. Use `span` instead: [Pass pointers
    to single objects (only)](#ri-array) and [Keep pointer arithmetic simple](#res-ptr).'
  id: totrans-6962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界.1：不要使用指针算术。使用 `span` 代替：[仅传递单个对象的指针](#ri-array) 和 [保持指针算术简单](#res-ptr)。
- en: 'Bounds.2: Only index into arrays using constant expressions: [Pass pointers
    to single objects (only)](#ri-array) and [Keep pointer arithmetic simple](#res-ptr).'
  id: totrans-6963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界.2：仅使用常量表达式索引数组：[仅传递单个对象的指针](#ri-array) 和 [保持指针算术简单](#res-ptr)。
- en: 'Bounds.3: No array-to-pointer decay: [Pass pointers to single objects (only)](#ri-array)
    and [Keep pointer arithmetic simple](#res-ptr).'
  id: totrans-6964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界.3：不允许数组到指针的退化：[仅传递单个对象的指针](#ri-array) 和 [保持指针算术简单](#res-ptr)。
- en: 'Bounds.4: Don’t use standard-library functions and types that are not bounds-checked:
    [Use the standard library in a type-safe manner](#rsl-bounds).'
  id: totrans-6965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界.4：不要使用未进行边界检查的标准库函数和类型：[以类型安全的方式使用标准库](#rsl-bounds)。
- en: Impact
  id: totrans-6966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 影响
- en: Bounds safety implies that access to an object - notably arrays - does not access
    beyond the object’s memory allocation. This eliminates a large class of insidious
    and hard-to-find errors, including the (in)famous “buffer overflow” errors. This
    closes security loopholes as well as a prominent source of memory corruption (when
    writing out of bounds). Even if an out-of-bounds access is “just a read”, it can
    lead to invariant violations (when the accessed isn’t of the assumed type) and
    “mysterious values.”
  id: totrans-6967
  prefs: []
  type: TYPE_NORMAL
  zh: 边界安全意味着对对象的访问——特别是数组——不会超出对象的内存分配范围。这消除了大量隐蔽且难以发现的错误，包括著名的（或非著名的）“缓冲区溢出”错误。这关闭了安全漏洞以及内存损坏的一个显著来源（当超出范围写入时）。即使超出范围的访问“仅仅是读取”，也可能导致不变性违反（当访问的不是假设的类型时）和“神秘值”。
- en: 'Pro.lifetime: Lifetime safety profile'
  id: totrans-6968
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pro.lifetime：生存期安全配置文件
- en: Accessing through a pointer that doesn’t point to anything is a major source
    of errors, and very hard to avoid in many traditional C or C++ styles of programming.
    For example, a pointer might be uninitialized, the `nullptr`, point beyond the
    range of an array, or to a deleted object.
  id: totrans-6969
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个不指向任何内容的指针进行访问是错误的主要来源，在许多传统的 C 或 C++ 编程风格中很难避免。例如，指针可能未初始化，是 `nullptr`，指向数组范围之外，或指向已删除的对象。
- en: '[See the current design specification here.](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)'
  id: totrans-6970
  prefs: []
  type: TYPE_NORMAL
  zh: '[在此处查看当前设计规范](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)。'
- en: 'Lifetime safety profile summary:'
  id: totrans-6971
  prefs: []
  type: TYPE_NORMAL
  zh: 生存期安全配置文件摘要：
- en: 'Lifetime.1: Don’t dereference a possibly invalid pointer: [detect or avoid](#res-deref).'
  id: totrans-6972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生存期.1：不要解引用可能无效的指针：[检测或避免](#res-deref)。
- en: Impact
  id: totrans-6973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 影响
- en: Once completely enforced through a combination of style rules, static analysis,
    and library support, this profile
  id: totrans-6974
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过组合样式规则、静态分析和库支持完全执行，此配置文件
- en: eliminates one of the major sources of nasty errors in C++
  id: totrans-6975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除了 C++ 中错误的主要来源之一
- en: eliminates a major source of potential security violations
  id: totrans-6976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除了潜在安全违规的主要来源
- en: improves performance by eliminating redundant “paranoia” checks
  id: totrans-6977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消除冗余的“偏执”检查来提高性能
- en: increases confidence in correctness of code
  id: totrans-6978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了代码正确性的信心
- en: avoids undefined behavior by enforcing a key C++ language rule
  id: totrans-6979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过强制执行关键的 C++ 语言规则来避免未定义的行为
- en: 'GSL: Guidelines support library'
  id: totrans-6980
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GSL：指南支持库
- en: The GSL is a small library of facilities designed to support this set of guidelines.
    Without these facilities, the guidelines would have to be far more restrictive
    on language details.
  id: totrans-6981
  prefs: []
  type: TYPE_NORMAL
  zh: GSL 是一个小型库，旨在支持这组指南。如果没有这些设施，指南将不得不在语言细节上更加严格。
- en: The Core Guidelines support library is defined in namespace `gsl` and the names
    might be aliases for standard library or other well-known library names. Using
    the (compile-time) indirection through the `gsl` namespace allows for experimentation
    and for local variants of the support facilities.
  id: totrans-6982
  prefs: []
  type: TYPE_NORMAL
  zh: 核心指南支持库定义在命名空间 `gsl` 中，名称可能是标准库或其他知名库名称的别名。通过 `gsl` 命名空间进行（编译时）间接引用允许进行实验和局部变体的支持设施。
- en: 'The GSL is header only, and can be found at [GSL: Guidelines support library](https://github.com/Microsoft/GSL).
    The support library facilities are designed to be extremely lightweight (zero-overhead)
    so that they impose no overhead compared to using conventional alternatives. Where
    desirable, they can be “instrumented” with additional functionality (e.g., checks)
    for tasks such as debugging.'
  id: totrans-6983
  prefs: []
  type: TYPE_NORMAL
  zh: 'GSL是头文件库，可以在[GSL: 指南支持库](https://github.com/Microsoft/GSL)中找到。支持库功能被设计得极其轻量级（零开销），因此与使用传统替代方案相比，它们不会产生任何开销。在需要的情况下，它们可以通过额外的功能（例如，检查）进行“仪器化”，以执行诸如调试等任务。'
- en: These Guidelines use types from the standard (e.g., C++17) in addition to ones
    from the GSL. For example, we assume a `variant` type, but this is not currently
    in GSL. Eventually, use [the one voted into C++17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html).
  id: totrans-6984
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南除了使用GSL的类型外，还使用标准（例如，C++17）中的类型。例如，我们假设有一个`variant`类型，但这个类型目前不在GSL中。最终，使用[被C++17采纳的那个](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html)。
- en: Some of the GSL types listed below might not be supported in the library you
    use due to technical reasons such as limitations in the current versions of C++.
    Therefore, please consult your GSL documentation to find out more.
  id: totrans-6985
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术原因，例如C++当前版本的限制，以下列出的某些GSL类型可能不在您使用的库中得到支持。因此，请查阅您的GSL文档以获取更多信息。
- en: For each GSL type below we state an invariant for that type. That invariant
    holds as long as user code only changes the state of a GSL object using the type’s
    provided member/free functions (i.e., user code does not bypass the type’s interface
    to change the object’s value/bits by violating any other Guidelines rule).
  id: totrans-6986
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个GSL类型，我们声明一个该类型的不可变性质。只要用户代码仅使用该类型的成员/自由函数更改GSL对象的状态（即用户代码不违反任何其他指南规则来绕过类型的接口更改对象的值/位），该不可变性质就保持有效。
- en: 'Summary of GSL components:'
  id: totrans-6987
  prefs: []
  type: TYPE_NORMAL
  zh: GSL组件总结：
- en: '[GSL.view: Views](#ss-views)'
  id: totrans-6988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GSL.view: 视图](#ss-views)'
- en: '[GSL.owner: Ownership pointers](#ss-ownership)'
  id: totrans-6989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GSL.owner: 所有权指针](#ss-ownership)'
- en: '[GSL.assert: Assertions](#ss-assertions)'
  id: totrans-6990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GSL.assert: 断言](#ss-assertions)'
- en: '[GSL.util: Utilities](#ss-utilities)'
  id: totrans-6991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GSL.util: 工具](#ss-utilities)'
- en: '[GSL.concept: Concepts](#ss-gsl-concepts)'
  id: totrans-6992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GSL.concept: 概念](#ss-gsl-concepts)'
- en: We plan for a “ISO C++ standard style” semi-formal specification of the GSL.
  id: totrans-6993
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划为GSL提供一个“ISO C++标准风格”的半正式规范。
- en: We rely on the ISO C++ Standard Library and hope for parts of the GSL to be
    absorbed into the standard library.
  id: totrans-6994
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖于ISO C++标准库，并希望GSL的部分内容被纳入标准库。
- en: 'GSL.view: Views'
  id: totrans-6995
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'GSL.view: 视图'
- en: These types allow the user to distinguish between owning and non-owning pointers
    and between pointers to a single object and pointers to the first element of a
    sequence.
  id: totrans-6996
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型允许用户区分所有者和非所有者指针，以及指向单个对象和指向序列的第一个元素的指针。
- en: These “views” are never owners.
  id: totrans-6997
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“视图”永远不会成为所有者。
- en: 'References are never owners (see [R.4](#rr-ref)). Note: References have many
    opportunities to outlive the objects they refer to (returning a local variable
    by reference, holding a reference to an element of a vector and doing `push_back`,
    binding to `std::max(x, y + 1)`, etc). The Lifetime safety profile aims to address
    those things, but even so `owner<T&>` does not make sense and is discouraged.'
  id: totrans-6998
  prefs: []
  type: TYPE_NORMAL
  zh: 引用永远不会成为所有者（见[R.4](#rr-ref)）。注意：引用有很多机会比它们引用的对象活得久（通过引用返回局部变量，持有向量的元素的引用并执行`push_back`，绑定到`std::max(x,
    y + 1)`等）。生命周期安全性配置文件旨在解决这些问题，但即使如此，`owner<T&>`也没有意义，并受到鼓励。
- en: 'The names are mostly ISO standard-library style (lower case and underscore):'
  id: totrans-6999
  prefs: []
  type: TYPE_NORMAL
  zh: 名称大多采用ISO标准库风格（小写和下划线）：
- en: '`T*` // The `T*` is not an owner, might be null; assumed to be pointing to
    a single element.'
  id: totrans-7000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T*` // `T*` 不是一个所有者，可能为空；假定指向单个元素。'
- en: '`T&` // The `T&` is not an owner and can never be a “null reference”; references
    are always bound to objects.'
  id: totrans-7001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T&` // `T&` 不是一个所有者，永远不能成为“空引用”；引用总是绑定到对象上。'
- en: The “raw-pointer” notation (e.g. `int*`) is assumed to have its most common
    meaning; that is, a pointer points to an object, but does not own it. Owners should
    be converted to resource handles (e.g., `unique_ptr` or `vector<T>`) or marked
    `owner<T*>`.
  id: totrans-7002
  prefs: []
  type: TYPE_NORMAL
  zh: “原始指针”表示法（例如`int*`）假定其最常见含义；即，指针指向一个对象，但不拥有它。所有者应转换为资源处理（例如，`unique_ptr`或`vector<T>`）或标记为`owner<T*>`。
- en: '`owner<T*>` // a `T*` that owns the object pointed/referred to; might be `nullptr`.'
  id: totrans-7003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner<T*>` // 指向所有被指向/引用的对象的`T*`；可能为`nullptr`。'
- en: '`owner` is used to mark owning pointers in code that cannot be upgraded to
    use proper resource handles. Reasons for that include:'
  id: totrans-7004
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner` 用于标记无法升级为使用适当资源处理的代码中的所有者指针。原因包括：'
- en: Cost of conversion.
  id: totrans-7005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换成本。
- en: The pointer is used with an ABI.
  id: totrans-7006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针与ABI一起使用。
- en: The pointer is part of the implementation of a resource handle.
  id: totrans-7007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针是资源句柄实现的一部分。
- en: An `owner<T>` differs from a resource handle for a `T` by still requiring an
    explicit `delete`.
  id: totrans-7008
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner<T>` 与 `T` 的资源句柄不同，因为它仍然需要显式 `delete`。'
- en: An `owner<T>` is assumed to refer to an object on the free store (heap).
  id: totrans-7009
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner<T>` 假设指的是堆上的对象。'
- en: 'If something is not supposed to be `nullptr`, say so:'
  id: totrans-7010
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某物不应该为 `nullptr`，请说明：
- en: '`not_null<T>` // `T` is usually a pointer type (e.g., `not_null<int*>` and
    `not_null<owner<Foo*>>`) that must not be `nullptr`. `T` can be any type for which
    `==nullptr` is meaningful.'
  id: totrans-7011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not_null<T>` // `T` 通常是一个指针类型（例如，`not_null<int*>` 和 `not_null<owner<Foo*>>`）且不能为
    `nullptr`。`T` 可以是任何对 `==nullptr` 有意义的类型。'
- en: '`span<T>` // `[p:p+n)`, constructor from `{p, q}` and `{p, n}`; `T` is the
    pointer type'
  id: totrans-7012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span<T>` // `[p:p+n)`，从 `{p, q}` 和 `{p, n}` 构造；`T` 是指针类型'
- en: '`span_p<T>` // `{p, predicate}` `[p:q)` where `q` is the first element for
    which `predicate(*p)` is true'
  id: totrans-7013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span_p<T>` // `{p, predicate}` `[p:q)` 其中 `q` 是第一个使 `predicate(*p)` 为真的元素'
- en: A `span<T>` refers to zero or more mutable `T`s unless `T` is a `const` type.
    All accesses to elements of the span, notably via `operator[]`, are guaranteed
    to be bounds-checked by default.
  id: totrans-7014
  prefs: []
  type: TYPE_NORMAL
  zh: '`span<T>` 指向零个或多个可变的 `T`，除非 `T` 是一个 `const` 类型。默认情况下，对span中元素的访问，特别是通过 `operator[]`，都保证进行边界检查。'
- en: 'Note: GSL’s `span` (initially called `array_view`) was proposed for inclusion
    in the C++ standard library, and was adopted (with changes to its name and interface)
    except only that `std::span` does not provide for guaranteed bounds checking.
    Therefore GSL changed `span`’s name and interface to track `std::span` and should
    be exactly the same as `std::span`, and the only difference should be that GSL
    `span` is fully bounds-safe by default. If bounds-safety might affect its interface,
    then those change proposals should be brought back via the ISO C++ committee to
    keep `gsl::span` interface-compatible with `std::span`. If a future evolution
    of `std::span` adds bounds checking, `gsl::span` can be removed.'
  id: totrans-7015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：GSL的 `span`（最初称为 `array_view`）被提议纳入C++标准库，并被采用（对其名称和接口进行了更改），但 `std::span`
    不提供保证的边界检查。因此，GSL更改了 `span` 的名称和接口以跟踪 `std::span`，并且应该与 `std::span` 完全相同，唯一的区别应该是GSL
    `span` 默认是完全边界安全的。如果边界安全性可能影响其接口，那么那些变更提案应通过ISO C++委员会重新提出，以保持 `gsl::span` 与 `std::span`
    的接口兼容。如果 `std::span` 的未来版本增加了边界检查，则可以移除 `gsl::span`。
- en: “Pointer arithmetic” is best done within `span`s. A `char*` that points to more
    than one `char` but is not a C-style string (e.g., a pointer into an input buffer)
    should be represented by a `span`.
  id: totrans-7016
  prefs: []
  type: TYPE_NORMAL
  zh: “指针算术”最好在 `span`s 中进行。一个指向多个 `char` 但不是C风格字符串的 `char*`（例如，指向输入缓冲区的指针）应该由一个 `span`
    表示。
- en: '`zstring` // a `char*` supposed to be a C-style string; that is, a zero-terminated
    sequence of `char` or `nullptr`'
  id: totrans-7017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zstring` // 一个假定为C风格字符串的 `char*`；即，一个以空字符终止的 `char` 序列或 `nullptr`'
- en: '`czstring` // a `const char*` supposed to be a C-style string; that is, a zero-terminated
    sequence of `const` `char` or `nullptr`'
  id: totrans-7018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`czstring` // 一个假定为C风格字符串的 `const char*`；即，一个以空字符终止的 `const` `char` 序列或 `nullptr`'
- en: Logically, those last two aliases are not needed, but we are not always logical,
    and they make the distinction between a pointer to one `char` and a pointer to
    a C-style string explicit. A sequence of characters that is not assumed to be
    zero-terminated should be a `span<char>`, or if that is impossible because of
    ABI issues a `char*`, rather than a `zstring`.
  id: totrans-7019
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，最后两个别名是不必要的，但我们并不总是那么逻辑，它们明确地区分了一个指向单个`char`的指针和一个指向C风格字符串的指针。一个不假定以空字符终止的字符序列应该是一个`span<char>`，或者如果由于ABI问题而无法实现，则是一个`char*`，而不是`zstring`。
- en: Use `not_null<zstring>` for C-style strings that cannot be `nullptr`. ??? Do
    we need a name for `not_null<zstring>`? or is its ugliness a feature?
  id: totrans-7020
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `not_null<zstring>` 对于不能为 `nullptr` 的C风格字符串。??? 我们需要为 `not_null<zstring>`
    命名吗？或者，它的丑陋是其特性？
- en: 'GSL.owner: Ownership pointers'
  id: totrans-7021
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'GSL.owner: 拥有指针'
- en: '`unique_ptr<T>` // unique ownership: `std::unique_ptr<T>`'
  id: totrans-7022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_ptr<T>` // 独占所有权：`std::unique_ptr<T>`'
- en: '`shared_ptr<T>` // shared ownership: `std::shared_ptr<T>` (a counted pointer)'
  id: totrans-7023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr<T>` // 共享所有权：`std::shared_ptr<T>`（一个计数指针）'
- en: '`stack_array<T>` // A stack-allocated array. The number of elements is determined
    at construction and fixed thereafter. The elements are mutable unless `T` is a
    `const` type.'
  id: totrans-7024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stack_array<T>` // 一个栈分配的数组。元素的数量在构造时确定，之后固定。除非 `T` 是一个 `const` 类型，否则元素是可变的。'
- en: '`dyn_array<T>` // A container, non-growing dynamically allocated array. The
    number of elements is determined at construction and fixed thereafter. The elements
    are mutable unless `T` is a `const` type. Basically a `span` that allocates and
    owns its elements.'
  id: totrans-7025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dyn_array<T>` // 一种容器，非增长的动态分配数组。元素数量在构造时确定，之后固定。除非 `T` 是 `const` 类型，否则元素是可变的。基本上是一个分配并拥有其元素的
    `span`。'
- en: 'GSL.assert: Assertions'
  id: totrans-7026
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'GSL.assert: 断言'
- en: '`Expects` // precondition assertion. Currently placed in function bodies. Later,
    should be moved to declarations. // `Expects(p)` terminates the program unless
    `p == true` // `Expects` is under control of some options (enforcement, error
    message, alternatives to terminate)'
  id: totrans-7027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Expects` // 预置条件断言。目前位于函数体中。以后应将其移动到声明中。// `Expects(p)` 除非 `p == true` 否则终止程序
    // `Expects` 受某些选项的控制（强制执行、错误消息、终止的替代方案）'
- en: '`Ensures` // postcondition assertion. Currently placed in function bodies.
    Later, should be moved to declarations.'
  id: totrans-7028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ensures` // 后置条件断言。目前位于函数体中。以后应将其移动到声明中。'
- en: 'These assertions are currently macros (yuck!) and must appear in function definitions
    (only) pending standard committee decisions on contracts and assertion syntax.
    See [the contract proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf);
    using the attribute syntax, for example, `Expects(p)` will become `[[expects:
    p]]`.'
  id: totrans-7029
  prefs: []
  type: TYPE_NORMAL
  zh: '这些断言目前是宏（真糟糕！）并且必须出现在函数定义中（仅限于此），等待标准委员会关于契约和断言语法的决定。参见[契约提议](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)；例如，使用属性语法，`Expects(p)`
    将变为 `[[expects: p]]`。'
- en: 'GSL.util: Utilities'
  id: totrans-7030
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'GSL.util: 工具'
- en: '`finally` // `finally(f)` makes a `final_action{f}` with a destructor that
    invokes `f`'
  id: totrans-7031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally` // `finally(f)` 创建一个 `final_action{f}`，其析构函数调用 `f`'
- en: '`narrow_cast` // `narrow_cast<T>(x)` is `static_cast<T>(x)`'
  id: totrans-7032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`narrow_cast` // `narrow_cast<T>(x)` 等同于 `static_cast<T>(x)`'
- en: '`narrow` // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x) ==
    x` with no signedness promotions, or it throws `narrowing_error` (e.g., `narrow<unsigned>(-42)`
    throws)'
  id: totrans-7033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`narrow` // `narrow<T>(x)` 在 `static_cast<T>(x) == x` 且没有符号提升的情况下等同于 `static_cast<T>(x)`，否则抛出
    `narrowing_error`（例如，`narrow<unsigned>(-42)` 抛出）'
- en: '`[[implicit]]` // “Marker” to put on single-argument constructors to explicitly
    make them non-explicit.'
  id: totrans-7034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[implicit]]` // 用于单参数构造函数的“标记”，以显式地使其非显式。'
- en: '`move_owner` // `p = move_owner(q)` means `p = q` but ???'
  id: totrans-7035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`move_owner` // `p = move_owner(q)` 意味着 `p = q` 但 ???'
- en: '`joining_thread` // a RAII style version of `std::thread` that joins.'
  id: totrans-7036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`joining_thread` // 一种与 `std::thread` 相结合的 RAII 风格版本，用于连接。'
- en: '`index` // a type to use for all container and array indexing (currently an
    alias for `ptrdiff_t`)'
  id: totrans-7037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index` // 用于所有容器和数组索引的类型（目前是 `ptrdiff_t` 的别名）'
- en: 'GSL.concept: Concepts'
  id: totrans-7038
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'GSL.concept: 概念'
- en: These concepts (type predicates) are borrowed from Andrew Sutton’s Origin library,
    the Range proposal, and the ISO WG21 Palo Alto TR. Many of them are very similar
    to what became part of the ISO C++ standard in C++20.
  id: totrans-7039
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念（类型谓词）借鉴自 Andrew Sutton 的 Origin 库、范围提议以及 ISO WG21 Palo Alto TR。其中许多与 C++20
    中成为 ISO C++ 标准一部分的内容非常相似。
- en: '`String`'
  id: totrans-7040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`Number`'
  id: totrans-7041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`'
- en: '`Boolean`'
  id: totrans-7042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`'
- en: '`Range` // in C++20, `std::ranges::range`'
  id: totrans-7043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range` // 在 C++20 中，`std::ranges::range`'
- en: '`Sortable` // in C++20, `std::sortable`'
  id: totrans-7044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sortable` // 在 C++20 中，`std::sortable`'
- en: '`EqualityComparable` // in C++20, `std::equality_comparable`'
  id: totrans-7045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EqualityComparable` // 在 C++20 中，`std::equality_comparable`'
- en: '`Convertible` // in C++20, `std::convertible_to`'
  id: totrans-7046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Convertible` // 在 C++20 中，`std::convertible_to`'
- en: '`Common` // in C++20, `std::common_with`'
  id: totrans-7047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Common` // 在 C++20 中，`std::common_with`'
- en: '`Integral` // in C++20, `std::integral`'
  id: totrans-7048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Integral` // 在 C++20 中，`std::integral`'
- en: '`SignedIntegral` // in C++20, `std::signed_integral`'
  id: totrans-7049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SignedIntegral` // 在 C++20 中，`std::signed_integral`'
- en: '`SemiRegular` // in C++20, `std::semiregular`'
  id: totrans-7050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SemiRegular` // 在 C++20 中，`std::semiregular`'
- en: '`Regular` // in C++20, `std::regular`'
  id: totrans-7051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Regular` // 在 C++20 中，`std::regular`'
- en: '`TotallyOrdered` // in C++20, `std::totally_ordered`'
  id: totrans-7052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TotallyOrdered` // 在 C++20 中，`std::totally_ordered`'
- en: '`Function` // in C++20, `std::invocable`'
  id: totrans-7053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function` // 在 C++20 中，`std::invocable`'
- en: '`RegularFunction` // in C++20, `std::regular_invocable`'
  id: totrans-7054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegularFunction` // 在 C++20 中，`std::regular_invocable`'
- en: '`Predicate` // in C++20, `std::predicate`'
  id: totrans-7055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Predicate` // 在 C++20 中，`std::predicate`'
- en: '`Relation` // in C++20, `std::relation`'
  id: totrans-7056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Relation` // 在 C++20 中，`std::relation`'
- en: …
  id: totrans-7057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: …
- en: 'GSL.ptr: Smart pointer concepts'
  id: totrans-7058
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'GSL.ptr: 智能指针概念'
- en: '`Pointer` // A type with `*`, `->`, `==`, and default construction (default
    construction is assumed to set the singular “null” value)'
  id: totrans-7059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pointer` // 一种具有 `*`、`->`、`==` 和默认构造（默认构造假定设置单个“空”值）的类型'
- en: '`Unique_pointer` // A type that matches `Pointer`, is movable, and is not copyable'
  id: totrans-7060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unique_pointer` // 一种与 `Pointer` 匹配、可移动且不可复制的类型'
- en: '`Shared_pointer` // A type that matches `Pointer`, and is copyable'
  id: totrans-7061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shared_pointer` // 一种与 `Pointer` 匹配且可复制的类型'
- en: 'NL: Naming and layout suggestions'
  id: totrans-7062
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'NL: 命名和布局建议'
- en: Consistent naming and layout are helpful. If for no other reason because it
    minimizes “my style is better than your style” arguments. However, there are many,
    many, different styles around and people are passionate about them (pro and con).
    Also, most real-world projects include code from many sources, so standardizing
    on a single style for all code is often impossible. After many requests for guidance
    from users, we present a set of rules that you might use if you have no better
    ideas, but the real aim is consistency, rather than any particular rule set. IDEs
    and tools can help (as well as hinder).
  id: totrans-7063
  prefs: []
  type: TYPE_NORMAL
  zh: 一致的命名和布局是有帮助的。如果只是为了减少“我的风格比你的风格好”的争论，这也是一个原因。然而，有很多人和不同的风格，人们对它们都很热情（无论是赞成还是反对）。此外，大多数现实世界的项目都包含来自许多来源的代码，因此为所有代码标准化单一风格通常是不可行的。在用户多次请求指导后，我们提供了一套规则，如果你没有更好的想法，你可以使用这些规则，但真正的目的是一致性，而不是任何特定的规则集。IDEs和工具可以帮助（也可能阻碍）。
- en: 'Naming and layout rules:'
  id: totrans-7064
  prefs: []
  type: TYPE_NORMAL
  zh: 命名和布局规则：
- en: '[NL.1: Don’t say in comments what can be clearly stated in code](#rl-comments)'
  id: totrans-7065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.1: 不要在注释中说出代码中可以明确表达的内容](#rl-comments)'
- en: '[NL.2: State intent in comments](#rl-comments-intent)'
  id: totrans-7066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.2: 在注释中表达意图](#rl-comments-intent)'
- en: '[NL.3: Keep comments crisp](#rl-comments-crisp)'
  id: totrans-7067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.3: 保持注释简洁](#rl-comments-crisp)'
- en: '[NL.4: Maintain a consistent indentation style](#rl-indent)'
  id: totrans-7068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.4: 保持一致的缩进风格](#rl-indent)'
- en: '[NL.5: Avoid encoding type information in names](#rl-name-type)'
  id: totrans-7069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.5: 避免在名称中编码类型信息](#rl-name-type)'
- en: '[NL.7: Make the length of a name roughly proportional to the length of its
    scope](#rl-name-length)'
  id: totrans-7070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.7: 使名称的长度与其作用域的长度大致成比例](#rl-name-length)'
- en: '[NL.8: Use a consistent naming style](#rl-name)'
  id: totrans-7071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.8: 使用一致的命名风格](#rl-name)'
- en: '[NL.9: Use `ALL_CAPS` for macro names only](#rl-all-caps)'
  id: totrans-7072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.9: 仅对宏名称使用`ALL_CAPS`](#rl-all-caps)'
- en: '[NL.10: Prefer `underscore_style` names](#rl-camel)'
  id: totrans-7073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.10: 优先使用`下划线风格`的名称](#rl-camel)'
- en: '[NL.11: Make literals readable](#rl-literals)'
  id: totrans-7074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.11: 使字面量可读](#rl-literals)'
- en: '[NL.15: Use spaces sparingly](#rl-space)'
  id: totrans-7075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.15: 节省使用空格](#rl-space)'
- en: '[NL.16: Use a conventional class member declaration order](#rl-order)'
  id: totrans-7076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.16: 使用传统的类成员声明顺序](#rl-order)'
- en: '[NL.17: Use K&R-derived layout](#rl-knr)'
  id: totrans-7077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.17: 使用K&R风格的布局](#rl-knr)'
- en: '[NL.18: Use C++-style declarator layout](#rl-ptr)'
  id: totrans-7078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.18: 使用C++风格的声明符布局](#rl-ptr)'
- en: '[NL.19: Avoid names that are easily misread](#rl-misread)'
  id: totrans-7079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.19: 避免易读错的名称](#rl-misread)'
- en: '[NL.20: Don’t place two statements on the same line](#rl-stmt)'
  id: totrans-7080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.20: 不要在同一行放置两个语句](#rl-stmt)'
- en: '[NL.21: Declare one name (only) per declaration](#rl-dcl)'
  id: totrans-7081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.21: 每个声明只声明一个名称（仅此而已）](#rl-dcl)'
- en: '[NL.25: Don’t use `void` as an argument type](#rl-void)'
  id: totrans-7082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.25: 不要将`void`用作参数类型](#rl-void)'
- en: '[NL.26: Use conventional `const` notation](#rl-const)'
  id: totrans-7083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.26: 仅对宏名称使用传统的`const`表示法](#rl-const)'
- en: '[NL.27: Use a `.cpp` suffix for code files and `.h` for interface files](#rl-file-suffix)'
  id: totrans-7084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NL.27: 为代码文件使用`.cpp`后缀，为接口文件使用`.h`后缀](#rl-file-suffix)'
- en: Most of these rules are aesthetic and programmers hold strong opinions. IDEs
    also tend to have defaults and a range of alternatives. These rules are suggested
    defaults to follow unless you have reasons not to.
  id: totrans-7085
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些规则都是关于美学的，程序员对此有强烈的看法。IDEs也倾向于有默认值和一系列替代方案。除非你有不遵循这些规则的理由，否则这些规则是建议的默认值。
- en: We have had comments to the effect that naming and layout are so personal and/or
    arbitrary that we should not try to “legislate” them. We are not “legislating”
    (see the previous paragraph). However, we have had many requests for a set of
    naming and layout conventions to use when there are no external constraints.
  id: totrans-7086
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了一些评论，认为命名和布局非常个人化和/或任意，我们不应该试图“立法”它们。我们并不是在“立法”（参见上一段）。然而，我们收到了许多请求，希望有一套命名和布局约定可以使用，当没有外部约束时。
- en: More specific and detailed rules are easier to enforce.
  id: totrans-7087
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体和详细的规则更容易执行。
- en: 'These rules bear a strong resemblance to the recommendations in the [PPP Style
    Guide](https://www.stroustrup.com/Programming/PPP-style.pdf) written in support
    of Stroustrup’s [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html).'
  id: totrans-7088
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则与[PPP风格指南](https://www.stroustrup.com/Programming/PPP-style.pdf)中的建议有很强的相似性，该指南是为了支持Stroustrup的[《C++程序设计：原理与实践》](https://www.stroustrup.com/programming.html)。
- en: 'NL.1: Don’t say in comments what can be clearly stated in code'
  id: totrans-7089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.1: 不要在注释中说出代码中可以明确表达的内容'
- en: Reason
  id: totrans-7090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Compilers do not read comments. Comments are less precise than code. Comments
    are not updated as consistently as code.
  id: totrans-7091
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不读取注释。注释不如代码精确。注释的更新不如代码一致。
- en: Example, bad
  id: totrans-7092
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例如，不好
- en: '[PRE875]'
  id: totrans-7093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: Enforcement
  id: totrans-7094
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Build an AI program that interprets colloquial English text and see if what
    is said could be better expressed in C++.
  id: totrans-7095
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个AI程序，该程序可以解释口语化的英语文本，并查看是否可以用C++更好地表达所说的话。
- en: 'NL.2: State intent in comments'
  id: totrans-7096
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.2：在注释中声明意图
- en: Reason
  id: totrans-7097
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Code says what is done, not what is supposed to be done. Often intent can be
    stated more clearly and concisely than the implementation.
  id: totrans-7098
  prefs: []
  type: TYPE_NORMAL
  zh: 代码说明的是做了什么，而不是应该做什么。通常意图可以用比实现更清晰、更简洁的方式表达。
- en: Example
  id: totrans-7099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE876]'
  id: totrans-7100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: Note
  id: totrans-7101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If the comment and the code disagree, both are likely to be wrong.
  id: totrans-7102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注释和代码不一致，两者都可能出错。
- en: 'NL.3: Keep comments crisp'
  id: totrans-7103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.3：保持注释简洁
- en: Reason
  id: totrans-7104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Verbosity slows down understanding and makes the code harder to read by spreading
    it around in the source file.
  id: totrans-7105
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽性会减慢理解速度，并使代码在源文件中分散，从而难以阅读。
- en: Note
  id: totrans-7106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Use intelligible English. I might be fluent in Danish, but most programmers
    are not; the maintainers of my code might not be. Avoid SMS lingo and watch your
    grammar, punctuation, and capitalization. Aim for professionalism, not “cool.”
  id: totrans-7107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可理解的英语。我可能丹麦语很流利，但大多数程序员不是；我的代码的维护者可能也不是。避免使用短信语言，注意你的语法、标点符号和大小写。追求专业，而不是“酷”。
- en: Enforcement
  id: totrans-7108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: not possible.
  id: totrans-7109
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能。
- en: 'NL.4: Maintain a consistent indentation style'
  id: totrans-7110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.4：保持一致的缩进风格
- en: Reason
  id: totrans-7111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Avoidance of “silly mistakes.”
  id: totrans-7112
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。避免“愚蠢的错误”。
- en: Example, bad
  id: totrans-7113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好
- en: '[PRE877]'
  id: totrans-7114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: Note
  id: totrans-7115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Always indenting the statement after `if (...)`, `for (...)`, and `while (...)`
    is usually a good idea:'
  id: totrans-7116
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在`if (...)`、`for (...)`和`while (...)`之后的语句缩进通常是个好主意：
- en: '[PRE878]'
  id: totrans-7117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: Enforcement
  id: totrans-7118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Use a tool.
  id: totrans-7119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具。
- en: 'NL.5: Avoid encoding type information in names'
  id: totrans-7120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.5：避免在名称中编码类型信息
- en: Rationale
  id: totrans-7121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理由
- en: If names reflect types rather than functionality, it becomes hard to change
    the types used to provide that functionality. Also, if the type of a variable
    is changed, code using it will have to be modified. Minimize unintentional conversions.
  id: totrans-7122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名称反映类型而不是功能，那么更改用于提供该功能的类型就会变得困难。此外，如果变量的类型发生变化，使用它的代码将需要修改。尽量减少意外的转换。
- en: Example, bad
  id: totrans-7123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，不好
- en: '[PRE879]'
  id: totrans-7124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: Example, good
  id: totrans-7125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子，好
- en: '[PRE880]'
  id: totrans-7126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: Note
  id: totrans-7127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Names with types encoded are either verbose or cryptic.
  id: totrans-7128
  prefs: []
  type: TYPE_NORMAL
  zh: 编码类型的名称要么冗长，要么晦涩。
- en: '[PRE881]'
  id: totrans-7129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: Requiring techniques like Hungarian notation to encode a type has been used
    in untyped languages, but is generally unnecessary and actively harmful in a strongly
    statically-typed language like C++, because the annotations get out of date (the
    warts are just like comments and rot just like them) and they interfere with good
    use of the language (use the same name and overload resolution instead).
  id: totrans-7130
  prefs: []
  type: TYPE_NORMAL
  zh: 在无类型语言中使用像匈牙利符号这样的技术来编码类型已被使用，但在像C++这样的强静态类型语言中通常是不必要的，甚至是有害的，因为注解会过时（这些瑕疵就像注释一样，会像它们一样腐烂）并且会干扰语言的良好使用（使用相同的名称并使用重载解析代替）。
- en: Note
  id: totrans-7131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some styles use very general (not type-specific) prefixes to denote the general
    use of a variable.
  id: totrans-7132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些风格使用非常通用的（非类型特定）前缀来表示变量的通用用途。
- en: '[PRE882]'
  id: totrans-7133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: This is not harmful and does not fall under this guideline because it does not
    encode type information.
  id: totrans-7134
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不有害，也不属于此指南范畴，因为它没有编码类型信息。
- en: Note
  id: totrans-7135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some styles distinguish members from local variable, and/or from global variable.
  id: totrans-7136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些风格区分成员变量与局部变量，以及/或全局变量。
- en: '[PRE883]'
  id: totrans-7137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: This is not harmful and does not fall under this guideline because it does not
    encode type information.
  id: totrans-7138
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不有害，也不属于此指南范畴，因为它没有编码类型信息。
- en: Note
  id: totrans-7139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Like C++, some styles distinguish types from non-types. For example, by capitalizing
    type names, but not the names of functions and variables.
  id: totrans-7140
  prefs: []
  type: TYPE_NORMAL
  zh: 像C++一样，一些风格区分类型和非类型。例如，通过将类型名称大写，但不将函数和变量的名称大写。
- en: '[PRE884]'
  id: totrans-7141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: This is not harmful and does not fall under this guideline because it does not
    encode type information.
  id: totrans-7142
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不有害，也不属于此指南范畴，因为它没有编码类型信息。
- en: 'NL.7: Make the length of a name roughly proportional to the length of its scope'
  id: totrans-7143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.7：使名称的长度与其作用域的长度大致成比例
- en: '**Rationale**: The larger the scope the greater the chance of confusion and
    of an unintended name clash.'
  id: totrans-7144
  prefs: []
  type: TYPE_NORMAL
  zh: '**理由**：作用域越大，混淆和意外名称冲突的机会就越大。'
- en: Example
  id: totrans-7145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE885]'
  id: totrans-7146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: The use of `p` for pointer and `x` for a floating-point variable is conventional
    and non-confusing in a restricted scope.
  id: totrans-7147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`p`表示指针和`x`表示浮点变量在受限的作用域内是传统且不混淆的。
- en: Enforcement
  id: totrans-7148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: ???
  id: totrans-7149
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'NL.8: Use a consistent naming style'
  id: totrans-7150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.8：使用一致的命名风格
- en: '**Rationale**: Consistency in naming and naming style increases readability.'
  id: totrans-7151
  prefs: []
  type: TYPE_NORMAL
  zh: '**理由**：命名和命名风格的一致性提高了可读性。'
- en: Note
  id: totrans-7152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are many styles and when you use multiple libraries, you can’t follow
    all their different conventions. Choose a “house style”, but leave “imported”
    libraries with their original style.
  id: totrans-7153
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多风格，当你使用多个库时，你无法遵循它们的所有不同约定。选择一种“家庭风格”，但保留“导入”库的原始风格。
- en: Example
  id: totrans-7154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'ISO Standard, use lower case only and digits, separate words with underscores:'
  id: totrans-7155
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 标准，仅使用小写字母和数字，单词之间用下划线分隔：
- en: '`int`'
  id: totrans-7156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`vector`'
  id: totrans-7157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector`'
- en: '`my_map`'
  id: totrans-7158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_map`'
- en: Avoid identifier names that contain double underscores `__` or that start with
    an underscore followed by a capital letter (e.g., `_Throws`). Such identifiers
    are reserved for the C++ implementation.
  id: totrans-7159
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用包含双下划线 `__` 或以下划线开头后跟大写字母（例如，`_Throws`）的标识符名称。这些标识符是为 C++ 实现保留的。
- en: Example
  id: totrans-7160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[Stroustrup](https://www.stroustrup.com/Programming/PPP-style.pdf): ISO Standard,
    but with upper case used for your own types and concepts:'
  id: totrans-7161
  prefs: []
  type: TYPE_NORMAL
  zh: '[斯特劳斯特普](https://www.stroustrup.com/Programming/PPP-style.pdf)：ISO 标准，但使用大写字母用于自己的类型和概念：'
- en: '`int`'
  id: totrans-7162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`vector`'
  id: totrans-7163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector`'
- en: '`My_map`'
  id: totrans-7164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`My_map`'
- en: Example
  id: totrans-7165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'CamelCase: capitalize each word in a multi-word identifier:'
  id: totrans-7166
  prefs: []
  type: TYPE_NORMAL
  zh: 驼峰式命名法：在多词标识符中的每个单词首字母大写：
- en: '`int`'
  id: totrans-7167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`vector`'
  id: totrans-7168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector`'
- en: '`MyMap`'
  id: totrans-7169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyMap`'
- en: '`myMap`'
  id: totrans-7170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myMap`'
- en: Some conventions capitalize the first letter, some don’t.
  id: totrans-7171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些约定将首字母大写，而另一些则不这样做。
- en: Note
  id: totrans-7172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Try to be consistent in your use of acronyms and lengths of identifiers:'
  id: totrans-7173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量在缩写词和标识符长度的一致性上保持一致：
- en: '[PRE886]'
  id: totrans-7174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: Enforcement
  id: totrans-7175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Would be possible except for the use of libraries with varying conventions.
  id: totrans-7176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用具有不同约定的库之外，这是可能的。
- en: 'NL.9: Use `ALL_CAPS` for macro names only'
  id: totrans-7177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.9：仅对宏名称使用 `ALL_CAPS`
- en: Reason
  id: totrans-7178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid confusing macros with names that obey scope and type rules.
  id: totrans-7179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免将宏与遵守范围和类型规则的名称混淆。
- en: Example
  id: totrans-7180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE887]'
  id: totrans-7181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: Note
  id: totrans-7182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In particular, this avoids confusing macros with non-macro symbolic constants
    (see also [Enum.5: Don’t use `ALL_CAPS` for enumerators](#renum-caps))'
  id: totrans-7183
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是这避免了将宏与非宏符号常量混淆（参见[枚举.5：不要使用 `ALL_CAPS` 作为枚举值](#renum-caps)）
- en: '[PRE888]'
  id: totrans-7184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: Enforcement
  id: totrans-7185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag macros with lower-case letters
  id: totrans-7186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用小写字母标记宏
- en: Flag `ALL_CAPS` non-macro names
  id: totrans-7187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记 `ALL_CAPS` 非宏名称
- en: 'NL.10: Prefer `underscore_style` names'
  id: totrans-7188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.10：优先使用 `underscore_style` 名称
- en: Reason
  id: totrans-7189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The use of underscores to separate parts of a name is the original C and C++
    style and used in the C++ Standard Library.
  id: totrans-7190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下划线分隔名称部分是 C 和 C++ 的原始风格，并在 C++ 标准库中使用。
- en: Note
  id: totrans-7191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This rule is a default to use only if you have a choice. Often, you don’t have
    a choice and must follow an established style for [consistency](#rl-name). The
    need for consistency beats personal taste.
  id: totrans-7192
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则是默认使用，仅在你有选择的情况下使用。通常，你没有选择，必须遵循既定的风格以保持[一致性](#rl-name)。一致性的需要胜过个人品味。
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  id: totrans-7193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[当你没有约束或更好的想法时](#s-naming)的建议。此规则是在收到许多指导请求后添加的。
- en: Example
  id: totrans-7194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[Stroustrup](https://www.stroustrup.com/Programming/PPP-style.pdf): ISO Standard,
    but with upper case used for your own types and concepts:'
  id: totrans-7195
  prefs: []
  type: TYPE_NORMAL
  zh: '[斯特劳斯特普](https://www.stroustrup.com/Programming/PPP-style.pdf)：ISO 标准，但使用大写字母用于自己的类型和概念：'
- en: '`int`'
  id: totrans-7196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`vector`'
  id: totrans-7197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector`'
- en: '`My_map`'
  id: totrans-7198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`My_map`'
- en: Enforcement
  id: totrans-7199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Impossible.
  id: totrans-7200
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能。
- en: 'NL.11: Make literals readable'
  id: totrans-7201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.11：使文字常量可读
- en: Reason
  id: totrans-7202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability.
  id: totrans-7203
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。
- en: Example
  id: totrans-7204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Use digit separators to avoid long strings of digits
  id: totrans-7205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数字分隔符以避免长数字字符串
- en: '[PRE889]'
  id: totrans-7206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: Example
  id: totrans-7207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Use literal suffixes where clarification is needed
  id: totrans-7208
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要澄清的地方使用文字后缀
- en: '[PRE890]'
  id: totrans-7209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: Note
  id: totrans-7210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Literals should not be sprinkled all over the code as [“magic constants”](#res-magic),
    but it is still a good idea to make them readable where they are defined. It is
    easy to make a typo in a long string of integers.
  id: totrans-7211
  prefs: []
  type: TYPE_NORMAL
  zh: 文字常量不应像[“魔法常量”](#res-magic)那样散布在代码中，但仍然是一个好主意，使它们在定义的地方可读。在长整数字符串中容易出错。
- en: Enforcement
  id: totrans-7212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag long digit sequences. The trouble is to define “long”; maybe 7.
  id: totrans-7213
  prefs: []
  type: TYPE_NORMAL
  zh: 标记长数字序列。问题是定义“长”；也许7。
- en: 'NL.15: Use spaces sparingly'
  id: totrans-7214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.15：谨慎使用空格
- en: Reason
  id: totrans-7215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Too much space makes the text larger and distracts.
  id: totrans-7216
  prefs: []
  type: TYPE_NORMAL
  zh: 过多的空格会使文本变大并分散注意力。
- en: Example, bad
  id: totrans-7217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE891]'
  id: totrans-7218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: Example
  id: totrans-7219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE892]'
  id: totrans-7220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: Note
  id: totrans-7221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some IDEs have their own opinions and add distracting space.
  id: totrans-7222
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 IDE 有自己的观点，并添加分散注意力的空格。
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  id: totrans-7223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[当你没有约束或更好的想法时](#s-naming)的建议。此规则是在收到许多指导请求后添加的。
- en: Note
  id: totrans-7224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We value well-placed whitespace as a significant help for readability. Just
    don’t overdo it.
  id: totrans-7225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重视合理放置的空白，因为它对可读性有很大帮助。只是不要过度使用。
- en: 'NL.16: Use a conventional class member declaration order'
  id: totrans-7226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.16: 使用常规类成员声明顺序'
- en: Reason
  id: totrans-7227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: A conventional order of members improves readability.
  id: totrans-7228
  prefs: []
  type: TYPE_NORMAL
  zh: 成员的常规顺序可以提高可读性。
- en: When declaring a class use the following order
  id: totrans-7229
  prefs: []
  type: TYPE_NORMAL
  zh: 声明类时，请使用以下顺序
- en: 'types: classes, enums, and aliases (`using`)'
  id: totrans-7230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'types: 类、枚举和别名（`using`）'
- en: constructors, assignments, destructor
  id: totrans-7231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数、赋值操作、析构函数
- en: functions
  id: totrans-7232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: data
  id: totrans-7233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Use the `public` before `protected` before `private` order.
  id: totrans-7234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `public` 在 `protected` 之前，再在 `private` 之前。
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  id: totrans-7235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[当你没有约束或更好的想法时](#s-naming)的建议。此规则是在许多指导请求之后添加的。
- en: Example
  id: totrans-7236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE893]'
  id: totrans-7237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: Example
  id: totrans-7238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: Sometimes, the default order of members conflicts with a desire to separate
    the public interface from implementation details. In such cases, private types
    and functions can be placed with private data.
  id: totrans-7239
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，成员的默认顺序与将公共接口与实现细节分开的愿望相冲突。在这种情况下，可以将私有类型和函数与私有数据一起放置。
- en: '[PRE894]'
  id: totrans-7240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: Example, bad
  id: totrans-7241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: Avoid multiple blocks of declarations of one access (e.g., `public`) dispersed
    among blocks of declarations with different access (e.g. `private`).
  id: totrans-7242
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在具有不同访问权限（例如 `private`）的声明块中分散一个访问（例如 `public`）的多个声明块。
- en: '[PRE895]'
  id: totrans-7243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: The use of macros to declare groups of members often leads to violation of any
    ordering rules. However, using macros obscures what is being expressed anyway.
  id: totrans-7244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏来声明成员组通常会导致违反任何排序规则。然而，使用宏会掩盖所表达的内容。
- en: Enforcement
  id: totrans-7245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Flag departures from the suggested order. There will be a lot of old code that
    doesn’t follow this rule.
  id: totrans-7246
  prefs: []
  type: TYPE_NORMAL
  zh: 标记偏离建议的顺序。将会有很多不遵循此规则的旧代码。
- en: 'NL.17: Use K&R-derived layout'
  id: totrans-7247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.17: 使用 K&R 衍生的布局'
- en: Reason
  id: totrans-7248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: This is the original C and C++ layout. It preserves vertical space well. It
    distinguishes different language constructs (such as functions and classes) well.
  id: totrans-7249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始的 C 和 C++ 布局。它很好地保留了垂直空间。它很好地区分了不同的语言结构（如函数和类）。
- en: Note
  id: totrans-7250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the context of C++, this style is often called “Stroustrup”.
  id: totrans-7251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 的上下文中，这种风格通常被称为“斯特劳斯特普”。
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  id: totrans-7252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[当你没有约束或更好的想法时](#s-naming)的建议。此规则是在许多指导请求之后添加的。
- en: Example
  id: totrans-7253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE896]'
  id: totrans-7254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: Note the space between `if` and `(`
  id: totrans-7255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `if` 和 `(` 之间的空格
- en: Note
  id: totrans-7256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Use separate lines for each statement, the branches of an `if`, and the body
    of a `for`.
  id: totrans-7257
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个语句、`if` 的分支和 `for` 的主体使用单独的行。
- en: Note
  id: totrans-7258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `{` for a `class` and a `struct` is *not* on a separate line, but the `{`
    for a function is.
  id: totrans-7259
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 和 `struct` 的 `{` 不是在单独的一行上，但函数的 `{` 是。'
- en: Note
  id: totrans-7260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Capitalize the names of your user-defined types to distinguish them from standards-library
    types.
  id: totrans-7261
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户定义类型的名称大写，以区分标准库类型。
- en: Note
  id: totrans-7262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Do not capitalize function names.
  id: totrans-7263
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将函数名称大写。
- en: Enforcement
  id: totrans-7264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: If you want enforcement, use an IDE to reformat.
  id: totrans-7265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要强制执行，请使用 IDE 重新格式化。
- en: 'NL.18: Use C++-style declarator layout'
  id: totrans-7266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.18: 使用 C++ 风格的声明符布局'
- en: Reason
  id: totrans-7267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: The C-style layout emphasizes use in expressions and grammar, whereas the C++-style
    emphasizes types. The use in expressions argument doesn’t hold for references.
  id: totrans-7268
  prefs: []
  type: TYPE_NORMAL
  zh: C 风格布局强调在表达式和语法中的使用，而 C++ 风格布局强调类型。对于引用，这个在表达式中的使用论点不成立。
- en: Example
  id: totrans-7269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE897]'
  id: totrans-7270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: Note
  id: totrans-7271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  id: totrans-7272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[当你没有约束或更好的想法时](#s-naming)的建议。此规则是在许多指导请求之后添加的。
- en: Enforcement
  id: totrans-7273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Impossible in the face of history.
  id: totrans-7274
  prefs: []
  type: TYPE_NORMAL
  zh: 面对历史，这是不可能的。
- en: 'NL.19: Avoid names that are easily misread'
  id: totrans-7275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.19: 避免易读错的名称'
- en: Reason
  id: totrans-7276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Not everyone has screens and printers that make it easy to distinguish
    all characters. We easily confuse similarly spelled and slightly misspelled words.
  id: totrans-7277
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。并非每个人都有屏幕和打印机可以轻松区分所有字符。我们很容易混淆拼写相似和轻微拼写错误的单词。
- en: Example
  id: totrans-7278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE898]'
  id: totrans-7279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: Enforcement
  id: totrans-7280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: ???
  id: totrans-7281
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'NL.20: Don’t place two statements on the same line'
  id: totrans-7282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.20: 不要在同一行上放置两个语句'
- en: Reason
  id: totrans-7283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. It is really easy to overlook a statement when there is more on
    a line.
  id: totrans-7284
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。当一行上有更多内容时，很容易忽略一个语句。
- en: Example
  id: totrans-7285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE899]'
  id: totrans-7286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: Enforcement
  id: totrans-7287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制执行
- en: Easy.
  id: totrans-7288
  prefs: []
  type: TYPE_NORMAL
  zh: 容易。
- en: 'NL.21: Declare one name (only) per declaration'
  id: totrans-7289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.21: 每个声明中只声明一个名称'
- en: Reason
  id: totrans-7290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Readability. Minimizing confusion with the declarator syntax.
  id: totrans-7291
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性。最小化与声明符语法的混淆。
- en: Note
  id: totrans-7292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For details, see [ES.10](#res-name-one).
  id: totrans-7293
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅 [ES.10](#res-name-one)。
- en: 'NL.25: Don’t use `void` as an argument type'
  id: totrans-7294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'NL.25: 不要使用 `void` 作为参数类型'
- en: Reason
  id: totrans-7295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s verbose and only needed where C compatibility matters.
  id: totrans-7296
  prefs: []
  type: TYPE_NORMAL
  zh: 它很冗长，只有在需要C兼容性时才需要。
- en: Example
  id: totrans-7297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE900]'
  id: totrans-7298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: Note
  id: totrans-7299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Even Dennis Ritchie deemed `void f(void)` an abomination. You can make an argument
    for that abomination in C when function prototypes were rare so that banning:'
  id: totrans-7300
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是丹尼斯·里奇也认为`void f(void)`是一种丑陋的做法。在函数原型很少的C语言中，你可以为这种丑陋的做法进行辩护，当时禁止：
- en: '[PRE901]'
  id: totrans-7301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: would have caused major problems, but not in the 21st century and in C++.
  id: totrans-7302
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会引起重大问题，但在21世纪和C++中不会。
- en: 'NL.26: Use conventional `const` notation'
  id: totrans-7303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.26：使用传统的`const`符号
- en: Reason
  id: totrans-7304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Conventional notation is more familiar to more programmers. Consistency in large
    code bases.
  id: totrans-7305
  prefs: []
  type: TYPE_NORMAL
  zh: 传统符号对更多程序员来说更为熟悉。在大型的代码库中保持一致性。
- en: Example
  id: totrans-7306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE902]'
  id: totrans-7307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: Note
  id: totrans-7308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We are well aware that you could claim the “bad” examples are more logical than
    the ones marked “OK”, but they also confuse more people, especially novices relying
    on teaching material using the far more common, conventional OK style.
  id: totrans-7309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常清楚，你可能会声称“不好”的例子比标记为“OK”的例子更有逻辑性，但它们也会让更多的人感到困惑，尤其是那些依赖使用更为常见、传统的OK风格的教材的新手。
- en: As ever, remember that the aim of these naming and layout rules is consistency
    and that aesthetics vary immensely.
  id: totrans-7310
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，请记住，这些命名和布局规则的目标是一致性，而美学差异很大。
- en: This is a recommendation for [when you have no constraints or better ideas](#s-naming).
    This rule was added after many requests for guidance.
  id: totrans-7311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对[当你没有限制或更好的想法时](#s-naming)的建议。这个规则是在许多请求指导后添加的。
- en: Enforcement
  id: totrans-7312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag `const` used as a suffix for a type.
  id: totrans-7313
  prefs: []
  type: TYPE_NORMAL
  zh: 将`const`用作类型的后缀。
- en: 'NL.27: Use a `.cpp` suffix for code files and `.h` for interface files'
  id: totrans-7314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NL.27：为代码文件使用`.cpp`后缀，为接口文件使用`.h`
- en: Reason
  id: totrans-7315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It’s a longstanding convention. But consistency is more important, so if your
    project uses something else, follow that.
  id: totrans-7316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长期的传统。但一致性更重要，所以如果你的项目使用其他东西，就遵循那个。
- en: Note
  id: totrans-7317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This convention reflects a common use pattern: Headers are more often shared
    with C to compile as both C++ and C, which typically uses `.h`, and it’s easier
    to name all headers `.h` instead of having different extensions for just those
    headers that are intended to be shared with C. On the other hand, implementation
    files are rarely shared with C and so should typically be distinguished from `.c`
    files, so it’s normally best to name all C++ implementation files something else
    (such as `.cpp`).'
  id: totrans-7318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定反映了常见的使用模式：头文件更常与C一起编译，作为C++和C（通常使用`.h`）的编译，而将所有头文件命名为`.h`比只为那些打算与C共享的头文件使用不同的扩展名更容易。另一方面，实现文件很少与C共享，因此通常应该与`.c`文件区分开来，所以通常最好将所有C++实现文件命名为其他名称（例如`.cpp`）。
- en: The specific names `.h` and `.cpp` are not required (just recommended as a default)
    and other names are in widespread use. Examples are `.hh`, `.C`, and `.cxx`. Use
    such names equivalently. In this document, we refer to `.h` and `.cpp` as a shorthand
    for header and implementation files, even though the actual extension might be
    different.
  id: totrans-7319
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的名称`.h`和`.cpp`不是必需的（只是作为默认推荐），其他名称也广泛使用。例如，`.hh`、`.C`和`.cxx`。等效地使用这些名称。在本文档中，我们使用`.h`和`.cpp`作为头文件和实现文件的简称，即使实际的扩展名可能不同。
- en: Your IDE (if you use one) might have strong opinions about suffixes.
  id: totrans-7320
  prefs: []
  type: TYPE_NORMAL
  zh: 你的IDE（如果你使用的话）可能对后缀有强烈的看法。
- en: Example
  id: totrans-7321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE903]'
  id: totrans-7322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: '`foo.h` provides the interface to `foo.cpp`. Global variables are best avoided.'
  id: totrans-7323
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo.h`提供了对`foo.cpp`的接口。最好避免使用全局变量。'
- en: Example, bad
  id: totrans-7324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例，不好
- en: '[PRE904]'
  id: totrans-7325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: '`#include <foo.h>` twice in a program and you get a linker error for two one-definition-rule
    violations.'
  id: totrans-7326
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中两次包含`#include <foo.h>`，你会因为违反单一定义规则而得到链接器错误。
- en: Enforcement
  id: totrans-7327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Flag non-conventional file names.
  id: totrans-7328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记非常规的文件名。
- en: Check that `.h` and `.cpp` (and equivalents) follow the rules below.
  id: totrans-7329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保`.h`和`.cpp`（及其等效项）遵循以下规则。
- en: 'FAQ: Answers to frequently asked questions'
  id: totrans-7330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答：对常见问题的回答
- en: This section covers answers to frequently asked questions about these guidelines.
  id: totrans-7331
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了关于这些指南的常见问题的答案。
- en: 'FAQ.1: What do these guidelines aim to achieve?'
  id: totrans-7332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见问题解答.1：这些指南的目的是什么？
- en: See the [top of this page](#s-abstract). This is an open-source project to maintain
    modern authoritative guidelines for writing C++ code using the current C++ Standard.
    The guidelines are designed to be modern, machine-enforceable wherever possible,
    and open to contributions and forking so that organizations can easily incorporate
    them into their own corporate coding guidelines.
  id: totrans-7333
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[本页面的顶部](#s-abstract)。这是一个开源项目，旨在维护使用当前C++标准编写的现代权威指南。这些指南旨在尽可能现代化、机器可执行，并开放贡献和分叉，以便组织可以轻松地将它们纳入自己的公司编码指南。
- en: 'FAQ.2: When and where was this work first announced?'
  id: totrans-7334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.2: 这个工作是在何时何地首次宣布的？'
- en: It was announced by [Bjarne Stroustrup in his CppCon 2015 opening keynote, “Writing
    Good C++14”](https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote). See
    also the [accompanying isocpp.org blog post](https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines),
    and for the rationale of the type and memory safety guidelines see [Herb Sutter’s
    follow-up CppCon 2015 talk, “Writing Good C++14 … By Default”](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary).
  id: totrans-7335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在[Bjarne Stroustrup在2015年CppCon开幕式上的主题演讲，“编写好的C++14”](https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote)中宣布的。另请参阅[随附的isocpp.org博客文章](https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines)，以及关于类型和内存安全指南的依据，请参阅[Herb
    Sutter在2015年CppCon后续演讲，“默认情况下编写好的C++14 …”](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary)。
- en: 'FAQ.3: Who are the authors and maintainers of these guidelines?'
  id: totrans-7336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.3: 这些指南的作者和维护者是谁？'
- en: 'The initial primary authors and maintainers are Bjarne Stroustrup and Herb
    Sutter, and the guidelines so far were developed with contributions from experts
    at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time
    of their release, the guidelines are in a “0.6” state, and contributions are welcome.
    As Stroustrup said in his announcement: “We need help!”'
  id: totrans-7337
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的主要作者和维护者是Bjarne Stroustrup和Herb Sutter，这些指南到目前为止是在CERN、Microsoft、Morgan Stanley和其他几个组织的专家的贡献下开发的。在发布时，这些指南处于“0.6”状态，欢迎贡献。正如Stroustrup在他的公告中所说：“我们需要帮助！”
- en: 'FAQ.4: How can I contribute?'
  id: totrans-7338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.4: 我如何贡献？'
- en: See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md).
    We appreciate volunteer help!
  id: totrans-7339
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md)。我们感激志愿者的帮助！
- en: 'FAQ.5: How can I become an editor/maintainer?'
  id: totrans-7340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.5: 我如何成为编辑/维护者？'
- en: By contributing a lot first and having the consistent quality of your contributions
    recognized. See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md).
    We appreciate volunteer help!
  id: totrans-7341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过大量贡献并使您贡献的一致质量得到认可。请参阅[CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md)。我们感激志愿者的帮助！
- en: 'FAQ.6: Have these guidelines been approved by the ISO C++ standards committee?
    Do they represent the consensus of the committee?'
  id: totrans-7342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.6: 这些指南是否得到了ISO C++标准委员会的批准？它们是否代表了委员会的共识？'
- en: No. These guidelines are outside the standard. They are intended to serve the
    standard, and be maintained as current guidelines about how to use the current
    Standard C++ effectively. We aim to keep them in sync with the standard as that
    is evolved by the committee.
  id: totrans-7343
  prefs: []
  type: TYPE_NORMAL
  zh: 不。这些指南超出了标准范围。它们旨在服务于标准，并作为关于如何有效使用当前标准C++的现行指南来维护。我们旨在使它们与委员会制定的标准的演变保持同步。
- en: 'FAQ.7: If these guidelines are not approved by the committee, why are they
    under `github.com/isocpp`?'
  id: totrans-7344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.7: 如果这些指南没有得到委员会的批准，为什么它们在 `github.com/isocpp` 下？'
- en: Because `isocpp` is the Standard C++ Foundation; the committee’s repositories
    are under [github.com/*cplusplus*](https://github.com/cplusplus). Some neutral
    organization has to own the copyright and license to make it clear this is not
    being dominated by any one person or vendor. The natural entity is the Foundation,
    which exists to promote the use and up-to-date understanding of modern Standard
    C++ and the work of the committee. This follows the same pattern that isocpp.org
    did for the [C++ FAQ](https://isocpp.org/faq), which was initially the work of
    Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open
    project in the same way.
  id: totrans-7345
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`isocpp`是标准C++基金会；委员会的仓库位于[github.com/*cplusplus*](https://github.com/cplusplus)。必须有一个中立的机构拥有版权和许可，以明确这不是由任何个人或供应商主导。自然实体是基金会，它存在是为了推广现代标准C++的使用和最新理解以及委员会的工作。这遵循了isocpp.org为[C++
    FAQ](https://isocpp.org/faq)所采取的相同模式，该FAQ最初是Bjarne Stroustrup、Marshall Cline和Herb
    Sutter的工作，并以相同的方式贡献给了开源项目。
- en: 'FAQ.8: Will there be a C++98 version of these Guidelines? A C++11 version?'
  id: totrans-7346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.8: 将会有C++98版本的这些指南吗？会有C++11版本吗？'
- en: No. These guidelines are about how to best use modern standard C++ and write
    code assuming you have a modern conforming compiler.
  id: totrans-7347
  prefs: []
  type: TYPE_NORMAL
  zh: 不。这些指南是关于如何最佳使用现代标准C++以及假设您有一个现代符合标准的编译器来编写代码。
- en: 'FAQ.9: Do these guidelines propose new language features?'
  id: totrans-7348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.9: 这些指南提出了新的语言特性吗？'
- en: No. These guidelines are about how to best use modern Standard C++, and they
    limit themselves to recommending only those features.
  id: totrans-7349
  prefs: []
  type: TYPE_NORMAL
  zh: 不。这些指南是关于如何最佳使用现代标准C++，并且它们仅限于推荐那些特性。
- en: 'FAQ.10: What version of Markdown do these guidelines use?'
  id: totrans-7350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAQ.10：这些指南使用哪个版本的Markdown？
- en: These coding standards are written using [CommonMark](https://commonmark.org),
    and `<a>` HTML anchors.
  id: totrans-7351
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编码标准是使用[CommonMark](https://commonmark.org)和`<a>` HTML锚点编写的。
- en: 'We are considering the following extensions from [GitHub Flavored Markdown
    (GFM)](https://help.github.com/articles/github-flavored-markdown/):'
  id: totrans-7352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在考虑以下来自[GitHub Flavored Markdown (GFM)](https://help.github.com/articles/github-flavored-markdown/)的扩展：
- en: fenced code blocks (consistently using indented vs. fenced is under discussion)
  id: totrans-7353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分隔代码块（一致地使用缩进与分隔正在讨论中）
- en: tables (none yet but we’ll likely need them, and this is a GFM extension)
  id: totrans-7354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格（目前还没有，但我们可能需要它们，这是GFM的一个扩展）
- en: Avoid other HTML tags and other extensions.
  id: totrans-7355
  prefs: []
  type: TYPE_NORMAL
  zh: 避免其他HTML标签和其他扩展。
- en: 'Note: We are not yet consistent with this style.'
  id: totrans-7356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们尚未与这种风格保持一致。
- en: 'FAQ.50: What is the GSL (guidelines support library)?'
  id: totrans-7357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAQ.50：GSL（指南支持库）是什么？
- en: The GSL is the small set of types and aliases specified in these guidelines.
    As of this writing, their specification herein is too sparse; we plan to add a
    WG21-style interface specification to ensure that different implementations agree,
    and to propose as a contribution for possible standardization, subject as usual
    to whatever the committee decides to accept/improve/alter/reject.
  id: totrans-7358
  prefs: []
  type: TYPE_NORMAL
  zh: GSL是这些指南中指定的类型和别名的小集合。截至本文撰写时，它们的规范过于稀疏；我们计划添加一个WG21风格的接口规范，以确保不同的实现达成一致，并作为可能的标准化贡献提出，如往常一样，取决于委员会决定接受/改进/修改/拒绝的内容。
- en: 'FAQ.51: Is [github.com/Microsoft/GSL](https://github.com/Microsoft/GSL) the
    GSL?'
  id: totrans-7359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAQ.51：[github.com/Microsoft/GSL](https://github.com/Microsoft/GSL)是GSL吗？
- en: No. That is just a first implementation contributed by Microsoft. Other implementations
    by other vendors are encouraged, as are forks of and contributions to that implementation.
    As of this writing one week into the public project, at least one GPLv3 open-source
    implementation already exists. We plan to produce a WG21-style interface specification
    to ensure that different implementations agree.
  id: totrans-7360
  prefs: []
  type: TYPE_NORMAL
  zh: 不，那只是微软贡献的一个初步实现。鼓励其他供应商提供其他实现，以及对该实现的分支和贡献。截至本文撰写时，公共项目已经进行了两周，至少已经存在一个GPLv3开源实现。我们计划生产一个WG21风格的接口规范，以确保不同的实现达成一致。
- en: 'FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?'
  id: totrans-7361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAQ.52：为什么不在这份指南中提供实际的GSL实现？
- en: We are reluctant to bless one particular implementation because we do not want
    to make people think there is only one, and inadvertently stifle parallel implementations.
    And if these guidelines included an actual implementation, then whoever contributed
    it could be mistakenly seen as too influential. We prefer to follow the long-standing
    approach of the committee, namely to specify interfaces, not implementations.
    But at the same time we want at least one implementation available; we hope for
    many.
  id: totrans-7362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不愿意祝福一个特定的实现，因为我们不希望让人们认为只有一个，并无意中扼杀并行实现。如果这些指南包括一个实际实现，那么贡献者可能会被错误地认为有太大影响。我们更喜欢遵循委员会长期以来的方法，即指定接口，而不是实现。但与此同时，我们希望至少有一个实现可用；我们希望有更多。
- en: 'FAQ.53: Why weren’t the GSL types proposed through Boost?'
  id: totrans-7363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAQ.53：为什么GSL类型没有通过Boost提出？
- en: Because we want to use them immediately, and because they are temporary in that
    we want to retire them as soon as types that fill the same needs exist in the
    standard library.
  id: totrans-7364
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望立即使用它们，并且因为它们是临时的，我们希望在标准库中有满足相同需求的类型时，就将其退役。
- en: 'FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++
    standards committee?'
  id: totrans-7365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAQ.54：GSL（指南支持库）是否已被ISO C++标准委员会批准？
- en: No. The GSL exists only to supply a few types and aliases that are not currently
    in the standard library. If the committee decides on standardized versions (of
    these or other types that fill the same need) then they can be removed from the
    GSL.
  id: totrans-7366
  prefs: []
  type: TYPE_NORMAL
  zh: 不。GSL仅用于提供一些目前不在标准库中的类型和别名。如果委员会决定标准化版本（这些或其他满足相同需求的类型），则它们可以从GSL中移除。
- en: 'FAQ.55: If you’re using the standard types where available, why is the GSL
    `span<char>` different from the `string_view` in the Library Fundamentals 1 Technical
    Specification and C++17 Working Paper? Why not just use the committee-approved
    `string_view`?'
  id: totrans-7367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FAQ.55：如果你在使用可用的标准类型，为什么GSL的`span<char>`与《库基础1技术规范》和C++17工作文件中的`string_view`不同？为什么不直接使用委员会批准的`string_view`？
- en: The consensus on the taxonomy of views for the C++ Standard Library was that
    “view” means “read-only”, and “span” means “read/write”. If you only need a read-only
    view of characters that does not need guaranteed bounds-checking and you have
    C++17, use C++17 `std::string_view`. Otherwise, if you need a read-write view
    that does not need guaranteed bounds-checking and you have C++20, use C++20 `std::span<char>`.
    Otherwise, use `gsl::span<char>`.
  id: totrans-7368
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 C++ 标准库视图分类法的共识是，“视图”意味着“只读”，“span”意味着“读写”。如果你只需要一个不需要保证边界检查的字符只读视图，并且你有
    C++17，请使用 C++17 的 `std::string_view`。否则，如果你需要一个不需要保证边界检查的读写视图，并且你有 C++20，请使用 C++20
    的 `std::span<char>`。否则，使用 `gsl::span<char>`。
- en: 'FAQ.56: Is `owner` the same as the proposed `observer_ptr`?'
  id: totrans-7369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.56: `owner` 是否与提议的 `observer_ptr` 相同？'
- en: No. `owner` owns, is an alias, and can be applied to any indirection type. The
    main intent of `observer_ptr` is to signify a *non*-owning pointer.
  id: totrans-7370
  prefs: []
  type: TYPE_NORMAL
  zh: 不。`owner` 拥有，是一个别名，可以应用于任何间接类型。`observer_ptr` 的主要意图是表示一个 *非* 拥有指针。
- en: 'FAQ.57: Is `stack_array` the same as the standard `array`?'
  id: totrans-7371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.57: `stack_array` 是否与标准 `array` 相同？'
- en: No. `stack_array` is guaranteed to be allocated on the stack. Although a `std::array`
    contains its storage directly inside itself, the `array` object can be put anywhere,
    including the heap.
  id: totrans-7372
  prefs: []
  type: TYPE_NORMAL
  zh: 不。`stack_array` 保证在栈上分配。尽管 `std::array` 直接在其内部包含其存储，但 `array` 对象可以放在任何地方，包括堆上。
- en: 'FAQ.58: Is `dyn_array` the same as `vector` or the proposed `dynarray`?'
  id: totrans-7373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.58: `dyn_array` 是否与 `vector` 或提议的 `dynarray` 相同？'
- en: No. `dyn_array` is a container, like `vector`, but it is not resizable; its
    size is fixed at runtime when it is constructed. It is a safe way to refer to
    a dynamically “heap”-allocated fixed-size array. Unlike `vector`, it is intended
    to replace array-`new[]`. Unlike the `dynarray` that has been proposed in the
    committee, this does not anticipate compiler/language magic to somehow allocate
    it on the stack when it is a member of an object that is allocated on the stack;
    it simply refers to a “dynamic” or heap-based array.
  id: totrans-7374
  prefs: []
  type: TYPE_NORMAL
  zh: 不。`dyn_array` 是一个容器，类似于 `vector`，但它不可调整大小；它在构造时的大小是固定的。这是一种安全地引用动态“堆”分配的固定大小数组的方法。与
    `vector` 不同，它旨在替换 `array`-`new[]`。与委员会中提议的 `dynarray` 不同，它不期望编译器/语言魔法在它是堆分配的对象的成员时将其分配在栈上；它只是引用一个“动态”或基于堆的数组。
- en: 'FAQ.59: Is `Expects` the same as `assert`?'
  id: totrans-7375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.59: `Expects` 是否与 `assert` 相同？'
- en: No. It is a placeholder for language support for contract preconditions.
  id: totrans-7376
  prefs: []
  type: TYPE_NORMAL
  zh: 不。它是语言对合同前置条件的支持的一个占位符。
- en: 'FAQ.60: Is `Ensures` the same as `assert`?'
  id: totrans-7377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'FAQ.60: `Ensures` 和 `assert` 是否相同？'
- en: No. It is a placeholder for language support for contract postconditions.
  id: totrans-7378
  prefs: []
  type: TYPE_NORMAL
  zh: 不。它是语言对合同后置条件的支持的一个占位符。
- en: 'Appendix A: Libraries'
  id: totrans-7379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A：库
- en: This section lists recommended libraries, and explicitly recommends a few.
  id: totrans-7380
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了推荐的库，并明确推荐了一些。
- en: ??? Suitable for the general guide? I think not ???
  id: totrans-7381
  prefs: []
  type: TYPE_NORMAL
  zh: ??? 适合一般指南吗？我认为不是 ???
- en: 'Appendix B: Modernizing code'
  id: totrans-7382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B：代码现代化
- en: 'Ideally, we follow all rules in all code. Realistically, we have to deal with
    a lot of old code:'
  id: totrans-7383
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们在所有代码中遵循所有规则。现实情况下，我们必须处理大量的旧代码：
- en: application code written before the guidelines were formulated or known
  id: totrans-7384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在制定或了解指南之前编写的应用程序代码
- en: libraries written to older/different standards
  id: totrans-7385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写为较旧/不同标准的库
- en: code written under “unusual” constraints
  id: totrans-7386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“不寻常”的约束下编写的代码
- en: code that we just haven’t gotten around to modernizing
  id: totrans-7387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还没有着手现代化的代码
- en: If we have a million lines of new code, the idea of “just changing it all at
    once” is typically unrealistic. Thus, we need a way of gradually modernizing a
    code base.
  id: totrans-7388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有百万行的新代码，一次性全部更改的想法通常是不可行的。因此，我们需要一种逐步现代化代码库的方法。
- en: Upgrading older code to modern style can be a daunting task. Often, the old
    code is both a mess (hard to understand) and working correctly (for the current
    range of uses). Typically, the original programmer is not around and the test
    cases incomplete. The fact that the code is a mess dramatically increases the
    effort needed to make any change and the risk of introducing errors. Often, messy
    old code runs unnecessarily slowly because it requires outdated compilers and
    cannot take advantage of modern hardware. In many cases, automated “modernizer”-style
    tool support would be required for major upgrade efforts.
  id: totrans-7389
  prefs: []
  type: TYPE_NORMAL
  zh: 将旧代码升级到现代风格可能是一项艰巨的任务。通常，旧代码既是一团糟（难以理解）又运行正确（对于当前的使用范围）。通常，原始程序员不在场，测试用例也不完整。代码一团糟的事实大大增加了进行任何更改所需的努力和引入错误的风险。通常，混乱的旧代码运行得非常慢，因为它需要过时的编译器，无法利用现代硬件。在许多情况下，需要自动化“现代化”风格的工具支持才能进行重大升级。
- en: The purpose of modernizing code is to simplify adding new functionality, to
    ease maintenance, and to increase performance (throughput or latency), and to
    better utilize modern hardware. Making code “look pretty” or “follow modern style”
    are not by themselves reasons for change. There are risks implied by every change
    and costs (including the cost of lost opportunities) implied by having an outdated
    code base. The cost reductions must outweigh the risks.
  id: totrans-7390
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现代化的目的是简化添加新功能，便于维护，并提高性能（吞吐量或延迟），以及更好地利用现代硬件。仅仅让代码“看起来漂亮”或“遵循现代风格”本身并不是改变的理由。每个改变都隐含着风险，而拥有过时的代码库则意味着有成本（包括失去机会的成本）。成本降低必须超过风险。
- en: But how?
  id: totrans-7391
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何做呢？
- en: 'There is no one approach to modernizing code. How best to do it depends on
    the code, the pressure for updates, the backgrounds of the developers, and the
    available tool. Here are some (very general) ideas:'
  id: totrans-7392
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种方法可以用来现代化代码。如何最好地做到这一点取决于代码、更新的压力、开发者的背景以及可用的工具。以下是一些（非常一般）的想法：
- en: The ideal is “just upgrade everything.” That gives the most benefits for the
    shortest total time. In most circumstances, it is also impossible.
  id: totrans-7393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想的情况是“一次性升级所有内容”。这可以在最短的时间内带来最大的好处。在大多数情况下，这也是不可能的。
- en: We could convert a code base module for module, but any rules that affects interfaces
    (especially ABIs), such as [use `span`](#ss-views), cannot be done on a per-module
    basis.
  id: totrans-7394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以模块化地转换代码库，但对于影响接口（特别是ABIs）的任何规则，例如[使用`span`](#ss-views)，不能按模块进行。
- en: We could convert code “bottom up” starting with the rules we estimate will give
    the greatest benefits and/or the least trouble in a given code base.
  id: totrans-7395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从规则开始“自下而上”地转换代码，这些规则是我们估计在给定的代码库中将带来最大好处和/或最少麻烦的。
- en: We could start by focusing on the interfaces, e.g., make sure that no resources
    are lost and no pointer is misused. This would be a set of changes across the
    whole code base, but would most likely have huge benefits. Afterwards, code hidden
    behind those interfaces can be gradually modernized without affecting other code.
  id: totrans-7396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以首先关注接口，例如，确保没有资源丢失，没有指针被误用。这将是一组跨越整个代码库的更改，但可能会带来巨大的好处。之后，隐藏在那些接口背后的代码可以逐步现代化，而不会影响其他代码。
- en: Whichever way you choose, please note that the most advantages come with the
    highest conformance to the guidelines. The guidelines are not a random set of
    unrelated rules where you can randomly pick and choose with an expectation of
    success.
  id: totrans-7397
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式，请注意，最大的优势来自于对指南的最高遵守。指南不是一套随机的、无关的规则集合，你可以随机挑选并期望成功。
- en: We would dearly love to hear about experience and about tools used. Modernization
    can be much faster, simpler, and safer when supported with analysis tools and
    even code transformation tools.
  id: totrans-7398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常希望听到关于经验和使用的工具。在分析工具和甚至代码转换工具的支持下，现代化可以变得更快、更简单、更安全。
- en: 'Appendix C: Discussion'
  id: totrans-7399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录C：讨论
- en: This section contains follow-up material on rules and sets of rules. In particular,
    here we present further rationale, longer examples, and discussions of alternatives.
  id: totrans-7400
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含关于规则和规则集的后续材料。特别是，在这里我们提供了进一步的推理、更长的示例以及关于替代方案的讨论。
- en: 'Discussion: Define and initialize data members in the order of member declaration'
  id: totrans-7401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：按照成员声明的顺序定义和初始化数据成员
- en: Data members are always initialized in the order they are declared in the class
    definition, so write them in that order in the constructor initialization list.
    Writing them in a different order just makes the code confusing because it won’t
    run in the order you see, and that can make it hard to see order-dependent bugs.
  id: totrans-7402
  prefs: []
  type: TYPE_NORMAL
  zh: 数据成员始终按照在类定义中声明的顺序进行初始化，因此在构造函数初始化列表中按此顺序编写它们。以不同的顺序编写它们只会使代码变得混乱，因为它们不会按你看到的顺序运行，这可能会使发现顺序相关的错误变得困难。
- en: '[PRE905]'
  id: totrans-7403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: In this example, `email` will be constructed before `first` and `last` because
    it is declared first. That means its constructor will attempt to use `first` and
    `last` too soon – not just before they are set to the desired values, but before
    they are constructed at all.
  id: totrans-7404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于 `email` 在 `first` 和 `last` 之前声明，它将在 `first` 和 `last` 之前被构造。这意味着它的构造函数将尝试过早地使用
    `first` 和 `last` – 不仅是在将它们设置为期望值之前，而且在它们被构造之前。
- en: If the class definition and the constructor body are in separate files, the
    long-distance influence that the order of data member declarations has over the
    constructor’s correctness will be even harder to spot.
  id: totrans-7405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类定义和构造函数体在单独的文件中，数据成员声明顺序对构造函数正确性的远程影响将更难被发现。
- en: '**References**:'
  id: totrans-7406
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**：'
- en: '[[Cline99]](#Cline99) §22.03-11, [[Dewhurst03]](#Dewhurst03) §52-53, [[Koenig97]](#Koenig97)
    §4, [[Lakos96]](#Lakos96) §10.3.5, [[Meyers97]](#Meyers97) §13, [[Murray93]](#Murray93)
    §2.1.3, [[Sutter00]](#Sutter00) §47'
  id: totrans-7407
  prefs: []
  type: TYPE_NORMAL
  zh: '[[Cline99]](#Cline99) §22.03-11, [[Dewhurst03]](#Dewhurst03) §52-53, [[Koenig97]](#Koenig97)
    §4, [[Lakos96]](#Lakos96) §10.3.5, [[Meyers97]](#Meyers97) §13, [[Murray93]](#Murray93)
    §2.1.3, [[Sutter00]](#Sutter00) §47'
- en: 'Discussion: Use of `=`, `{}`, and `()` as initializers'
  id: totrans-7408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：使用 `=`, `{}`, 和 `()` 作为初始化器
- en: ???
  id: totrans-7409
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Discussion: Use a factory function if you need “virtual behavior” during initialization'
  id: totrans-7410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：如果需要在初始化期间使用“虚拟行为”，请使用工厂函数
- en: 'If your design wants virtual dispatch into a derived class from a base class
    constructor or destructor for functions like `f` and `g`, you need other techniques,
    such as a post-constructor – a separate member function the caller must invoke
    to complete initialization, which can safely call `f` and `g` because in member
    functions virtual calls behave normally. Some techniques for this are shown in
    the References. Here’s a non-exhaustive list of options:'
  id: totrans-7411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设计需要在基类构造函数或析构函数中从派生类进行虚拟分派，例如 `f` 和 `g` 函数，你需要其他技术，例如后构造函数 – 一个调用者必须调用的单独成员函数来完成初始化，它可以安全地调用
    `f` 和 `g`，因为在成员函数中虚拟调用表现正常。这里展示了这种技术的几种方法。以下是一个非详尽的选项列表：
- en: '*Pass the buck:* Just document that user code must call the post-initialization
    function right after constructing an object.'
  id: totrans-7412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推卸责任:* 仅记录用户代码必须在构造对象后立即调用后初始化函数。'
- en: '*Post-initialize lazily:* Do it during the first call of a member function.
    A Boolean flag in the base class tells whether or not post-construction has taken
    place yet.'
  id: totrans-7413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*延迟后初始化:* 在成员函数的第一次调用期间执行。基类中的一个布尔标志指示后构造是否已经发生。'
- en: '*Use virtual base class semantics:* Language rules dictate that the constructor
    of the most-derived class decides which base constructor will be invoked; you
    can use that to your advantage. (See [[Taligent94]](#Taligent94).)'
  id: totrans-7414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用虚拟基类语义:* 语言规则规定，最派生类的构造函数决定将调用哪个基类构造函数；你可以利用这一点。（参见 [[Taligent94]](#Taligent94)。）'
- en: '*Use a factory function:* This way, you can easily force a mandatory invocation
    of a post-constructor function.'
  id: totrans-7415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用工厂函数:* 这样，你可以轻松地强制调用后构造函数的强制调用。'
- en: 'Here is an example of the last option:'
  id: totrans-7416
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是最后一个选项的例子：
- en: '[PRE906]'
  id: totrans-7417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: 'This design requires the following discipline:'
  id: totrans-7418
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计需要以下纪律：
- en: Derived classes such as `D` must not expose a publicly callable constructor.
    Otherwise, `D`’s users could create `D` objects that don’t invoke `post_initialize`.
  id: totrans-7419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类如 `D` 不应公开可调用的构造函数。否则，`D` 的用户可能会创建不调用 `post_initialize` 的 `D` 对象。
- en: Allocation is limited to `operator new`. `B` can, however, override `new` (see
    Items 45 and 46 in [SuttAlex05](#SuttAlex05)).
  id: totrans-7420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配仅限于 `operator new`。然而，`B` 可以覆盖 `new`（参见 [SuttAlex05](#SuttAlex05) 中的第 45 和
    46 条）。
- en: '`D` must define a constructor with the same parameters that `B` selected. Defining
    several overloads of `create` can assuage this problem, however; and the overloads
    can even be templated on the argument types.'
  id: totrans-7421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D` 必须定义一个与 `B` 选择相同的参数的构造函数。定义多个 `create` 重载可以缓解这个问题；而且这些重载甚至可以基于参数类型进行模板化。'
- en: If the requirements above are met, the design guarantees that `post_initialize`
    has been called for any fully constructed `B`-derived object. `post_initialize`
    doesn’t need to be virtual; it can, however, invoke virtual functions freely.
  id: totrans-7422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足上述要求，设计保证任何完全构造的`B`派生对象都调用了`post_initialize`。`post_initialize`不需要是虚拟的；然而，它可以自由地调用虚拟函数。
- en: In summary, no post-construction technique is perfect. The worst techniques
    dodge the whole issue by simply asking the caller to invoke the post-constructor
    manually. Even the best require a different syntax for constructing objects (easy
    to check at compile time) and/or cooperation from derived class authors (impossible
    to check at compile time).
  id: totrans-7423
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，没有任何后构造技术是完美的。最差的技术只是简单地要求调用者手动调用后构造函数，从而回避了整个问题。即使是最好的技术，也需要不同的语法来构造对象（在编译时容易检查）和/或从派生类作者那里获得合作（在编译时无法检查）。
- en: '**References**: [[Alexandrescu01]](#Alexandrescu01) §3, [[Boost]](#Boost),
    [[Dewhurst03]](#Dewhurst03) §75, [[Meyers97]](#Meyers97) §46, [[Stroustrup00]](#Stroustrup00)
    §15.4.3, [[Taligent94]](#Taligent94)'
  id: totrans-7424
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**：[[Alexandrescu01]](#Alexandrescu01) §3, [[Boost]](#Boost), [[Dewhurst03]](#Dewhurst03)
    §75, [[Meyers97]](#Meyers97) §46, [[Stroustrup00]](#Stroustrup00) §15.4.3, [[Taligent94]](#Taligent94)'
- en: 'Discussion: Make base class destructors public and virtual, or protected and
    non-virtual'
  id: totrans-7425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：使基类析构函数为公共和虚拟，或为受保护和非虚拟
- en: Should destruction behave virtually? That is, should destruction through a pointer
    to a `base` class be allowed? If yes, then `base`’s destructor must be public
    in order to be callable, and virtual, otherwise calling it results in undefined
    behavior. Otherwise, it should be protected so that only derived classes can invoke
    it in their own destructors, and non-virtual since it doesn’t need to behave virtually.
  id: totrans-7426
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁行为应该是虚拟的吗？也就是说，是否应该允许通过基类指针进行销毁？如果是的话，那么`base`的析构函数必须是公共的，以便可以调用，并且是虚拟的，否则调用它会导致未定义的行为。否则，它应该是受保护的，这样只有派生类可以在它们的析构函数中调用它，并且是非虚拟的，因为它不需要表现出虚拟行为。
- en: Example
  id: totrans-7427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: 'The common case for a base class is that it’s intended to have publicly derived
    classes, and so calling code is just about sure to use something like a `shared_ptr<base>`:'
  id: totrans-7428
  prefs: []
  type: TYPE_NORMAL
  zh: 基类的常见情况是它打算有公开的派生类，因此调用代码几乎肯定会使用类似`shared_ptr<base>`的东西：
- en: '[PRE907]'
  id: totrans-7429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: 'In rarer cases, such as policy classes, the class is used as a base class for
    convenience, not for polymorphic behavior. It is recommended to make those destructors
    protected and non-virtual:'
  id: totrans-7430
  prefs: []
  type: TYPE_NORMAL
  zh: 在更罕见的情况下，例如策略类，类被用作基类以方便起见，而不是为了多态行为。建议将这些析构函数设置为受保护的和非虚拟的：
- en: '[PRE908]'
  id: totrans-7431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: Note
  id: totrans-7432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This simple guideline illustrates a subtle issue and reflects modern uses of
    inheritance and object-oriented design principles.
  id: totrans-7433
  prefs: []
  type: TYPE_NORMAL
  zh: 这条简单的指南说明了一个微妙的问题，并反映了继承和面向对象设计原则的现代使用。
- en: For a base class `Base`, calling code might try to destroy derived objects through
    pointers to `Base`, such as when using a `unique_ptr<Base>`. If `Base`’s destructor
    is public and non-virtual (the default), it can be accidentally called on a pointer
    that actually points to a derived object, in which case the behavior of the attempted
    deletion is undefined. This state of affairs has led older coding standards to
    impose a blanket requirement that all base class destructors must be virtual.
    This is overkill (even if it is the common case); instead, the rule should be
    to make base class destructors virtual if and only if they are public.
  id: totrans-7434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个基类`Base`，调用代码可能会尝试通过`Base`指针销毁派生对象，例如在使用`unique_ptr<Base>`时。如果`Base`的析构函数是公共的和非虚拟的（默认情况），它可能会意外地在一个实际上指向派生对象的指针上被调用，在这种情况下，尝试删除的行为是未定义的。这种情况导致旧的编码标准强制要求所有基类析构函数都必须是虚拟的。这是过度的（即使这是常见情况）；相反，规则应该是只有在基类析构函数是公共的时才使其虚拟。
- en: 'To write a base class is to define an abstraction (see Items 35 through 37).
    Recall that for each member function participating in that abstraction, you need
    to decide:'
  id: totrans-7435
  prefs: []
  type: TYPE_NORMAL
  zh: 编写基类就是定义一个抽象（参见第35至37条项目）。回想一下，对于参与该抽象的每个成员函数，你需要决定：
- en: Whether it should behave virtually or not.
  id: totrans-7436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否应该表现出虚拟行为。
- en: Whether it should be publicly available to all callers using a pointer to `Base`
    or else be a hidden internal implementation detail.
  id: totrans-7437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否应该对所有使用`Base`指针的调用者公开，或者它是否应该是隐藏的内部实现细节。
- en: As described in Item 39, for a normal member function, the choice is between
    allowing it to be called via a pointer to `Base` non-virtually (but possibly with
    virtual behavior if it invokes virtual functions, such as in the NVI or Template
    Method patterns), virtually, or not at all. The NVI pattern is a technique to
    avoid public virtual functions.
  id: totrans-7438
  prefs: []
  type: TYPE_NORMAL
  zh: 如第39项所述，对于一个普通的成员函数，选择是在允许它通过指向`Base`的非虚指针调用（但如果是调用虚函数，如NVI或模板方法模式，则可能具有虚行为），虚调用，或者根本不调用。NVI模式是一种避免公共虚函数的技术。
- en: Destruction can be viewed as just another operation, albeit with special semantics
    that make non-virtual calls dangerous or wrong. For a base class destructor, therefore,
    the choice is between allowing it to be called via a pointer to `Base` virtually
    or not at all; “non-virtually” is not an option. Hence, a base class destructor
    is virtual if it can be called (i.e., is public), and non-virtual otherwise.
  id: totrans-7439
  prefs: []
  type: TYPE_NORMAL
  zh: 析构可以看作是另一种操作，尽管它具有特殊的语义，使得非虚调用危险或不正确。因此，对于基类析构函数，选择是在允许它通过指向`Base`的指针虚调用或根本不调用；“非虚”不是一个选项。因此，如果可以调用（即，是公共的），则基类析构函数是虚的，否则是非虚的。
- en: Note that the NVI pattern cannot be applied to the destructor because constructors
    and destructors cannot make deep virtual calls. (See Items 39 and 55.)
  id: totrans-7440
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，NVI模式不能应用于析构函数，因为构造函数和析构函数不能进行深度虚调用。（参见第39项和第55项。）
- en: 'Corollary: When writing a base class, always write a destructor explicitly,
    because the implicitly generated one is public and non-virtual. You can always
    `=default` the implementation if the default body is fine and you’re just writing
    the function to give it the proper visibility and virtuality.'
  id: totrans-7441
  prefs: []
  type: TYPE_NORMAL
  zh: 推论：当编写基类时，始终显式编写析构函数，因为隐式生成的析构函数是公共的且非虚的。如果默认体是可接受的，并且你只是编写函数以提供适当的可见性和虚性，则可以始终使用`=default`实现。
- en: Exception
  id: totrans-7442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: Some component architectures (e.g., COM and CORBA) don’t use a standard deletion
    mechanism, and foster different protocols for object disposal. Follow the local
    patterns and idioms, and adapt this guideline as appropriate.
  id: totrans-7443
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件架构（例如，COM和CORBA）不使用标准删除机制，并促进不同的对象处置协议。遵循本地模式和习惯用法，并根据需要调整此指南。
- en: 'Consider also this rare case:'
  id: totrans-7444
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种罕见的情况：
- en: '`B` is both a base class and a concrete class that can be instantiated by itself,
    and so the destructor must be public for `B` objects to be created and destroyed.'
  id: totrans-7445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B`既是基类，也是一个可以自身实例化的具体类，因此析构函数必须是公共的，以便创建和销毁`B`对象。'
- en: Yet `B` also has no virtual functions and is not meant to be used polymorphically,
    and so although the destructor is public it does not need to be virtual.
  id: totrans-7446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，`B`也没有虚函数，并且不打算用于多态，因此尽管析构函数是公共的，但它不需要是虚的。
- en: Then, even though the destructor has to be public, there can be great pressure
    to not make it virtual because as the first virtual function it would incur all
    the run-time type overhead when the added functionality should never be needed.
  id: totrans-7447
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尽管析构函数必须是公共的，但可能存在很大的压力不使其成为虚函数，因为作为第一个虚函数，它会在添加的功能根本不需要时产生所有运行时类型开销。
- en: In this rare case, you could make the destructor public and non-virtual but
    clearly document that further-derived objects must not be used polymorphically
    as `B`’s. This is what was done with `std::unary_function`.
  id: totrans-7448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种罕见的情况下，你可以使析构函数公共且非虚，但必须明确记录，进一步派生的对象不得作为`B`的多态使用。这是`std::unary_function`所采取的做法。
- en: In general, however, avoid concrete base classes (see Item 35). For example,
    `unary_function` is a bundle-of-typedefs that was never intended to be instantiated
    standalone. It really makes no sense to give it a public destructor; a better
    design would be to follow this Item’s advice and give it a protected non-virtual
    destructor.
  id: totrans-7449
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常应避免具体基类（参见第35项）。例如，`unary_function`是一个类型定义的集合，从未打算独立实例化。给它一个公共析构函数实际上没有意义；更好的设计是遵循本项的建议，给它一个受保护的非虚析构函数。
- en: '**References**: [[SuttAlex05]](#SuttAlex05) Item 50, [[Cargill92]](#Cargill92)
    pp. 77-79, 207, [[Cline99]](#Cline99) §21.06, 21.12-13, [[Henricson97]](#Henricson97)
    pp. 110-114, [[Koenig97]](#Koenig97) Chapters 4, 11, [[Meyers97]](#Meyers97) §14,
    [[Stroustrup00]](#Stroustrup00) §12.4.2, [[Sutter02]](#Sutter02) §27, [[Sutter04]](#Sutter04)
    §18'
  id: totrans-7450
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**：[[SuttAlex05]](#SuttAlex05) 第50项，[[Cargill92]](#Cargill92) 第77-79页，第207页，[[Cline99]](#Cline99)
    §21.06，21.12-13，[[Henricson97]](#Henricson97) 第110-114页，[[Koenig97]](#Koenig97)
    第4章，第11章，[[Meyers97]](#Meyers97) §14，[[Stroustrup00]](#Stroustrup00) §12.4.2，[[Sutter02]](#Sutter02)
    §27，[[Sutter04]](#Sutter04) §18'
- en: 'Discussion: Usage of noexcept'
  id: totrans-7451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：noexcept的使用
- en: ???
  id: totrans-7452
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: 'Discussion: Destructors, deallocation, and swap must never fail'
  id: totrans-7453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：析构函数、资源释放和交换不得失败
- en: Never allow an error to be reported from a destructor, a resource deallocation
    function (e.g., `operator delete`), or a `swap` function using `throw`. It is
    nearly impossible to write useful code if these operations can fail, and even
    if something does go wrong it nearly never makes any sense to retry. Specifically,
    types whose destructors might throw an exception are flatly forbidden from use
    with the C++ Standard Library. Most destructors are now implicitly `noexcept`
    by default.
  id: totrans-7454
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要允许从析构函数、资源释放函数（例如`operator delete`）或`swap`函数中通过`throw`报告错误。如果这些操作可能失败，则编写有用的代码几乎是不可能的，即使出了问题，也几乎永远没有重试的任何意义。具体来说，那些析构函数可能会抛出异常的类型被明确禁止与C++标准库一起使用。现在大多数析构函数默认情况下都是隐式`noexcept`。
- en: Example
  id: totrans-7455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE909]'
  id: totrans-7456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: '`Nefarious` objects are hard to use safely even as local variables:'
  id: totrans-7457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使作为局部变量，`Nefarious`对象也很难安全使用：
- en: '[PRE910]'
  id: totrans-7458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE910]'
- en: Here, copying `s` could throw, and if that throws and if `n`’s destructor then
    also throws, the program will exit via `std::terminate` because two exceptions
    can’t be propagated simultaneously.
  id: totrans-7459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，复制`s`可能会抛出异常，如果抛出异常并且如果`n`的析构函数也抛出异常，程序将通过`std::terminate`退出，因为两个异常不能同时传播。
- en: 'Classes with `Nefarious` members or bases are also hard to use safely, because
    their destructors must invoke `Nefarious`’ destructor, and are similarly poisoned
    by its bad behavior:'
  id: totrans-7460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有或基类为`Nefarious`的类也很难安全使用，因为它们的析构函数必须调用`Nefarious`的析构函数，并且会像其不良行为一样被毒化：
- en: '[PRE911]'
  id: totrans-7461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE911]'
- en: Here, if constructing `copy2` throws, we have the same problem because `i`’s
    destructor now also can throw, and if so we’ll invoke `std::terminate`.
  id: totrans-7462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，如果构造`copy2`时抛出异常，我们会有同样的问题，因为`i`的析构函数现在也可能抛出异常，如果是这样，我们将调用`std::terminate`。
- en: 'You can’t reliably create global or static `Nefarious` objects either:'
  id: totrans-7463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也无法可靠地创建全局或静态的`Nefarious`对象：
- en: '[PRE912]'
  id: totrans-7464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE912]'
- en: 'You can’t reliably create arrays of `Nefarious`:'
  id: totrans-7465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也无法可靠地创建`Nefarious`数组：
- en: '[PRE913]'
  id: totrans-7466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE913]'
- en: 'The behavior of arrays is undefined in the presence of destructors that throw
    because there is no reasonable rollback behavior that could ever be devised. Just
    think: What code can the compiler generate for constructing an `arr` where, if
    the fourth object’s constructor throws, the code has to give up and in its cleanup
    mode tries to call the destructors of the already-constructed objects … and one
    or more of those destructors throws? There is no satisfactory answer.'
  id: totrans-7467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在存在抛出异常的析构函数的情况下，数组的行为是未定义的，因为没有合理的回滚行为可以设计出来。想想看：编译器可以为构造`arr`生成什么代码，其中如果第四个对象的构造函数抛出异常，代码必须放弃，并在清理模式下尝试调用已构造对象的析构函数……并且其中一个或多个析构函数抛出异常？没有令人满意的答案。
- en: 'You can’t use `Nefarious` objects in standard containers:'
  id: totrans-7468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您无法在标准容器中使用`Nefarious`对象：
- en: '[PRE914]'
  id: totrans-7469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE914]'
- en: The standard library forbids all destructors used with it from throwing. You
    can’t store `Nefarious` objects in standard containers or use them with any other
    part of the standard library.
  id: totrans-7470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '标准库禁止使用它的所有析构函数抛出异常。您不能在标准容器中存储`Nefarious`对象或使用标准库的任何其他部分。 '
- en: Note
  id: totrans-7471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'These are key functions that must not fail because they are necessary for the
    two key operations in transactional programming: to back out work if problems
    are encountered during processing, and to commit work if no problems occur. If
    there’s no way to safely back out using no-fail operations, then no-fail rollback
    is impossible to implement. If there’s no way to safely commit state changes using
    a no-fail operation (notably, but not limited to, `swap`), then no-fail commit
    is impossible to implement.'
  id: totrans-7472
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是关键函数，不得失败，因为它们是事务编程中两个关键操作所必需的：在处理过程中遇到问题时撤回工作，以及如果没有问题发生则提交工作。如果没有安全地使用无失败操作撤回的方法，则无失败回滚无法实现。如果没有安全地使用无失败操作提交状态变化的方法（特别是但不限于`swap`），则无失败提交无法实现。
- en: 'Consider the following advice and requirements found in the C++ Standard:'
  id: totrans-7473
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在C++标准中找到的以下建议和要求：
- en: If a destructor called during stack unwinding exits with an exception, terminate
    is called (15.5.1). So destructors should generally catch exceptions and not let
    them propagate out of the destructor. –[[C++03]](#Cplusplus03) §15.2(3)
  id: totrans-7474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在栈展开期间调用的析构函数以异常退出，则调用终止（15.5.1）。因此，析构函数通常应该捕获异常，而不是让它们从析构函数中传播出去。 –[[C++03]](#Cplusplus03)
    §15.2(3)
- en: ''
  id: totrans-7475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No destructor operation defined in the C++ Standard Library (including the destructor
    of any type that is used to instantiate a standard-library template) will throw
    an exception. –[[C++03]](#Cplusplus03) §17.4.4.8(3)
  id: totrans-7476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C++标准库中定义的任何析构函数操作（包括用于实例化标准库模板的任何类型的析构函数）都不会抛出异常。 –[[C++03]](#Cplusplus03)
    §17.4.4.8(3)
- en: 'Deallocation functions, including specifically overloaded `operator delete`
    and `operator delete[]`, fall into the same category, because they too are used
    during cleanup in general, and during exception handling in particular, to back
    out of partial work that needs to be undone. Besides destructors and deallocation
    functions, common error-safety techniques rely also on `swap` operations never
    failing – in this case, not because they are used to implement a guaranteed rollback,
    but because they are used to implement a guaranteed commit. For example, here
    is an idiomatic implementation of `operator=` for a type `T` that performs copy
    construction followed by a call to a no-fail `swap`:'
  id: totrans-7477
  prefs: []
  type: TYPE_NORMAL
  zh: 释放内存的函数，包括特别重载的`operator delete`和`operator delete[]`，都属于同一类别，因为它们在一般情况下用于清理，特别是在异常处理期间，用于撤销需要取消的部分工作。除了析构函数和释放内存函数之外，常见的错误安全技术还依赖于`swap`操作永远不会失败——在这种情况下，不是因为它们用于实现保证回滚，而是因为它们用于实现保证提交。例如，以下是一个类型`T`的`operator=`的惯用实现，它执行复制构造然后调用一个无失败的`swap`：
- en: '[PRE915]'
  id: totrans-7478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: (See also Item 56\. ???)
  id: totrans-7479
  prefs: []
  type: TYPE_NORMAL
  zh: （另见条目 56\. ???）
- en: Fortunately, when releasing a resource, the scope for failure is definitely
    smaller. If using exceptions as the error reporting mechanism, make sure such
    functions handle all exceptions and other errors that their internal processing
    might generate. (For exceptions, simply wrap everything sensitive that your destructor
    does in a `try/catch(...)` block.) This is particularly important because a destructor
    might be called in a crisis situation, such as failure to allocate a system resource
    (e.g., memory, files, locks, ports, windows, or other system objects).
  id: totrans-7480
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在释放资源时，失败的范围肯定更小。如果使用异常作为错误报告机制，确保这些函数处理它们内部处理可能生成的所有异常和其他错误。（对于异常，只需将析构函数中所有敏感的操作包裹在`try/catch(...)`块中。）这尤其重要，因为析构函数可能在危机情况下被调用，例如无法分配系统资源（例如，内存、文件、锁、端口、窗口或其他系统对象）。
- en: When using exceptions as your error handling mechanism, always document this
    behavior by declaring these functions `noexcept`. (See Item 75.)
  id: totrans-7481
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用异常作为错误处理机制时，始终通过声明这些函数为`noexcept`来记录此行为。（参见条目 75。）
- en: '**References**: [[SuttAlex05]](#SuttAlex05) Item 51; [[C++03]](#Cplusplus03)
    §15.2(3), §17.4.4.8(3), [[Meyers96]](#Meyers96) §11, [[Stroustrup00]](#Stroustrup00)
    §14.4.7, §E.2-4, [[Sutter00]](#Sutter00) §8, §16, [[Sutter02]](#Sutter02) §18-19'
  id: totrans-7482
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**：[[SuttAlex05]](#SuttAlex05) 条目 51；[[C++03]](#Cplusplus03) §15.2(3)，§17.4.4.8(3)，[[Meyers96]](#Meyers96)
    §11，[[Stroustrup00]](#Stroustrup00) §14.4.7，§E.2-4，[[Sutter00]](#Sutter00) §8，§16，[[Sutter02]](#Sutter02)
    §18-19'
- en: Define Copy, move, and destroy consistently
  id: totrans-7483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致地定义复制、移动和销毁
- en: Reason
  id: totrans-7484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: ???
  id: totrans-7485
  prefs: []
  type: TYPE_NORMAL
  zh: ???
- en: Note
  id: totrans-7486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you define a copy constructor, you must also define a copy assignment operator.
  id: totrans-7487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了一个复制构造函数，你也必须定义一个复制赋值运算符。
- en: Note
  id: totrans-7488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you define a move constructor, you must also define a move assignment operator.
  id: totrans-7489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了一个移动构造函数，你也必须定义一个移动赋值运算符。
- en: Example
  id: totrans-7490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE916]'
  id: totrans-7491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: If you define a destructor, you should not use the compiler-generated copy or
    move operation; you probably need to define or suppress copy and/or move.
  id: totrans-7492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了一个析构函数，你不应该使用编译器生成的复制或移动操作；你可能需要定义或抑制复制和/或移动。
- en: '[PRE917]'
  id: totrans-7493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: If you define copying, and any base or member has a type that defines a move
    operation, you should also define a move operation.
  id: totrans-7494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了复制，并且任何基类或成员具有定义了移动操作的类型，你应该也定义一个移动操作。
- en: '[PRE918]'
  id: totrans-7495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: If you define any of the copy constructor, copy assignment operator, or destructor,
    you probably should define the others.
  id: totrans-7496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了任何复制构造函数、复制赋值运算符或析构函数，你可能应该定义其他几个。
- en: Note
  id: totrans-7497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you need to define any of these five functions, it means you need it to
    do more than its default behavior – and the five are asymmetrically interrelated.
    Here’s how:'
  id: totrans-7498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要定义这些五个函数中的任何一个，这意味着你需要它执行比默认行为更多的功能——而这五个函数是不对称相互关联的。以下是这样做的方法：
- en: 'If you write/disable either of the copy constructor or the copy assignment
    operator, you probably need to do the same for the other: If one does “special”
    work, probably so should the other because the two functions should have similar
    effects. (See Item 53, which expands on this point in isolation.)'
  id: totrans-7499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你编写/禁用了复制构造函数或复制赋值运算符之一，你可能需要为另一个也做同样的事情：如果一个执行“特殊”工作，另一个可能也应该这样做，因为这两个函数应该有相似的效果。（参见第53条，它单独扩展了这一点。）
- en: 'If you explicitly write the copying functions, you probably need to write the
    destructor: If the “special” work in the copy constructor is to allocate or duplicate
    some resource (e.g., memory, file, socket), you need to deallocate it in the destructor.'
  id: totrans-7500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你显式地编写了复制函数，你可能需要编写析构函数：如果复制构造函数中的“特殊”工作是为分配或复制某些资源（例如，内存、文件、套接字），你需要在析构函数中释放它。
- en: 'If you explicitly write the destructor, you probably need to explicitly write
    or disable copying: If you have to write a non-trivial destructor, it’s often
    because you need to manually release a resource that the object held. If so, it
    is likely that those resources require careful duplication, and then you need
    to pay attention to the way objects are copied and assigned, or disable copying
    completely.'
  id: totrans-7501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你显式地编写了析构函数，你可能需要显式地编写或禁用复制：如果你必须编写一个非平凡的析构函数，通常是因为你需要手动释放对象所持有的资源。如果是这样，这些资源可能需要仔细的复制，然后你需要注意对象复制和赋值的方式，或者完全禁用复制。
- en: In many cases, holding properly encapsulated resources using RAII “owning” objects
    can eliminate the need to write these operations yourself. (See Item 13.)
  id: totrans-7502
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用RAII“拥有”对象正确封装资源可以消除自己编写这些操作的需求。（参见第13条。）
- en: Prefer compiler-generated (including `=default`) special members; only these
    can be classified as “trivial”, and at least one major standard library vendor
    heavily optimizes for classes having trivial special members. This is likely to
    become common practice.
  id: totrans-7503
  prefs: []
  type: TYPE_NORMAL
  zh: 优先使用编译器生成的（包括`=default`）特殊成员；只有这些才能被归类为“平凡的”，至少有一个主要标准库供应商为具有平凡特殊成员的类进行了大量优化。这很可能会成为常见做法。
- en: '**Exceptions**: When any of the special functions are declared only to make
    them non-public or virtual, but without special semantics, it doesn’t imply that
    the others are needed. In rare cases, classes that have members of strange types
    (such as reference members) are an exception because they have peculiar copy semantics.
    In a class holding a reference, you likely need to write the copy constructor
    and the assignment operator, but the default destructor already does the right
    thing. (Note that using a reference member is almost always wrong.)'
  id: totrans-7504
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常**：当任何特殊函数仅被声明为非公共或虚拟，但没有特殊语义时，这并不意味着其他函数是必需的。在罕见的情况下，具有奇怪类型成员（如引用成员）的类是一个例外，因为它们具有特殊的复制语义。在一个包含引用的类中，你可能需要编写复制构造函数和赋值运算符，但默认析构函数已经做了正确的事情。（注意，使用引用成员几乎总是错误的。）'
- en: '**References**: [[SuttAlex05]](#SuttAlex05) Item 52; [[Cline99]](#Cline99)
    §30.01-14, [[Koenig97]](#Koenig97) §4, [[Stroustrup00]](#Stroustrup00) §5.5, §10.4,
    [[SuttHysl04b]](#SuttHysl04b)'
  id: totrans-7505
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**：[[SuttAlex05]](#SuttAlex05) 第52条；[[Cline99]](#Cline99) §30.01-14，[[Koenig97]](#Koenig97)
    §4，[[Stroustrup00]](#Stroustrup00) §5.5，§10.4，[[SuttHysl04b]](#SuttHysl04b)'
- en: 'Resource management rule summary:'
  id: totrans-7506
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理规则摘要：
- en: '[Provide strong resource safety; that is, never leak anything that you think
    of as a resource](#cr-safety)'
  id: totrans-7507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提供强大的资源安全性；也就是说，永远不要泄露你认为的资源](#cr-safety)'
- en: '[Never return or throw while holding a resource not owned by a handle](#cr-never)'
  id: totrans-7508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[永远不要在持有非句柄拥有的资源时返回或抛出异常](#cr-never)'
- en: '[A “raw” pointer or reference is never a resource handle](#cr-raw)'
  id: totrans-7509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“原始”指针或引用永远不会是资源句柄](#cr-raw)'
- en: '[Never let a pointer outlive the object it points to](#cr-outlive)'
  id: totrans-7510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[永远不要让指针的生命周期超过它指向的对象](#cr-outlive)'
- en: '[Use templates to express containers (and other resource handles)](#cr-templates)'
  id: totrans-7511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用模板来表示容器（和其他资源句柄）](#cr-templates)'
- en: '[Return containers by value (relying on move or copy elision for efficiency)](#cr-value-return)'
  id: totrans-7512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过值返回容器（依赖于移动或复制省略以提高效率）](#cr-value-return)'
- en: '[If a class is a resource handle, it needs a constructor, a destructor, and
    copy and/or move operations](#cr-handle)'
  id: totrans-7513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如果一个类是资源句柄，它需要一个构造函数、一个析构函数以及复制和/或移动操作](#cr-handle)'
- en: '[If a class is a container, give it an initializer-list constructor](#cr-list)'
  id: totrans-7514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如果一个类是容器，给它提供一个初始化列表构造函数](#cr-list)'
- en: 'Discussion: Provide strong resource safety; that is, never leak anything that
    you think of as a resource'
  id: totrans-7515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：提供强大的资源安全性；也就是说，永远不要泄露你认为的资源
- en: Reason
  id: totrans-7516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: Prevent leaks. Leaks can lead to performance degradation, mysterious error,
    system crashes, and security violations.
  id: totrans-7517
  prefs: []
  type: TYPE_NORMAL
  zh: 防止泄漏。泄漏可能导致性能下降、神秘错误、系统崩溃和安全违规。
- en: '**Alternative formulation**: Have every resource represented as an object of
    some class managing its lifetime.'
  id: totrans-7518
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方案**：将每个资源表示为某个类的一个对象，该类管理其生命周期。'
- en: Example
  id: totrans-7519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE919]'
  id: totrans-7520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: This class is a resource handle. It manages the lifetime of the `T`s. To do
    so, `Vector` must define or delete [the copy, move, and destruction operations](#rc-five).
  id: totrans-7521
  prefs: []
  type: TYPE_NORMAL
  zh: 此类是一个资源句柄。它管理`T`的生命周期。为此，`Vector`必须定义或删除[复制、移动和析构操作](#rc-five)。
- en: Example
  id: totrans-7522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE920]'
  id: totrans-7523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: Enforcement
  id: totrans-7524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: The basic technique for preventing leaks is to have every resource owned by
    a resource handle with a suitable destructor. A checker can find “naked `new`s”.
    Given a list of C-style allocation functions (e.g., `fopen()`), a checker can
    also find uses that are not managed by a resource handle. In general, “naked pointers”
    can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources
    cannot be generated without human input (the definition of “a resource” is necessarily
    too general), but a tool can be “parameterized” with a resource list.
  id: totrans-7525
  prefs: []
  type: TYPE_NORMAL
  zh: 防止泄漏的基本技术是让每个资源都由一个具有合适析构函数的资源句柄拥有。检查器可以找到“裸`new`s`”。给定一组C风格分配函数（例如，`fopen()`），检查器还可以找到未由资源句柄管理的使用情况。一般来说，“裸指针”可以被视为可疑、标记和/或分析。没有人类输入（“资源”的定义必然过于宽泛），无法生成完整的资源列表，但工具可以用资源列表进行“参数化”。
- en: 'Discussion: Never return or throw while holding a resource not owned by a handle'
  id: totrans-7526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：在持有非句柄拥有的资源时，永远不要返回或抛出
- en: Reason
  id: totrans-7527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: That would be a leak.
  id: totrans-7528
  prefs: []
  type: TYPE_NORMAL
  zh: 那将是泄漏。
- en: Example
  id: totrans-7529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE921]'
  id: totrans-7530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: 'If `i == 0` the file handle for `a file` is leaked. On the other hand, the
    `ifstream` for `another file` will correctly close its file (upon destruction).
    If you must use an explicit pointer, rather than a resource handle with specific
    semantics, use a `unique_ptr` or a `shared_ptr` with a custom deleter:'
  id: totrans-7531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`i == 0`，则`a file`的文件句柄会泄漏。另一方面，`another file`的`ifstream`将在销毁时正确关闭其文件。如果您必须使用显式指针，而不是具有特定语义的资源句柄，请使用`unique_ptr`或`shared_ptr`并带有自定义析构器：
- en: '[PRE922]'
  id: totrans-7532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: 'Better:'
  id: totrans-7533
  prefs: []
  type: TYPE_NORMAL
  zh: 更好：
- en: '[PRE923]'
  id: totrans-7534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: Enforcement
  id: totrans-7535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: A checker must consider all “naked pointers” suspicious. A checker probably
    must rely on a human-provided list of resources. For starters, we know about the
    standard-library containers, `string`, and smart pointers. The use of `span` and
    `string_view` should help a lot (they are not resource handles).
  id: totrans-7536
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器必须将所有“裸指针”视为可疑。检查器可能必须依赖于人类提供的资源列表。首先，我们知道标准库容器、`string`和智能指针。使用`span`和`string_view`将非常有帮助（它们不是资源句柄）。
- en: 'Discussion: A “raw” pointer or reference is never a resource handle'
  id: totrans-7537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：一个“原始”指针或引用永远不是资源句柄
- en: Reason
  id: totrans-7538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To be able to distinguish owners from views.
  id: totrans-7539
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够区分所有者和视图。
- en: Note
  id: totrans-7540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is independent of how you “spell” pointer: `T*`, `T&`, `Ptr<T>` and `Range<T>`
    are not owners.'
  id: totrans-7541
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您如何“拼写”指针无关：`T*`、`T&`、`Ptr<T>`和`Range<T>`都不是所有者。
- en: 'Discussion: Never let a pointer outlive the object it points to'
  id: totrans-7542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：永远不要让指针比它指向的对象存活时间更长
- en: Reason
  id: totrans-7543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined
    behavior and could lead to violations of the type system.
  id: totrans-7544
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免难以找到的错误。此类指针的解引用是未定义的行为，可能导致类型系统违规。
- en: Example
  id: totrans-7545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE924]'
  id: totrans-7546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: The `string`s of `v` are destroyed upon exit from `bad()` and so is `v` itself.
    The returned pointer points to unallocated memory on the free store. This memory
    (pointed into by `p`) might have been reallocated by the time `*p` is executed.
    There might be no `string` to read and a write through `p` could easily corrupt
    objects of unrelated types.
  id: totrans-7547
  prefs: []
  type: TYPE_NORMAL
  zh: '`v`的`string`在`bad()`退出时被销毁，`v`本身也是如此。返回的指针指向堆上的未分配内存。此内存（由`p`指向）在`*p`执行时可能已被重新分配。可能没有`string`可读取，并且通过`p`的写入可能会轻易破坏无关类型的对象。'
- en: Enforcement
  id: totrans-7548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行
- en: Most compilers already warn about simple cases and have the information to do
    more. Consider any pointer returned from a function suspect. Use containers, resource
    handles, and views (e.g., `span` known not to be resource handles) to lower the
    number of cases to be examined. For starters, consider every class with a destructor
    as resource handle.
  id: totrans-7549
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器已经警告了简单的情况，并且有更多的信息。考虑任何从函数返回的指针都是可疑的。使用容器、资源句柄和视图（例如，已知不是资源句柄的`span`）来减少需要检查的情况的数量。首先，考虑每个具有析构函数的类作为资源句柄。
- en: 'Discussion: Use templates to express containers (and other resource handles)'
  id: totrans-7550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：使用模板来表示容器（和其他资源句柄）
- en: Reason
  id: totrans-7551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To provide statically type-safe manipulation of elements.
  id: totrans-7552
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对元素的静态类型安全操作。
- en: Example
  id: totrans-7553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE925]'
  id: totrans-7554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: 'Discussion: Return containers by value (relying on move or copy elision for
    efficiency)'
  id: totrans-7555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：通过值返回容器（依靠移动或复制省略以提高效率）
- en: Reason
  id: totrans-7556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To simplify code and eliminate a need for explicit memory management. To bring
    an object into a surrounding scope, thereby extending its lifetime.
  id: totrans-7557
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码并消除显式内存管理的需要。将对象带入周围的作用域，从而延长其生命周期。
- en: '**See also**: [F.20, the general item about “out” output values](#rf-out)'
  id: totrans-7558
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅**：[F.20，关于“输出”值的一般项目](#rf-out)'
- en: Example
  id: totrans-7559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE926]'
  id: totrans-7560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: Exception
  id: totrans-7561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 异常
- en: See the Exceptions in [F.20](#rf-out).
  id: totrans-7562
  prefs: []
  type: TYPE_NORMAL
  zh: 见[F.20](#rf-out)中的异常。
- en: Enforcement
  id: totrans-7563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: Check for pointers and references returned from functions and see if they are
    assigned to resource handles (e.g., to a `unique_ptr`).
  id: totrans-7564
  prefs: []
  type: TYPE_NORMAL
  zh: 检查函数返回的指针和引用是否分配给资源句柄（例如，分配给`unique_ptr`）。
- en: 'Discussion: If a class is a resource handle, it needs a constructor, a destructor,
    and copy and/or move operations'
  id: totrans-7565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：如果一个类是资源句柄，它需要一个构造函数、析构函数和复制和/或移动操作
- en: Reason
  id: totrans-7566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: To provide complete control of the lifetime of the resource. To provide a coherent
    set of operations on the resource.
  id: totrans-7567
  prefs: []
  type: TYPE_NORMAL
  zh: 提供对资源生命周期的完全控制。提供对资源的一致操作集。
- en: Example
  id: totrans-7568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE927]'
  id: totrans-7569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: Note
  id: totrans-7570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If all members are resource handles, rely on the compiler-generated operations
    where possible.
  id: totrans-7571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有成员都是资源句柄，尽可能依赖编译器生成的操作。
- en: '[PRE928]'
  id: totrans-7572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: Now `Named` has a default constructor, a destructor, and efficient copy and
    move operations, provided `T` has.
  id: totrans-7573
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Named`有一个默认构造函数、析构函数和高效的复制和移动操作，前提是`T`有。
- en: Enforcement
  id: totrans-7574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: In general, a tool cannot know if a class is a resource handle. However, if
    a class has some of [the default operations](#ss-ctor), it should have all, and
    if a class has a member that is a resource handle, it should be considered as
    resource handle.
  id: totrans-7575
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个工具无法知道一个类是否是资源句柄。然而，如果一个类具有一些[默认操作](#ss-ctor)，它应该具有所有，如果一个类有一个是资源句柄的成员，它应该被视为资源句柄。
- en: 'Discussion: If a class is a container, give it an initializer-list constructor'
  id: totrans-7576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论：如果一个类是容器，给它一个初始化列表构造函数
- en: Reason
  id: totrans-7577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原因
- en: It is common to need an initial set of elements.
  id: totrans-7578
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要一个初始元素集。
- en: Example
  id: totrans-7579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE929]'
  id: totrans-7580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: Enforcement
  id: totrans-7581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执法
- en: When is a class a container? ???
  id: totrans-7582
  prefs: []
  type: TYPE_NORMAL
  zh: 何时一个类是容器？ ???
- en: 'Appendix D: Supporting tools'
  id: totrans-7583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录D：支持工具
- en: This section contains a list of tools that directly support adoption of the
    C++ Core Guidelines. This list is not intended to be an exhaustive list of tools
    that are helpful in writing good C++ code. If a tool is designed specifically
    to support and links to the C++ Core Guidelines it is a candidate for inclusion.
  id: totrans-7584
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含一个工具列表，这些工具直接支持采用C++核心指南。这个列表并不是一个旨在列出所有有助于编写良好C++代码的工具的详尽列表。如果一个工具专门设计来支持并链接到C++核心指南，它就是包含的候选者。
- en: 'Tools: [Clang-tidy](https://clang.llvm.org/extra/clang-tidy/checks/list.html)'
  id: totrans-7585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具：[Clang-tidy](https://clang.llvm.org/extra/clang-tidy/checks/list.html)
- en: Clang-tidy has a set of rules that specifically enforce the C++ Core Guidelines.
    These rules are named in the pattern `cppcoreguidelines-*`.
  id: totrans-7586
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-tidy有一组旨在执行C++核心指南的规则。这些规则以`cppcoreguidelines-*`的模式命名。
- en: 'Tools: [CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)'
  id: totrans-7587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具：[CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)
- en: The Microsoft compiler’s C++ code analysis contains a set of rules specifically
    aimed at enforcement of the C++ Core Guidelines.
  id: totrans-7588
  prefs: []
  type: TYPE_NORMAL
  zh: 微软编译器的C++代码分析包含一组旨在执行C++核心指南的规则。
- en: Glossary
  id: totrans-7589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词汇表
- en: 'A relatively informal definition of terms used in the guidelines (based off
    the glossary in [Programming: Principles and Practice using C++](https://www.stroustrup.com/programming.html))'
  id: totrans-7590
  prefs: []
  type: TYPE_NORMAL
  zh: 指南中使用的术语的相对非正式定义（基于[《使用C++编程：原理与实践》](https://www.stroustrup.com/programming.html)中的词汇表）
- en: More information on many topics about C++ can be found on the [Standard C++
    Foundation](https://isocpp.org)’s site.
  id: totrans-7591
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C++的许多主题的更多信息可以在[标准C++基金会](https://isocpp.org)的网站上找到。
- en: '*ABI*: Application Binary Interface, a specification for a specific hardware
    platform combined with the operating system. Contrast with API.'
  id: totrans-7592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ABI*：应用程序二进制接口，是特定硬件平台与操作系统的结合规范。与API相对比。'
- en: '*abstract class*: a class that cannot be directly used to create objects; often
    used to define an interface to derived classes. A class is made abstract by having
    a pure virtual function or only protected constructors.'
  id: totrans-7593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象类*：一个不能直接用来创建对象的类；通常用于定义派生类的接口。一个类通过拥有一个纯虚函数或仅有的受保护构造函数来成为抽象类。'
- en: '*abstraction*: a description of something that selectively and deliberately
    ignores (hides) details (e.g., implementation details); selective ignorance.'
  id: totrans-7594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*abstraction*：对某物的描述，有选择性地故意忽略（隐藏）细节（例如，实现细节）；选择性无知。'
- en: '*address*: a value that allows us to find an object in a computer’s memory.'
  id: totrans-7595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*address*：允许我们在计算机内存中找到对象的值。'
- en: '*algorithm*: a procedure or formula for solving a problem; a finite series
    of computational steps to produce a result.'
  id: totrans-7596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*algorithm*：解决问题的程序或公式；产生结果的一组有限的计算步骤。'
- en: '*alias*: an alternative way of referring to an object; often a name, pointer,
    or reference.'
  id: totrans-7597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*alias*：指代对象的另一种方式；通常是名称、指针或引用。'
- en: '*API*: Application Programming Interface, a set of functions that form the
    communication between various software components. Contrast with ABI.'
  id: totrans-7598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*API*：应用程序编程接口，一组形成各种软件组件之间通信的函数。与ABI相对。'
- en: '*application*: a program or a collection of programs that is considered an
    entity by its users.'
  id: totrans-7599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*application*：一个程序或一组程序，用户将其视为一个实体。'
- en: '*approximation*: something (e.g., a value or a design) that is close to the
    perfect or ideal (value or design). Often an approximation is a result of trade-offs
    among ideals.'
  id: totrans-7600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*approximation*：接近完美或理想的某物（例如，值或设计）。通常，近似是理想之间的权衡的结果。'
- en: '*argument*: a value passed to a function or a template, in which it is accessed
    through a parameter.'
  id: totrans-7601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*argument*：传递给函数或模板的值，通过参数访问它。'
- en: '*array*: a homogeneous sequence of elements, usually numbered, e.g., `[0:max)`.'
  id: totrans-7602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*array*：同质元素序列，通常编号，例如，`[0:max)`。'
- en: '*assertion*: a statement inserted into a program to state (assert) that something
    must always be true at this point in the program.'
  id: totrans-7603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*assertion*：插入到程序中的一条语句，用于声明（断言）在程序的这个点上某物必须始终为真。'
- en: '*base class*: a type that is intended to be derived from (e.g., has a non-`final`
    virtual function), and objects of the type are intended to be used only indirectly
    (e.g., by pointer). [In strict terms, “base class” could be defined as “something
    we derived from” but we are specifying in terms of the class designer’s intent.]
    Typically a base class has one or more virtual functions.'
  id: totrans-7604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*base class*：旨在从其派生的类型（例如，具有非`final`虚拟函数），该类型的对象旨在仅间接使用（例如，通过指针）。[严格来说，“基类”可以定义为“我们从其派生的东西”，但我们是在根据类设计者的意图进行指定。]通常，基类有一个或多个虚拟函数。'
- en: '*bit*: the basic unit of information in a computer. A bit can have the value
    0 or the value 1.'
  id: totrans-7605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bit*：计算机中的基本信息单位。一个比特可以是0或1的值。'
- en: '*bug*: an error in a program.'
  id: totrans-7606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bug*：程序中的错误。'
- en: '*byte*: the basic unit of addressing in most computers. Typically, a byte holds
    8 bits.'
  id: totrans-7607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*byte*：大多数计算机中寻址的基本单位。通常，一个字节包含8位。'
- en: '*class*: a user-defined type that can contain data members, function members,
    and member types.'
  id: totrans-7608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*class*：用户定义的类型，可以包含数据成员、函数成员和成员类型。'
- en: '*code*: a program or a part of a program; ambiguously used for both source
    code and object code.'
  id: totrans-7609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*code*：程序或程序的一部分；模糊地用于源代码和目标代码。'
- en: '*compiler*: a program that turns source code into object code.'
  id: totrans-7610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*compiler*：将源代码转换为目标代码的程序。'
- en: '*complexity*: a hard-to-precisely-define notion or measure of the difficulty
    of constructing a solution to a problem or of the solution itself. Sometimes complexity
    is used to (simply) mean an estimate of the number of operations needed to execute
    an algorithm.'
  id: totrans-7611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*complexity*：难以精确定义的概念或衡量解决问题或解决方案本身的难度的度量。有时复杂性被用来（简单地）表示执行算法所需的操作数的估计。'
- en: '*computation*: the execution of some code, usually taking some input and producing
    some output.'
  id: totrans-7612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*computation*：执行某些代码，通常需要一些输入并产生一些输出。'
- en: '*concept*: (1) a notion, and idea; (2) a set of requirements, usually for a
    template argument.'
  id: totrans-7613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*concept*：（1）一个概念，一个想法；（2）一组要求，通常用于模板参数。'
- en: '*concrete type*: a type that is not a base class, and objects of the type are
    intended to be used directly (not only by pointer/indirection), its size is known,
    it can typically be allocated anywhere the programmer wants (e.g., stack or statically).'
  id: totrans-7614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*concrete type*：不是基类的类型，该类型的对象旨在直接使用（不仅通过指针/间接），其大小是已知的，通常可以在程序员想要的地方分配（例如，堆栈或静态）。'
- en: '*constant*: a value that cannot be changed (in a given scope); not mutable.'
  id: totrans-7615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*constant*：在给定范围内不能更改的值（不可变）。'
- en: '*constructor*: an operation that initializes (“constructs”) an object. Typically
    a constructor establishes an invariant and often acquires resources needed for
    an object to be used (which are then typically released by a destructor).'
  id: totrans-7616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构造函数*：一个初始化（构造）对象的操作。通常，构造函数建立不变性，并且通常获取对象使用所需的资源（然后通常由析构函数释放）。'
- en: '*container*: an object that holds elements (other objects).'
  id: totrans-7617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器*：一个包含元素（其他对象）的对象。'
- en: '*copy*: an operation that makes two objects have values that compare equal.
    See also move.'
  id: totrans-7618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复制*：一个操作，使得两个对象具有相等的值。另见移动。'
- en: '*correctness*: a program or a piece of a program is correct if it meets its
    specification. Unfortunately, a specification can be incomplete or inconsistent,
    or can fail to meet users’ reasonable expectations. Thus, to produce acceptable
    code, we sometimes have to do more than just follow the formal specification.'
  id: totrans-7619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正确性*：如果一个程序或程序的一部分满足其规格说明，则该程序或程序的一部分是正确的。不幸的是，规格说明可能是不完整或不一致的，或者可能无法满足用户的合理期望。因此，为了生成可接受的代码，我们有时必须做的不仅仅是遵循正式的规格说明。'
- en: '*cost*: the expense (e.g., in programmer time, run time, or space) of producing
    a program or of executing it. Ideally, cost should be a function of complexity.'
  id: totrans-7620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*成本*：生成程序或执行程序的费用（例如，在程序员时间、运行时间或空间方面）。理想情况下，成本应该是复杂性的函数。'
- en: '*customization point*: ???'
  id: totrans-7621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自定义点*：???'
- en: '*data*: values used in a computation.'
  id: totrans-7622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据*：用于计算中的值。'
- en: '*debugging*: the act of searching for and removing errors from a program; usually
    far less systematic than testing.'
  id: totrans-7623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试*：搜索和删除程序中的错误的行为；通常不如测试系统化。'
- en: '*declaration*: the specification of a name with its type in a program.'
  id: totrans-7624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*声明*：在程序中指定一个名称及其类型。'
- en: '*definition*: a declaration of an entity that supplies all information necessary
    to complete a program using the entity. Simplified definition: a declaration that
    allocates memory.'
  id: totrans-7625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义*：一个提供完成程序所需所有必要信息的实体的声明。简化定义：一个分配内存的声明。'
- en: '*derived class*: a class derived from one or more base classes.'
  id: totrans-7626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*派生类*：从一个或多个基类派生出的类。'
- en: '*design*: an overall description of how a piece of software should operate
    to meet its specification.'
  id: totrans-7627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计*：对软件如何操作以满足其规格说明的整体描述。'
- en: '*destructor*: an operation that is implicitly invoked (called) when an object
    is destroyed (e.g., at the end of a scope). Often, it releases resources.'
  id: totrans-7628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*析构函数*：当对象被销毁时（例如，在作用域结束时）隐式调用（调用）的操作。通常，它释放资源。'
- en: '*encapsulation*: protecting something meant to be private (e.g., implementation
    details) from unauthorized access.'
  id: totrans-7629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*封装*：保护某些打算为私有的东西（例如实现细节）免受未经授权的访问。'
- en: '*error*: a mismatch between reasonable expectations of program behavior (often
    expressed as a requirement or a users’ guide) and what a program actually does.'
  id: totrans-7630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*：程序行为的合理期望（通常表示为需求或用户指南）与程序实际执行之间的不匹配。'
- en: '*executable*: a program ready to be run (executed) on a computer.'
  id: totrans-7631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可执行文件*：准备好在计算机上运行（执行）的程序。'
- en: '*feature creep*: a tendency to add excess functionality to a program “just
    in case.”'
  id: totrans-7632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*功能蔓延*：倾向于向程序添加过多的功能“以防万一”。'
- en: '*file*: a container of permanent information in a computer.'
  id: totrans-7633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件*：计算机中永久信息的容器。'
- en: '*floating-point number*: a computer’s approximation of a real number, such
    as 7.93 and 10.78e-3.'
  id: totrans-7634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浮点数*：计算机对实数的近似，例如7.93和10.78e-3。'
- en: '*function*: a named unit of code that can be invoked (called) from different
    parts of a program; a logical unit of computation.'
  id: totrans-7635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数*：可以从程序的不同部分调用的命名代码单元；计算逻辑单元。'
- en: '*generic programming*: a style of programming focused on the design and efficient
    implementation of algorithms. A generic algorithm will work for all argument types
    that meet its requirements. In C++, generic programming typically uses templates.'
  id: totrans-7636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泛型编程*：一种编程风格，专注于算法的设计和高效实现。泛型算法将适用于满足其要求的所有参数类型。在C++中，泛型编程通常使用模板。'
- en: '*global variable*: technically, a named object in namespace scope.'
  id: totrans-7637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局变量*：技术上，命名对象在命名空间作用域内。'
- en: '*handle*: a class that allows access to another through a member pointer or
    reference. See also resource, copy, move.'
  id: totrans-7638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*句柄*：一个允许通过成员指针或引用访问另一个对象的类。另见资源、复制、移动。'
- en: '*header*: a file containing declarations used to share interfaces between parts
    of a program.'
  id: totrans-7639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头文件*：包含用于在程序的不同部分之间共享接口的声明的文件。'
- en: '*hiding*: the act of preventing a piece of information from being directly
    seen or accessed. For example, a name from a nested (inner) scope can prevent
    that same name from an outer (enclosing) scope from being directly used.'
  id: totrans-7640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隐藏*：防止信息被直接看到或访问的行为。例如，一个嵌套（内部）作用域中的名称可以防止外部（封装）作用域中的相同名称被直接使用。'
- en: '*ideal*: the perfect version of something we are striving for. Usually we have
    to make trade-offs and settle for an approximation.'
  id: totrans-7641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理想的*：我们努力追求的某物的完美版本。通常我们不得不做出权衡，并满足于近似值。'
- en: '*implementation*: (1) the act of writing and testing code; (2) the code that
    implements a program.'
  id: totrans-7642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现*：（1）编写和测试代码的行为；（2）实现程序的代码。'
- en: '*infinite loop*: a loop where the termination condition never becomes true.
    See iteration.'
  id: totrans-7643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无限循环*：一个终止条件永远不会成为真的循环。参见迭代。'
- en: '*infinite recursion*: a recursion that doesn’t end until the machine runs out
    of memory to hold the calls. In reality, such recursion is never infinite but
    is terminated by some hardware error.'
  id: totrans-7644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无限递归*：直到机器耗尽内存来保存调用才结束的递归。实际上，这样的递归永远不会无限，而是由某些硬件错误终止。'
- en: '*information hiding*: the act of separating interface and implementation, thus
    hiding implementation details not meant for the user’s attention and providing
    an abstraction.'
  id: totrans-7645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息隐藏*：分离接口和实现的行为，从而隐藏用户不需要注意的实现细节，并提供抽象。 '
- en: '*initialize*: giving an object its first (initial) value.'
  id: totrans-7646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化*：给对象赋予其第一个（初始）值。'
- en: '*input*: values used by a computation (e.g., function arguments and characters
    typed on a keyboard).'
  id: totrans-7647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入*：计算使用的值（例如，函数参数和键盘上输入的字符）。'
- en: '*integer*: a whole number, such as 42 and -99.'
  id: totrans-7648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整数*：一个整数，例如42和-99。'
- en: '*interface*: a declaration or a set of declarations specifying how a piece
    of code (such as a function or a class) can be called.'
  id: totrans-7649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接口*：声明或一组声明，指定如何调用代码（如函数或类）。'
- en: '*invariant*: something that must be always true at a given point (or points)
    of a program; typically used to describe the state (set of values) of an object
    or the state of a loop before entry into the repeated statement.'
  id: totrans-7650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不变量*：在程序的某个（些）点上必须始终为真的东西；通常用于描述对象的状态（值集）或循环在进入重复语句之前的状态。'
- en: '*iteration*: the act of repeatedly executing a piece of code; see recursion.'
  id: totrans-7651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代*：重复执行代码片段的行为；参见递归。'
- en: '*iterator*: an object that identifies an element of a sequence.'
  id: totrans-7652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迭代器*：一个标识序列中元素的对象。'
- en: '*ISO*: International Organization for Standardization. The C++ language is
    an ISO standard, ISO/IEC 14882\. More information at [iso.org](https://iso.org).'
  id: totrans-7653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO*：国际标准化组织。C++语言是一个ISO标准，ISO/IEC 14882。更多信息请访问[iso.org](https://iso.org)。'
- en: '*library*: a collection of types, functions, classes, etc. implementing a set
    of facilities (abstractions) meant to be potentially used as part of more than
    one program.'
  id: totrans-7654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*库*：一组类型、函数、类等，实现了一组设施（抽象），这些设施（抽象）可能被用作多个程序的一部分。'
- en: '*lifetime*: the time from the initialization of an object until it becomes
    unusable (goes out of scope, is deleted, or the program terminates).'
  id: totrans-7655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生命周期*：从对象的初始化到它变得不可使用（超出作用域、被删除或程序终止）的时间。'
- en: '*linker*: a program that combines object code files and libraries into an executable
    program.'
  id: totrans-7656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接器*：一个将目标代码文件和库组合成可执行程序的程序。'
- en: '*literal*: a notation that directly specifies a value, such as 12 specifying
    the integer value “twelve.”'
  id: totrans-7657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字面量*：直接指定值的表示法，例如12指定整数值“十二”。'
- en: '*loop*: a piece of code executed repeatedly; in C++, typically a for-statement
    or a `while`-statement.'
  id: totrans-7658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*循环*：重复执行的代码片段；在C++中通常是for语句或while语句。'
- en: '*move*: an operation that transfers a value from one object to another leaving
    behind a value representing “empty.” See also copy.'
  id: totrans-7659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移动*：将值从一个对象转移到另一个对象的操作，留下表示“空”的值。另见复制。'
- en: '*move-only type*: a concrete type that is movable but not copyable.'
  id: totrans-7660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移动类型*：一个可移动但不能复制的具体类型。'
- en: '*mutable*: changeable; the opposite of immutable, constant, and invariable.'
  id: totrans-7661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可变的*：可更改的；与不可变的、常量和不变的相反。'
- en: '*object*: (1) an initialized region of memory of a known type which holds a
    value of that type; (2) a region of memory.'
  id: totrans-7662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象*：（1）一个已知类型的初始化内存区域，它持有该类型的值；（2）一个内存区域。'
- en: '*object code*: output from a compiler intended as input for a linker (for the
    linker to produce executable code).'
  id: totrans-7663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标代码*：编译器输出的，作为链接器输入的代码（以便链接器生成可执行代码）。'
- en: '*object file*: a file containing object code.'
  id: totrans-7664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标文件*：包含目标代码的文件。'
- en: '*object-oriented programming*: (OOP) a style of programming focused on the
    design and use of classes and class hierarchies.'
  id: totrans-7665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*object-oriented programming*：（OOP）一种关注类和类层次结构的设计和使用的编程风格。'
- en: '*operation*: something that can perform some action, such as a function and
    an operator.'
  id: totrans-7666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*operation*：可以执行某些操作的事物，例如函数和运算符。'
- en: '*output*: values produced by a computation (e.g., a function result or lines
    of characters written on a screen).'
  id: totrans-7667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*output*：计算产生的值（例如，函数结果或写入屏幕的字符行）。'
- en: '*overflow*: producing a value that cannot be stored in its intended target.'
  id: totrans-7668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*overflow*：产生一个无法存储在其预期目标中的值。'
- en: '*overload*: defining two functions or operators with the same name but different
    argument (operand) types.'
  id: totrans-7669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*overload*：定义两个具有相同名称但不同参数（操作数）类型的函数或运算符。'
- en: '*override*: defining a function in a derived class with the same name and argument
    types as a virtual function in the base class, thus making the function callable
    through the interface defined by the base class.'
  id: totrans-7670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*override*：在派生类中定义与基类中虚拟函数具有相同名称和参数类型的函数，从而使得函数可以通过基类定义的接口调用。'
- en: '*owner*: an object responsible for releasing a resource.'
  id: totrans-7671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*owner*：负责释放资源的对象。'
- en: '*paradigm*: a somewhat pretentious term for design or programming style; often
    used with the (erroneous) implication that there exists a paradigm that is superior
    to all others.'
  id: totrans-7672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*paradigm*：设计或编程风格的一个有些自负的术语；常与（错误的）暗示一起使用，即存在一个优于所有其他风格的范式。'
- en: '*parameter*: a declaration of an explicit input to a function or a template.
    When called, a function can access the arguments passed through the names of its
    parameters.'
  id: totrans-7673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*parameter*：函数或模板的显式输入的声明。当调用时，函数可以通过其参数名称访问传递的参数。'
- en: '*pointer*: (1) a value used to identify a typed object in memory; (2) a variable
    holding such a value.'
  id: totrans-7674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pointer*：（1）用于在内存中标识类型对象的值；（2）持有此类值的变量。'
- en: '*post-condition*: a condition that must hold upon exit from a piece of code,
    such as a function or a loop.'
  id: totrans-7675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*post-condition*：在从一段代码（如函数或循环）退出时必须满足的条件。'
- en: '*pre-condition*: a condition that must hold upon entry into a piece of code,
    such as a function or a loop.'
  id: totrans-7676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pre-condition*：在进入一段代码（如函数或循环）之前必须满足的条件。'
- en: '*program*: code (possibly with associated data) that is sufficiently complete
    to be executed by a computer.'
  id: totrans-7677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*program*：足够完整以由计算机执行的代码（可能附带相关数据）。'
- en: '*programming*: the art of expressing solutions to problems as code.'
  id: totrans-7678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*programming*：将问题的解决方案表达为代码的艺术。'
- en: '*programming language*: a language for expressing programs.'
  id: totrans-7679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*programming language*：表达程序的编程语言。'
- en: '*pseudo code*: a description of a computation written in an informal notation
    rather than a programming language.'
  id: totrans-7680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pseudo code*：用非正式符号而不是编程语言编写的计算描述。'
- en: '*pure virtual function*: a virtual function that must be overridden in a derived
    class.'
  id: totrans-7681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pure virtual function*：必须在派生类中重写的虚拟函数。'
- en: '*RAII*: (“Resource Acquisition Is Initialization”) a basic technique for resource
    management based on scopes.'
  id: totrans-7682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RAII*：（“资源获取即初始化”）基于作用域的基本资源管理技术。'
- en: '*range*: a sequence of values that can be described by a start point and an
    end point. For example, `[0:5)` means the values 0, 1, 2, 3, and 4.'
  id: totrans-7683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*range*：可以通过起点和终点描述的值序列。例如，`[0:5)` 表示值 0, 1, 2, 3 和 4。'
- en: '*recursion*: the act of a function calling itself; see also iteration.'
  id: totrans-7684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*recursion*：函数调用自身的行为；另见迭代。'
- en: '*reference*: (1) a value describing the location of a typed value in memory;
    (2) a variable holding such a value.'
  id: totrans-7685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*reference*：（1）描述类型值在内存中位置的值；（2）持有此类值的变量。'
- en: '*regular expression*: a notation for patterns in character strings.'
  id: totrans-7686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*regular expression*：字符字符串中模式的表示法。'
- en: '*regular*: a semiregular type that is equality-comparable (see `std::regular`
    concept). After a copy, the copied object compares equal to the original object.
    A regular type behaves similarly to built-in types like `int` and can be compared
    with `==`. In particular, an object of a regular type can be copied and the result
    of a copy is a separate object that compares equal to the original. See also *semiregular
    type*.'
  id: totrans-7687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*regular*：一种半正则类型，是可比较的（参见 `std::regular` 概念）。复制后，复制的对象与原始对象相等。正则类型的行为类似于内置类型如
    `int`，可以用 `==` 进行比较。特别是，正则类型的对象可以被复制，复制的结果是另一个与原始对象相等的独立对象。另见 *semiregular type*。'
- en: '*requirement*: (1) a description of the desired behavior of a program or part
    of a program; (2) a description of the assumptions a function or template makes
    of its arguments.'
  id: totrans-7688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*requirement*：（1）对程序或程序部分所需行为的描述；（2）函数或模板对其参数的假设的描述。'
- en: '*resource*: something that is acquired and must later be released, such as
    a file handle, a lock, or memory. See also handle, owner.'
  id: totrans-7689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*resource*: 被获取并在以后必须释放的东西，例如文件句柄、锁或内存。另见handle、owner。'
- en: '*rounding*: conversion of a value to the mathematically nearest value of a
    less precise type.'
  id: totrans-7690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*rounding*: 将值转换为数学上最接近的较低精度类型的值。'
- en: '*RTTI*: Run-Time Type Information. ???'
  id: totrans-7691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RTTI*: 运行时类型信息。???'
- en: '*scope*: the region of program text (source code) in which a name can be referred
    to.'
  id: totrans-7692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*scope*: 可以引用名称的程序文本（源代码）区域。'
- en: '*semiregular*: a concrete type that is copyable (including movable) and default-constructible
    (see `std::semiregular` concept). The result of a copy is an independent object
    with the same value as the original. A semiregular type behaves roughly like a
    built-in type like `int`, but possibly without a `==` operator. See also *regular
    type*.'
  id: totrans-7693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*semiregular*: 一个可复制（包括可移动）且默认可构造（参见`std::semiregular`概念）的具体类型。复制的结果是具有与原始对象相同值的独立对象。半正则类型的行为大致类似于`int`这样的内置类型，但可能没有`==`运算符。另见*regular
    type*。'
- en: '*sequence*: elements that can be visited in a linear order.'
  id: totrans-7694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sequence*: 可以按线性顺序访问的元素。'
- en: '*software*: a collection of pieces of code and associated data; often used
    interchangeably with program.'
  id: totrans-7695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*software*: 一组代码片段和相关数据的集合；通常与程序互换使用。'
- en: '*source code*: code as produced by a programmer and (in principle) readable
    by other programmers.'
  id: totrans-7696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*source code*: 程序员生成的代码，原则上可由其他程序员阅读。'
- en: '*source file*: a file containing source code.'
  id: totrans-7697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*source file*: 包含源代码的文件。'
- en: '*specification*: a description of what a piece of code should do.'
  id: totrans-7698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*specification*: 对代码应执行的操作的描述。'
- en: '*standard*: an officially agreed upon definition of something, such as a programming
    language.'
  id: totrans-7699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*standard*: 对某物的官方协议定义，例如编程语言。'
- en: '*state*: a set of values.'
  id: totrans-7700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*state*: 一组值。'
- en: '*STL*: the containers, iterators, and algorithms part of the standard library.'
  id: totrans-7701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*STL*: 标准库中的容器、迭代器和算法部分。'
- en: '*string*: a sequence of characters.'
  id: totrans-7702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*string*: 字符序列。'
- en: '*style*: a set of techniques for programming leading to a consistent use of
    language features; sometimes used in a very restricted sense to refer just to
    low-level rules for naming and appearance of code.'
  id: totrans-7703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*style*: 一组编程技术，用于引导语言特性的统一使用；有时在非常受限的意义上使用，仅指命名和代码外观的低级规则。'
- en: '*subtype*: derived type; a type that has all the properties of a type and possibly
    more.'
  id: totrans-7704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*subtype*: 派生类型；具有类型的所有属性，可能还有更多属性。'
- en: '*supertype*: base type; a type that has a subset of the properties of a type.'
  id: totrans-7705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*supertype*: 基础类型；一个具有类型属性子集的类型。'
- en: '*system*: (1) a program or a set of programs for performing a task on a computer;
    (2) a shorthand for “operating system”, that is, the fundamental execution environment
    and tools for a computer.'
  id: totrans-7706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*system*: (1) 在计算机上执行任务的程序或程序集；(2) “操作系统”的简称，即计算机的基本执行环境和工具。'
- en: '*TS*: [Technical Specification](https://www.iso.org/deliverables-all.html?type=ts),
    A Technical Specification addresses work still under technical development, or
    where it is believed that there will be a future, but not immediate, possibility
    of agreement on an International Standard. A Technical Specification is published
    for immediate use, but it also provides a means to obtain feedback. The aim is
    that it will eventually be transformed and republished as an International Standard.'
  id: totrans-7707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TS*: [技术规范](https://www.iso.org/deliverables-all.html?type=ts)，技术规范针对仍在技术发展中或预计将来但不是立即可能达成国际标准的工作。技术规范是为了立即使用而发布的，但它也提供了一种获取反馈的手段。目标是它最终将被转换并重新发布为国际标准。'
- en: '*template*: a class or a function parameterized by one or more types or (compile-time)
    values; the basic C++ language construct supporting generic programming.'
  id: totrans-7708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*template*: 通过一个或多个类型或（编译时）值参数化的类或函数；支持泛型编程的基本C++语言结构。'
- en: '*testing*: a systematic search for errors in a program.'
  id: totrans-7709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*testing*: 对程序中错误进行系统性的搜索。'
- en: '*trade-off*: the result of balancing several design and implementation criteria.'
  id: totrans-7710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*trade-off*: 平衡几个设计和实现标准的结果。'
- en: '*truncation*: loss of information in a conversion from a type into another
    that cannot exactly represent the value to be converted.'
  id: totrans-7711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*truncation*: 在将类型转换为无法精确表示要转换的值的类型时丢失信息。'
- en: '*type*: something that defines a set of possible values and a set of operations
    for an object.'
  id: totrans-7712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*type*: 定义一组可能值和一组操作的对象。'
- en: '*uninitialized*: the (undefined) state of an object before it is initialized.'
  id: totrans-7713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*uninitialized*: 在初始化之前对象所处的（未定义的）状态。'
- en: '*unit*: (1) a standard measure that gives meaning to a value (e.g., km for
    a distance); (2) a distinguished (e.g., named) part of a larger whole.'
  id: totrans-7714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单位*：（1）一个赋予值意义的标准度量（例如，距离的km）；（2）一个较大的整体中的显著（例如，命名的）部分。'
- en: '*use case*: a specific (typically simple) use of a program meant to test its
    functionality and demonstrate its purpose.'
  id: totrans-7715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*：一个特定的（通常是简单的）程序用途，旨在测试其功能并展示其目的。'
- en: '*value*: a set of bits in memory interpreted according to a type.'
  id: totrans-7716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值*：内存中一组按类型解释的位。'
- en: '*value type*: a term some people use to mean a regular or semiregular type.'
  id: totrans-7717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值类型*：一些人用来表示常规或半常规类型的术语。'
- en: '*variable*: a named object of a given type; contains a value unless uninitialized.'
  id: totrans-7718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*变量*：给定类型的命名对象；除非未初始化，否则包含一个值。'
- en: '*virtual function*: a member function that can be overridden in a derived class.'
  id: totrans-7719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚函数*：一个可以在派生类中重写的成员函数。'
- en: '*word*: a basic unit of memory in a computer, often the unit used to hold an
    integer.'
  id: totrans-7720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单词*：计算机中内存的基本单元，通常是用来存储整数的单元。'
- en: 'To-do: Unclassified proto-rules'
  id: totrans-7721
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项：未分类的原型规则
- en: This is our to-do list. Eventually, the entries will become rules or parts of
    rules. Alternatively, we will decide that no change is needed and delete the entry.
  id: totrans-7722
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的待办事项清单。最终，条目将变成规则或规则的一部分。或者，我们可能会决定不需要更改，并删除条目。
- en: No long-distance friendship
  id: totrans-7723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有长距离的友谊
- en: Should physical design (what’s in a file) and large-scale design (libraries,
    groups of libraries) be addressed?
  id: totrans-7724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该处理物理设计（文件中的内容）和大规模设计（库、库组）？
- en: Namespaces
  id: totrans-7725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Avoid using directives in the global scope (except for std, and other “fundamental”
    namespaces (e.g. experimental))
  id: totrans-7726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在全局作用域中使用指令（除了std和其他“基本”命名空间（例如实验性的））
- en: How granular should namespaces be? All classes/functions designed to work together
    and released together (as defined in Sutter/Alexandrescu) or something narrower
    or wider?
  id: totrans-7727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间应该有多细？所有设计为一起工作并一起发布的类/函数（如Sutter/Alexandrescu所定义）或更窄或更宽的范围？
- en: Should there be inline namespaces (à la `std::literals::*_literals`)?
  id: totrans-7728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该有内联命名空间（类似于`std::literals::*_literals`）？
- en: Avoid implicit conversions
  id: totrans-7729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免隐式转换
- en: Const member functions should be thread safe … aka, but I don’t really change
    the variable, just assign it a value the first time it’s called … argh
  id: totrans-7730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量成员函数应该是线程安全的……也称为，但我实际上并没有改变变量，只是第一次调用时给它赋值……啊
- en: Always initialize variables, use initialization lists for data members.
  id: totrans-7731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是初始化变量，使用初始化列表对数据成员进行初始化。
- en: Anyone writing a public interface which takes or returns `void*` should have
    their toes set on fire. That one has been a personal favorite of mine for a number
    of years. :)
  id: totrans-7732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何编写接受或返回`void*`的公共接口的人都应该被点燃脚趾。这已经是我多年的个人最爱了。 :)
- en: 'Use `const`-ness wherever possible: member functions, variables and (yippee)
    `const_iterators`'
  id: totrans-7733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`const`：成员函数、变量和（耶）`const_iterators`
- en: Use `auto`
  id: totrans-7734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`
- en: '`(size)` vs. `{initializers}` vs. `{Extent{size}}`'
  id: totrans-7735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(size)` 与 `{初始化器}` 与 `{Extent{size}}`'
- en: Don’t overabstract
  id: totrans-7736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要过度抽象
- en: Never pass a pointer down the call stack
  id: totrans-7737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要将指针传递到调用栈中
- en: falling through a function bottom
  id: totrans-7738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数底部掉落
- en: Should there be guidelines to choose between polymorphisms? YES. classic (virtual
    functions, reference semantics) vs. Sean Parent style (value semantics, type-erased,
    kind of like `std::function`) vs. CRTP/static? YES Perhaps even vs. tag dispatch?
  id: totrans-7739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该有指南来选择多态性？YES。经典（虚函数，引用语义）与Sean Parent风格（值语义，类型擦除，类似于`std::function`）与CRTP/静态？YES。也许甚至还有标签分发？
- en: should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot
    of people ban them, even though I think it’s a big strength of C++ that they are
    ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD
    BE A GOOD EXAMPLE?
  id: totrans-7740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的指南中是否应该禁止在构造函数/析构函数中使用虚函数？YES。很多人禁止这样做，尽管我认为这是C++的一个大优点，它们是??? -preserving（D让我非常失望，当它走向Java的方式时）。什么是一个好的例子？
- en: Speaking of lambdas, what would weigh in on the decision between lambdas and
    (local?) classes in algorithm calls and other callback scenarios?
  id: totrans-7741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谈到lambda表达式，在算法调用和其他回调场景中，是什么因素会影响在lambda表达式和（局部？）类之间的选择？
- en: And speaking of `std::bind`, Stephen T. Lavavej criticizes it so much I’m starting
    to wonder if it is indeed going to fade away in future. Should lambdas be recommended
    instead?
  id: totrans-7742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说到`std::bind`，Stephen T. Lavavej对其进行了如此多的批评，我开始怀疑它是否真的会在未来消失。是否应该推荐使用lambda表达式？
- en: 'What to do with leaks out of temporaries? : `p = (s1 + s2).c_str();`'
  id: totrans-7743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理临时对象的泄漏？：`p = (s1 + s2).c_str();`
- en: 'pointer/iterator invalidation leading to dangling pointers:'
  id: totrans-7744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针/迭代器失效导致悬挂指针：
- en: '[PRE930]'
  id: totrans-7745
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE930]'
- en: LSP
  id: totrans-7746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LSP
- en: private inheritance vs/and membership
  id: totrans-7747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有继承与成员关系
- en: avoid static class members variables (race conditions, almost-global variables)
  id: totrans-7748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免静态类成员变量（竞争条件，几乎全局变量）
- en: Use RAII lock guards (`lock_guard`, `unique_lock`, `shared_lock`), never call
    `mutex.lock` and `mutex.unlock` directly (RAII)
  id: totrans-7749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RAII 锁保护器（`lock_guard`、`unique_lock`、`shared_lock`），永远不要直接调用 `mutex.lock`
    和 `mutex.unlock`（RAII）
- en: Prefer non-recursive locks (often used to work around bad reasoning, overhead)
  id: totrans-7750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾向于使用非递归锁（常用于解决不良推理，开销）
- en: Join your threads! (because of `std::terminate` in destructor if not joined
    or detached … is there a good reason to detach threads?) – ??? could support library
    provide a RAII wrapper for `std::thread`?
  id: totrans-7751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的线程连接起来！（因为如果未连接或分离，析构函数中的 `std::terminate` ... 有没有好的理由来分离线程？） – ??? 库提供 `std::thread`
    的 RAII 包装器吗？
- en: If two or more mutexes must be acquired at the same time, use `std::lock` (or
    another deadlock avoidance algorithm?)
  id: totrans-7752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果必须同时获取两个或多个互斥锁，请使用 `std::lock`（或另一个死锁避免算法？）
- en: When using a `condition_variable`, always protect the condition by a mutex (atomic
    bool whose value is set outside of the mutex is wrong!), and use the same mutex
    for the condition variable itself.
  id: totrans-7753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `condition_variable` 时，始终通过互斥锁来保护条件（在互斥锁外部设置值的原子布尔值是错误的！），并且使用相同的互斥锁来保护条件变量本身。
- en: Never use `atomic_compare_exchange_strong` with `std::atomic<user-defined-struct>`
    (differences in padding matter, while `compare_exchange_weak` in a loop converges
    to stable padding)
  id: totrans-7754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要使用 `atomic_compare_exchange_strong` 与 `std::atomic<用户定义的结构体>`（填充差异很重要，而循环中的
    `compare_exchange_weak` 会收敛到稳定的填充）
- en: 'individual `shared_future` objects are not thread-safe: two threads cannot
    wait on the same `shared_future` object (they can wait on copies of a `shared_future`
    that refer to the same shared state)'
  id: totrans-7755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个 `shared_future` 对象不是线程安全的：两个线程不能在同一个 `shared_future` 对象上等待（它们可以在指向相同共享状态的
    `shared_future` 复制上等待）
- en: 'individual `shared_ptr` objects are not thread-safe: different threads can
    call non-`const` member functions on *different* `shared_ptr`s that refer to the
    same shared object, but one thread cannot call a non-`const` member function of
    a `shared_ptr` object while another thread accesses that same `shared_ptr` object
    (if you need that, consider `atomic_shared_ptr` instead)'
  id: totrans-7756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个 `shared_ptr` 对象不是线程安全的：不同的线程可以在不同的 `shared_ptr` 上调用非 `const` 成员函数，这些 `shared_ptr`
    指向相同的共享对象，但一个线程不能在另一个线程访问相同 `shared_ptr` 对象的同时调用该 `shared_ptr` 对象的非 `const` 成员函数（如果需要，可以考虑使用
    `atomic_shared_ptr`）
- en: rules for arithmetic
  id: totrans-7757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术规则
- en: Bibliography
  id: totrans-7758
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献列表
- en: '[Abrahams01]: D. Abrahams. [Exception-Safety in Generic Components](https://www.boost.org/community/exception_safety.html).'
  id: totrans-7759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Abrahams01]: D. Abrahams. [泛型组件的异常安全性](https://www.boost.org/community/exception_safety.html).'
- en: '[Alexandrescu01]: A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).'
  id: totrans-7760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Alexandrescu01]: A. Alexandrescu. 《现代C++设计》（Addison-Wesley, 2001）.'
- en: '[C++03]: ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and
    ANSI C++ Standard including the contents of (C++98) plus errata corrections).'
  id: totrans-7761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C++03]: ISO/IEC 14882:2003(E), 《编程语言 — C++》（更新后的ISO和ANSI C++标准，包括（C++98）的内容以及错误修正）.'
- en: '[Cargill92]: T. Cargill. C++ Programming Style (Addison-Wesley, 1992).'
  id: totrans-7762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cargill92]: T. Cargill. 《C++编程风格》（Addison-Wesley, 1992）.'
- en: '[Cline99]: M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley,
    1999).'
  id: totrans-7763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cline99]: M. Cline, G. Lomow, 和 M. Girou. 《C++常见问题解答》（第2版）（Addison-Wesley,
    1999）.'
- en: '[Dewhurst03]: S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).'
  id: totrans-7764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Dewhurst03]: S. Dewhurst. 《C++常见问题解答》（Addison-Wesley, 2003）.'
- en: '[Henricson97]: M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice
    Hall, 1997).'
  id: totrans-7765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Henricson97]: M. Henricson 和 E. Nyquist. 《工业级C++》（Prentice Hall, 1997）.'
- en: '[Koenig97]: A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).'
  id: totrans-7766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Koenig97]: A. Koenig 和 B. Moo. 《C++沉思录》（Addison-Wesley, 1997）.'
- en: '[Lakos96]: J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).'
  id: totrans-7767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lakos96]: J. Lakos. 《大规模C++软件设计》（Addison-Wesley, 1996）.'
- en: '[Meyers96]: S. Meyers. More Effective C++ (Addison-Wesley, 1996).'
  id: totrans-7768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers96]: S. Meyers. 《更多有效C++》（Addison-Wesley, 1996）.'
- en: '[Meyers97]: S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).'
  id: totrans-7769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers97]: S. Meyers. 《有效C++》（第2版）（Addison-Wesley, 1997）.'
- en: '[Meyers01]: S. Meyers. Effective STL (Addison-Wesley, 2001).'
  id: totrans-7770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers01]: S. Meyers. 《有效STL》（Addison-Wesley, 2001）.'
- en: '[Meyers05]: S. Meyers. Effective C++ (3rd Edition) (Addison-Wesley, 2005).'
  id: totrans-7771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers05]: S. Meyers. 《有效C++》（第3版）（Addison-Wesley, 2005）.'
- en: '[Meyers15]: S. Meyers. Effective Modern C++ (O’Reilly, 2015).'
  id: totrans-7772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Meyers15]: S. Meyers. 《有效现代C++》（O’Reilly, 2015）.'
- en: '[Murray93]: R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).'
  id: totrans-7773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Murray93]: R. Murray. 《C++策略与战术》（Addison-Wesley, 1993）.'
- en: '[Stroustrup94]: B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley,
    1994).'
  id: totrans-7774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup94]: B. Stroustrup. 《C++的设计与演化》（Addison-Wesley, 1994）.'
- en: '[Stroustrup00]: B. Stroustrup. The C++ Programming Language (Special 3rdEdition)
    (Addison-Wesley, 2000).'
  id: totrans-7775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup00]: B. Stroustrup. C++编程语言（特别第三版）(Addison-Wesley，2000年)。'
- en: '[Stroustrup05]: B. Stroustrup. [A rationale for semantically enhanced library
    languages](https://www.stroustrup.com/SELLrationale.pdf).'
  id: totrans-7776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup05]: B. Stroustrup. [语义增强库语言的合理性](https://www.stroustrup.com/SELLrationale.pdf)。'
- en: '[Stroustrup13]: B. Stroustrup. [The C++ Programming Language (4th Edition)](https://www.stroustrup.com/4th.html).
    Addison-Wesley 2013.'
  id: totrans-7777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup13]: B. Stroustrup. [C++编程语言（第四版）](https://www.stroustrup.com/4th.html).
    Addison-Wesley 2013年。'
- en: '[Stroustrup14]: B. Stroustrup. [A Tour of C++](https://www.stroustrup.com/Tour.html).
    Addison-Wesley 2014.'
  id: totrans-7778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup14]: B. Stroustrup. [C++之旅](https://www.stroustrup.com/Tour.html).
    Addison-Wesley 2014年。'
- en: '[Stroustrup15]: B. Stroustrup, Herb Sutter, and G. Dos Reis: [A brief introduction
    to C++’s model for type- and resource-safety](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf).'
  id: totrans-7779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stroustrup15]: B. Stroustrup, Herb Sutter, 和 G. Dos Reis: [C++类型和资源安全模型的简要介绍](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf).'
- en: '[SuttHysl04b]: H. Sutter and J. Hyslop. [Collecting Shared Objects](https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839)
    (C/C++ Users Journal, 22(8), August 2004).'
  id: totrans-7780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SuttHysl04b]: H. Sutter 和 J. Hyslop. [收集共享对象](https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839)（C/C++用户杂志，第22卷第8期，2004年8月）。'
- en: '[SuttAlex05]: H. Sutter and A. Alexandrescu. C++ Coding Standards. Addison-Wesley
    2005.'
  id: totrans-7781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SuttAlex05]: H. Sutter 和 A. Alexandrescu. C++编码标准. Addison-Wesley 2005年。'
- en: '[Sutter00]: H. Sutter. Exceptional C++ (Addison-Wesley, 2000).'
  id: totrans-7782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sutter00]: H. Sutter. Exceptional C++ (Addison-Wesley，2000年)。'
- en: '[Sutter02]: H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).'
  id: totrans-7783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sutter02]: H. Sutter. More Exceptional C++ (Addison-Wesley，2002年)。'
- en: '[Sutter04]: H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).'
  id: totrans-7784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sutter04]: H. Sutter. Exceptional C++ Style (Addison-Wesley，2004年)。'
- en: '[Taligent94]: Taligent’s Guide to Designing Programs (Addison-Wesley, 1994).'
  id: totrans-7785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Taligent94]: Taligent设计程序指南（Addison-Wesley，1994年）。'
