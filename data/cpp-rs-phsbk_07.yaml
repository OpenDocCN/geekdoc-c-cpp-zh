- en: Destructors and resource cleanup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 析构函数和资源清理
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/destructors.html](https://cel.cs.brown.edu/crp/idioms/destructors.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cel.cs.brown.edu/crp/idioms/destructors.html](https://cel.cs.brown.edu/crp/idioms/destructors.html)
- en: In C++, a destructor for a class `T` is defined by providing a special member
    function `~T()`. To achieve the equivalent in Rust, the [`Drop` trait](https://doc.rust-lang.org/std/ops/trait.Drop.html)
    is implemented for a type.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，类`T`的析构函数通过提供一个特殊的成员函数`~T()`来定义。要在Rust中实现等效功能，需要对类型实现`Drop`特质。
- en: For an example, see [the chapter on copy and move constructors](./constructors/copy_and_move_constructors.html#user-defined-constructors).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请参阅[关于复制和移动构造函数的章节](./constructors/copy_and_move_constructors.html#user-defined-constructors)。
- en: '`Drop` implementations play the same role as destructors in C++ for types that
    manage resources. That is, they enable cleanup of resources owned by the value
    at the end of the value''s lifetime.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drop`实现对于管理资源的类型在Rust中扮演着与C++中析构函数相同的角色。也就是说，它们允许在值的生命周期结束时清理由值拥有的资源。'
- en: In Rust the `Drop::drop` method of a value is called automatically by a destructor
    when the variable that owns the value goes out of scope. Unlike in C++, the drop
    method cannot be called manually. Instead the automatic "drop glue" implicitly
    calls the destructors of fields.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，值的`Drop::drop`方法在拥有该值的变量超出作用域时由析构函数自动调用。与C++不同，不能手动调用析构方法。相反，自动的“析构粘合剂”隐式调用字段的析构函数。
- en: '[Lifetimes, destructors, and destruction order](#lifetimes-destructors-and-destruction-order)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[生命周期、析构函数和销毁顺序](#lifetimes-destructors-and-destruction-order)'
- en: C++ destructors are called in reverse order of construction when variables go
    out of scope, or for dynamically allocated objects, when they are deleted. This
    includes destructors of moved-from objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C++析构函数在变量超出作用域时按构造顺序的相反顺序调用，或者在动态分配的对象被删除时调用。这包括从移动对象中调用的析构函数。
- en: In Rust, the drop order for items going out of scope is similar to that of C++
    (reverse order of declaration). If additional specific details about the drop
    order are needed (e.g., for writing unsafe code), the full rules for the drop
    order are described in [the language reference](https://doc.rust-lang.org/reference/destructors.html).
    However, moving an object in Rust does not leave a moved-from object on which
    a destructor will be called.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，超出作用域的项目删除顺序与C++类似（声明顺序的相反顺序）。如果需要关于删除顺序的更详细信息（例如，用于编写不安全代码），则在[语言参考](https://doc.rust-lang.org/reference/destructors.html)中描述了删除顺序的完整规则。然而，在Rust中移动对象不会留下一个被移动的对象，该对象将调用析构函数。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: struct A {
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: struct A {
- en: 'id: i32,'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'id: i32,'
- en: '}'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: impl Drop for A {
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: impl Drop for A {
- en: fn drop(&mut self) {
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fn drop(&mut self) {
- en: println!("{}", self.id)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: println!("{}", self.id)
- en: '}'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'fn accept(x: A) -> i32 {'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn accept(x: A) -> i32 {'
- en: return x.id;
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return x.id;
- en: '}'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '// Prints:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印：
- en: // 2
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: // 2
- en: // 3
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: // 3
- en: // 1
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: // 1
- en: fn main() {
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: 'let x = A { id: 1 };'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let x = A { id: 1 };'
- en: 'let y = A { id: 2 };'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let y = A { id: 2 };'
- en: accept(y);
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: accept(y);
- en: 'let z = A { id: 3 };'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let z = A { id: 3 };'
- en: '}'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In Rust, after ownership of `y` is moved into the function `accept`, there is
    no additional object remaining, and so there is no additional `Drop::drop` call
    (which in the C++ example prints `0`).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，当`y`的所有权被移动到函数`accept`中后，没有剩余的对象，因此没有额外的`Drop::drop`调用（在C++示例中打印`0`）。
- en: Rust's drop methods do run when leaving scope due to a panic, though not if
    the panic occurs in a destructor that was called in response to an initial panic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的析构方法在离开作用域时确实会运行，尽管在响应初始panic而调用的析构函数中panic不会运行。
- en: The drop order of fields in Rust is essentially the reverse of that of non-static
    class members in C++. Again, the specific details of what happens in a Rust destructor
    are given in [the language reference](https://doc.rust-lang.org/reference/destructors.html#r-destructors.operation).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中字段的删除顺序本质上与C++中非静态类成员的删除顺序相反。再次强调，Rust析构函数中具体发生的事情在[语言参考](https://doc.rust-lang.org/reference/destructors.html#r-destructors.operation)中有详细说明。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: struct Part(&'static str);
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: struct Part(&'static str);
- en: impl Drop for Part {
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: impl Drop for Part {
- en: fn drop(&mut self) {
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: fn drop(&mut self) {
- en: println!("{}", self.0);
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: println!("{}", self.0);
- en: '}'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: struct Widget {
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: struct Widget {
- en: 'part1: Part,'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'part1: Part,'
- en: 'part2: Part,'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'part2: Part,'
- en: 'part3: Part,'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'part3: Part,'
- en: '}'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: fn main() {
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: let w = Widget {
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let w = Widget {
- en: 'part1: Part("1"),'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'part1: Part("1"),'
- en: 'part2: Part("2"),'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'part2: Part("2"),'
- en: 'part3: Part("3"),'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'part3: Part("3"),'
- en: '};'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: '// Prints:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 打印：
- en: // 1
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 1
- en: // 2
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 2
- en: // 3
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 3
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Early cleanup and explicitly destroying values](#early-cleanup-and-explicitly-destroying-values)'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[早期清理和显式销毁值](#early-cleanup-and-explicitly-destroying-values)'
- en: In C++ you can explicitly destroy an object. This is mainly useful for situations
    where placement new has been used to allocate the object at a specific memory
    location, and so the destructor will not be implicitly called.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，你可以显式地销毁一个对象。这主要用于那些使用了 placement new 在特定内存位置分配对象的情况，因此析构函数不会被隐式调用。
- en: However, once the destructor has been explicitly called, [it may not be called
    again, even implicitly](https://eel.is/c++draft/class.dtor#note-8). Thus the destructor
    can't be used for early cleanup. Instead, either the class must be designed with
    a separate cleanup method that releases the resources but leaves the object in
    a state where the destructor can be called or the function using the object must
    be structured so that the variable goes out of scope at the desired time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦显式调用了析构函数，[它可能不会被再次调用，即使是隐式调用](https://eel.is/c++draft/class.dtor#note-8)。因此，析构函数不能用于早期清理。相反，类必须设计一个单独的清理方法来释放资源，但对象的状态仍然允许析构函数被调用，或者使用对象的函数必须被结构化，以便变量在期望的时间出作用域。
- en: In Rust, values can be dropped early for early cleanup by using [`std::mem::drop`](https://doc.rust-lang.org/std/mem/fn.drop.html).
    This works because ([for non-`Copy` types](./constructors/copy_and_move_constructors.html#trivially-copyable-types))
    ownership of the object is actually transferred to `std::mem::drop` function,
    and so `Drop::drop` is called at the end of `std::mem::drop` when the lifetime
    of the parameter ends.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，可以使用 `std::mem::drop` 来提前释放值，以便进行早期清理。这是因为在非 `Copy` 类型的情况下（[对于简单可复制的类型](./constructors/copy_and_move_constructors.html#trivially-copyable-types)），对象的拥有权实际上转移到了
    `std::mem::drop` 函数，因此当参数的生命周期结束时，会在 `std::mem::drop` 的末尾调用 `Drop::drop`。
- en: Thus, `std::mem::drop` can be used for early cleanup of resources without having
    to restructure a function to force variables out of scope early.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`std::mem::drop` 可以用于在不重新结构化函数以强制变量提前出作用域的情况下，对资源进行早期清理。
- en: For example, the following allocates a large vector on the heap, but explicitly
    drops it before allocating a second large vector on the heap, reducing the overall
    memory usage.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码在堆上分配了一个大向量，但在分配第二个大向量之前显式地释放了它，从而减少了总的内存使用。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: fn main() {
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: let v = vec![0u32; 100000];
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let v = vec![0u32; 100000];
- en: // ... use v
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ... 使用 v
- en: std::mem::drop(v);
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: std::mem::drop(v);
- en: // can no longer use v here
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 在这里不能再使用 v
- en: let v2 = vec![0u32; 100000];
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let v2 = vec![0u32; 100000];
- en: // ... use v2
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ... 使用 v2
- en: '}'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <link rel="stylesheet" type="text/css" href="../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Destructors
    and resource cleanup)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" type="text/css" href="../quiz/style.css"> [点击此处为此页面提供反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Destructors
    and resource cleanup)
