- en: RTTI and dynamic_cast
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTTI and dynamic_cast
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/rtti.html](https://cel.cs.brown.edu/crp/idioms/rtti.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cel.cs.brown.edu/crp/idioms/rtti.html](https://cel.cs.brown.edu/crp/idioms/rtti.html)
- en: Rust does not have built-in support for generalized RTTI, nor does Rust have
    a direct analog to `dynamic_cast`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rust does not have built-in support for generalized RTTI, nor does Rust have
    a direct analog to `dynamic_cast`.
- en: The only language primitive provided by Rust in this vein is [`TypeId`](https://doc.rust-lang.org/std/any/struct.TypeId.html),
    which is a globally unique identifier for a type. Rust's standard library builds
    on `TypeId` to provide an [`Any` trait](https://doc.rust-lang.org/std/any/trait.Any.html)
    that supports similar uses to `std::any` in C++. However, `Any` does not enable
    testing for implementation of, or converting to, another trait. It only enables
    testing for and converting to a specific type.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: The only language primitive provided by Rust in this vein is [`TypeId`](https://doc.rust-lang.org/std/any/struct.TypeId.html),
    which is a globally unique identifier for a type. Rust's standard library builds
    on `TypeId` to provide an [`Any` trait](https://doc.rust-lang.org/std/any/trait.Any.html)
    that supports similar uses to `std::any` in C++. However, `Any` does not enable
    testing for implementation of, or converting to, another trait. It only enables
    testing for and converting to a specific type.
- en: Every type with a `'static` lifetime bound (i.e., that does not contain references
    with a non-static lifetime) implements `Any` via a blanket implementation in the
    standard library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Every type with a `'static` lifetime bound (i.e., that does not contain references
    with a non-static lifetime) implements `Any` via a blanket implementation in the
    standard library.
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: use std::any::Any;
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: use std::any::Any;
- en: 'fn print_if_string(x: &dyn Any) {'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn print_if_string(x: &dyn Any) {'
- en: match x.downcast_ref::<String>() {
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: match x.downcast_ref::<String>() {
- en: Some(s) => println!("{}", s),
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Some(s) => println!("{}", s),
- en: None    => println!("Not a string!")
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: None    => println!("Not a string!")
- en: '}'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: fn main() {
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: print_if_string(&String::from("hello world"));
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print_if_string(&String::from("hello world"));
- en: print_if_string(&5);
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print_if_string(&5);
- en: '}'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Event handling](#event-handling)'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[Event handling](#event-handling)'
- en: One practical use of RTTI and `dynamic_cast` in C++ is for event handling in
    situations where both the subsystem generating events and the events themselves
    need to be decoupled from the handling logic. This is usually because the events
    are generated by a framework, such as a GUI or game framework, while the response
    to the events is application-specific.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: One practical use of RTTI and `dynamic_cast` in C++ is for event handling in
    situations where both the subsystem generating events and the events themselves
    need to be decoupled from the handling logic. This is usually because the events
    are generated by a framework, such as a GUI or game framework, while the response
    to the events is application-specific.
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#![allow(unused)] fn main() { enum Event {'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { enum Event {'
- en: ClickEvent {
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ClickEvent {
- en: 'x: i32,'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'x: i32,'
- en: 'y: i32,'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'y: i32,'
- en: '},'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: ResizeEvent {
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ResizeEvent {
- en: 'old_height: i32,'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'old_height: i32,'
- en: 'old_width: i32,'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'old_width: i32,'
- en: 'new_height: i32,'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'new_height: i32,'
- en: 'new_width: i32,'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'new_width: i32,'
- en: '},'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '}'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'fn handle_event(e: Event) {'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn handle_event(e: Event) {'
- en: match e {
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: match e {
- en: Event::ClickEvent { x, y } => {
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Event::ClickEvent { x, y } => {
- en: // ...
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: Event::ResizeEvent {
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Event::ResizeEvent {
- en: old_height,
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: old_height,
- en: old_width,
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: old_width,
- en: new_height,
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: new_height,
- en: new_width,
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: new_width,
- en: '} => {'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} => {'
- en: // ...
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even when the a client of the library is needs to be able to define custom events,
    it is usually possible to make use of an event enum. This is the approach taken
    by the [winit crate](https://docs.rs/winit/latest/winit/event/enum.Event.html),
    which does cross-platform window and event loop management.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即使库的客户端需要能够定义自定义事件，通常也可以使用事件枚举。这是[winit crate](https://docs.rs/winit/latest/winit/event/enum.Event.html)所采取的方法，它实现了跨平台的窗口和事件循环管理。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#![allow(unused)] fn main() { enum Event<T> {'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { enum Event<T> {'
- en: 'ClickEvent { x: i32, y: i32, }, ResizeEvent { old_height: i32, old_width: i32,
    new_height: i32, new_width: i32, },    // ...'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'ClickEvent { x: i32, y: i32, }, ResizeEvent { old_height: i32, old_width: i32,
    new_height: i32, new_width: i32, },    // ...'
- en: UserEvent(T),
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UserEvent(T),
- en: '}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: enum UserEvent {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: enum UserEvent {
- en: 'DoSomething { how_much: f64 },'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'DoSomething { how_much: f64 },'
- en: 'DoSomethingElse { how_many: i32 },'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'DoSomethingElse { how_many: i32 },'
- en: '}'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'fn handle_event(e: Event<UserEvent>) {'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn handle_event(e: Event<UserEvent>) {'
- en: match e {
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: match e {
- en: Event::ClickEvent { x, y } => { // ... } Event::ResizeEvent { old_height, old_width,
    new_height, new_width, } => { // ... }        // ...
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Event::ClickEvent { x, y } => { // ... } Event::ResizeEvent { old_height, old_width,
    new_height, new_width, } => { // ... }        // ...
- en: Event::UserEvent(
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Event::UserEvent(
- en: UserEvent::DoSomething { how_much },
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: UserEvent::DoSomething { how_much },
- en: ) => {
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ) => {
- en: // ...
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: Event::UserEvent(
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Event::UserEvent(
- en: UserEvent::DoSomethingElse {
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: UserEvent::DoSomethingElse {
- en: how_many,
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: how_many,
- en: '},'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: ) => {
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ) => {
- en: // ...
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When representing events as an enum truly isn't feasible, sometimes double dispatch
    can be used instead. Otherwise it may be necessary to use the `Any` trait or to
    define an `Event` trait that exposes a type identifier that an be used for safe
    downcasting (via `Any`) or unsafe downcasting behind a safe interface.^([1](#footnote-safe-event-handler))
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当将事件表示为枚举实际上不可行时，有时可以使用双重分派来代替。否则，可能需要使用`Any`特质或定义一个`Event`特质，该特质公开一个类型标识符，可用于安全下转型（通过`Any`）或在不安全接口背后的不安全下转型.^([1](#footnote-safe-event-handler))
- en: '[Library support for reflection via macros](#library-support-for-reflection-via-macros)'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[通过宏实现的库对反射的支持](#library-support-for-reflection-via-macros)'
- en: Some of the use cases of RTTI can be achieved in Rust by using one of the third-party
    reflection libraries. These libraries implement reflection by providing macros
    for deriving traits to support common reflection operations. Rust reflection libraries
    include [bevy_reflect](https://docs.rs/bevy_reflect/latest/bevy_reflect/), [facet](https://facet.rs/),
    and [mirror-mirror](https://docs.rs/mirror-mirror/latest/mirror_mirror/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: RTTI的一些用例可以通过在Rust中使用第三方反射库来实现。这些库通过提供用于推导特质的宏来实现反射，以支持常见的反射操作。Rust反射库包括[bevy_reflect](https://docs.rs/bevy_reflect/latest/bevy_reflect/)、[facet](https://facet.rs/)和[mirror-mirror](https://docs.rs/mirror-mirror/latest/mirror_mirror/)。
- en: The derive-macro approach to reflection essentially makes it opt-in, so that
    software that does not use reflection does not have to pay a price for it (performance
    costs or binary size). However, due to Rust's [orphan rule](https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules),
    this approach makes it more difficult to integrate third-party types that lack
    the derived trait.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过推导宏的反射方法基本上是可选的，这样不使用反射的软件就不必为此付出代价（性能成本或二进制大小）。然而，由于Rust的[孤儿规则](https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules)，这种方法使得集成缺乏推导特质的第三方类型变得更加困难。
- en: '* * *'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Such an interface usually involves providing individual event handling functions
    for specific types, rather than a single large event handling function, so that
    the underlying implementation can managing the enforcement of the invariants required
    to make the casting safe. [↩](#fr-safe-event-handler-1)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样的接口通常涉及为特定类型提供单独的事件处理函数，而不是一个单一的大型事件处理函数，这样底层实现就可以管理执行下转型所需的一致性强制。 [↩](#fr-safe-event-handler-1)
- en: '[Click here to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=RTTI
    and dynamic_cast)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处为此页面提供反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=RTTI
    and dynamic_cast)'
