- en: Errors indicating bugs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示错误的错误
- en: 原文：[https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html](https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html](https://cel.cs.brown.edu/crp/idioms/exceptions/bugs.html)
- en: In C++, exceptions are sometimes used to indicate an error that is due to a
    programming bug. In many situations no exception is produced, and instead the
    invalid use of an API is simply undefined behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，异常有时用于指示由编程错误引起的错误。在许多情况下不会产生异常，而是简单地将 API 的无效使用视为未定义行为。
- en: In Rust, `panic!` is used for these kinds of errors, often via an [`expect`](https://doc.rust-lang.org/std/result/enum.Result.html#method.expect)
    or [`unwrap`](https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap)
    method on `Result` or `Option` or via [assertions like `assert!`](#assertions).
    While a panic in Rust may unwind the stack or abort a program, it is never undefined
    behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`panic!` 用于这些类型的错误，通常通过 `Result` 或 `Option` 上的 `expect` 或 `unwrap`
    方法，或者通过 [断言如 `assert!`](#assertions) 来实现。虽然 Rust 中的恐慌可能会回滚堆栈或终止程序，但它永远不会是未定义的行为。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: fn main() {
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: let v = vec![1,2,3];
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let v = vec![1,2,3];
- en: // panics!
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // panics!
- en: let x = v[4];
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let x = v[4];
- en: '}'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Converting `Result` or `Option` to `panic!`](#converting-result-or-option-to-panic)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[将 `Result` 或 `Option` 转换为 `panic!`](#converting-result-or-option-to-panic)'
- en: It is easier to convert from a `Result` or `Option` to a panic than to go the
    other way around. Therefore, many libraries in Rust are written to return `Result`
    or `Option` and allow the caller to determine whether a `None` result indicates
    a bug by using `unwrap` or `expect` to extract the value, panicking if there isn't
    one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Result` 或 `Option` 转换为恐慌比反过来更容易。因此，许多 Rust 库被编写为返回 `Result` 或 `Option`，并允许调用者通过使用
    `unwrap` 或 `expect` 来提取值，如果没有值则引发恐慌，以确定 `None` 结果是否表示错误。
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: /// Returns `None` if the number cannot be divided evenly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: /// 如果数字不能被均匀除尽，则返回 `None`。
- en: 'fn divide_exact(dividend: i32, divisor: i32) -> Option<i32> {'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn divide_exact(dividend: i32, divisor: i32) -> Option<i32> {'
- en: let quotient = dividend / divisor;
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let quotient = dividend / divisor;
- en: if quotient * divisor == dividend {
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if quotient * divisor == dividend {
- en: Some(quotient)
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Some(quotient)
- en: '} else {'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: None
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: None
- en: '}'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // Returns `None` if the number cannot be divided by 2
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果数字不能被 2 整除，则返回 `None`
- en: 'fn divide_by_two_exact(dividend: i32) -> Option<i32> {'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 'fn divide_by_two_exact(dividend: i32) -> Option<i32> {'
- en: // divide_exact returning None here isn't a bug
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // divide_exact 返回 None 这里不是错误
- en: divide_exact(dividend, 2)
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: divide_exact(dividend, 2)
- en: '}'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: fn main() {
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: let res = divide_exact(10, 3); // Oops, a bug!
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let res = divide_exact(10, 3); // 哎呀，一个错误！
- en: let x = res.unwrap();
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let x = res.unwrap();
- en: // ...
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When designing an API, if only one of a `Result`-based (or `Option`-based) or
    panicking interface is going to be offered, it is generally better to offer the
    `Result`-based interface. That way that the caller can choose to omit the pre-condition
    checks and handle the error instead or to panic because pre-conditions should
    have been met.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计 API 时，如果只提供基于 `Result`（或基于 `Option`）或引发恐慌的接口之一，通常最好提供基于 `Result` 的接口。这样，调用者可以选择省略前置条件检查并处理错误，或者因为前置条件应该得到满足而引发恐慌。
- en: '[Assertions](#assertions)'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[断言](#assertions)'
- en: In Rust, panics are also generated by assertions. Unlike `assert` in C++, The
    [`assert!`](https://doc.rust-lang.org/std/macro.assert.html) family of macros
    in Rust cannot be disabled. They are therefore appropriate for asserting invariants
    when creating safe wrappers for unsafe code, in addition to checking for logical
    invariants.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，断言也会引发恐慌。与 C++ 中的 `assert` 不同，Rust 中的 `assert!` 宏家族不能被禁用。因此，当为不安全代码创建安全包装时，它们非常适合断言不变性，除了检查逻辑不变性。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#![allow(unused)] fn main() { use std::convert::TryFrom;'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { use std::convert::TryFrom;'
- en: pub struct Widget<T> {
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: pub struct Widget<T> {
- en: 'parts: *const T,'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'part_count: usize,'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'part_count: usize,'
- en: '}'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'impl<T: Copy> Widget<T> {'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'impl<T: Copy> Widget<T> {'
- en: // ... constructor methods ...
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ... 构造函数方法 ...
- en: /// Panics if n is greater than the number of
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// 如果 n 大于部分数量，则引发恐慌
- en: /// parts.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// 部分。
- en: 'pub fn get_part(&self, n: usize) -> T {'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'pub fn get_part(&self, n: usize) -> T {'
- en: '// SAFETY: Widget maintians invariant of'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 安全性：Widget 维护不变性
- en: // at least part_count parts, so if n is
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 至少有 part_count 个部分，所以如果 n 是
- en: // less than the part count then we can
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 如果小于部分数量，则我们可以
- en: // use it access a part.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // 使用它访问一个部分。
- en: assert!(
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert!(
- en: n < self.part_count,
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n < self.part_count,
- en: '"index {} exceeds part count {}",'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"索引 {} 超出部分数量 {}",'
- en: n,
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: n,
- en: self.part_count
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.part_count
- en: );
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: );
- en: let idx = isize::try_from(n).expect(
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: let idx = isize::try_from(n).expect(
- en: '"can''t convert index to offset"'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"无法将索引转换为偏移量"'
- en: );
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: );
- en: unsafe { self.parts.offset(idx).read() }
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: unsafe { self.parts.offset(idx).read() }
- en: '}'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Rust [`debug_assert!` macro](https://doc.rust-lang.org/std/macro.debug_assert.html)
    is more like `assert!` in C++, in that it can be turned off by a compilation configuration
    option, and so is useful for encoding logical invariants that should be checked
    during development and testing, but are too expensive to check in production.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的 `debug_assert!` 宏更像 C++ 中的 `assert!`，因为它可以通过编译配置选项关闭，因此对于编码在开发和测试期间应该检查但生产中检查成本过高的逻辑不变性非常有用。
- en: '[Other assertion macros](#other-assertion-macros)'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[其他断言宏](#其他断言宏)'
- en: Rust has several other convenience assertion macros. The macros [`assert_eq!`](https://doc.rust-lang.org/std/macro.assert_eq.html)
    and [`assert_ne!`](https://doc.rust-lang.org/std/macro.assert_ne.html) will print
    their arguments on assertion failure using the `Debug` trait implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有几个其他便利的断言宏。宏 `[`assert_eq!`](https://doc.rust-lang.org/std/macro.assert_eq.html)
    和 `[`assert_ne!`](https://doc.rust-lang.org/std/macro.assert_ne.html) 在断言失败时将使用
    `Debug` 特性实现打印它们的参数。
- en: The [`unreachable!`](https://doc.rust-lang.org/std/macro.unreachable.html) macro
    is for asserting that when matching on an enum certain cases are expected to not
    be possible. It is essentially `panic!` with a fixed error message, but better
    communicates intent.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`unreachable!` 宏用于断言在枚举匹配时某些情况预期不可能发生。它本质上与 `panic!` 相同，但具有固定的错误消息，并且更好地传达了意图。'
- en: '[Static assertions](#static-assertions)'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[静态断言](#静态断言)'
- en: C++ also has `static_assert`, which is guaranteed to be evaluated at compile
    time, other than when used in templates. When used in templates, it is guaranteed
    to be evaluated at compile time if the template is instantiated. In Rust the same
    thing can achieved by calling `assert!` in a const block or some other [constant
    context](https://doc.rust-lang.org/reference/const_eval.html#const-context). The
    convenience macros `assert_eq!` and `assert_ne!` cannot (yet) be used in const
    contexts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 也有 `static_assert`，它在模板中使用时保证在编译时评估，除非在模板中使用。当在模板中使用时，如果模板被实例化，它保证在编译时评估。在
    Rust 中，可以通过在 const 块或其他某些 [常量上下文](https://doc.rust-lang.org/reference/const_eval.html#const-context)
    中调用 `assert!` 来实现相同的效果。便利宏 `assert_eq!` 和 `assert_ne!` （目前）不能在 const 上下文中使用。
- en: The following example fails to compile in both Rust and C++ with the message
    from the static assertion.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在 Rust 和 C++ 中都无法编译，并显示静态断言的消息。
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: fn main() {
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {
- en: const {
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const {
- en: assert!(false, "static requirement");
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert!(false, "静态要求");
- en: '}'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like with C++ `static_assert`, a Rust assertion in a const block in a generic
    definition is only evaluated when the generic arguments are known. Both the C++
    and the Rust versions of the following example only fail to compile if the `first`
    function is called on an array with a size less than 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C++ 的 `static_assert` 类似，Rust 中的断言在泛型定义中的 const 块中只有在泛型参数已知时才会评估。以下示例的 C++
    和 Rust 版本只有在 `first` 函数被调用在一个大小小于 1 的数组上时才会编译失败。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#![allow(unused)] fn main() { fn first<const N: usize>(arr: [i32; N]) -> i32
    {'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#![allow(unused)] fn main() { fn first<const N: usize>(arr: [i32; N]) -> i32
    {'
- en: const {
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const {
- en: assert!(
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert!(
- en: N >= 1,
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: N >= 1,
- en: '"array needs to have at last size 1!"'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"数组至少需要大小为 1！"'
- en: )
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '}'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: arr[0]
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: arr[0]
- en: '}'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In C++, `static_assert` can also be used at namespace scope. To achieve an equivalent
    thing in Rust requires defining an unnamed constant.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`static_assert` 也可以在命名空间作用域中使用。在 Rust 中实现等效功能需要定义一个未命名的常量。
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'const _: () = assert!(true, "top-level assert true");'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'const _: () = assert!(true, "顶级断言为真");'
- en: 'const _: () = assert!(false, "top-level assert false");'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'const _: () = assert!(false, "顶级断言为假");'
- en: fn main() {}
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: fn main() {}
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Assertions and the optimizer](#assertions-and-the-optimizer)'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[断言和优化器](#断言和优化器)'
- en: Assertions do affect how the Rust compiler optimizes code (e.g., by enabling
    the optimizer to eliminate subsequent redundant checks) but the specific effects
    are not guaranteed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 断言确实会影响 Rust 编译器优化代码的方式（例如，通过使优化器能够消除后续冗余检查），但具体效果并不保证。
- en: '[Panics in embedded systems](#panics-in-embedded-systems)'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[嵌入式系统中的恐慌](#嵌入式系统中的恐慌)'
- en: When programming in Rust for embedded systems using `#![no_std]`, there is no
    default panic handler. Instead one must be specified using the `#[panic_handler]`
    annotation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `#![no_std]` 编程 Rust 嵌入式系统时，没有默认的恐慌处理程序。相反，必须使用 `#[panic_handler]` 注解来指定一个。
- en: The Embedded Rust Book [chapter on handling panics](https://docs.rust-embedded.org/book/start/panicking.html)
    has more details on implementing panic handlers for in `no_std` programs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 《嵌入式Rust书籍》[关于处理恐慌的章节](https://docs.rust-embedded.org/book/start/panicking.html)提供了更多关于在`no_std`程序中实现恐慌处理器的详细信息。
- en: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [Click here
    to leave us feedback about this page.](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Errors
    indicating bugs)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <link rel="stylesheet" type="text/css" href="../../quiz/style.css"> [点击此处为此页面提供反馈](https://docs.google.com/forms/d/e/1FAIpQLScoygeNlygODY2owQ-HvU8VGx3hi50aic7ZlKCyhJ0VktjiCg/viewform?usp=pp_url&entry.1450251950=Errors
    indicating bugs)
